var LifoScheduler=function LifoSchedulerClosure(){function LifoScheduler(createResource,jobsLimit){this._resourceCreator=createResource;this._jobsLimit=jobsLimit;this._freeResourcesCount=this._jobsLimit;this._freeResources=new Array(this._jobsLimit);this._pendingJobs=[]}LifoScheduler.prototype={enqueueJob:function enqueueJob(jobFunc,jobContext){if(this._freeResourcesCount>0){--this._freeResourcesCount;var resource=this._freeResources.pop();if(resource===undefined)resource=this._resourceCreator();
jobFunc(resource,jobContext)}else this._pendingJobs.push({jobFunc:jobFunc,jobContext:jobContext})},jobDone:function jobDone(resource){if(this._pendingJobs.length>0){var nextJob=this._pendingJobs.pop();nextJob.jobFunc(resource,nextJob.jobContext)}else{this._freeResources.push(resource);++this._freeResourcesCount}},shouldYieldOrAbort:function shouldYieldOrAbort(jobContext){return false},tryYield:function yieldResource(jobFunc,jobContext,resource){return false}};return LifoScheduler}();var LinkedList=function LinkedListClosure(){function LinkedList(){this._first={_prev:null,_parent:this};this._last={_next:null,_parent:this};this._count=0;this._last._prev=this._first;this._first._next=this._last}LinkedList.prototype.add=function add(value,addBefore){if(addBefore===null||addBefore===undefined)addBefore=this._last;this._validateIteratorOfThis(addBefore);++this._count;var newNode={_value:value,_next:addBefore,_prev:addBefore._prev,_parent:this};newNode._prev._next=newNode;addBefore._prev=
newNode;return newNode};LinkedList.prototype.remove=function remove(iterator){this._validateIteratorOfThis(iterator);--this._count;iterator._prev._next=iterator._next;iterator._next._prev=iterator._prev;iterator._parent=null};LinkedList.prototype.getValue=function getValue(iterator){this._validateIteratorOfThis(iterator);return iterator._value};LinkedList.prototype.getFirstIterator=function getFirstIterator(){var iterator=this.getNextIterator(this._first);return iterator};LinkedList.prototype.getLastIterator=
function getFirstIterator(){var iterator=this.getPrevIterator(this._last);return iterator};LinkedList.prototype.getNextIterator=function getNextIterator(iterator){this._validateIteratorOfThis(iterator);if(iterator._next===this._last)return null;return iterator._next};LinkedList.prototype.getPrevIterator=function getPrevIterator(iterator){this._validateIteratorOfThis(iterator);if(iterator._prev===this._first)return null;return iterator._prev};LinkedList.prototype.getCount=function getCount(){return this._count};
LinkedList.prototype._validateIteratorOfThis=function validateIteratorOfThis(iterator){if(iterator._parent!==this)throw"iterator must be of the current LinkedList";};return LinkedList}();var PriorityScheduler=function PrioritySchedulerClosure(){function PriorityScheduler(createResource,jobsLimit,prioritizer,options){options=options||{};this._resourceCreator=createResource;this._jobsLimit=jobsLimit;this._prioritizer=prioritizer;this._showLog=options["showLog"];this._schedulerName=options["schedulerName"];this._numNewJobs=options["numNewJobs"]||20;this._numJobsBeforeRerankOldPriorities=options["numJobsBeforeRerankOldPriorities"]||20;this._freeResourcesCount=this._jobsLimit;this._freeResources=
new Array(this._jobsLimit);this._resourcesGuaranteedForHighPriority=options["resourcesGuaranteedForHighPriority"]||0;this._highPriorityToGuaranteeResource=options["highPriorityToGuaranteeResource"]||0;this._pendingJobsCount=0;this._oldPendingJobsByPriority=[];initializeNewPendingJobsLinkedList(this);this._schedulesCounter=0}PriorityScheduler.prototype={enqueueJob:function enqueueJob(jobFunc,jobContext,jobAbortedFunc){var priority=this._prioritizer["getPriority"](jobContext);if(priority<0){jobAbortedFunc(jobContext);
return}var job={jobFunc:jobFunc,jobAbortedFunc:jobAbortedFunc,jobContext:jobContext};var minPriority=getMinimalPriorityToSchedule(self);var resource=null;if(priority>=minPriority)resource=tryGetFreeResource(this);if(resource!==null){schedule(this,job,resource);return}enqueueNewJob(this,job,priority);ensurePendingJobsCount(self)},jobDone:function jobDone(resource,jobContext){if(this._showLog){var message="";if(this._schedulerName!==undefined)message=this._schedulerName+"'s ";var priority=this._prioritizer["getPriority"](jobContext);
message+=" job done of priority "+priority;console.log(message)}resourceFreed(this,resource);ensurePendingJobsCount(self)},tryYield:function tryYield(jobContinueFunc,jobContext,jobAbortedFunc,jobYieldedFunc,resource){var priority=this._prioritizer["getPriority"](jobContext);if(priority<0){jobAbortedFunc(jobContext);resourceFreed(this,resource);return true}var higherPriorityJob=tryDequeueNewJobWithHigherPriority(this,priority);ensurePendingJobsCount(self);if(higherPriorityJob===null)return false;jobYieldedFunc(jobContext);
var job={jobFunc:jobContinueFunc,jobAbortedFunc:jobAbortedFunc,jobContext:jobContext};enqueueNewJob(this,job,priority);ensurePendingJobsCount(self);schedule(this,higherPriorityJob,resource);ensurePendingJobsCount(self);return true}};function tryDequeueNewJobWithHigherPriority(self,lowPriority){var jobToScheduleNode=null;var highestPriorityFound=lowPriority;var countedPriorities=[];var currentNode=self._newPendingJobsLinkedList.getFirstIterator();while(currentNode!==null){var nextNode=self._newPendingJobsLinkedList.getNextIterator(currentNode);
var job=self._newPendingJobsLinkedList.getValue(currentNode);var priority=self._prioritizer["getPriority"](job.jobContext);if(priority<0){extractJobFromLinkedList(self,currentNode);--self._pendingJobsCount;job.jobAbortedFunc(job.jobContext);currentNode=nextNode;continue}if(highestPriorityFound===undefined||priority>highestPriorityFound){highestPriorityFound=priority;jobToScheduleNode=currentNode}if(!self._showLog){currentNode=nextNode;continue}if(countedPriorities[priority]===undefined)countedPriorities[priority]=
1;else++countedPriorities[priority];currentNode=nextNode}var jobToSchedule=null;if(jobToScheduleNode!==null){jobToSchedule=extractJobFromLinkedList(self,jobToScheduleNode);--self._pendingJobsCount}if(self._showLog){var jobsListMessage="";var jobDequeuedMessage="";if(self._schedulerName!==undefined){jobsListMessage=self._schedulerName+"'s ";jobDequeuedMessage=self._schedulerName+"'s "}jobsListMessage+="Jobs list:";for(var i=0;i<countedPriorities.length;++i)if(countedPriorities[i]!==undefined)jobsListMessage+=
countedPriorities[i]+" jobs of priority "+i+";";console.log(jobsListMessage);if(jobToSchedule!==null){jobDequeuedMessage+=" dequeued new job of priority "+highestPriorityFound;console.log(jobDequeuedMessage)}}ensurePendingJobsCount(self);return jobToSchedule}function tryGetFreeResource(self){if(self._freeResourcesCount===0)return null;--self._freeResourcesCount;var resource=self._freeResources.pop();if(resource===undefined)resource=self._resourceCreator();ensurePendingJobsCount(self);return resource}
function enqueueNewJob(self,job,priority){++self._pendingJobsCount;var firstIterator=self._newPendingJobsLinkedList.getFirstIterator();addJobToLinkedList(self,job,firstIterator);if(self._showLog){var message="";if(self._schedulerName!==undefined)message=self._schedulerName+"'s ";message+=" enqueued job of priority "+priority;console.log(message)}if(self._newPendingJobsLinkedList.getCount()<=self._numNewJobs){ensurePendingJobsCount(self);return}var lastIterator=self._newPendingJobsLinkedList.getLastIterator();
var oldJob=extractJobFromLinkedList(self,lastIterator);enqueueOldJob(self,oldJob);ensurePendingJobsCount(self)}function enqueueOldJob(self,job){var priority=self._prioritizer["getPriority"](job.jobContext);if(priority<0){--self._pendingJobsCount;job.jobAbortedFunc(job.jobContext);return}if(self._oldPendingJobsByPriority[priority]===undefined)self._oldPendingJobsByPriority[priority]=[];self._oldPendingJobsByPriority[priority].push(job)}function rerankPriorities(self){var originalOldsArray=self._oldPendingJobsByPriority;
var originalNewsList=self._newPendingJobsLinkedList;if(originalOldsArray.length===0)return;self._oldPendingJobsByPriority=[];initializeNewPendingJobsLinkedList(self);for(var i=0;i<originalOldsArray.length;++i){if(originalOldsArray[i]===undefined)continue;for(var j=0;j<originalOldsArray[i].length;++j)enqueueOldJob(self,originalOldsArray[i][j])}var iterator=originalNewsList.getFirstIterator();while(iterator!==null){var value=originalNewsList.getValue(iterator);enqueueOldJob(self,value);iterator=originalNewsList.getNextIterator(iterator)}var message=
"";if(self._schedulerName!==undefined)message=self._schedulerName+"'s ";message+="rerank: ";for(var i=self._oldPendingJobsByPriority.length-1;i>=0;--i){var highPriorityJobs=self._oldPendingJobsByPriority[i];if(highPriorityJobs===undefined)continue;if(self._showLog)message+=highPriorityJobs.length+" jobs in priority "+i+";";while(highPriorityJobs.length>0&&self._newPendingJobsLinkedList.getCount()<self._numNewJobs){var job=highPriorityJobs.pop();addJobToLinkedList(self,job)}if(self._newPendingJobsLinkedList.getCount()>=
self._numNewJobs&&!self._showLog)break}if(self._showLog)console.log(message);ensurePendingJobsCount(self)}function resourceFreed(self,resource){++self._freeResourcesCount;var minPriority=getMinimalPriorityToSchedule(self);--self._freeResourcesCount;var job=tryDequeueNewJobWithHigherPriority(self,minPriority);if(job!==null){ensurePendingJobsCount(self);schedule(self,job,resource);ensurePendingJobsCount(self);return}var hasOldJobs=self._pendingJobsCount>self._newPendingJobsLinkedList.getCount();if(hasOldJobs){self._freeResources.push(resource);
++self._freeResourcesCount;ensurePendingJobsCount(self);return}var numPriorities=self._oldPendingJobsByPriority.length;var jobPriority;for(var priority=numPriorities-1;priority>=0;--priority){var jobs=self._oldPendingJobsByPriority[priority];if(jobs===undefined||jobs.length===0)continue;for(var i=jobs.length-1;i>=0;--i){job=jobs[i];jobPriority=self._prioritizer["getPriority"](job.jobContext);if(jobPriority>=priority){jobs.length=i;break}else if(jobPriority<0){--self._pendingJobsCount;job.jobAbortedFunc(job.jobContext)}else{if(self._oldPendingJobsByPriority[jobPriority]===
undefined)self._oldPendingJobsByPriority[jobPriority]=[];self._oldPendingJobsByPriority[jobPriority].push(job)}job=null}if(job!==null)break;jobs.length=0}if(job===null){self._freeResources.push(resource);++self._freeResourcesCount;ensurePendingJobsCount(self);return}if(self._showLog){var message="";if(self._schedulerName!==undefined)message=self._schedulerName+"'s ";message+=" dequeued old job of priority "+jobPriority;console.log(message)}--self._pendingJobsCount;ensurePendingJobsCount(self);schedule(self,
job,resource);ensurePendingJobsCount(self)}function schedule(self,job,resource){++self._schedulesCounter;if(self._schedulesCounter>=self._numJobsBeforeRerankOldPriorities){self._schedulesCounter=0;rerankPriorities(self)}if(self._showLog){var message="";if(self._schedulerName!==undefined)message=self._schedulerName+"'s ";var priority=self._prioritizer["getPriority"](job.jobContext);message+=" scheduled job of priority "+priority;console.log(message)}job.jobFunc(resource,job.jobContext)}function initializeNewPendingJobsLinkedList(self){self._newPendingJobsLinkedList=
new LinkedList}function addJobToLinkedList(self,job,addBefore){self._newPendingJobsLinkedList.add(job,addBefore);ensureNumberOfNodes(self)}function extractJobFromLinkedList(self,iterator){var value=self._newPendingJobsLinkedList.getValue(iterator);self._newPendingJobsLinkedList.remove(iterator);ensureNumberOfNodes(self);return value}function ensureNumberOfNodes(self){if(!self._showLog)return;var iterator=self._newPendingJobsLinkedList.getIterator();var expectedCount=0;while(iterator!==null){++expectedCount;
iterator=self._newPendingJobsLinkedList.getNextIterator(iterator)}if(expectedCount!==self._newPendingJobsLinkedList.getCount())throw"Unexpected count of new jobs";}function ensurePendingJobsCount(self){if(!self._showLog)return;var oldJobsCount=0;for(var i=0;i<self._oldPendingJobsByPriority.length;++i){var jobs=self._oldPendingJobsByPriority[i];if(jobs!==undefined)oldJobsCount+=jobs.length}var expectedCount=oldJobsCount+self._newPendingJobsLinkedList.getCount();if(expectedCount!==self._pendingJobsCount)throw"Unexpected count of jobs";
}function getMinimalPriorityToSchedule(self){if(self._freeResourcesCount<=self._resourcesGuaranteedForHighPriority)return self._highPriorityToGuaranteeResources;return 0}return PriorityScheduler}();self["ResourceScheduler"]={};self["ResourceScheduler"]["PriorityScheduler"]=PriorityScheduler;self["ResourceScheduler"]["LifoScheduler"]=LifoScheduler;PriorityScheduler.prototype["enqueueJob"]=PriorityScheduler.prototype.enqueueJob;PriorityScheduler.prototype["tryYield"]=PriorityScheduler.prototype.tryYield;PriorityScheduler.prototype["jobDone"]=PriorityScheduler.prototype.jobDone;LifoScheduler.prototype["enqueueJob"]=LifoScheduler.prototype.enqueueJob;LifoScheduler.prototype["tryYield"]=LifoScheduler.prototype.tryYield;
LifoScheduler.prototype["jobDone"]=LifoScheduler.prototype.jobDone;

var BlobScriptGenerator=BlobScriptGeneratorClosure();self["asyncProxyScriptBlob"]=new BlobScriptGenerator;
function BlobScriptGeneratorClosure(){function BlobScriptGenerator(){var that=this;that._blobChunks=["'use strict';"];that._blob=null;that._blobUrl=null;that._namespaces={};that.addMember(BlobScriptGeneratorClosure,"BlobScriptGenerator");that.addStatement("var asyncProxyScriptBlob = new BlobScriptGenerator();")}BlobScriptGenerator.prototype.addMember=function addMember(closureFunction,memberName,namespace){if(this._blob)throw new Error("Cannot add member to AsyncProxyScriptBlob after blob was used");
if(memberName){if(namespace){this._namespaces[namespace]=true;this._blobChunks.push(namespace);this._blobChunks.push(".")}else this._blobChunks.push("var ");this._blobChunks.push(memberName);this._blobChunks.push(" = ")}this._blobChunks.push("(");this._blobChunks.push(closureFunction.toString());this._blobChunks.push(")();")};BlobScriptGenerator.prototype.addStatement=function addStatement(statement){if(this._blob)throw new Error("Cannot add statement to AsyncProxyScriptBlob after blob was used");
this._blobChunks.push(statement)};BlobScriptGenerator.prototype.getBlob=function getBlob(){if(!this._blob)this._blob=new Blob(this._blobChunks,{type:"application/javascript"});return this._blob};BlobScriptGenerator.prototype.getBlobUrl=function getBlobUrl(){if(!this._blobUrl)this._blobUrl=URL.createObjectURL(this.getBlob());return this._blobUrl};return BlobScriptGenerator};function SubWorkerEmulationForChromeClosure(){var subWorkerId=0;var subWorkerIdToSubWorker=null;function SubWorkerEmulationForChrome(scriptUrl){if(subWorkerIdToSubWorker===null)throw"AsyncProxy internal error: SubWorkerEmulationForChrome "+"not initialized";var that=this;that._subWorkerId=++subWorkerId;subWorkerIdToSubWorker[that._subWorkerId]=that;self.postMessage({type:"subWorkerCtor",subWorkerId:that._subWorkerId,scriptUrl:scriptUrl})}SubWorkerEmulationForChrome.initialize=function initialize(subWorkerIdToSubWorker_){subWorkerIdToSubWorker=
subWorkerIdToSubWorker_};SubWorkerEmulationForChrome.prototype.postMessage=function postMessage(data,transferables){self.postMessage({type:"subWorkerPostMessage",subWorkerId:this._subWorkerId,data:data},transferables)};SubWorkerEmulationForChrome.prototype.terminate=function terminate(data,transferables){self.postMessage({type:"subWorkerTerminate",subWorkerId:this._subWorkerId},transferables)};self["asyncProxyScriptBlob"].addMember(SubWorkerEmulationForChromeClosure,"SubWorkerEmulationForChrome");
return SubWorkerEmulationForChrome}var SubWorkerEmulationForChrome=SubWorkerEmulationForChromeClosure();function AsyncProxyMasterClosure(){var asyncProxyScriptBlob=self["asyncProxyScriptBlob"];var callId=0;var isGetMasterEntryUrlCalled=false;var masterEntryUrl=getBaseUrlFromEntryScript();function AsyncProxyMaster(scriptsToImport,ctorName,ctorArgs,options){var that=this;options=options||{};var slaveScriptContentString=mainSlaveScriptContent.toString();slaveScriptContentString=slaveScriptContentString.replace("SCRIPT_PLACEHOLDER",asyncProxyScriptBlob.getBlobUrl());var slaveScriptContentBlob=new Blob(["(",
slaveScriptContentString,")()"],{type:"application/javascript"});var slaveScriptUrl=URL.createObjectURL(slaveScriptContentBlob);that._callbacks=[];that._pendingPromiseCalls=[];that._subWorkerById=[];that._subWorkers=[];that._worker=new Worker(slaveScriptUrl);that._worker.onmessage=onWorkerMessageInternal;that._userDataHandler=null;that._notReturnedFunctions=0;that._functionsBufferSize=options["functionsBufferSize"]||5;that._pendingMessages=[];that._worker.postMessage({functionToCall:"ctor",scriptsToImport:scriptsToImport,
ctorName:ctorName,args:ctorArgs,callId:++callId,isPromise:false,masterEntryUrl:AsyncProxyMaster.getEntryUrl()});function onWorkerMessageInternal(workerEvent){onWorkerMessage(that,workerEvent)}}AsyncProxyMaster.prototype.setUserDataHandler=function setUserDataHandler(userDataHandler){this._userDataHandler=userDataHandler};AsyncProxyMaster.prototype.terminate=function terminate(){this._worker.terminate();for(var i=0;i<this._subWorkers.length;++i)this._subWorkers[i].terminate()};AsyncProxyMaster.prototype.callFunction=
function callFunction(functionToCall,args,options){options=options||{};var isReturnPromise=!!options["isReturnPromise"];var transferables=options["transferables"];var pathsToTransferables=options["pathsToTransferablesInPromiseResult"];var localCallId=++callId;var promiseOnMasterSide=null;var that=this;if(isReturnPromise)promiseOnMasterSide=new Promise(function promiseFunc(resolve,reject){that._pendingPromiseCalls[localCallId]={resolve:resolve,reject:reject}});var sendMessageFunction=options["isSendImmediately"]?
sendMessageToSlave:enqueueMessageToSlave;sendMessageFunction(this,transferables,true,{functionToCall:functionToCall,args:args||[],callId:localCallId,isPromise:isReturnPromise,pathsToTransferablesInPromiseResult:pathsToTransferables});if(isReturnPromise)return promiseOnMasterSide};AsyncProxyMaster.prototype.wrapCallback=function wrapCallback(callback,callbackName,options){options=options||{};var localCallId=++callId;var callbackHandle={isWorkerHelperCallback:true,isMultipleTimeCallback:!!options["isMultipleTimeCallback"],
callId:localCallId,callbackName:callbackName,pathsToTransferables:options["pathsToTransferables"]};var internalCallbackHandle={isMultipleTimeCallback:!!options["isMultipleTimeCallback"],callId:localCallId,callback:callback,pathsToTransferables:options["pathsToTransferables"]};this._callbacks[localCallId]=internalCallbackHandle;return callbackHandle};AsyncProxyMaster.prototype.freeCallback=function freeCallback(callbackHandle){delete this._callbacks[callbackHandle.callId]};AsyncProxyMaster.getEntryUrl=
function getEntryUrl(){isGetMasterEntryUrlCalled=true;return masterEntryUrl};AsyncProxyMaster._setEntryUrl=function setEntryUrl(newUrl){if(masterEntryUrl!==newUrl&&isGetMasterEntryUrlCalled)throw"Previous values returned from getMasterEntryUrl "+"is wrong. Avoid calling it within the slave c`tor";masterEntryUrl=newUrl};function mainSlaveScriptContent(){importScripts("SCRIPT_PLACEHOLDER");AsyncProxy["AsyncProxySlave"]=self["AsyncProxy"]["AsyncProxySlaveSingleton"];AsyncProxy["AsyncProxySlave"]._initializeSlave()}
function onWorkerMessage(that,workerEvent){var callId=workerEvent.data.callId;switch(workerEvent.data.type){case "functionCalled":--that._notReturnedFunctions;trySendPendingMessages(that);break;case "promiseResult":var promiseData=that._pendingPromiseCalls[callId];delete that._pendingPromiseCalls[callId];var result=workerEvent.data.result;promiseData.resolve(result);break;case "promiseFailure":var promiseData=that._pendingPromiseCalls[callId];delete that._pendingPromiseCalls[callId];var reason=workerEvent.data.reason;
promiseData.reject(reason);break;case "userData":if(that._userDataHandler!==null)that._userDataHandler(workerEvent.data.userData);break;case "callback":var callbackHandle=that._callbacks[workerEvent.data.callId];if(callbackHandle===undefined)throw"Unexpected message from SlaveWorker of callback ID: "+workerEvent.data.callId+". Maybe should indicate "+"isMultipleTimesCallback = true on creation?";if(!callbackHandle.isMultipleTimeCallback)that.freeCallback(that._callbacks[workerEvent.data.callId]);
if(callbackHandle.callback!==null)callbackHandle.callback.apply(null,workerEvent.data.args);break;case "subWorkerCtor":var subWorker=new Worker(workerEvent.data.scriptUrl);var id=workerEvent.data.subWorkerId;that._subWorkerById[id]=subWorker;that._subWorkers.push(subWorker);subWorker.onmessage=function onSubWorkerMessage(subWorkerEvent){enqueueMessageToSlave(that,subWorkerEvent.ports,false,{functionToCall:"subWorkerOnMessage",subWorkerId:id,data:subWorkerEvent.data})};break;case "subWorkerPostMessage":var subWorker=
that._subWorkerById[workerEvent.data.subWorkerId];subWorker.postMessage(workerEvent.data.data);break;case "subWorkerTerminate":var subWorker=that._subWorkerById[workerEvent.data.subWorkerId];subWorker.terminate();break;default:throw"Unknown message from AsyncProxySlave of type: "+workerEvent.data.type;}}function enqueueMessageToSlave(that,transferables,isFunctionCall,message){if(that._notReturnedFunctions>=that._functionsBufferSize){that._pendingMessages.push({transferables:transferables,isFunctionCall:isFunctionCall,
message:message});return}sendMessageToSlave(that,transferables,isFunctionCall,message)}function sendMessageToSlave(that,transferables,isFunctionCall,message){if(isFunctionCall)++that._notReturnedFunctions;that._worker.postMessage(message,transferables)}function trySendPendingMessages(that){while(that._notReturnedFunctions<that._functionsBufferSize&&that._pendingMessages.length>0){var message=that._pendingMessages.shift();sendMessageToSlave(that,message.transferables,message.isFunctionCall,message.message)}}
function getBaseUrlFromEntryScript(){var baseUrl=location.href;var endOfPath=baseUrl.lastIndexOf("/");if(endOfPath>=0)baseUrl=baseUrl.substring(0,endOfPath);return baseUrl}asyncProxyScriptBlob.addMember(AsyncProxyMasterClosure,"AsyncProxyMaster");return AsyncProxyMaster}var AsyncProxyMaster=AsyncProxyMasterClosure();function AsyncProxySlaveClosure(){var slaveHelperSingleton={};var beforeOperationListener=null;var slaveSideMainInstance;var slaveSideInstanceCreator=defaultInstanceCreator;var subWorkerIdToSubWorker={};var ctorName;slaveHelperSingleton._initializeSlave=function initializeSlave(){self.onmessage=onMessage};slaveHelperSingleton.setSlaveSideCreator=function setSlaveSideCreator(creator){slaveSideInstanceCreator=creator};slaveHelperSingleton.setBeforeOperationListener=function setBeforeOperationListener(listener){beforeOperationListener=
listener};slaveHelperSingleton.sendUserDataToMaster=function sendUserDataToMaster(userData){self.postMessage({type:"userData",userData:userData})};slaveHelperSingleton.wrapPromiseFromSlaveSide=function wrapPromiseFromSlaveSide(callId,promise,pathsToTransferables){var promiseThen=promise.then(function sendPromiseToMaster(result){var transferables=extractTransferables(pathsToTransferables,result);self.postMessage({type:"promiseResult",callId:callId,result:result},transferables)});promiseThen["catch"](function sendFailureToMaster(reason){self.postMessage({type:"promiseFailure",
callId:callId,reason:reason})})};slaveHelperSingleton.wrapCallbackFromSlaveSide=function wrapCallbackFromSlaveSide(callbackHandle){var isAlreadyCalled=false;function callbackWrapperFromSlaveSide(){if(isAlreadyCalled)throw"Callback is called twice but isMultipleTimeCallback "+"= false";var argumentsAsArray=getArgumentsAsArray(arguments);if(beforeOperationListener!==null)try{beforeOperationListener.call(slaveSideMainInstance,"callback",callbackHandle.callbackName,argumentsAsArray)}catch(e){console.log("AsyncProxySlave.beforeOperationListener has thrown an exception: "+
e)}var transferables=extractTransferables(callbackHandle.pathsToTransferables,argumentsAsArray);self.postMessage({type:"callback",callId:callbackHandle.callId,args:argumentsAsArray},transferables);if(!callbackHandle.isMultipleTimeCallback)isAlreadyCalled=true}return callbackWrapperFromSlaveSide};slaveHelperSingleton._getScriptName=function _getScriptName(){var error=new Error;var scriptName=ScriptsToImportPool._getScriptName(error);return scriptName};function extractTransferables(pathsToTransferables,
pathsBase){if(pathsToTransferables===undefined)return undefined;var transferables=new Array(pathsToTransferables.length);for(var i=0;i<pathsToTransferables.length;++i){var path=pathsToTransferables[i];var transferable=pathsBase;for(var j=0;j<path.length;++j){var member=path[j];transferable=transferable[member]}transferables[i]=transferable}return transferables}function onMessage(event){var functionNameToCall=event.data.functionToCall;var args=event.data.args;var callId=event.data.callId;var isPromise=
event.data.isPromise;var pathsToTransferablesInPromiseResult=event.data.pathsToTransferablesInPromiseResult;var result=null;switch(functionNameToCall){case "ctor":self["AsyncProxy"]["AsyncProxyMaster"]._setEntryUrl(event.data.masterEntryUrl);var scriptsToImport=event.data.scriptsToImport;ctorName=event.data.ctorName;for(var i=0;i<scriptsToImport.length;++i)importScripts(scriptsToImport[i]);slaveSideMainInstance=slaveSideInstanceCreator.apply(null,args);return;case "subWorkerOnMessage":var subWorker=
subWorkerIdToSubWorker[event.data.subWorkerId];var workerEvent={data:event.data.data};subWorker.onmessage(workerEvent);return}args=new Array(event.data.args.length);for(var i=0;i<event.data.args.length;++i){var arg=event.data.args[i];if(arg!==undefined&&arg!==null&&arg.isWorkerHelperCallback)arg=slaveHelperSingleton.wrapCallbackFromSlaveSide(arg);args[i]=arg}var functionContainer=slaveSideMainInstance;var functionToCall;while(functionContainer){functionToCall=slaveSideMainInstance[functionNameToCall];
if(functionToCall)break;functionContainer=functionContainer.__proto__}if(!functionToCall)throw"AsyncProxy error: could not find function "+functionToCall;var promise=functionToCall.apply(slaveSideMainInstance,args);if(isPromise)slaveHelperSingleton.wrapPromiseFromSlaveSide(callId,promise,pathsToTransferablesInPromiseResult);self.postMessage({type:"functionCalled",callId:event.data.callId,result:result})}function defaultInstanceCreator(){var namespacesAndCtorName=ctorName.split(".");var member=self;
for(var i=0;i<namespacesAndCtorName.length;++i)member=member[namespacesAndCtorName[i]];var TypeCtor=member;var bindArgs=[null].concat(getArgumentsAsArray(arguments));var instance=new (Function.prototype.bind.apply(TypeCtor,bindArgs));return instance}function getArgumentsAsArray(args){var argumentsAsArray=new Array(args.length);for(var i=0;i<args.length;++i)argumentsAsArray[i]=args[i];return argumentsAsArray}if(self["Worker"]===undefined){var SubWorkerEmulationForChrome=self["SubWorkerEmulationForChrome"];
SubWorkerEmulationForChrome.initialize(subWorkerIdToSubWorker);self["Worker"]=SubWorkerEmulationForChrome}self["asyncProxyScriptBlob"].addMember(AsyncProxySlaveClosure,"AsyncProxySlaveSingleton");return slaveHelperSingleton}var AsyncProxySlaveSingleton=AsyncProxySlaveClosure();function ScriptsToImportPoolClosure(){function ScriptsToImportPool(){var that=this;that._scriptsByName={};that._scriptsArray=null}ScriptsToImportPool.prototype.addScriptFromErrorWithStackTrace=function addScriptForWorkerImport(errorWithStackTrace){var fileName=ScriptsToImportPool._getScriptName(errorWithStackTrace);if(!this._scriptsByName[fileName]){this._scriptsByName[fileName]=true;this._scriptsArray=null}};ScriptsToImportPool.prototype.getScriptsForWorkerImport=function getScriptsForWorkerImport(){if(this._scriptsArray===
null){this._scriptsArray=[];for(var fileName in this._scriptsByName)this._scriptsArray.push(fileName)}return this._scriptsArray};ScriptsToImportPool._getScriptName=function getScriptName(errorWithStackTrace){var stack=errorWithStackTrace.stack.trim();var currentStackFrameRegex=/at (|[^ ]+ \()([^ ]+):\d+:\d+/;var source=currentStackFrameRegex.exec(stack);if(source&&source[2]!=="")return source[2];var lastStackFrameRegex=new RegExp(/.+\/(.*?):\d+(:\d+)*$/);source=lastStackFrameRegex.exec(stack);if(source&&
source[1]!=="")return source[1];if(errorWithStackTrace.fileName!=undefined)return errorWithStackTrace.fileName;throw"ImageDecoderFramework.js: Could not get current script URL";};self["asyncProxyScriptBlob"].addMember(ScriptsToImportPoolClosure,"ScriptsToImportPool");return ScriptsToImportPool}var ScriptsToImportPool=ScriptsToImportPoolClosure();function ExportAsyncProxySymbolsClosure(){function ExportAsyncProxySymbols(SubWorkerEmulationForChrome,AsyncProxySlaveSingleton,AsyncProxyMaster,ScriptsToImportPool){self["AsyncProxy"]=self["AsyncProxy"]||{};SubWorkerEmulationForChrome.prototype["postMessage"]=SubWorkerEmulationForChrome.prototype.postMessage;SubWorkerEmulationForChrome.prototype["terminate"]=SubWorkerEmulationForChrome.prototype.terminate;AsyncProxySlaveSingleton["setSlaveSideCreator"]=AsyncProxySlaveSingleton.setSlaveSideCreator;
AsyncProxySlaveSingleton["setBeforeOperationListener"]=AsyncProxySlaveSingleton.setBeforeOperationListener;AsyncProxySlaveSingleton["sendUserDataToMaster"]=AsyncProxySlaveSingleton.sendUserDataToMaster;AsyncProxySlaveSingleton["wrapPromiseFromSlaveSide"]=AsyncProxySlaveSingleton.wrapPromiseFromSlaveSide;AsyncProxySlaveSingleton["wrapCallbackFromSlaveSide"]=AsyncProxySlaveSingleton.wrapCallbackFromSlaveSide;AsyncProxyMaster.prototype["setUserDataHandler"]=AsyncProxyMaster.prototype.setUserDataHandler;
AsyncProxyMaster.prototype["terminate"]=AsyncProxyMaster.prototype.terminate;AsyncProxyMaster.prototype["callFunction"]=AsyncProxyMaster.prototype.callFunction;AsyncProxyMaster.prototype["wrapCallback"]=AsyncProxyMaster.prototype.wrapCallback;AsyncProxyMaster.prototype["freeCallback"]=AsyncProxyMaster.prototype.freeCallback;AsyncProxyMaster["getEntryUrl"]=AsyncProxyMaster.getEntryUrl;ScriptsToImportPool.prototype["addScriptFromErrorWithStackTrace"]=ScriptsToImportPool.prototype.addScriptFromErrorWithStackTrace;
ScriptsToImportPool.prototype["getScriptsForWorkerImport"]=ScriptsToImportPool.prototype.getScriptsForWorkerImport}asyncProxyScriptBlob.addMember(ExportAsyncProxySymbolsClosure,"ExportAsyncProxySymbols");asyncProxyScriptBlob.addStatement("ExportAsyncProxySymbols(SubWorkerEmulationForChrome, AsyncProxySlaveSingleton, AsyncProxyMaster, ScriptsToImportPool);");asyncProxyScriptBlob.addStatement("self['AsyncProxy']['AsyncProxySlaveSingleton'] = AsyncProxySlaveSingleton;");asyncProxyScriptBlob.addStatement("self['AsyncProxy']['AsyncProxyMaster'] = AsyncProxyMaster;");
asyncProxyScriptBlob.addStatement("self['AsyncProxy']['ScriptsToImportPool'] = ScriptsToImportPool;");return ExportAsyncProxySymbols}ExportAsyncProxySymbolsClosure()(SubWorkerEmulationForChrome,AsyncProxySlaveSingleton,AsyncProxyMaster,ScriptsToImportPool);self["AsyncProxy"]["AsyncProxySlaveSingleton"]=AsyncProxySlaveSingleton;self["AsyncProxy"]["AsyncProxyMaster"]=AsyncProxyMaster;self["AsyncProxy"]["ScriptsToImportPool"]=ScriptsToImportPool;

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.imageDecoderFramework = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

module.exports = calculateFrustum;

/* global Cesium: false */

var imageHelperFunctions = require('imagehelperfunctions.js');

var MAX_RECURSIVE_LEVEL_ON_FAILED_TRANSFORM = 4;

function calculateFrustum(cesiumWidget) {
    var screenSize = {
        x: cesiumWidget.scene.canvas.width,
        y: cesiumWidget.scene.canvas.height
    };
    
    var points = [];
    searchBoundingPoints(
        0, 0, screenSize.x, screenSize.y, points, cesiumWidget, /*recursive=*/0);

    var frustumRectangle = Cesium.Rectangle.fromCartographicArray(points);
    if (frustumRectangle.east < frustumRectangle.west || frustumRectangle.north < frustumRectangle.south) {
        frustumRectangle = {
            east: Math.max(frustumRectangle.east, frustumRectangle.west),
            west: Math.min(frustumRectangle.east, frustumRectangle.west),
            north: Math.max(frustumRectangle.north, frustumRectangle.south),
            south: Math.min(frustumRectangle.north, frustumRectangle.south)
        };
    }

    var frustumData = imageHelperFunctions.calculateFrustum2DFromBounds(
        frustumRectangle, screenSize);
                
    return frustumData;
}
    
function searchBoundingPoints(
    minX, minY, maxX, maxY, points, cesiumWidget, recursiveLevel) {
    
    var transformedPoints = 0;
    transformedPoints += transformAndAddPoint(
        minX, minY, cesiumWidget, points);
    transformedPoints += transformAndAddPoint(
        maxX, minY, cesiumWidget, points);
    transformedPoints += transformAndAddPoint(
        minX, maxY, cesiumWidget, points);
    transformedPoints += transformAndAddPoint(
        maxX, maxY, cesiumWidget, points);

    var maxLevel = MAX_RECURSIVE_LEVEL_ON_FAILED_TRANSFORM;
    
    if (transformedPoints === 4 || recursiveLevel >= maxLevel) {
        return;
    }
    
    ++recursiveLevel;
    
    var middleX = (minX + maxX) / 2;
    var middleY = (minY + maxY) / 2;
    
    searchBoundingPoints(
        minX, minY, middleX, middleY, points, cesiumWidget, recursiveLevel);

    searchBoundingPoints(
        minX, middleY, middleX, maxY, points, cesiumWidget, recursiveLevel);

    searchBoundingPoints(
        middleX, minY, maxX, middleY, points, cesiumWidget, recursiveLevel);

    searchBoundingPoints(
        middleX, middleY, maxX, maxY, points, cesiumWidget, recursiveLevel);
}

function transformAndAddPoint(x, y, cesiumWidget, points) {
    
    var screenPoint = new Cesium.Cartesian2(x, y);
    var ellipsoid = cesiumWidget.scene.mapProjection.ellipsoid;
    var point3D = cesiumWidget.scene.camera.pickEllipsoid(screenPoint, ellipsoid);
    
    if (point3D === undefined) {
        return 0;
    }

    var cartesian = ellipsoid.cartesianToCartographic(point3D);
    if (cartesian === undefined) {
        return 0;
    }
    
    points.push(cartesian);
    return 1;
}
},{"imagehelperfunctions.js":12}],2:[function(require,module,exports){
'use strict';

module.exports = CesiumImageDecoderLayerManager;

var CanvasImageryProvider = require('canvasimageryprovider.js');
var ViewerImageDecoder = require('viewerimagedecoder.js');
var calculateCesiumFrustum = require('_cesiumfrustumcalculator.js');

/* global Cesium: false */

function CesiumImageDecoderLayerManager(imageImplementationClassName, options) {
    this._options = options || {};
    
    if (this._options.rectangle !== undefined) {
        this._options = JSON.parse(JSON.stringify(options));
        this._options.cartographicBounds = {
            west: options.rectangle.west,
            east: options.rectangle.east,
            south: options.rectangle.south,
            north: options.rectangle.north
        };
    }
    
    this._options.minFunctionCallIntervalMilliseconds =
        options.minFunctionCallIntervalMilliseconds || 100;
    this._url = options.url;

    this._targetCanvas = document.createElement('canvas');
    this._imageryProviders = [
        new CanvasImageryProvider(this._targetCanvas),
        new CanvasImageryProvider(this._targetCanvas)
    ];
    this._imageryLayerShown = new Cesium.ImageryLayer(this._imageryProviders[0]);
    this._imageryLayerPending = new Cesium.ImageryLayer(this._imageryProviders[1]);

    this._canvasUpdatedCallbackBound = this._canvasUpdatedCallback.bind(this);
    
    this._isPendingUpdateCallback = false;
    this._isWhileReplaceLayerShown = false;
    this._pendingPositionRectangle = null;
    
    this._image = new ViewerImageDecoder(
        imageImplementationClassName,
        this._canvasUpdatedCallbackBound,
        this._options);
    
    this._image.setTargetCanvas(this._targetCanvas);
    
    this._updateFrustumBound = this._updateFrustum.bind(this);
    this._postRenderBound = this._postRender.bind(this);
}

CesiumImageDecoderLayerManager.prototype.setExceptionCallback = function setExceptionCallback(exceptionCallback) {
    this._image.setExceptionCallback(exceptionCallback);
};

CesiumImageDecoderLayerManager.prototype.open = function open(widgetOrViewer) {
    this._widget = widgetOrViewer;
    this._layers = widgetOrViewer.scene.imageryLayers;
    widgetOrViewer.scene.postRender.addEventListener(this._postRenderBound);
    
    this._image.open(this._url);
    this._layers.add(this._imageryLayerShown);
    
    // NOTE: Is there an event handler to register instead?
    // (Cesium's event controllers only expose keyboard and mouse
    // events, but there is no event for frustum changed
    // programmatically).
    this._intervalHandle = setInterval(
        this._updateFrustumBound,
        500);
};

CesiumImageDecoderLayerManager.prototype.close = function close() {
    this._image.close();
    clearInterval(this._intervalHandle);

    this._layers.remove(this._imageryLayerShown);
    this._widget.removeEventListener(this._postRenderBound);
    if (this._isWhileReplaceLayerShown) {
        this._isWhileReplaceLayerShown = false;
        this._isPendingUpdateCallback = false;
        this._layers.remove(this._imageryLayerPending);
    }
};

CesiumImageDecoderLayerManager.prototype.getImageryLayers = function getImageryLayers() {
    return [this._imageryLayerShown, this._imageryLayerPending];
};

CesiumImageDecoderLayerManager.prototype._updateFrustum = function updateFrustum() {
    var frustum = calculateCesiumFrustum(this._widget);
    if (frustum !== null) {
        this._image.updateViewArea(frustum);
    }
};

CesiumImageDecoderLayerManager.prototype._canvasUpdatedCallback = function canvasUpdatedCallback(newPosition) {
    if (this._isWhileReplaceLayerShown) {
        this._isPendingUpdateCallback = true;
        this._pendingPositionRectangle = newPosition;
    }
    
    if (newPosition !== null) {
        var rectangle = new Cesium.Rectangle(
            newPosition.west,
            newPosition.south,
            newPosition.east,
            newPosition.north);
        
        this._imageryProviders[0].setRectangle(rectangle);
        this._imageryProviders[1].setRectangle(rectangle);
    }
    
    this._removeAndReAddLayer();
};

CesiumImageDecoderLayerManager.prototype._removeAndReAddLayer = function removeAndReAddLayer() {
    var index = this._layers.indexOf(this._imageryLayerShown);
    
    if (index < 0) {
        throw 'Layer was removed from viewer\'s layers  without ' +
            'closing layer manager. Use CesiumImageDecoderLayerManager.' +
            'close() instead';
    }
    
    this._isWhileReplaceLayerShown = true;
    this._layers.add(this._imageryLayerPending, index);
};

CesiumImageDecoderLayerManager.prototype._postRender = function postRender() {
    if (!this._isWhileReplaceLayerShown)
        return;
    
    this._isWhileReplaceLayerShown = false;
    this._layers.remove(this._imageryLayerShown, /*destroy=*/false);
    
    var swap = this._imageryLayerShown;
    this._imageryLayerShown = this._imageryLayerPending;
    this._imageryLayerPending = swap;
    
    if (this._isPendingUpdateCallback) {
        this._isPendingUpdateCallback = false;
        this._canvasUpdatedCallback(this._pendingPositionRectangle);
    }
};
},{"_cesiumfrustumcalculator.js":1,"canvasimageryprovider.js":3,"viewerimagedecoder.js":20}],3:[function(require,module,exports){
'use strict';

module.exports = CanvasImageryProvider;

/* global Cesium: false */
/* global DeveloperError: false */
/* global Credit: false */

/**
 * Provides a Single Canvas imagery tile.  The image is assumed to use a
 * {@link GeographicTilingScheme}.
 *
 * @alias CanvasImageryProvider
 * @constructor
 *
 * @param {canvas} Canvas for the tile.
 * @param {Object} options Object with the following properties:
 * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.
 *
 * @see ArcGisMapServerImageryProvider
 * @see BingMapsImageryProvider
 * @see GoogleEarthImageryProvider
 * @see OpenStreetMapImageryProvider
 * @see TileMapServiceImageryProvider
 * @see WebMapServiceImageryProvider
 */
function CanvasImageryProvider(canvas, options) {
    if (options === undefined) {
        options = {};
    }

    //>>includeStart('debug', pragmas.debug);
    if (canvas === undefined) {
        throw new DeveloperError('canvas is required.');
    }
    //>>includeEnd('debug');

    this._canvas = canvas;

    this._errorEvent = new Event('CanvasImageryProviderStatus');

    this._ready = false;

    var credit = options.credit;
    if (typeof credit === 'string') {
        credit = new Credit(credit);
    }
    this._credit = credit;
}

CanvasImageryProvider.prototype = {
    /**
     * Gets the width of each tile, in pixels. This function should
     * not be called before {@link CanvasImageryProvider#ready} returns true.
     * @memberof CanvasImageryProvider.prototype
     * @type {Number}
     * @readonly
     */
    get tileWidth() {
            //>>includeStart('debug', pragmas.debug);
            if (!this._ready) {
                    throw new DeveloperError('tileWidth must not be called before the imagery provider is ready.');
            }
            //>>includeEnd('debug');

            return this._canvas.width;
    },

    /**
     * Gets the height of each tile, in pixels.  This function should
     * not be called before {@link CanvasImageryProvider#ready} returns true.
     * @memberof CanvasImageryProvider.prototype
     * @type {Number}
     * @readonly
     */
    get tileHeight() {
            //>>includeStart('debug', pragmas.debug);
            if (!this._ready) {
                    throw new DeveloperError('tileHeight must not be called before the imagery provider is ready.');
            }
            //>>includeEnd('debug');

            return this._canvas.height;
    },

    /**
     * Gets the maximum level-of-detail that can be requested.  This function should
     * not be called before {@link CanvasImageryProvider#ready} returns true.
     * @memberof CanvasImageryProvider.prototype
     * @type {Number}
     * @readonly
     */
    get maximumLevel() {
            //>>includeStart('debug', pragmas.debug);
            if (!this._ready) {
                    throw new DeveloperError('maximumLevel must not be called before the imagery provider is ready.');
            }
            //>>includeEnd('debug');

            return 0;
    },

    /**
     * Gets the minimum level-of-detail that can be requested.  This function should
     * not be called before {@link CanvasImageryProvider#ready} returns true.
     * @memberof CanvasImageryProvider.prototype
     * @type {Number}
     * @readonly
     */
    get minimumLevel() {
            //>>includeStart('debug', pragmas.debug);
            if (!this._ready) {
                    throw new DeveloperError('minimumLevel must not be called before the imagery provider is ready.');
            }
            //>>includeEnd('debug');

            return 0;
    },

    /**
     * Gets the tiling scheme used by this provider.  This function should
     * not be called before {@link CanvasImageryProvider#ready} returns true.
     * @memberof CanvasImageryProvider.prototype
     * @type {TilingScheme}
     * @readonly
     */
    get tilingScheme() {
            //>>includeStart('debug', pragmas.debug);
            if (!this._ready) {
                    throw new DeveloperError('tilingScheme must not be called before the imagery provider is ready.');
            }
            //>>includeEnd('debug');

            return this._tilingScheme;
    },

    /**
     * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
     * not be called before {@link CanvasImageryProvider#ready} returns true.
     * @memberof CanvasImageryProvider.prototype
     * @type {Rectangle}
     * @readonly
     */
    get rectangle() {
            return this._tilingScheme.rectangle;
    },

    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.  This function should
     * not be called before {@link CanvasImageryProvider#ready} returns true.
     * @memberof CanvasImageryProvider.prototype
     * @type {TileDiscardPolicy}
     * @readonly
     */
    get tileDiscardPolicy() {
            //>>includeStart('debug', pragmas.debug);
            if (!this._ready) {
                    throw new DeveloperError('tileDiscardPolicy must not be called before the imagery provider is ready.');
            }
            //>>includeEnd('debug');

            return undefined;
    },

    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     * @memberof CanvasImageryProvider.prototype
     * @type {Event}
     * @readonly
     */
    get errorEvent() {
            return this._errorEvent;
    },

    /**
     * Gets a value indicating whether or not the provider is ready for use.
     * @memberof CanvasImageryProvider.prototype
     * @type {Boolean}
     * @readonly
     */
    get ready() {
            return this._ready;
    },

    /**
     * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.  This function should not be called before {@link CanvasImageryProvider#ready} returns true.
     * @memberof CanvasImageryProvider.prototype
     * @type {Credit}
     * @readonly
     */
    get credit() {
            return this._credit;
    },

    /**
     * Gets a value indicating whether or not the images provided by this imagery provider
     * include an alpha channel.  If this property is false, an alpha channel, if present, will
     * be ignored.  If this property is true, any images without an alpha channel will be treated
     * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
     * and texture upload time are reduced.
     * @memberof CanvasImageryProvider.prototype
     * @type {Boolean}
     * @readonly
     */
    get hasAlphaChannel() {
            return true;
    }
};

CanvasImageryProvider.prototype.setRectangle = function setRectangle(rectangle) {
    
    this._tilingScheme = new Cesium.GeographicTilingScheme({
        rectangle: rectangle,
        numberOfLevelZeroTilesX: 1,
        numberOfLevelZeroTilesY: 1
    });
    
    if (!this._ready) {
        this._ready = true;
        Cesium.TileProviderError.handleSuccess(this._errorEvent);
    }
};

CanvasImageryProvider.prototype.getTileWidth = function getTileWidth() {
    return this.tileWidth;
};

CanvasImageryProvider.prototype.getTileHeight = function getTileHeight() {
    return this.tileHeight;
};

CanvasImageryProvider.prototype.getMaximumLevel = function getMaximumLevel() {
    return this.maximumLevel;
};

CanvasImageryProvider.prototype.getMinimumLevel = function getMinimumLevel() {
    return this.minimumLevel;
};

CanvasImageryProvider.prototype.isReady = function isReady() {
    return this.ready;
};

CanvasImageryProvider.prototype.getCredit = function getCredit() {
    return this.credit;
};

CanvasImageryProvider.prototype.getRectangle = function getRectangle() {
    return this.tilingScheme.rectangle;
};

CanvasImageryProvider.prototype.getTilingScheme = function getTilingScheme() {
    return this.tilingScheme;
};

CanvasImageryProvider.prototype.getTileDiscardPolicy = function getTileDiscardPolicy() {
    return this.tileDiscardPolicy;
};

CanvasImageryProvider.prototype.getErrorEvent = function getErrorEvent() {
    return this.errorEvent;
};

CanvasImageryProvider.prototype.getHasAlphaChannel = function getHasAlphaChannel() {
    return this.hasAlphaChannel;
};

/**
 * Gets the credits to be displayed when a given tile is displayed.
 *
 * @param {Number} x The tile X coordinate.
 * @param {Number} y The tile Y coordinate.
 * @param {Number} level The tile level;
 * @returns {Credit[]} The credits to be displayed when the tile is displayed.
 *
 * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.
 */
CanvasImageryProvider.prototype.getTileCredits = function(x, y, level) {
    return undefined;
};

/**
 * Requests the image for a given tile.  This function should
 * not be called before {@link CanvasImageryProvider#ready} returns true.
 *
 * @param {Number} x The tile X coordinate.
 * @param {Number} y The tile Y coordinate.
 * @param {Number} level The tile level.
 * @returns {Promise} A promise for the image that will resolve when the image is available, or
 *          undefined if there are too many active requests to the server, and the request
 *          should be retried later.  The resolved image may be either an
 *          Image or a Canvas DOM object.
 *
 * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.
 */
CanvasImageryProvider.prototype.requestImage = function(x, y, level) {
    //>>includeStart('debug', pragmas.debug);
    if (!this._ready) {
            throw new DeveloperError('requestImage must not be called before the imagery provider is ready.');
    }
    //>>includeEnd('debug');

    return this._canvas;
};

/**
 * Picking features is not currently supported by this imagery provider, so this function simply returns
 * undefined.
 *
 * @param {Number} x The tile X coordinate.
 * @param {Number} y The tile Y coordinate.
 * @param {Number} level The tile level.
 * @param {Number} longitude The longitude at which to pick features.
 * @param {Number} latitude  The latitude at which to pick features.
 * @return {Promise} A promise for the picked features that will resolve when the asynchronous
 *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
 *                   instances.  The array may be empty if no features are found at the given location.
 *                   It may also be undefined if picking is not supported.
 */
CanvasImageryProvider.prototype.pickFeatures = function() {
        return undefined;
};
},{}],4:[function(require,module,exports){
'use strict';

module.exports = ImageDecoderImageryProvider;

var WorkerProxyImageDecoder = require('workerproxyimagedecoder.js');
var calculateCesiumFrustum = require('_cesiumfrustumcalculator.js');
var imageHelperFunctions = require('imagehelperfunctions.js');

/* global Cesium: false */
/* global DeveloperError: false */
/* global Credit: false */
/* global Promise: false */

/**
 * Provides a ImageDecoder client imagery tile.  The image is assumed to use a
 * {@link GeographicTilingScheme}.
 *
 * @alias ImageDecoderImageryProvider
 * @constructor
 *
 * @param {Object} options Object with the following properties:
 * @param {String} options.url The url for the tile.
 * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the image.
 * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.
 * @param {Object} [options.proxy] A proxy to use for requests. This object is expected to have a getURL function which returns the proxied URL, if needed.
 * @param {boolean} [options.adaptProportions] determines if to adapt the proportions of the rectangle provided to the image pixels proportions.
 *
 * @see ArcGisMapServerImageryProvider
 * @see BingMapsImageryProvider
 * @see GoogleEarthImageryProvider
 * @see OpenStreetMapImageryProvider
 * @see TileMapServiceImageryProvider
 * @see WebMapServiceImageryProvider
 */
function ImageDecoderImageryProvider(imageImplementationClassName, options) {
    var url = options.url;
    this._adaptProportions = options.adaptProportions;
    this._rectangle = options.rectangle;
    this._proxy = options.proxy;
    this._updateFrustumInterval = 1000 || options.updateFrustumInterval;
    this._credit = options.credit;
    
    if (typeof this._credit === 'string') {
        this._credit = new Credit(this._credit);
    }
    
    if (this._rectangle === undefined) {
        this._rectangle = Cesium.Rectangle.fromDegrees(-180, -90, 180, 90);
    }
    
    if (this._adaptProportions === undefined) {
        this._adaptProportions = true;
    }

    options = JSON.parse(JSON.stringify(options || {}));
    options.cartographicBounds = {
        west: this._rectangle.west,
        east: this._rectangle.east,
        south: this._rectangle.south,
        north: this._rectangle.north
    };
    
    //>>includeStart('debug', pragmas.debug);
    if (url === undefined) {
            throw new DeveloperError('url is required.');
    }
    //>>includeEnd('debug');

    this._url = url;

    this._tilingScheme = undefined;

    this._tileWidth = 0;
    this._tileHeight = 0;

    this._errorEvent = new Event('ImageDecoderImageryProviderStatus');

    this._ready = false;
    this._exceptionCallback = null;
    this._cesiumWidget = null;
    this._updateFrustumIntervalHandle = null;
    

    var imageUrl = url;
    if (this._proxy !== undefined) {
        // NOTE: Is that the correct logic?
        imageUrl = this._proxy.getURL(imageUrl);
    }
        
    this._image = new WorkerProxyImageDecoder(imageImplementationClassName, {
        serverRequestPrioritizer: 'frustum',
        decodePrioritizer: 'frustum'
    });

    this._url = imageUrl;
}

ImageDecoderImageryProvider.prototype = {
    /**
     * Gets the URL of the ImageDecoder server (including target).
     * @memberof ImageDecoderImageryProvider.prototype
     * @type {String}
     * @readonly
     */
    get url() {
        return this._url;
    },

    /**
     * Gets the proxy used by this provider.
     * @memberof ImageDecoderImageryProvider.prototype
     * @type {Proxy}
     * @readonly
     */
    get proxy() {
        return this._proxy;
    },

    /**
     * Gets the width of each tile, in pixels. This function should
     * not be called before {@link ImageDecoderImageryProvider#ready} returns true.
     * @memberof ImageDecoderImageryProvider.prototype
     * @type {Number}
     * @readonly
     */
    get tileWidth() {
        //>>includeStart('debug', pragmas.debug);
        if (!this._ready) {
                throw new DeveloperError('tileWidth must not be called before the imagery provider is ready.');
        }
        //>>includeEnd('debug');

        return this._tileWidth;
    },

    /**
     * Gets the height of each tile, in pixels.  This function should
     * not be called before {@link ImageDecoderImageryProvider#ready} returns true.
     * @memberof ImageDecoderImageryProvider.prototype
     * @type {Number}
     * @readonly
     */
    get tileHeight() {
        //>>includeStart('debug', pragmas.debug);
        if (!this._ready) {
                throw new DeveloperError('tileHeight must not be called before the imagery provider is ready.');
        }
        //>>includeEnd('debug');

        return this._tileHeight;
    },

    /**
     * Gets the maximum level-of-detail that can be requested.  This function should
     * not be called before {@link ImageDecoderImageryProvider#ready} returns true.
     * @memberof ImageDecoderImageryProvider.prototype
     * @type {Number}
     * @readonly
     */
    get maximumLevel() {
        //>>includeStart('debug', pragmas.debug);
        if (!this._ready) {
                throw new DeveloperError('maximumLevel must not be called before the imagery provider is ready.');
        }
        //>>includeEnd('debug');

        return this._numResolutionLevels - 1;
    },

    /**
     * Gets the minimum level-of-detail that can be requested.  This function should
     * not be called before {@link ImageDecoderImageryProvider#ready} returns true.
     * @memberof ImageDecoderImageryProvider.prototype
     * @type {Number}
     * @readonly
     */
    get minimumLevel() {
        //>>includeStart('debug', pragmas.debug);
        if (!this._ready) {
                throw new DeveloperError('minimumLevel must not be called before the imagery provider is ready.');
        }
        //>>includeEnd('debug');

        return 0;
    },

    /**
     * Gets the tiling scheme used by this provider.  This function should
     * not be called before {@link ImageDecoderImageryProvider#ready} returns true.
     * @memberof ImageDecoderImageryProvider.prototype
     * @type {TilingScheme}
     * @readonly
     */
    get tilingScheme() {
        //>>includeStart('debug', pragmas.debug);
        if (!this._ready) {
            throw new DeveloperError('tilingScheme must not be called before the imagery provider is ready.');
        }
        //>>includeEnd('debug');

        return this._tilingScheme;
    },

    /**
     * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
     * not be called before {@link ImageDecoderImageryProvider#ready} returns true.
     * @memberof ImageDecoderImageryProvider.prototype
     * @type {Rectangle}
     * @readonly
     */
    get rectangle() {
        return this._tilingScheme.rectangle;
    },

    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.  This function should
     * not be called before {@link ImageDecoderImageryProvider#ready} returns true.
     * @memberof ImageDecoderImageryProvider.prototype
     * @type {TileDiscardPolicy}
     * @readonly
     */
    get tileDiscardPolicy() {
        //>>includeStart('debug', pragmas.debug);
        if (!this._ready) {
            throw new DeveloperError('tileDiscardPolicy must not be called before the imagery provider is ready.');
        }
        //>>includeEnd('debug');

        return undefined;
    },

    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     * @memberof ImageDecoderImageryProvider.prototype
     * @type {Event}
     * @readonly
     */
    get errorEvent() {
        return this._errorEvent;
    },

    /**
     * Gets a value indicating whether or not the provider is ready for use.
     * @memberof ImageDecoderImageryProvider.prototype
     * @type {Boolean}
     * @readonly
     */
    get ready() {
        return this._ready;
    },

    /**
     * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.  This function should not be called before {@link ImageDecoderImageryProvider#ready} returns true.
     * @memberof ImageDecoderImageryProvider.prototype
     * @type {Credit}
     * @readonly
     */
    get credit() {
        return this._credit;
    },

    /**
     * Gets a value indicating whether or not the images provided by this imagery provider
     * include an alpha channel.  If this property is false, an alpha channel, if present, will
     * be ignored.  If this property is true, any images without an alpha channel will be treated
     * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
     * and texture upload time are reduced.
     * @memberof ImageDecoderImageryProvider.prototype
     * @type {Boolean}
     * @readonly
     */
    get hasAlphaChannel() {
        return true;
    }
};

ImageDecoderImageryProvider.prototype.setExceptionCallback =
    function setExceptionCallback(exceptionCallback) {
    
    this._exceptionCallback = exceptionCallback;
};

ImageDecoderImageryProvider.prototype.open = function open(widgetOrViewer) {
    if (this._updateFrustumIntervalHandle !== null) {
        throw new DeveloperError('Cannot set two parent viewers.');
    }
    
    if (widgetOrViewer === undefined) {
        throw new DeveloperError('widgetOrViewer should be given. It is ' +
            'needed for frustum calculation for the priority mechanism');
    }
    
    this._image.open(this._url)
		.then(this._opened.bind(this))
		.catch(this._onException.bind(this));
    
    this._cesiumWidget = widgetOrViewer;
    
    this._updateFrustumIntervalHandle = setInterval(
        this._setPriorityByFrustum.bind(this),
        this._updateFrustumInterval);
};

ImageDecoderImageryProvider.prototype.close = function close() {
    clearInterval(this._updateFrustumIntervalHandle);
    this._image.close();
};

ImageDecoderImageryProvider.prototype.getTileWidth = function getTileWidth() {
    return this.tileWidth;
};

ImageDecoderImageryProvider.prototype.getTileHeight = function getTileHeight() {
    return this.tileHeight;
};

ImageDecoderImageryProvider.prototype.getMaximumLevel = function getMaximumLevel() {
    return this.maximumLevel;
};

ImageDecoderImageryProvider.prototype.getMinimumLevel = function getMinimumLevel() {
    return this.minimumLevel;
};

ImageDecoderImageryProvider.prototype.getUrl = function getUrl() {
    return this.url;
};

ImageDecoderImageryProvider.prototype.getProxy = function getProxy() {
    return this.proxy;
};

ImageDecoderImageryProvider.prototype.isReady = function isReady() {
    return this.ready;
};

ImageDecoderImageryProvider.prototype.getCredit = function getCredit() {
    return this.credit;
};

ImageDecoderImageryProvider.prototype.getRectangle = function getRectangle() {
    return this.tilingScheme.rectangle;
};

ImageDecoderImageryProvider.prototype.getTilingScheme = function getTilingScheme() {
    return this.tilingScheme;
};

ImageDecoderImageryProvider.prototype.getTileDiscardPolicy = function getTileDiscardPolicy() {
    return this.tileDiscardPolicy;
};

ImageDecoderImageryProvider.prototype.getErrorEvent = function getErrorEvent() {
    return this.errorEvent;
};

ImageDecoderImageryProvider.prototype.getHasAlphaChannel = function getHasAlphaChannel() {
    return this.hasAlphaChannel;
};

/**
 * Gets the credits to be displayed when a given tile is displayed.
 *
 * @param {Number} x The tile X coordinate.
 * @param {Number} y The tile Y coordinate.
 * @param {Number} level The tile level;
 * @returns {Credit[]} The credits to be displayed when the tile is displayed.
 *
 * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.
 */
ImageDecoderImageryProvider.prototype.getTileCredits = function(x, y, level) {
    return undefined;
};

/**
 * Requests the image for a given tile.  This function should
 * not be called before {@link ImageDecoderImageryProvider#ready} returns true.
 *
 * @param {Number} x The tile X coordinate.
 * @param {Number} y The tile Y coordinate.
 * @param {Number} level The tile level.
 * @returns {Promise} A promise for the image that will resolve when the image is available, or
 *          undefined if there are too many active requests to the server, and the request
 *          should be retried later.  The resolved image may be either an
 *          Image or a Canvas DOM object.
 *
 * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.
 */
ImageDecoderImageryProvider.prototype.requestImage = function(x, y, cesiumLevel) {
    //>>includeStart('debug', pragmas.debug);
    if (!this._ready) {
        throw new DeveloperError('requestImage must not be called before the imagery provider is ready.');
    }
    //>>includeEnd('debug');
    
    var self = this;
    
    var levelFactor = Math.pow(2, this._numResolutionLevels - cesiumLevel - 1);
    var minX = x * this._tileWidth  * levelFactor;
    var minY = y * this._tileHeight * levelFactor;
    var maxXExclusive = (x + 1) * this._tileWidth  * levelFactor;
    var maxYExclusive = (y + 1) * this._tileHeight * levelFactor;
    
    var alignedParams = imageHelperFunctions.alignParamsToTilesAndLevel({
        minX: minX,
        minY: minY,
        maxXExclusive: maxXExclusive,
        maxYExclusive: maxYExclusive,
        screenWidth: this._tileWidth,
        screenHeight: this._tileHeight
    }, this._image);
    
    var level = alignedParams.imagePartParams.level;
    var levelWidth = this._image.getLevelWidth(level);
    var levelHeight = this._image.getLevelHeight(level);
    
    var scaledCanvas = document.createElement('canvas');
    scaledCanvas.width = this._tileWidth;
    scaledCanvas.height = this._tileHeight;
    
    var scaledContext = scaledCanvas.getContext('2d');
    scaledContext.clearRect(0, 0, this._tileWidth, this._tileHeight);
    
    var tempPixelWidth  = alignedParams.imagePartParams.maxXExclusive - alignedParams.imagePartParams.minX;
    var tempPixelHeight = alignedParams.imagePartParams.maxYExclusive - alignedParams.imagePartParams.minY;
    if (tempPixelWidth <= 0 || tempPixelHeight <= 0) {
        return scaledCanvas;
    }
    
    var tempCanvas = document.createElement('canvas');
    tempCanvas.width = tempPixelWidth;
    tempCanvas.height = tempPixelHeight;
    var tempContext = tempCanvas.getContext('2d');
    tempContext.clearRect(0, 0, tempPixelWidth, tempPixelHeight);
    
    alignedParams.imagePartParams.quality = this._quality;
    alignedParams.imagePartParams.requestPriorityData = {
        imageRectangle: this._rectangle
    };
    
    var resolve, reject;
    var requestPixelsPromise = new Promise(function(resolve_, reject_) {
        resolve = resolve_;
        reject = reject_;
        
        self._image.requestPixelsProgressive(
            alignedParams.imagePartParams,
            pixelsDecodedCallback,
            terminatedCallback);
    });
    
    function pixelsDecodedCallback(decoded) {
        var partialTileWidth = decoded.imageData.width;
        var partialTileHeight = decoded.imageData.height;

        if (partialTileWidth > 0 && partialTileHeight > 0) {
            tempContext.putImageData(
                decoded.imageData,
                decoded.xInOriginalRequest,
                decoded.yInOriginalRequest);
        }
    }

    function terminatedCallback(isAborted) {
        if (isAborted) {
            reject('Fetch request or decode aborted');
        } else {
            scaledContext.drawImage(
                tempCanvas,
                0, 0, tempPixelWidth, tempPixelHeight,
                alignedParams.croppedScreen.minX, alignedParams.croppedScreen.minY,
                alignedParams.croppedScreen.maxXExclusive, alignedParams.croppedScreen.maxYExclusive);
                
            resolve(scaledCanvas);
        }
    }

    return requestPixelsPromise;
};

ImageDecoderImageryProvider.prototype._setPriorityByFrustum =
    function setPriorityByFrustum() {
    
    if (!this._ready) {
        return;
    }
    
    var frustumData = calculateCesiumFrustum(
        this._cesiumWidget, this);
    
    if (frustumData === null) {
        return;
    }
    
    frustumData.imageRectangle = this.getRectangle();
    frustumData.exactlevel = null;

    this._image.setServerRequestPrioritizerData(frustumData);
    this._image.setDecodePrioritizerData(frustumData);
};

/**
 * Picking features is not currently supported by this imagery provider, so this function simply returns
 * undefined.
 *
 * @param {Number} x The tile X coordinate.
 * @param {Number} y The tile Y coordinate.
 * @param {Number} level The tile level.
 * @param {Number} longitude The longitude at which to pick features.
 * @param {Number} latitude  The latitude at which to pick features.
 * @return {Promise} A promise for the picked features that will resolve when the asynchronous
 *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
 *                   instances.  The array may be empty if no features are found at the given location.
 *                   It may also be undefined if picking is not supported.
 */
ImageDecoderImageryProvider.prototype.pickFeatures = function() {
        return undefined;
};

ImageDecoderImageryProvider.prototype._onException = function onException(reason) {
    if (this._exceptionCallback !== null) {
		this._exceptionCallback(reason);
    }
};

ImageDecoderImageryProvider.prototype._opened = function opened() {
    if (this._ready) {
        throw 'ImageDecoderImageryProvider error: opened() was called more than once!';
    }
    
    this._ready = true;
    
    // This is wrong if COD or COC exists besides main header COD
    this._numResolutionLevels = this._image.getNumResolutionLevelsForLimittedViewer();
    this._quality = this._image.getHighestQuality();
    var maximumCesiumLevel = this._numResolutionLevels - 1;
        
    this._tileWidth = this._image.getTileWidth();
    this._tileHeight = this._image.getTileHeight();
        
    var bestLevel = this._image.getImageLevel();
    var bestLevelWidth  = this._image.getLevelWidth (bestLevel);
    var bestLevelHeight = this._image.getLevelHeight(bestLevel);
    
    var lowestLevelTilesX = Math.ceil(bestLevelWidth  / this._tileWidth ) >> maximumCesiumLevel;
    var lowestLevelTilesY = Math.ceil(bestLevelHeight / this._tileHeight) >> maximumCesiumLevel;

    imageHelperFunctions.fixBounds(
        this._rectangle,
        this._image,
        this._adaptProportions);
    var rectangleWidth  = this._rectangle.east  - this._rectangle.west;
    var rectangleHeight = this._rectangle.north - this._rectangle.south;
    
    var bestLevelScale = 1 << maximumCesiumLevel;
    var pixelsWidthForCesium  = this._tileWidth  * lowestLevelTilesX * bestLevelScale;
    var pixelsHeightForCesium = this._tileHeight * lowestLevelTilesY * bestLevelScale;
    
    // Cesium works with full tiles only, thus fix the geographic bounds so
    // the pixels lies exactly on the original bounds
    
    var geographicWidthForCesium =
        rectangleWidth * pixelsWidthForCesium / bestLevelWidth;
    var geographicHeightForCesium =
        rectangleHeight * pixelsHeightForCesium / bestLevelHeight;
    
    var fixedEast  = this._rectangle.west  + geographicWidthForCesium;
    var fixedSouth = this._rectangle.north - geographicHeightForCesium;
    
    this._tilingSchemeParams = {
        west: this._rectangle.west,
        east: fixedEast,
        south: fixedSouth,
        north: this._rectangle.north,
        levelZeroTilesX: lowestLevelTilesX,
        levelZeroTilesY: lowestLevelTilesY,
        maximumLevel: maximumCesiumLevel
    };
    
    this._tilingScheme = createTilingScheme(this._tilingSchemeParams);
        
    Cesium.TileProviderError.handleSuccess(this._errorEvent);
};

function createTilingScheme(params) {
    var geographicRectangleForCesium = new Cesium.Rectangle(
        params.west, params.south, params.east, params.north);
    
    var tilingScheme = new Cesium.GeographicTilingScheme({
        rectangle: geographicRectangleForCesium,
        numberOfLevelZeroTilesX: params.levelZeroTilesX,
        numberOfLevelZeroTilesY: params.levelZeroTilesY
    });
    
    return tilingScheme;
}
},{"_cesiumfrustumcalculator.js":1,"imagehelperfunctions.js":12,"workerproxyimagedecoder.js":18}],5:[function(require,module,exports){
'use strict';

module.exports = ImageDecoder;

var WorkerProxyFetchManager = require('workerproxyfetchmanager.js');
var imageHelperFunctions = require('imageHelperFunctions.js');
var DecodeJobsPool = require('decodejobspool.js');
var WorkerProxyPixelsDecoder = require('workerproxypixelsdecoder.js');
var ImageParamsRetrieverProxy = require('imageparamsretrieverproxy.js');

/* global console: false */
/* global Promise: false */

function ImageDecoder(imageImplementationClassName, options) {
    ImageParamsRetrieverProxy.call(this, imageImplementationClassName);
    
    this._options = options || {};
    this._optionsWebWorkers = imageHelperFunctions.createInternalOptions(imageImplementationClassName, this._options);
    var decodeWorkersLimit = this._options.workersLimit || 5;
    
    this._tileWidth = this._options.tileWidth || 256;
    this._tileHeight = this._options.tileHeight || 256;
    this._showLog = !!this._options.showLog;
    
    /*if (this._showLog) {
        // Old IE
        throw 'showLog is not supported on this browser';
    }*/

    this._channelStates = [];
    this._decoders = [];

    this._fetchManager = new WorkerProxyFetchManager(this._optionsWebWorkers);
    
    var decodeScheduler = imageHelperFunctions.createScheduler(
        this._showLog,
        this._options.decodePrioritizer,
        'decode',
        this._createDecoder.bind(this),
        decodeWorkersLimit);
    
    this._decodePrioritizer = decodeScheduler.prioritizer;

    this._requestsDecodeJobsPool = new DecodeJobsPool(
        this._fetchManager,
        decodeScheduler.scheduler,
        this._tileWidth,
        this._tileHeight,
        /*onlyWaitForDataAndDecode=*/false);
        
    this._channelsDecodeJobsPool = new DecodeJobsPool(
        this._fetchManager,
        decodeScheduler.scheduler,
        this._tileWidth,
        this._tileHeight,
        /*onlyWaitForDataAndDecode=*/true);
}

ImageDecoder.prototype = Object.create(ImageParamsRetrieverProxy.prototype);

ImageDecoder.prototype.getTileWidth = function getTileWidth() {
    this._validateSizesCalculator();
    return this._tileWidth;
};

ImageDecoder.prototype.getTileHeight = function getTileHeight() {
    this._validateSizesCalculator();
    return this._tileHeight;
};
    
ImageDecoder.prototype.setServerRequestPrioritizerData =
    function setServerRequestPrioritizerData(prioritizerData) {
    
    this._fetchManager.setServerRequestPrioritizerData(
        prioritizerData);
};

ImageDecoder.prototype.setDecodePrioritizerData =
    function setDecodePrioritizerData(prioritizerData) {
    
    if (this._decodePrioritizer === null) {
        throw 'No decode prioritizer has been set';
    }
    
    if (this._showLog) {
        console.log('setDecodePrioritizerData(' + prioritizerData + ')');
    }
    
    var prioritizerDataModified = Object.create(prioritizerData);
    prioritizerDataModified.image = this;
    
    this._decodePrioritizer.setPrioritizerData(prioritizerDataModified);
};

ImageDecoder.prototype.open = function open(url) {
    var self = this;
    return this._fetchManager.open(url).then(function (sizesParams) {
        self._internalSizesParams = sizesParams;
        return {
            sizesParams: sizesParams,
            applicativeTileWidth : self.getTileWidth(),
            applicativeTileHeight: self.getTileHeight()
        };
    });
};

ImageDecoder.prototype.close = function close() {
    for (var i = 0; i < this._decoders.length; ++i) {
        this._decoders[i].terminate();
    }

    return this._fetchManager.close();
};

ImageDecoder.prototype.createChannel = function createChannel(
    createdCallback) {
    
    this._validateSizesCalculator();
    
    var self = this;
    
    function channelCreated(channelHandle) {
        self._channelStates[channelHandle] = {
            decodeJobsListenerHandle: null
        };
        
        createdCallback(channelHandle);
    }
    
    this._fetchManager.createChannel(
        channelCreated);
};

ImageDecoder.prototype.requestPixels = function requestPixels(imagePartParams) {
    this._validateSizesCalculator();
    
    var level = imagePartParams.level;
    var levelWidth = this._sizesCalculator.getLevelWidth(level);
    var levelHeight = this._sizesCalculator.getLevelHeight(level);
    
    var resolve, reject;
    var accumulatedResult = {};
    
    var self = this;
    var promise = new Promise(startPromise);
    return promise;
    
    function startPromise(resolve_, reject_) {
        resolve = resolve_;
        reject = reject_;
        
        self._requestsDecodeJobsPool.forkDecodeJobs(
            imagePartParams,
            internalCallback,
            internalTerminatedCallback,
            levelWidth,
            levelHeight,
            /*isProgressive=*/false);
    }
    
    function internalCallback(decodedData) {
        copyPixelsToAccumulatedResult(decodedData, accumulatedResult);
    }
    
    function internalTerminatedCallback(isAborted) {
        if (isAborted) {
            reject('Request was aborted due to failure or priority');
        } else {
            resolve(accumulatedResult);
        }
    }
};

ImageDecoder.prototype.requestPixelsProgressive = function requestPixelsProgressive(
    imagePartParams,
    callback,
    terminatedCallback,
    imagePartParamsNotNeeded,
    channelHandle) {
    
    this._validateSizesCalculator();
    
    var level = imagePartParams.level;
    var levelWidth = this._sizesCalculator.getLevelWidth(level);
    var levelHeight = this._sizesCalculator.getLevelHeight(level);
    
    var channelState = null;
    var decodeJobsPool;
    if (channelHandle === undefined) {
        decodeJobsPool = this._requestsDecodeJobsPool;
    } else {
        decodeJobsPool = this._channelsDecodeJobsPool;
        
        channelState = this._channelStates[channelHandle];
        
        if (channelState === undefined) {
            throw 'Channel handle does not exist';
        }
    }
    
    var listenerHandle = decodeJobsPool.forkDecodeJobs(
        imagePartParams,
        callback,
        terminatedCallback,
        levelWidth,
        levelHeight,
        /*isProgressive=*/true,
        imagePartParamsNotNeeded);
        
    if (channelHandle !== undefined) {
        if (channelState.decodeJobsListenerHandle !== null) {
            // Unregister after forked new jobs, so no termination occurs meanwhile
            decodeJobsPool.unregisterForkedJobs(
                channelState.decodeJobsListenerHandle);
        }
        channelState.decodeJobsListenerHandle = listenerHandle;
        this._fetchManager.moveChannel(channelHandle, imagePartParams);
    }
};

ImageDecoder.prototype.reconnect = function reconnect() {
    this._fetchManager.reconnect();
};

ImageDecoder.prototype.alignParamsToTilesAndLevel = function alignParamsToTilesAndLevel(region) {
	return imageHelperFunctions.alignParamsToTilesAndLevel(region, this);
};

ImageDecoder.prototype._getSizesParamsInternal = function getSizesParamsInternal() {
    return this._internalSizesParams;
};

ImageDecoder.prototype._createDecoder = function createDecoder() {
    var decoder = new WorkerProxyPixelsDecoder(this._optionsWebWorkers);
    this._decoders.push(decoder);
    
    return decoder;
};

function copyPixelsToAccumulatedResult(decodedData, accumulatedResult) {
    var bytesPerPixel = 4;
    var sourceStride = decodedData.width * bytesPerPixel;
    var targetStride =
        decodedData.originalRequestWidth * bytesPerPixel;
    
    if (accumulatedResult.pixels === undefined) {
        var size =
            targetStride * decodedData.originalRequestHeight;
            
        accumulatedResult.pixels = new Uint8Array(size);
        accumulatedResult.xInOriginalRequest = 0;
        accumulatedResult.yInOriginalRequest = 0;
        
        var width = decodedData.originalRequestWidth;
        accumulatedResult.originalRequestWidth = width;
        accumulatedResult.width = width;

        var height = decodedData.originalRequestHeight;
        accumulatedResult.originalRequestHeight = height;
        accumulatedResult.height = height;
    }
    
    accumulatedResult.allRelevantBytesLoaded =
        decodedData.allRelevantBytesLoaded;

    var sourceOffset = 0;
    var targetOffset =
        decodedData.xInOriginalRequest * bytesPerPixel + 
        decodedData.yInOriginalRequest * targetStride;
    
    for (var i = 0; i < decodedData.height; ++i) {
        var sourceSubArray = decodedData.pixels.subarray(
            sourceOffset, sourceOffset + sourceStride);
        
        accumulatedResult.pixels.set(sourceSubArray, targetOffset);
        
        sourceOffset += sourceStride;
        targetOffset += targetStride;
    }
}
},{"decodejobspool.js":7,"imageHelperFunctions.js":12,"imageparamsretrieverproxy.js":15,"workerproxyfetchmanager.js":17,"workerproxypixelsdecoder.js":19}],6:[function(require,module,exports){
'use strict';

module.exports = DecodeJob;

var LinkedList = require('linkedlist.js');

var requestIdCounter = 0;

function DecodeJob(
    imagePartParams,
    fetchManager,
    decodeScheduler,
    onlyWaitForDataAndDecode) {
    
    this._isAborted = false;
    this._isTerminated = false;
    this._isFetchRequestTerminated = false;
    this._isFirstStage = true;
    this._isManuallyAborted = false;

    this._firstDecodeInput = null;
    this._pendingDecodeInput = null;
    this._activeSubJobs = 1;
    this._imagePartParams = imagePartParams;
    this._decodeScheduler = decodeScheduler;
    this._jobSequenceId = 0;
    this._lastFinishedJobSequenceId = -1;
    this._progressiveStagesDone = 0;
    this._listenersLinkedList = new LinkedList();
    this._progressiveListenersCount = 0;
    this._requestId = ++requestIdCounter;
    this._allRelevantBytesLoaded = 0;
    this._fetchManager = fetchManager;
    this._startDecodeBound = this._startDecode.bind(this);
    this._decodeAbortedBound = this._decodeAborted.bind(this);
    
    fetchManager.createRequest(
        imagePartParams,
        this,
        this._dataReadyForDecode,
        this._fetchTerminated,
        onlyWaitForDataAndDecode,
        this._requestId);
}

DecodeJob.prototype.registerListener = function registerListener(listenerHandle) {
    var iterator = this._listenersLinkedList.add(listenerHandle);
    
    if (listenerHandle.isProgressive) {
        ++this._progressiveListenersCount;
        
        if (this._progressiveListenersCount === 1) {
            this._fetchManager.setIsProgressiveRequest(
                this._requestId, true);
        }
    }
    
    var unregisterHandle = iterator;
    return unregisterHandle;
};

DecodeJob.prototype.unregisterListener = function unregisterListener(unregisterHandle) {
    var iterator = unregisterHandle;
    var listenerHandle = this._listenersLinkedList.getValue(iterator);

    this._listenersLinkedList.remove(unregisterHandle);
    
    if (listenerHandle.isProgressive) {
        --this._progressiveListenersCount;
    }
    
    if (this._listenersLinkedList.getCount() === 0) {
        this._fetchManager.manualAbortRequest(
            this._requestId);
        
        this._isAborted = true;
        this._isTerminated = true;
        this._isFetchRequestTerminated = true;
        this._isManuallyAborted = true;
    } else if (this._progressiveListenersCount === 0) {
        this._fetchManager.setIsProgressiveRequest(
            this._requestId, false);
    }
};

DecodeJob.prototype.getIsTerminated = function getIsTerminated() {
    return this._isTerminated;
};

DecodeJob.prototype._dataReadyForDecode = function dataReadyForDecode(dataForDecode) {
    if (this._isAbortedNoTermination() ||
        this._listenersLinkedList.getCount() === 0) {
        
        // NOTE: Should find better way to clean job if listeners list
        // is empty
        
        return;
    }
    
	// Implementation idea:
	// 1. We have at most one active decode per DecodeJob. Thus if already
	//    active decode is done, we put the new data in a "pendingDecodeInput"
	//    variable which will be decoded when current decode is done.
	// 2. When we have more than a single decode we need to decode only last
	//    fetched data (because it is of highest quality). Thus older pending
	//    data is overriden by last one.
	// 3. The only case that older data should be decoded is the lowest quality
	//    (which is the first fetched data arrived). This is because we want to
	//    show a primary image ASAP, and the the lowest quality is easier to
	//    than others decode.
	// The idea described below is correct for JPIP, and I guess for other
	// heavy-decoded image types. One may add options to the ImageDecoder
	// library in order to configure another behavior, and change the
	// implementation in the DecodeJob class accordingly.
	
    if (this._isFirstStage) {
        this._firstDecodeInput = {
            dataForDecode: dataForDecode
        };
    } else {
        this._pendingDecodeInput = {
            dataForDecode: dataForDecode
        };
    
        if (this._isAlreadyScheduledNonFirstJob) {
            return;
        }
        
        this._isAlreadyScheduledNonFirstJob = true;
    }
    
    if (this._isTerminated) {
        throw 'Job has already been terminated';
    }
    
    this._isFirstStage = false;
    ++this._activeSubJobs;
    
    var jobContext = {
        self: this,
        imagePartParams: this._imagePartParams,
        progressiveStagesDone: this._progressiveStagesDone
    };
    
    this._decodeScheduler.enqueueJob(
        this._startDecodeBound, jobContext, this._decodeAbortedBound);
};

DecodeJob.prototype._startDecode = function startDecode(decoder, jobContext) {
    var decodeInput;
    if (this._firstDecodeInput !== null) {
        decodeInput = this._firstDecodeInput;
        this._firstDecodeInput = null;
    } else {
        decodeInput = this._pendingDecodeInput;
        this._pendingDecodeInput = null;
        
        this._isAlreadyScheduledNonFirstJob = false;
    }
    
    jobContext.allRelevantBytesLoaded = decodeInput.dataForDecode.allRelevantBytesLoaded;
    
    if (this._isAbortedNoTermination()) {
        --this._activeSubJobs;
        this._decodeScheduler.jobDone(decoder, jobContext);
        this._checkIfAllTerminated();
        
        return;
    }
    
    var jobSequenceId = ++this._jobSequenceId;
    
    var params = this._imagePartParams;
    var width = params.maxXExclusive - params.minX;
    var height = params.maxYExclusive - params.minY;

    decoder.decode(decodeInput.dataForDecode).then(pixelsDecodedCallbackInClosure);
        
    var self = this;
    
    function pixelsDecodedCallbackInClosure(decodeResult) {
        self._pixelsDecodedCallback(
            decoder,
            decodeResult,
            jobSequenceId,
            jobContext);
        
        self = null;
    }
};

DecodeJob.prototype._pixelsDecodedCallback = function pixelsDecodedCallback(
    decoder, decodeResult, jobSequenceId, jobContext) {
    
    this._decodeScheduler.jobDone(decoder, jobContext);
    --this._activeSubJobs;
    
    var relevantBytesLoadedDiff =
        jobContext.allRelevantBytesLoaded - this._allRelevantBytesLoaded;
    this._allRelevantBytesLoaded = jobContext.allRelevantBytesLoaded;
    
    if (this._isAbortedNoTermination()) {
        this._checkIfAllTerminated();
        return;
    }
    
    var lastFinished = this._lastFinishedJobSequenceId;
    if (lastFinished > jobSequenceId) {
        // Do not refresh pixels with lower quality than
        // what was already returned
        
        this._checkIfAllTerminated();
        return;
    }
    
    this._lastFinishedJobSequenceId = jobSequenceId;
    
    var tileParams = this._imagePartParams;
    
    var iterator = this._listenersLinkedList.getFirstIterator();
    while (iterator !== null) {
        var listenerHandle = this._listenersLinkedList.getValue(iterator);
        var originalParams = listenerHandle.imagePartParams;
        
        var offsetX = tileParams.minX - originalParams.minX;
        var offsetY = tileParams.minY - originalParams.minY;
        var width = originalParams.maxXExclusive - originalParams.minX;
        var height = originalParams.maxYExclusive - originalParams.minY;
        
        listenerHandle.allRelevantBytesLoaded += relevantBytesLoadedDiff;
        
        var decodedOffsetted = {
            originalRequestWidth: width,
            originalRequestHeight: height,
            xInOriginalRequest: offsetX,
            yInOriginalRequest: offsetY,
            
            imageData: decodeResult,
            
            allRelevantBytesLoaded: listenerHandle.allRelevantBytesLoaded
        };
        
        listenerHandle.callback(decodedOffsetted);
        
        iterator = this._listenersLinkedList.getNextIterator(iterator);
    }

    this._checkIfAllTerminated();
};

DecodeJob.prototype._fetchTerminated = function fetchTerminated(isAborted) {
    if (this._isManuallyAborted) {
        // This situation might occur if request has been terminated,
        // but user's terminatedCallback has not been called yet. It
        // happens on WorkerProxyFetchManager due to thread
        // message delay.
        
        return;
    }

    if (this._isFetchRequestTerminated) {
        throw 'Double termination of fetch request';
    }
    
    this._isFetchRequestTerminated = true;
    --this._activeSubJobs;
    this._isAborted |= isAborted;
    
    this._checkIfAllTerminated();
};

DecodeJob.prototype._decodeAborted = function decodeAborted(jobContext) {
    this._isAborted = true;
    
    if (this._firstDecodeInput !== null) {
        this._firstDecodeInput = null;
    } else {
        this._pendingDecodeInput = null;
        this._isAlreadyScheduledNonFirstJob = false;
    }
    
    --this._activeSubJobs;
    
    this._checkIfAllTerminated();
};

DecodeJob.prototype._isAbortedNoTermination = function _isAbortedNoTermination() {
    if (this._isManuallyAborted) {
        return;
    }
    
    if (this._isTerminated) {
        throw 'Unexpected job state of terminated: Still runnin sub-jobs';
    }
    
    return this._isAborted;
};

DecodeJob.prototype._checkIfAllTerminated = function checkIfAllTerminated() {
    if (this._activeSubJobs < 0) {
        throw 'Inconsistent number of decode jobs';
    }
    
    if (this._activeSubJobs > 0) {
        return;
    }
    
    if (this._isAlreadyScheduledNonFirstJob) {
        throw 'Inconsistent isAlreadyScheduledNonFirstJob flag';
    }
    
    this._isTerminated = true;
    var linkedList = this._listenersLinkedList;
    this._listenersLinkedList = null;

    var iterator = linkedList.getFirstIterator();
    
    while (iterator !== null) {
        var listenerHandle = linkedList.getValue(iterator);
        listenerHandle.isAnyDecoderAborted |= this._isAborted;
        
        var remaining = --listenerHandle.remainingDecodeJobs;
        if (remaining < 0) {
            throw 'Inconsistent number of done requests';
        }
        
        var isListenerDone = remaining === 0;
        if (isListenerDone) {
            listenerHandle.isTerminatedCallbackCalled = true;
            listenerHandle.terminatedCallback(
                listenerHandle.isAnyDecoderAborted);
        }
        
        iterator = linkedList.getNextIterator(iterator);
    }
};
},{"linkedlist.js":13}],7:[function(require,module,exports){
'use strict';

module.exports = DecodeJobsPool;

var DecodeJob = require('decodejob.js');

function DecodeJobsPool(
    fetchManager,
    decodeScheduler,
    tileWidth,
    tileHeight,
    onlyWaitForDataAndDecode) {
    
    this._tileWidth = tileWidth;
    this._tileHeight = tileHeight;
    this._activeRequests = [];
    this._onlyWaitForDataAndDecode = onlyWaitForDataAndDecode;
    
    this._fetchManager = fetchManager;
    
    this._decodeScheduler = decodeScheduler;
}

DecodeJobsPool.prototype.forkDecodeJobs = function forkDecodeJobs(
    imagePartParams,
    callback,
    terminatedCallback,
    levelWidth,
    levelHeight,
    isProgressive,
    imagePartParamsNotNeeded) {
    
    var minX = imagePartParams.minX;
    var minY = imagePartParams.minY;
    var maxX = imagePartParams.maxXExclusive;
    var maxY = imagePartParams.maxYExclusive;
    var level = imagePartParams.level || 0;
    var quality = imagePartParams.quality;
    var priorityData = imagePartParams.requestPriorityData;
                
    var isMinAligned =
        minX % this._tileWidth === 0 && minY % this._tileHeight === 0;
    var isMaxXAligned = maxX % this._tileWidth === 0 || maxX === levelWidth;
    var isMaxYAligned = maxY % this._tileHeight === 0 || maxY === levelHeight;
    var isOrderValid = minX < maxX && minY < maxY;
    
    if (!isMinAligned || !isMaxXAligned || !isMaxYAligned || !isOrderValid) {
        throw 'imagePartParams for decoders is not aligned to ' +
            'tile size or not in valid order';
    }
    
    var requestsInLevel = getOrAddValue(this._activeRequests, level, []);
    var requestsInQuality = getOrAddValue(
        requestsInLevel, imagePartParams.quality, []);
        
    var numTilesX = Math.ceil((maxX - minX) / this._tileWidth);
    var numTilesY = Math.ceil((maxY - minY) / this._tileHeight);
    
    var listenerHandle = {
        imagePartParams: imagePartParams,
        callback: callback,
        terminatedCallback: terminatedCallback,
        remainingDecodeJobs: numTilesX * numTilesY,
        isProgressive: isProgressive,
        isAnyDecoderAborted: false,
        isTerminatedCallbackCalled: false,
        allRelevantBytesLoaded: 0,
        unregisterHandles: []
    };
    
    for (var x = minX; x < maxX; x += this._tileWidth) {
        var requestsInX = getOrAddValue(requestsInQuality, x, []);
        var singleTileMaxX = Math.min(x + this._tileWidth, levelWidth);
        
        for (var y = minY; y < maxY; y += this._tileHeight) {
            var singleTileMaxY = Math.min(y + this._tileHeight, levelHeight);
            
            var isTileNotNeeded = isUnneeded(
                x,
                y,
                singleTileMaxX,
                singleTileMaxY,
                imagePartParamsNotNeeded);
                
            if (isTileNotNeeded) {
                --listenerHandle.remainingDecodeJobs;
                continue;
            }
        
            var decodeJobContainer = getOrAddValue(requestsInX, y, {});
            
            if (decodeJobContainer.job === undefined ||
                decodeJobContainer.job.getIsTerminated()) {
                
                var singleTileImagePartParams = {
                    minX: x,
                    minY: y,
                    maxXExclusive: singleTileMaxX,
                    maxYExclusive: singleTileMaxY,
                    level: level,
                    quality: quality,
                    requestPriorityData: priorityData
                };
                
                decodeJobContainer.job = new DecodeJob(
                    singleTileImagePartParams,
                    this._fetchManager,
                    this._decodeScheduler,
                    this._onlyWaitForDataAndDecode);
            }
            
            var unregisterHandle =
                decodeJobContainer.job.registerListener(listenerHandle);
            listenerHandle.unregisterHandles.push({
                unregisterHandle: unregisterHandle,
                job: decodeJobContainer.job
            });
        }
    }
    
    if (!listenerHandle.isTerminatedCallbackCalled &&
        listenerHandle.remainingDecodeJobs === 0) {
        
        listenerHandle.isTerminatedCallbackCalled = true;
        listenerHandle.terminatedCallback(listenerHandle.isAnyDecoderAborted);
    }
    
    return listenerHandle;
};

DecodeJobsPool.prototype.unregisterForkedJobs = function unregisterForkedJobs(listenerHandle) {
    if (listenerHandle.remainingDecodeJobs === 0) {
        // All jobs has already been terminated, no need to unregister
        return;
    }
    
    for (var i = 0; i < listenerHandle.unregisterHandles.length; ++i) {
        var handle = listenerHandle.unregisterHandles[i];
        if (handle.job.getIsTerminated()) {
            continue;
        }
        
        handle.job.unregisterListener(handle.unregisterHandle);
    }
};

function isUnneeded(
    minX, minY, maxX, maxY, imagePartParamsNotNeeded) {
    
    if (imagePartParamsNotNeeded === undefined) {
        return false;
    }
    
    for (var i = 0; i < imagePartParamsNotNeeded.length; ++i) {
        var notNeeded = imagePartParamsNotNeeded[i];
        var isInX = minX >= notNeeded.minX && maxX <= notNeeded.maxXExclusive;
        var isInY = minY >= notNeeded.minY && maxY <= notNeeded.maxYExclusive;
        
        if (isInX && isInY) {
            return true;
        }
    }
    
    return false;
}

function getOrAddValue(parentArray, index, defaultValue) {
    var subArray = parentArray[index];
    if (subArray === undefined) {
        subArray = defaultValue;
        parentArray[index] = subArray;
    }
    
    return subArray;
}
},{"decodejob.js":6}],8:[function(require,module,exports){
'use strict';

module.exports = FetchJob;

FetchJob.FETCH_TYPE_REQUEST = 1;
FetchJob.FETCH_TYPE_CHANNEL = 2; // movable
FetchJob.FETCH_TYPE_ONLY_WAIT_FOR_DATA = 3;

function FetchJob(fetcher, scheduler, fetchType, contextVars) {
    this._fetcher = fetcher;
    this._scheduler = scheduler;
    
    this._dataListeners = [];
    this._terminatedListeners = [];
    
    this._imagePartParams = null;
    this._progressiveStagesDone = 0;
    
    this._isYielded = false;
    this._isFailure = false;
    this._isTerminated = false;
    this._isManuallyAborted = false;
    this._isChannel = fetchType === FetchJob.FETCH_TYPE_CHANNEL;
	this._isChannelStartedFetch = false;
    this._contextVars = contextVars;
    this._isOnlyWaitForData = fetchType === FetchJob.FETCH_TYPE_ONLY_WAIT_FOR_DATA;
    this._useScheduler = fetchType === FetchJob.FETCH_TYPE_REQUEST;
    this._imageDataContext = null;
    this._resource = null;
    this._abortedBound = this._aborted.bind(this);
	this._fetchHandle = null;
    //this._alreadyTerminatedWhenAllDataArrived = false;
    
    if (fetchType === FetchJob.FETCH_TYPE_CHANNEL) {
        this._movableFetchState = {};
    } else {
        this._movableFetchState = null;
    }
}

FetchJob.prototype.fetch = function fetch(imagePartParams) {
    if (this._isChannel) {
		if (this._imageDataContext !== null) {
			this._imageDataContext.dispose();
		}
        this._imagePartParams = imagePartParams;
        this._startFetch();
        return;
    }
    
    if (this._imagePartParams !== null) {
        throw 'Cannot fetch twice on fetch type of "request"';
    }
    
    this._imagePartParams = imagePartParams;
    
    if (!this._useScheduler) {
        startRequest(/*resource=*/null, this);
        return;
    }
    
    this._scheduler.enqueueJob(startRequest, this, fetchAbortedByScheduler);
};

FetchJob.prototype.manualAbortRequest = function manualAbortRequest() {
    this._isManuallyAborted = true;
    this._isTerminated = true;
    
    if (this._fetchHandle !== null) {
        this._fetchHandle.abortAsync().then(this._abortedBound);
    } else {
		this._imageDataContext.dispose();
	}
};

FetchJob.prototype.getContextVars = function getContextVars(requestId) {
    return this._contextVars;
};

FetchJob.prototype.on = function on(event, listener) {
    switch (event) {
        case 'data':
            this._dataListeners.push(listener);
            break;
        case 'terminated':
            this._terminatedListeners.push(listener);
            break;
        default:
            throw 'Unexpected event ' + event;
    }
};

FetchJob.prototype.setIsProgressive = function setIsProgressive(isProgressive) {
    this._isProgressive = isProgressive;
	if (this._imageDataContext !== null) {
		this._imageDataContext.setIsProgressive(isProgressive);
	}
};

FetchJob.prototype.getIsProgressive = function getIsProgressive() {
    return this._isProgressive;
};

FetchJob.prototype._startFetch = function startFetch() {
    var imageDataContext = this._fetcher.createImageDataContext(
        this._imagePartParams);
    
    this._imageDataContext = imageDataContext;
	this._imageDataContext.setIsProgressive(this._isProgressive);

    if (imageDataContext.isDone()) {
        for (var i = 0; i < this._dataListeners.length; ++i) {
            this._dataListeners[i].call(this, this._contextVars, imageDataContext);
        }

        this._fetchTerminated(/*isAborted=*/false);
        //this._alreadyTerminatedWhenAllDataArrived = true;
        
        return;
    }
    
    if (imageDataContext.hasData()) {
        for (var j = 0; j < this._dataListeners.length; ++j) {
            this._dataListeners[j].call(this, this._contextVars, imageDataContext);
        }
    }
    
    var self = this;
    imageDataContext.on('data', function() {
        self._dataCallback(imageDataContext);
    });
    
    if (!this._isOnlyWaitForData) {
		if (!this._isChannel) {
			this._fetchHandle = this._fetcher.fetch(imageDataContext);
		} else if (this._isChannelStartedFetch) {
			this._fetcher.moveFetch(imageDataContext, this._movableFetchState);
		} else {
			this._fetcher.startMovableFetch(imageDataContext, this._movableFetchState);
			this._isChannelStartedFetch = true;
		}
    }
};

FetchJob.prototype._fetchTerminated = function fetchTerminated(isAborted) {
    if (this._isYielded || this._isTerminated) {
        throw 'Unexpected request state on terminated';
    }
    
    if (this._resource !== null) {
        if (isAborted) {
            throw 'Unexpected request termination without resource allocated';
        }

        this._scheduler.jobDone(this._resource, this);

        this._resource = null;
    } else if (!isAborted && this._useScheduler) {
        throw 'Job expected to have resource on successful termination';
    }
    
    // Channel is not really terminated, but only fetches a new region
    // (see moveChannel()).
    if (!this._isChannel) {
        this._isTerminated = true;
        
        for (var i = 0; i < this._terminatedListeners.length; ++i) {
            this._terminatedListeners[i](
                this._contextVars, this._imageDataContext, isAborted);
        }
    }
    
    if (this._imageDataContext !== null && !this._isFailure) {
        this._imageDataContext.dispose();
    }
};

FetchJob.prototype._continueFetch = function continueFetch() {
    if (this.isChannel) {
        throw 'Unexpected call to continueFetch on channel';
    }
    
    this._fetchHandle = this._fetcher.fetch(this._imageDataContext);
};

FetchJob.prototype._dataCallback = function dataCallback(imageDataContext) {
    try {
        if (this._isYielded || this._isTerminated) {
            throw 'Unexpected request state on fetch callback';
        }
            
        if (imageDataContext !== this._imageDataContext) {
            throw 'Unexpected imageDataContext';
        }

        ++this._progressiveStagesDone;
        
        
        for (var i = 0; i < this._dataListeners.length; ++i) {
            this._dataListeners[i].call(this, this._contextVars, imageDataContext);
        }
        
        if (imageDataContext.isDone()) {
            this._fetchTerminated(/*isAborted=*/false);
            //this._alreadyTerminatedWhenAllDataArrived = true;
            return;
        }
        
        if (this._useScheduler) {
            if (this._resource === null) {
                throw 'No resource allocated but fetch callback called';
            }
            
			var isYielded = this._scheduler.tryYield(
				continueYieldedRequest,
				this,
				fetchAbortedByScheduler,
				fetchYieldedByScheduler,
				this._resource);
            
			if (isYielded) {
                this._fetchHandle.abortAsync().then(this._abortedBound);
            }
        }
    } catch (e) {
        this._isFailure = true;
        fetchAbortedByScheduler(this);
    }
};

FetchJob.prototype._aborted = function aborted() {
    // TODO: It seems that this function is totally historical code. Should review it.
    
    //if (this._alreadyTerminatedWhenAllDataArrived) {
    //    // Resources were already released ASAP
    //    return;
    //}
    
    if (this._isYielded || this._resource === null) {
        throw 'Unexpected request state on stopped';
    }
    
    if (this._isOnlyWaitForData ||
        this._fetchHandle === null) {
        
        throw 'Unexpected request type on stopped';
    }
    
    /*
    if (!isAborted) {
        if (!this._isTerminated) {
            throw '"stopped" listener was called with isAborted=false but ' +
                'imageDataContext "data" listener was not called yet';
        }
        
        return;
    }
    //*/
    
    var scheduler = this._scheduler;
    
    var isYielded = scheduler.tryYield(
        continueYieldedRequest,
        this,
        fetchAbortedByScheduler,
        fetchYieldedByScheduler,
        this._resource);
    
    if (isYielded || this._isTerminated) {
        this._fetchHandle = null;
        scheduler.jobDone(this._resource, this);
        
        return;
    }
    
    this._continueFetch();
};

// Properties for FrustumRequesetPrioritizer

Object.defineProperty(FetchJob.prototype, 'imagePartParams', {
    get: function getImagePartParams() {
        return this._imagePartParams;
    }
});

Object.defineProperty(FetchJob.prototype, 'progressiveStagesDone', {
    get: function getProgressiveStagesDone() {
        return this._progressiveStagesDone;
    }
});

function startRequest(resource, self) {
    if (self._imageDataContext !== null) {
        throw 'Unexpected restart of already started request';
    }
    
    if (self._isManuallyAborted) {
        if (resource !== null) {
            self._scheduler.jobDone(resource, self);
        }
        
        return;
    }
    
    self._resource = resource;
    
    self._startFetch();
}

function continueYieldedRequest(resource, self) {
    if (self._isManuallyAborted || self._isFailure) {
        self._scheduler.jobDone(self._resource, self);
        
        return;
    }
    
    if (!self.isYielded || self.isTerminated) {
        throw 'Unexpected request state on continue';
    }
    
    self.isYielded = false;
    self.resource = resource;
    
    self._continueFetch();
}

function fetchYieldedByScheduler(self) {
    if (self._isYielded || self._isTerminated) {
        throw 'Unexpected request state on yield';
    }
    
    self._isYielded = true;
    self._resource = null;
}

function fetchAbortedByScheduler(self) {
    self._isYielded = false;
    self._resource = null;
    self._fetchTerminated(/*isAborted=*/true);
}
},{}],9:[function(require,module,exports){
'use strict';

module.exports = FetchManager;

var imageHelperFunctions = require('imagehelperfunctions.js');
var FetchJob = require('fetchjob.js');
var ImageParamsRetrieverProxy = require('imageparamsretrieverproxy.js');

/* global console: false */

function FetchManager(options) {
    ImageParamsRetrieverProxy.call(this, options.imageImplementationClassName);

    var serverRequestsLimit = options.serverRequestsLimit || 5;
    
    this._fetcher = null;
    this._internalSizesParams = null;
    this._showLog = options.showLog;
    
    if (this._showLog) {
        // Old IE
        throw 'showLog is not supported on this browser';
    }
    
    var serverRequestScheduler = imageHelperFunctions.createScheduler(
        options.showLog,
        options.serverRequestPrioritizer,
        'serverRequest',
        createServerRequestDummyResource,
        serverRequestsLimit);
    
    this._serverRequestPrioritizer = serverRequestScheduler.prioritizer;
    
    this._scheduler = serverRequestScheduler.scheduler;
    this._channelHandleCounter = 0;
    this._channelHandles = [];
    this._requestById = [];
}

FetchManager.prototype = Object.create(ImageParamsRetrieverProxy.prototype);

FetchManager.prototype.open = function open(url) {
    var promise = this._imageImplementation.createFetcher(url, {isReturnPromise: true});
    var self = this;
    return promise.then(function(result) {
        self._fetcher = result.fetcher;
        self._internalSizesParams = result.sizesParams;
        return result.sizesParams;
    });
};

FetchManager.prototype.close = function close() {
    return this._fetcher.close({isReturnPromise: true});
};

FetchManager.prototype.setIsProgressiveRequest = function setIsProgressiveRequest(
    requestId, isProgressive) {
    
    var fetchJob = this._requestById[requestId];
    if (fetchJob === undefined) {
        // This situation might occur if request has been terminated,
        // but user's terminatedCallback has not been called yet. It
        // happens on WorkerProxyFetchManager due to thread
        // message delay.
        
        return null;
    }
    
    fetchJob.setIsProgressive(isProgressive);
};

FetchManager.prototype.createChannel = function createChannel(
    createdCallback) {
    
    var channelHandle = ++this._channelHandleCounter;
    this._channelHandles[channelHandle] = new FetchJob(
        this._fetcher,
        this._scheduler,
        FetchJob.FETCH_TYPE_CHANNEL,
        /*contextVars=*/null);

    createdCallback(channelHandle);
};

FetchManager.prototype.moveChannel = function moveChannel(
    channelHandle, imagePartParams) {
    
    var channel = this._channelHandles[channelHandle];
    channel.fetch(imagePartParams);
};

FetchManager.prototype.createRequest = function createRequest(
    fetchParams,
    callbackThis,
    callback,
    terminatedCallback,
    isOnlyWaitForData,
    requestId) {
    
    var contextVars = {
        progressiveStagesDone: 0,
        isLastCallbackCalledWithoutLowQualityLimit: false,
        callbackThis: callbackThis,
        callback: callback,
        terminatedCallback: terminatedCallback,
        requestId: requestId,
        fetchJob: null,
        self: this
    };
    
    var fetchType = isOnlyWaitForData ?
        FetchJob.FETCH_TYPE_ONLY_WAIT_FOR_DATA : FetchJob.FETCH_TYPE_REQUEST;
    
    var fetchJob = new FetchJob(
        this._fetcher, this._scheduler, fetchType, contextVars);
    
    contextVars.fetchJob = fetchJob;
    
    if (this._requestById[requestId] !== undefined) {
        throw 'Duplication of requestId ' + requestId;
    } else if (requestId !== undefined) {
        this._requestById[requestId] = fetchJob;
    }
    
    fetchJob.on('data', internalCallback);
    fetchJob.on('terminated', internalTerminatedCallback);
    
    fetchJob.fetch(fetchParams);
};

FetchManager.prototype.manualAbortRequest = function manualAbortRequest(
    requestId) {
    
    var fetchJob = this._requestById[requestId];
    
    if (fetchJob === undefined) {
        // This situation might occur if request has been terminated,
        // but user's terminatedCallback has not been called yet. It
        // happens on WorkerProxyFetchManager due to web worker
        // message delay.
        
        return;
    }
    
    fetchJob.manualAbortRequest();
    delete this._requestById[requestId];
};

FetchManager.prototype.reconnect = function reconnect() {
    this._fetcher.reconnect();
};

FetchManager.prototype.setServerRequestPrioritizerData =
    function setServerRequestPrioritizerData(prioritizerData) {
        if (this._serverRequestPrioritizer === null) {
            throw 'No serverRequest prioritizer has been set';
        }
        
        if (this._showLog) {
            console.log('setServerRequestPrioritizerData(' + prioritizerData + ')');
        }
        
        prioritizerData.image = this;
        this._serverRequestPrioritizer.setPrioritizerData(prioritizerData);
    };

FetchManager.prototype._getSizesParamsInternal = function getSizesParamsInternal() {
    return this._internalSizesParams;
};

function internalCallback(contextVars, imageDataContext) {
    var isProgressive = contextVars.fetchJob.getIsProgressive();
    var isLimitToLowQuality = 
        contextVars.progressiveStagesDone === 0;
    
    // See comment at internalTerminatedCallback method
    contextVars.isLastCallbackCalledWithoutLowQualityLimit |=
        isProgressive && !isLimitToLowQuality;
    
    if (!isProgressive) {
        return;
    }
    
    var quality = isLimitToLowQuality ? contextVars.self.getLowestQuality() : undefined;
    
    ++contextVars.progressiveStagesDone;
    
    extractDataAndCallCallback(contextVars, imageDataContext, quality);
}

function internalTerminatedCallback(contextVars, imageDataContext, isAborted) {
    if (!contextVars.isLastCallbackCalledWithoutLowQualityLimit) {
        // This condition come to check if another decoding should be done.
        // One situation it may happen is when the request is not
        // progressive, then the decoding is done only on termination.
        // Another situation is when only the first stage has been reached,
        // thus the callback was called with only the first quality (for
        // performance reasons). Thus another decoding should be done.
        
        extractDataAndCallCallback(contextVars, imageDataContext);
    }
    
    contextVars.terminatedCallback.call(
        contextVars.callbackThis, isAborted);
    
    delete contextVars.self._requestById[contextVars.requestId];
}

function extractDataAndCallCallback(contextVars, imageDataContext, quality) {
    var dataForDecode = imageDataContext.getFetchedData(quality);
    
    contextVars.callback.call(
        contextVars.callbackThis, dataForDecode);
}

function createServerRequestDummyResource() {
    return {};
}
},{"fetchjob.js":8,"imagehelperfunctions.js":12,"imageparamsretrieverproxy.js":15}],10:[function(require,module,exports){
'use strict';

module.exports = FrustumRequestsPrioritizer;
var PRIORITY_ABORT_NOT_IN_FRUSTUM = -1;
var PRIORITY_CALCULATION_FAILED = 0;
var PRIORITY_TOO_GOOD_RESOLUTION = 1;
var PRIORITY_NOT_IN_FRUSTUM = 2;
var PRIORITY_LOWER_RESOLUTION = 3;

var PRIORITY_MINORITY_IN_FRUSTUM = 4;
var PRIORITY_PARTIAL_IN_FRUSTUM = 5;
var PRIORITY_MAJORITY_IN_FRUSTUM = 6;
var PRIORITY_FULLY_IN_FRUSTUM = 7;

var ADD_PRIORITY_TO_LOW_QUALITY = 5;

var PRIORITY_HIGHEST = 13;

var log2 = Math.log(2);

function FrustumRequestsPrioritizer(
    isAbortRequestsNotInFrustum, isPrioritizeLowProgressiveStage) {
    
    this._frustumData = null;
    this._isAbortRequestsNotInFrustum = isAbortRequestsNotInFrustum;
    this._isPrioritizeLowProgressiveStage = isPrioritizeLowProgressiveStage;
}

Object.defineProperty(
    FrustumRequestsPrioritizer.prototype, 'minimalLowQualityPriority', {
        get: function minimalLowQualityPriority() {
            return PRIORITY_MINORITY_IN_FRUSTUM + ADD_PRIORITY_TO_LOW_QUALITY;
        }
    }
);
    
FrustumRequestsPrioritizer.prototype.setPrioritizerData = function setPrioritizerData(prioritizerData) {
    this._frustumData = prioritizerData;
};

FrustumRequestsPrioritizer.prototype.getPriority = function getPriority(jobContext) {
    var imagePartParams = jobContext.imagePartParams;
    if (imagePartParams.requestPriorityData.overrideHighestPriority) {
        return PRIORITY_HIGHEST;
    }

    var priority = this._getPriorityInternal(imagePartParams);
    var isInFrustum = priority >= PRIORITY_MINORITY_IN_FRUSTUM;
    
    if (this._isAbortRequestsNotInFrustum && !isInFrustum) {
        return PRIORITY_ABORT_NOT_IN_FRUSTUM;
    }
    
    var prioritizeLowProgressiveStage = 0;
    
    if (this._isPrioritizeLowProgressiveStage && isInFrustum) {
        if (jobContext.progressiveStagesDone === undefined) {
            throw 'Missing progressive stage information';
        }
        
        prioritizeLowProgressiveStage =
            jobContext.progressiveStagesDone === 0 ? ADD_PRIORITY_TO_LOW_QUALITY :
            jobContext.progressiveStagesDone === 1 ? 1 :
            0;
    }
    
    return priority + prioritizeLowProgressiveStage;
};

FrustumRequestsPrioritizer.prototype._getPriorityInternal = function getPriorityInternal(imagePartParams) {
    if (this._frustumData === null) {
        return PRIORITY_CALCULATION_FAILED;
    }
    
    if (this._frustumData.imageRectangle === undefined) {
        throw 'No imageRectangle information passed in setPrioritizerData';
    }
    
    var exactFrustumLevel = this._frustumData.exactlevel;
    
    if (this._frustumData.exactlevel === undefined) {
        throw 'No exactlevel information passed in ' +
            'setPrioritizerData. Use null if unknown';
    }
    
    var tileWest = this._pixelToCartographicX(
        imagePartParams.minX, imagePartParams);
    var tileEast = this._pixelToCartographicX(
        imagePartParams.maxXExclusive, imagePartParams);
    var tileNorth = this._pixelToCartographicY(
        imagePartParams.minY, imagePartParams);
    var tileSouth = this._pixelToCartographicY(
        imagePartParams.maxYExclusive, imagePartParams);
    
    var tilePixelsWidth =
        imagePartParams.maxXExclusive - imagePartParams.minX;
    var tilePixelsHeight =
        imagePartParams.maxYExclusive - imagePartParams.minY;
    
    var requestToFrustumResolutionRatio;
    var tileLevel = imagePartParams.level || 0;
    if (exactFrustumLevel === null) {
        var tileResolutionX = tilePixelsWidth / (tileEast - tileWest);
        var tileResolutionY = tilePixelsHeight / (tileNorth - tileSouth);
        var tileResolution = Math.max(tileResolutionX, tileResolutionY);
        var frustumResolution = this._frustumData.resolution;
        requestToFrustumResolutionRatio = tileResolution / frustumResolution;
    
        if (requestToFrustumResolutionRatio > 2) {
            return PRIORITY_TOO_GOOD_RESOLUTION;
        }
    } else if (tileLevel < exactFrustumLevel) {
        return PRIORITY_TOO_GOOD_RESOLUTION;
    }
    
    var frustumRectangle = this._frustumData.rectangle;
    var intersectionWest = Math.max(frustumRectangle.west, tileWest);
    var intersectionEast = Math.min(frustumRectangle.east, tileEast);
    var intersectionSouth = Math.max(frustumRectangle.south, tileSouth);
    var intersectionNorth = Math.min(frustumRectangle.north, tileNorth);
    
    var intersectionWidth = intersectionEast - intersectionWest;
    var intersectionHeight = intersectionNorth - intersectionSouth;
    
    if (intersectionWidth < 0 || intersectionHeight < 0) {
        return PRIORITY_NOT_IN_FRUSTUM;
    }
    
    if (exactFrustumLevel !== null) {
        if (tileLevel > exactFrustumLevel) {
            return PRIORITY_LOWER_RESOLUTION;
        }
    } else if (tileLevel > 0 && requestToFrustumResolutionRatio < 0.25) {
        return PRIORITY_LOWER_RESOLUTION;
    }
    
    var intersectionArea = intersectionWidth * intersectionHeight;
    var tileArea = (tileEast - tileWest) * (tileNorth - tileSouth);
    var partInFrustum = intersectionArea / tileArea;
    
    if (partInFrustum > 0.99) {
        return PRIORITY_FULLY_IN_FRUSTUM;
    } else if (partInFrustum > 0.7) {
        return PRIORITY_MAJORITY_IN_FRUSTUM;
    } else if (partInFrustum > 0.3) {
        return PRIORITY_PARTIAL_IN_FRUSTUM;
    } else {
        return PRIORITY_MINORITY_IN_FRUSTUM;
    }
};

FrustumRequestsPrioritizer.prototype._pixelToCartographicX = function pixelToCartographicX(
    x, imagePartParams) {
    
    var relativeX = x / this._frustumData.image.getLevelWidth(
        imagePartParams.level);
    
    var imageRectangle = this._frustumData.imageRectangle;
    var rectangleWidth = imageRectangle.east - imageRectangle.west;
    
    var xProjected = imageRectangle.west + relativeX * rectangleWidth;
    return xProjected;
};

FrustumRequestsPrioritizer.prototype._pixelToCartographicY = function tileToCartographicY(
    y, imagePartParams, image) {
    
    var relativeY = y / this._frustumData.image.getLevelHeight(
        imagePartParams.level);
    
    var imageRectangle = this._frustumData.imageRectangle;
    var rectangleHeight = imageRectangle.north - imageRectangle.south;
    
    var yProjected = imageRectangle.north - relativeY * rectangleHeight;
    return yProjected;
};
},{}],11:[function(require,module,exports){
'use strict';

module.exports = HashMap;

var LinkedList = require('linkedlist.js');

function HashMap(hasher) {
    this._byKey = [];
    this._hasher = hasher;
}

HashMap.prototype.getFromKey = function getFromKey(key) {
    var hashCode = this._hasher.getHashCode(key);
    var hashElements = this._byKey[hashCode];
    if (!hashElements) {
        return null;
    }
    
    var iterator = hashElements.getFirstIterator();
    while (iterator !== null) {
        var item = hashElements.getValue(iterator);
        if (this._hasher.isEqual(item.key, key)) {
            return item.value;
        }
        
        iterator = hashElements.getNextIterator(iterator);
    }

    return null;
};

HashMap.prototype.getFromIterator = function getFromIterator(iterator) {
    return iterator._hashElements.getValue(iterator._internalIterator).value;
};

HashMap.prototype.tryAdd = function tryAdd(key, createValue) {
    var hashCode = this._hasher.getHashCode(key);
    var hashElements = this._byKey[hashCode];
    if (!hashElements) {
        hashElements = new LinkedList();
        this._byKey[hashCode] = hashElements ;
    }
    
    var iterator = {
        _hashCode: hashCode,
        _hashElements: hashElements,
        _internalIterator: null
    };
    
    iterator._internalIterator = hashElements.getFirstIterator();
    while (iterator._internalIterator !== null) {
        var item = hashElements.getValue(iterator._internalIterator);
        if (this._hasher.isEqual(item.key, key)) {
            return {
                iterator: iterator,
                isNew: false,
                value: item.value
            };
        }
        
        iterator._internalIterator = hashElements.getNextIterator(iterator._internalIterator);
    }
    
    var value = createValue();
    iterator._internalIterator = hashElements.add({
        key: key,
        value: value
    });
    
    return {
        iterator: iterator,
        isNew: true,
        value: value
    };
};

HashMap.prototype.remove = function remove(iterator) {
    iterator._hashElements.remove(iterator._internalIterator);
    if (iterator._hashElements.getCount() === 0) {
        delete this._byKey[iterator._hashCode];
    }
};
},{"linkedlist.js":13}],12:[function(require,module,exports){
'use strict';

var FrustumRequestsPrioritizer = require('frustumrequestsprioritizer.js');

module.exports = {
    calculateFrustum2DFromBounds: calculateFrustum2DFromBounds,
    createScheduler: createScheduler,
    fixBounds: fixBounds,
    alignParamsToTilesAndLevel: alignParamsToTilesAndLevel,
    getImageImplementation: getImageImplementation,
    getScriptsForWorkerImport: getScriptsForWorkerImport,
    createInternalOptions: createInternalOptions
};

// Avoid jshint error
/* global self: false */
/* global globals: false */
    
//var log2 = Math.log(2);

var imageDecoderFrameworkScript = new AsyncProxy.ScriptsToImportPool();
imageDecoderFrameworkScript.addScriptFromErrorWithStackTrace(new Error());
var scriptsForWorkerToImport = imageDecoderFrameworkScript.getScriptsForWorkerImport();

function calculateFrustum2DFromBounds(
    bounds, screenSize) {
    
    var screenPixels =
        screenSize.x * screenSize.x + screenSize.y * screenSize.y;
    
    var boundsWidth = bounds.east - bounds.west;
    var boundsHeight = bounds.north - bounds.south;
    var boundsDistance =
        boundsWidth * boundsWidth + boundsHeight * boundsHeight;
    
    var resolution = Math.sqrt(screenPixels / boundsDistance);
    
    var frustumData = {
        resolution: resolution,
        rectangle: bounds,
        
        // Redundant, but enables to avoid already-performed calculation
        screenSize: screenSize
    };
    
    return frustumData;
}
    
function createScheduler(
    showLog, prioritizerType, schedulerName, createResource, resourceLimit) {
    
    var prioritizer;
    var scheduler;
    
    if (prioritizerType === undefined) {
        prioritizer = null;
        
        scheduler = new ResourceScheduler.LifoScheduler(
            createResource,
            resourceLimit);
    } else {
        var limitResourceByLowQualityPriority = false;
        
        if (prioritizerType === 'frustum') {
            limitResourceByLowQualityPriority = true;
            prioritizer = new FrustumRequestsPrioritizer();
        } else if (prioritizerType === 'frustumOnly') {
            limitResourceByLowQualityPriority = true;
            prioritizer = new FrustumRequestsPrioritizer(
                /*isAbortRequestsNotInFrustum=*/true,
                /*isPrioritizeLowQualityStage=*/true);
        } else {
            prioritizer = prioritizerType;
        }
        
        var options = {
            schedulerName: schedulerName,
            showLog: showLog
        };
        
        if (limitResourceByLowQualityPriority) {
            options.resourceGuaranteedForHighPriority = resourceLimit - 2;
            options.highPriorityToGuaranteeResource =
                prioritizer.minimalLowQualityPriority;
        }
        
        scheduler = new ResourceScheduler.PriorityScheduler(
            createResource,
            resourceLimit,
            prioritizer,
            options);
    }
    
    return {
        prioritizer: prioritizer,
        scheduler: scheduler
    };
}
    
function fixBounds(bounds, image, adaptProportions) {
    if (!adaptProportions) {
        return;
    }

    var rectangleWidth = bounds.east - bounds.west;
    var rectangleHeight = bounds.north - bounds.south;

    var level = image.getImageLevel();
    var pixelsAspectRatio =
        image.getLevelWidth(level) / image.getLevelHeight(level);
    var rectangleAspectRatio = rectangleWidth / rectangleHeight;
    
    if (pixelsAspectRatio < rectangleAspectRatio) {
        var oldWidth = rectangleWidth;
        rectangleWidth = rectangleHeight * pixelsAspectRatio;
        var substractFromWidth = oldWidth - rectangleWidth;
        
        bounds.east -= substractFromWidth / 2;
        bounds.west += substractFromWidth / 2;
    } else {
        var oldHeight = rectangleHeight;
        rectangleHeight = rectangleWidth / pixelsAspectRatio;
        var substractFromHeight = oldHeight - rectangleHeight;
        
        bounds.north -= substractFromHeight / 2;
        bounds.south += substractFromHeight / 2;
    }
}

function alignParamsToTilesAndLevel(
    region, imageDecoder) {
    
    var sizesCalculator = imageDecoder._getSizesCalculator();
    var tileWidth = imageDecoder.getTileWidth();
    var tileHeight = imageDecoder.getTileHeight();
    
    var regionMinX = region.minX;
    var regionMinY = region.minY;
    var regionMaxX = region.maxXExclusive;
    var regionMaxY = region.maxYExclusive;
    var screenWidth = region.screenWidth;
    var screenHeight = region.screenHeight;
    
    var isValidOrder = regionMinX < regionMaxX && regionMinY < regionMaxY;
    if (!isValidOrder) {
        throw 'Parameters order is invalid';
    }
    
    var imageLevel = sizesCalculator.getImageLevel();
    var defaultLevelWidth = sizesCalculator.getLevelWidth(imageLevel);
    var defaultLevelHeight = sizesCalculator.getLevelHeight(imageLevel);
    if (regionMaxX < 0 || regionMinX >= defaultLevelWidth ||
        regionMaxY < 0 || regionMinY >= defaultLevelHeight) {
        
        return null;
    }
    
    //var maxLevel =
    //    sizesCalculator.getDefaultNumResolutionLevels() - 1;

    //var levelX = Math.log((regionMaxX - regionMinX) / screenWidth ) / log2;
    //var levelY = Math.log((regionMaxY - regionMinY) / screenHeight) / log2;
    //var level = Math.ceil(Math.min(levelX, levelY));
    //level = Math.max(0, Math.min(maxLevel, level));
    var level = sizesCalculator.getLevel(region);
    var levelWidth = sizesCalculator.getLevelWidth(level);
    var levelHeight = sizesCalculator.getLevelHeight(level);
    
    var scaleX = defaultLevelWidth / levelWidth;
    var scaleY = defaultLevelHeight / levelHeight;
    
    var minTileX = Math.floor(regionMinX / (scaleX * tileWidth ));
    var minTileY = Math.floor(regionMinY / (scaleY * tileHeight));
    var maxTileX = Math.ceil (regionMaxX / (scaleX * tileWidth ));
    var maxTileY = Math.ceil (regionMaxY / (scaleY * tileHeight));
    
    var minX = minTileX * tileWidth;
    var minY = minTileY * tileHeight;
    var maxX = maxTileX * tileWidth;
    var maxY = maxTileY * tileHeight;
    
    var croppedMinX = Math.max(0, Math.min(levelWidth , minX));
    var croppedMinY = Math.max(0, Math.min(levelHeight, minY));
    var croppedMaxX = Math.max(0, Math.min(levelWidth , maxX));
    var croppedMaxY = Math.max(0, Math.min(levelHeight, maxY));
    
    var imageParamsToScreenScaleX = screenWidth  / (maxX - minX);
    var imageParamsToScreenScaleY = screenHeight / (maxY - minY);
    
    var imagePartParams = {
        minX: croppedMinX,
        minY: croppedMinY,
        maxXExclusive: croppedMaxX,
        maxYExclusive: croppedMaxY,
        level: level
    };
    
    var positionInImage = {
        minX: croppedMinX * scaleX,
        minY: croppedMinY * scaleY,
        maxXExclusive: croppedMaxX * scaleX,
        maxYExclusive: croppedMaxY * scaleY
    };
    
    var croppedScreen = {
        minX : Math.floor((croppedMinX - minX) * imageParamsToScreenScaleX),
        minY : Math.floor((croppedMinY - minY) * imageParamsToScreenScaleY),
        maxXExclusive : Math.ceil((croppedMaxX - minX) * imageParamsToScreenScaleX),
        maxYExclusive : Math.ceil((croppedMaxY - minY) * imageParamsToScreenScaleY)
    };
    
    return {
        imagePartParams: imagePartParams,
        positionInImage: positionInImage,
        croppedScreen: croppedScreen
    };
}

function getImageImplementation(imageImplementationClassName) {
    try {
        return window && window[imageImplementationClassName];
    } catch(e) { }

    try {
        return globals && globals[imageImplementationClassName];
    } catch(e) { }

    try {
        return self && self[imageImplementationClassName];
    } catch(e) { }
}

function getScriptsForWorkerImport(imageImplementation, options) {
    return scriptsForWorkerToImport.concat(
        imageImplementation.getScriptsToImport());
}

function createInternalOptions(imageImplementationClassName, options) {
    options = options || {};
    
    if (options.imageImplementationClassName &&
        options.scriptsToImport) {
            
        return options;
    }
    
    var imageImplementation = getImageImplementation(imageImplementationClassName);
    
    var optionsInternal = JSON.parse(JSON.stringify(options));
    optionsInternal.imageImplementationClassName = options.imageImplementationClassName || imageImplementationClassName;
    optionsInternal.scriptsToImport = options.scriptsToImport || getScriptsForWorkerImport(imageImplementation, options);
    
    return optionsInternal;
}
},{"frustumrequestsprioritizer.js":10}],13:[function(require,module,exports){
'use strict';

module.exports = LinkedList;

function LinkedList() {
    this._first = { _prev: null, _parent: this };
    this._last = { _next: null, _parent: this };
    this._count = 0;
    
    this._last._prev = this._first;
    this._first._next = this._last;
}

LinkedList.prototype.add = function add(value, addBefore) {
    if (addBefore === null || addBefore === undefined) {
        addBefore = this._last;
    }
    
    this._validateIteratorOfThis(addBefore);
    
    ++this._count;
    
    var newNode = {
        _value: value,
        _next: addBefore,
        _prev: addBefore._prev,
        _parent: this
    };
    
    newNode._prev._next = newNode;
    addBefore._prev = newNode;
    
    return newNode;
};

LinkedList.prototype.remove = function remove(iterator) {
    this._validateIteratorOfThis(iterator);
    
    --this._count;
    
    iterator._prev._next = iterator._next;
    iterator._next._prev = iterator._prev;
    iterator._parent = null;
};

LinkedList.prototype.getValue = function getValue(iterator) {
    this._validateIteratorOfThis(iterator);
    
    return iterator._value;
};

LinkedList.prototype.getFirstIterator = function getFirstIterator() {
    var iterator = this.getNextIterator(this._first);
    return iterator;
};

LinkedList.prototype.getLastIterator = function getFirstIterator() {
    var iterator = this.getPrevIterator(this._last);
    return iterator;
};

LinkedList.prototype.getNextIterator = function getNextIterator(iterator) {
    this._validateIteratorOfThis(iterator);

    if (iterator._next === this._last) {
        return null;
    }
    
    return iterator._next;
};

LinkedList.prototype.getPrevIterator = function getPrevIterator(iterator) {
    this._validateIteratorOfThis(iterator);

    if (iterator._prev === this._first) {
        return null;
    }
    
    return iterator._prev;
};

LinkedList.prototype.getCount = function getCount() {
    return this._count;
};

LinkedList.prototype._validateIteratorOfThis =
    function validateIteratorOfThis(iterator) {
    
    if (iterator._parent !== this) {
        throw 'iterator must be of the current LinkedList';
    }
};
},{}],14:[function(require,module,exports){
'use strict';

// Suppress "Unnecessary directive 'use strict'" for the slaveScriptContent function
/*jshint -W034 */

var ImageDecoder = require('imagedecoder.js');

module.exports.getScriptUrl = function getScriptUrl() {
    return slaveScriptUrl;
};

var slaveScriptBlob = new Blob(
    ['(', slaveScriptContent.toString(), ')()'],
    { type: 'application/javascript' });
var slaveScriptUrl = URL.createObjectURL(slaveScriptBlob);

function slaveScriptContent() {
    'use strict';
    AsyncProxy.AsyncProxySlave.setSlaveSideCreator(function() {
        var argumentsAsArray = new Array(arguments.length + 1);
        argumentsAsArray[0] = null;
        for (var i = 0; i < arguments.length; ++i) {
            argumentsAsArray[i + 1] = arguments[i];
        }
        
        var instance = new (Function.prototype.bind.apply(imageDecoderFramework.ImageDecoder, argumentsAsArray));
        
        return instance;
    });
}
},{"imagedecoder.js":5}],15:[function(require,module,exports){
'use strict';

module.exports = ImageParamsRetrieverProxy;

var imageHelperFunctions = require('imagehelperfunctions.js');

function ImageParamsRetrieverProxy(imageImplementationClassName) {
    this._imageImplementation = imageHelperFunctions.getImageImplementation(imageImplementationClassName);
    this._sizesParams = null;
    this._sizesCalculator = null;
}

ImageParamsRetrieverProxy.prototype.getImageLevel = function getImageLevel() {
    this._validateSizesCalculator();
    var level = this._sizesCalculator.getImageLevel();

    return level;
};

ImageParamsRetrieverProxy.prototype.getNumResolutionLevelsForLimittedViewer = function getNumResolutionLevelsForLimittedViewer() {
    this._validateSizesCalculator();
    var levels = this._sizesCalculator.getNumResolutionLevelsForLimittedViewer();

    return levels;
};

ImageParamsRetrieverProxy.prototype.getLevelWidth = function getLevelWidth(level) {
    this._validateSizesCalculator();
    var width = this._sizesCalculator.getLevelWidth(
        level);

    return width;
};

ImageParamsRetrieverProxy.prototype.getLevelHeight = function getLevelHeight(level) {
    this._validateSizesCalculator();
    var height = this._sizesCalculator.getLevelHeight(
        level);

    return height;
};

ImageParamsRetrieverProxy.prototype.getLevel = function getLevel(regionLevel0) {
    this._validateSizesCalculator();
    var level = this._sizesCalculator.getLevel(regionLevel0);
    
    return level;
};

ImageParamsRetrieverProxy.prototype.getLowestQuality = function getLowestQuality() {
    this._validateSizesCalculator();
    var quality = this._sizesCalculator.getLowestQuality();
    
    return quality;
};

ImageParamsRetrieverProxy.prototype.getHighestQuality = function getHighestQuality() {
    this._validateSizesCalculator();
    var quality = this._sizesCalculator.getHighestQuality();

    return quality;
};

ImageParamsRetrieverProxy.prototype._getSizesCalculator = function getSizesCalculator() {
    this._validateSizesCalculator(this);
    
    return this._sizesCalculator;
};

ImageParamsRetrieverProxy.prototype._getSizesParams = function getSizesParams() {
    if (!this._sizesParams) {
        this._sizesParams = this._getSizesParamsInternal();
        if (!this._sizesParams) {
            throw 'getSizesParams() return falsy value; Maybe image not ready yet?';
        }
    }
    
    return this._sizesParams;
};

ImageParamsRetrieverProxy.prototype._getSizesParamsInternal = function getSizesParamsInternal() {
    throw 'ImageParamsRetrieverProxy implemented did not implement _getSizesParamsInternal()';
};

ImageParamsRetrieverProxy.prototype._validateSizesCalculator = function validateSizesCalculator() {
    if (this._sizesCalculator !== null) {
        return;
    }
    
    var sizesParams = this._getSizesParams();
    this._sizesCalculator = this._imageImplementation.createImageParamsRetriever(
        sizesParams);
}
},{"imagehelperfunctions.js":12}],16:[function(require,module,exports){
'use strict';

// Suppress "Unnecessary directive 'use strict'" for the slaveScriptContent function
/*jshint -W034 */

module.exports.getScriptUrl = function getScriptUrl() {
    return slaveScriptUrl;
};

var slaveScriptBlob = new Blob(
    ['(', slaveScriptContent.toString(), ')()'],
    { type: 'application/javascript' });
var slaveScriptUrl = URL.createObjectURL(slaveScriptBlob);

function slaveScriptContent() {
    'use strict';
    
    var isReady = false;

    AsyncProxy.AsyncProxySlave.setBeforeOperationListener(beforeOperationListener);

    function beforeOperationListener(operationType, operationName, args) {
        /* jshint validthis: true */
        
        if (operationType !== 'callback' || operationName !== 'statusCallback') {
            return;
        }
        
        if (isReady || !args[0].isReady) {
            return null;
        }
        
        var data = { sizesParams: this._getSizesParams() };
        
        // getTileWidth and getTileHeight exists only in ImageDecoder but not in FetchManager
        if (this.getTileWidth) {
            data.applicativeTileWidth = this.getTileWidth();
        }
        if (this.getTileHeight) {
            data.applicativeTileHeight = this.getTileHeight();
        }
        
        AsyncProxy.AsyncProxySlave.sendUserDataToMaster(data);
        isReady = true;
    }
}
},{}],17:[function(require,module,exports){
'use strict';

module.exports = WorkerProxyFetchManager;

var imageHelperFunctions = require('imagehelperfunctions.js');
var sendImageParametersToMaster = require('sendimageparameterstomaster.js');
var ImageParamsRetrieverProxy = require('imageparamsretrieverproxy.js');

function WorkerProxyFetchManager(options) {
    ImageParamsRetrieverProxy.call(this, options.imageImplementationClassName);

    this._imageWidth = null;
    this._imageHeight = null;
    this._internalSizesParams = null;
    this._options = options;
    
    var ctorArgs = [options];
    var scriptsToImport = options.scriptsToImport.concat([sendImageParametersToMaster.getScriptUrl()]);
    
    this._workerHelper = new AsyncProxy.AsyncProxyMaster(
        scriptsToImport, 'imageDecoderFramework.Internals.FetchManager', ctorArgs);
    
    var boundUserDataHandler = this._userDataHandler.bind(this);
    this._workerHelper.setUserDataHandler(boundUserDataHandler);
}

WorkerProxyFetchManager.prototype = Object.create(ImageParamsRetrieverProxy.prototype);

WorkerProxyFetchManager.prototype.open = function open(url) {
    return this._workerHelper.callFunction('open', [url], { isReturnPromise: true });
};

WorkerProxyFetchManager.prototype.close = function close() {
    var self = this;
    return this._workerHelper.callFunction('close', [], { isReturnPromise: true }).then(function() {
        self._workerHelper.terminate();
    });
};

WorkerProxyFetchManager.prototype.createChannel = function createChannel(
    createdCallback) {
    
    var callbackWrapper = this._workerHelper.wrapCallback(
        createdCallback,
        'FetchManager_createChannelCallback');
    
    var args = [callbackWrapper];
    this._workerHelper.callFunction('createChannel', args);
};

WorkerProxyFetchManager.prototype.moveChannel = function moveChannel(
    channelHandle, imagePartParams) {
    
    var args = [channelHandle, imagePartParams];
    this._workerHelper.callFunction('moveChannel', args);
};

WorkerProxyFetchManager.prototype.createRequest = function createRequest(
    fetchParams,
    callbackThis,
    callback,
    terminatedCallback,
    isOnlyWaitForData,
    requestId) {
    
    //var pathToArrayInPacketsData = [0, 'data', 'buffer'];
    //var pathToHeadersCodestream = [1, 'codestream', 'buffer'];
    //var transferablePaths = [
    //    pathToArrayInPacketsData,
    //    pathToHeadersCodestream
    //];
    
    var transferablePaths = this._options.transferablePathsOfRequestCallback;
    
    var internalCallbackWrapper =
        this._workerHelper.wrapCallback(
            callback.bind(callbackThis), 'requestTilesProgressiveCallback', {
                isMultipleTimeCallback: true,
                pathsToTransferables: transferablePaths
            }
        );
    
    var internalTerminatedCallbackWrapper =
        this._workerHelper.wrapCallback(
            internalTerminatedCallback, 'requestTilesProgressiveTerminatedCallback', {
                isMultipleTimeCallback: false
            }
        );
            
    var args = [
        fetchParams,
        /*callbackThis=*/{ dummyThis: 'dummyThis' },
        internalCallbackWrapper,
        internalTerminatedCallbackWrapper,
        isOnlyWaitForData,
        requestId];
        
    var self = this;
    
    this._workerHelper.callFunction('createRequest', args);
    
    function internalTerminatedCallback(isAborted) {
        self._workerHelper.freeCallback(internalCallbackWrapper);
        terminatedCallback.call(callbackThis, isAborted);
    }
};

WorkerProxyFetchManager.prototype.manualAbortRequest = function manualAbortRequest(
    requestId) {
    
    var args = [requestId];
    this._workerHelper.callFunction(
        'manualAbortRequest', args);
};

WorkerProxyFetchManager.prototype.setIsProgressiveRequest = function setIsProgressiveRequest(
    requestId, isProgressive) {
    
    var args = [requestId, isProgressive];
    this._workerHelper.callFunction('setIsProgressiveRequest', args);
};

WorkerProxyFetchManager.prototype.setServerRequestPrioritizerData =
    function setServerRequestPrioritizerData(prioritizerData) {
    
    this._workerHelper.callFunction(
        'setServerRequestPrioritizerData',
        [ prioritizerData ],
        { isSendImmediately: true });
};

WorkerProxyFetchManager.prototype.reconnect = function reconnect() {
    this._workerHelper.callFunction('reconnect');
};

WorkerProxyFetchManager.prototype._getSizesParamsInternal = function getSizesParamsInternal() {
    return this._internalSizesParams;
};

WorkerProxyFetchManager.prototype._userDataHandler = function userDataHandler(data) {
    this._internalSizesParams = data.sizesParams;
};
},{"imagehelperfunctions.js":12,"imageparamsretrieverproxy.js":15,"sendimageparameterstomaster.js":16}],18:[function(require,module,exports){
'use strict';

module.exports = WorkerProxyImageDecoder;

var imageHelperFunctions = require('imagehelperfunctions.js');
var sendImageParametersToMaster = require('sendimageparameterstomaster.js');
var createImageDecoderSlaveSide = require('createimagedecoderonslaveside.js');
var ImageParamsRetrieverProxy = require('imageparamsretrieverproxy.js');

function WorkerProxyImageDecoder(imageImplementationClassName, options) {
    ImageParamsRetrieverProxy.call(this, imageImplementationClassName);

    this._imageWidth = null;
    this._imageHeight = null;
    this._tileWidth = 0;
    this._tileHeight = 0;
    this._sizesCalculator = null;
    
    var optionsInternal = imageHelperFunctions.createInternalOptions(imageImplementationClassName, options);
    var ctorArgs = [imageImplementationClassName, optionsInternal];
    
    var scriptsToImport = imageHelperFunctions.getScriptsForWorkerImport(
        this._imageImplementation, options);
    scriptsToImport = scriptsToImport.concat([
        sendImageParametersToMaster.getScriptUrl(),
        createImageDecoderSlaveSide.getScriptUrl()]);

    this._workerHelper = new AsyncProxy.AsyncProxyMaster(
        scriptsToImport, 'imageDecoderFramework.ImageDecoder', ctorArgs);
    
    var boundImageOpened = this._imageOpened.bind(this);
    this._workerHelper.setUserDataHandler(boundImageOpened);
}

WorkerProxyImageDecoder.prototype = Object.create(ImageParamsRetrieverProxy.prototype);

WorkerProxyImageDecoder.prototype.getTileWidth = function getTileWidth() {
    this._validateSizesCalculator();
    return this._tileWidth;
};

WorkerProxyImageDecoder.prototype.getTileHeight = function getTileHeight() {
    this._validateSizesCalculator();
    return this._tileHeight;
};

WorkerProxyImageDecoder.prototype.open = function open(url) {
    var self = this;
    return this._workerHelper.callFunction('open', [url], { isReturnPromise: true })
        .then(function(imageParams) {
            self._imageOpened(imageParams);
            return imageParams;
        });
};

WorkerProxyImageDecoder.prototype.close = function close() {
    return this._workerHelper.callFunction('close', [], { isReturnPromise: true });
};

WorkerProxyImageDecoder.prototype.createChannel = function createChannel(
    createdCallback) {
    
    var callbackWrapper = this._workerHelper.wrapCallback(
        createdCallback, 'ImageDecoder_createChannelCallback');
    
    var args = [callbackWrapper];
    this._workerHelper.callFunction('createChannel', args);
};

WorkerProxyImageDecoder.prototype.requestPixels = function requestPixels(imagePartParams) {
    var pathToPixelsArray = ['data', 'buffer'];
    var transferables = [pathToPixelsArray];
    
    var args = [imagePartParams];
    
    this._workerHelper.callFunction('requestPixels', args, {
        isReturnPromise: true,
        pathsToTransferablesInPromiseResult: transferables
    });
};

WorkerProxyImageDecoder.prototype.requestPixelsProgressive = function requestPixelsProgressive(
    imagePartParams,
    callback,
    terminatedCallback,
    imagePartParamsNotNeeded,
    channelHandle) {
    
    var transferables;
    
    // NOTE: Cannot pass it as transferables because it is passed to all
    // listener callbacks, thus after the first one the buffer is not valid
    
    //var pathToPixelsArray = [0, 'pixels', 'buffer'];
    //transferables = [pathToPixelsArray];
    
    var internalCallbackWrapper =
        this._workerHelper.wrapCallback(
            callback, 'requestPixelsProgressiveCallback', {
                isMultipleTimeCallback: true,
                pathsToTransferables: transferables
            }
        );
    
    var internalTerminatedCallbackWrapper =
        this._workerHelper.wrapCallback(
            internalTerminatedCallback, 'requestPixelsProgressiveTerminatedCallback', {
                isMultipleTimeCallback: false
            }
        );
            
    var args = [
        imagePartParams,
        internalCallbackWrapper,
        internalTerminatedCallbackWrapper,
        imagePartParamsNotNeeded,
        channelHandle];
    
    this._workerHelper.callFunction('requestPixelsProgressive', args);
        
    var self = this;
    
    function internalTerminatedCallback(isAborted) {
        self._workerHelper.freeCallback(internalCallbackWrapper);
        
        terminatedCallback(isAborted);
    }
};

WorkerProxyImageDecoder.prototype.setServerRequestPrioritizerData =
    function setServerRequestPrioritizerData(prioritizerData) {
    
    this._workerHelper.callFunction(
        'setServerRequestPrioritizerData',
        [ prioritizerData ],
        { isSendImmediately: true });
};

WorkerProxyImageDecoder.prototype.setDecodePrioritizerData =
    function setDecodePrioritizerData(prioritizerData) {
    
    this._workerHelper.callFunction(
        'setDecodePrioritizerData',
        [ prioritizerData ],
        { isSendImmediately: true });
};

WorkerProxyImageDecoder.prototype.reconnect = function reconnect() {
    this._workerHelper.callFunction('reconnect');
};

WorkerProxyImageDecoder.prototype.alignParamsToTilesAndLevel = function alignParamsToTilesAndLevel(region) {
	return imageHelperFunctions.alignParamsToTilesAndLevel(region, this);
};

WorkerProxyImageDecoder.prototype._imageOpened = function imageOpened(data) {
    this._internalSizesParams = data.sizesParams;
    this._tileWidth = data.applicativeTileWidth;
    this._tileHeight = data.applicativeTileHeight;
    this._validateSizesCalculator();
};

WorkerProxyImageDecoder.prototype._getSizesParamsInternal = function getSizesParamsInternal() {
    return this._internalSizesParams;
};
},{"createimagedecoderonslaveside.js":14,"imagehelperfunctions.js":12,"imageparamsretrieverproxy.js":15,"sendimageparameterstomaster.js":16}],19:[function(require,module,exports){
'use strict';

// Suppress "Unnecessary directive 'use strict'" for the slaveScriptContent function
/*jshint -W034 */

/* global self: false */

module.exports = WorkerProxyPixelsDecoder;

var imageHelperFunctions = require('imagehelperfunctions.js');

var decoderSlaveScriptBlob = new Blob(
    ['(', decoderSlaveScriptBody.toString(), ')()'],
    { type: 'application/javascript' });
var decoderSlaveScriptUrl = URL.createObjectURL(decoderSlaveScriptBlob);

function WorkerProxyPixelsDecoder(options) {
    this._options = options || {};
    this._imageImplementation = imageHelperFunctions.getImageImplementation(
        options.imageImplementationClassName);
    
    var scriptsToImport = (this._options.scriptsToImport || []).concat([decoderSlaveScriptUrl]);
    var args = [this._options];
    
    this._workerHelper = new AsyncProxy.AsyncProxyMaster(
        scriptsToImport,
        'ArbitraryClassName',
        args);
}

WorkerProxyPixelsDecoder.prototype.decode = function decode(dataForDecode) {
    //var transferables = this._imageImplementation.getTransferableOfDecodeArguments(dataForDecode);
    var resultTransferables = [['data', 'buffer']];
    
    var args = [dataForDecode];
    var options = {
        //transferables: transferables,
        pathsToTransferablesInPromiseResult: resultTransferables,
        isReturnPromise: true
    };
    
    return this._workerHelper.callFunction('decode', args, options);
};

WorkerProxyPixelsDecoder.prototype.terminate = function terminate() {
    this._workerHelper.terminate();
};

function decoderSlaveScriptBody() {
    'use strict';

    AsyncProxy.AsyncProxySlave.setSlaveSideCreator(function createDecoder(options) {
        var imageImplementation = self[options.imageImplementationClassName];
        return imageImplementation.createPixelsDecoder();
    });
}
},{"imagehelperfunctions.js":12}],20:[function(require,module,exports){
'use strict';

module.exports = ViewerImageDecoder;

var ImageDecoder = require('imagedecoder.js');
var WorkerProxyImageDecoder = require('workerproxyimagedecoder.js');
var imageHelperFunctions = require('imagehelperfunctions.js');

var PENDING_CALL_TYPE_PIXELS_UPDATED = 1;
var PENDING_CALL_TYPE_REPOSITION = 2;

var REGION_OVERVIEW = 0;
var REGION_DYNAMIC = 1;

function ViewerImageDecoder(imageImplementationClassName, canvasUpdatedCallback, options) {
    this._imageImplementationClassName = imageImplementationClassName;
    this._canvasUpdatedCallback = canvasUpdatedCallback;
    
    this._adaptProportions = options.adaptProportions;
    this._cartographicBounds = options.cartographicBounds;
    this._isMainImageOnUi = options.isMainImageOnUi;
    this._showLog = options.showLog;
    this._allowMultipleChannelsInSession =
        options.allowMultipleChannelsInSession;
    this._minFunctionCallIntervalMilliseconds =
        options.minFunctionCallIntervalMilliseconds;
    this._overviewResolutionX = options.overviewResolutionX || 100;
    this._overviewResolutionY = options.overviewResolutionY || 100;
    this._workersLimit = options.workersLimit;
        
    this._lastRequestIndex = 0;
    this._pendingUpdateViewArea = null;
    this._regions = [];
    this._targetCanvas = null;
    
    this._callPendingCallbacksBound = this._callPendingCallbacks.bind(this);
    this._createdChannelBound = this._createdChannel.bind(this);
    
    this._pendingCallbacksIntervalHandle = 0;
    this._pendingCallbackCalls = [];
    this._canShowDynamicRegion = false;
    
    if (this._cartographicBounds === undefined) {
        this._cartographicBounds = {
            west: -175.0,
            east: 175.0,
            south: -85.0,
            north: 85.0
        };
    }
    
    if (this._adaptProportions === undefined) {
        this._adaptProportions = true;
    }
    
    var ImageType = this._isMainImageOnUi ?
        ImageDecoder: WorkerProxyImageDecoder;
        
    this._image = new ImageType(imageImplementationClassName, {
        serverRequestPrioritizer: 'frustumOnly',
        decodePrioritizer: 'frustumOnly',
        showLog: this._showLog,
        workersLimit: this._workersLimit
        });
}

ViewerImageDecoder.prototype.setExceptionCallback = function setExceptionCallback(exceptionCallback) {
    // TODO: Support exceptionCallback in every place needed
	this._exceptionCallback = exceptionCallback;
};
    
ViewerImageDecoder.prototype.open = function open(url) {
    return this._image.open(url)
        .then(this._opened.bind(this))
        .catch(this._exceptionCallback);
};

ViewerImageDecoder.prototype.close = function close() {
    var promise = this._image.close();
    promise.catch(this._exceptionCallback);
    this._isReady = false;
    this._canShowDynamicRegion = false;
    this._targetCanvas = null;
	return promise;
};

ViewerImageDecoder.prototype.setTargetCanvas = function setTargetCanvas(canvas) {
    this._targetCanvas = canvas;
};

ViewerImageDecoder.prototype.updateViewArea = function updateViewArea(frustumData) {
    if (this._targetCanvas === null) {
        throw 'Cannot update dynamic region before setTargetCanvas()';
    }
    
    if (!this._canShowDynamicRegion) {
        this._pendingUpdateViewArea = frustumData;
        
        return;
    }
    
    var bounds = frustumData.rectangle;
    var screenSize = frustumData.screenSize;
    
    var regionParams = {
        minX: bounds.west * this._scaleX + this._translateX,
        minY: bounds.north * this._scaleY + this._translateY,
        maxXExclusive: bounds.east * this._scaleX + this._translateX,
        maxYExclusive: bounds.south * this._scaleY + this._translateY,
        screenWidth: screenSize.x,
        screenHeight: screenSize.y
    };
    
    var alignedParams =
        imageHelperFunctions.alignParamsToTilesAndLevel(
            regionParams, this._image);
    
    var isOutsideScreen = alignedParams === null;
    if (isOutsideScreen) {
        return;
    }
    
    alignedParams.imagePartParams.quality = this._quality;

    var isSameRegion =
        this._dynamicFetchParams !== undefined &&
        this._isImagePartsEqual(
            alignedParams.imagePartParams,
            this._dynamicFetchParams.imagePartParams);
    
    if (isSameRegion) {
        return;
    }
    
    frustumData.imageRectangle = this._cartographicBoundsFixed;
    frustumData.exactlevel =
        alignedParams.imagePartParams.level;
    
    this._image.setDecodePrioritizerData(frustumData);
    this._image.setServerRequestPrioritizerData(frustumData);

    this._dynamicFetchParams = alignedParams;
    
    var startDynamicRegionOnTermination = false;
    var moveExistingChannel = !this._allowMultipleChannelsInSession;
    this._fetch(
        REGION_DYNAMIC,
        alignedParams,
        startDynamicRegionOnTermination,
        moveExistingChannel);
};

ViewerImageDecoder.prototype.getBounds = function getCartographicBounds() {
    if (!this._isReady) {
        throw 'ViewerImageDecoder error: Image is not ready yet';
    }
    return this._cartographicBoundsFixed;
};

ViewerImageDecoder.prototype._isImagePartsEqual = function isImagePartsEqual(first, second) {
    var isEqual =
        this._dynamicFetchParams !== undefined &&
        first.minX === second.minX &&
        first.minY === second.minY &&
        first.maxXExclusive === second.maxXExclusive &&
        first.maxYExclusive === second.maxYExclusive &&
        first.level === second.level;
    
    return isEqual;
};

ViewerImageDecoder.prototype._fetch = function fetch(
    regionId,
    fetchParams,
    startDynamicRegionOnTermination,
    moveExistingChannel) {
    
    var requestIndex = ++this._lastRequestIndex;
    
    var imagePartParams = fetchParams.imagePartParams;
    imagePartParams.requestPriorityData =
        imagePartParams.requestPriorityData || {};
    
    imagePartParams.requestPriorityData.requestIndex = requestIndex;

    var minX = fetchParams.positionInImage.minX;
    var minY = fetchParams.positionInImage.minY;
    var maxX = fetchParams.positionInImage.maxXExclusive;
    var maxY = fetchParams.positionInImage.maxYExclusive;
    
    var west = (minX - this._translateX) / this._scaleX;
    var east = (maxX - this._translateX) / this._scaleX;
    var north = (minY - this._translateY) / this._scaleY;
    var south = (maxY - this._translateY) / this._scaleY;
    
    var position = {
        west: west,
        east: east,
        north: north,
        south: south
    };
    
    var canReuseOldData = false;
    var fetchParamsNotNeeded;
    
    var region = this._regions[regionId];
    if (region !== undefined) {
        var newResolution = imagePartParams.level;
        var oldResolution = region.imagePartParams.level;
        
        canReuseOldData = newResolution === oldResolution;
        
        if (canReuseOldData && region.donePartParams) {
            fetchParamsNotNeeded = [ region.donePartParams ];
        }

        if (regionId !== REGION_OVERVIEW) {
            var addedPendingCall = this._checkIfRepositionNeeded(
                region, imagePartParams, position);
            
            if (addedPendingCall) {
                this._notifyNewPendingCalls();
            }
        }
    }
    
    var self = this;
    
    var channelHandle = moveExistingChannel ? this._channelHandle: undefined;

    this._image.requestPixelsProgressive(
        fetchParams.imagePartParams,
        callback,
        terminatedCallback,
        fetchParamsNotNeeded,
        channelHandle);
    
    function callback(decoded) {
        self._tilesDecodedCallback(
            regionId,
            fetchParams,
            position,
            decoded);
    }
    
    function terminatedCallback(isAborted) {
        if (isAborted &&
            imagePartParams.requestPriorityData.overrideHighestPriority) {
            
            // NOTE: Bug in kdu_server causes first request to be sent wrongly.
            // Then Chrome raises ERR_INVALID_CHUNKED_ENCODING and the request
            // never returns. Thus perform second request.
            
            self._image.requestPixelsProgressive(
                fetchParams.imagePartParams,
                callback,
                terminatedCallback,
                fetchParamsNotNeeded);
        }
        
        self._fetchTerminatedCallback(
            regionId,
            fetchParams.imagePartParams.requestPriorityData,
            isAborted,
            startDynamicRegionOnTermination);
    }
};

ViewerImageDecoder.prototype._fetchTerminatedCallback = function fetchTerminatedCallback(
    regionId, priorityData, isAborted, startDynamicRegionOnTermination) {
    
    var region = this._regions[regionId];
    if (region === undefined) {
        return;
    }
    
    if (!priorityData.overrideHighestPriority &&
        priorityData.requestIndex !== this._lastRequestIndex) {
    
        return;
    }
    
    region.isDone = !isAborted && this._isReady;
	if (region.isDone) {
		region.donePartParams = region.imagePartParams;
	}
    
    if (startDynamicRegionOnTermination) {
        this._image.createChannel(
            this._createdChannelBound);
    }
};

ViewerImageDecoder.prototype._createdChannel = function createdChannel(channelHandle) {
    this._channelHandle = channelHandle;
    this._startShowingDynamicRegion();
};

ViewerImageDecoder.prototype._startShowingDynamicRegion = function startShowingDynamicRegion() {
    this._canShowDynamicRegion = true;
    
    if (this._pendingUpdateViewArea !== null) {
        this.updateViewArea(this._pendingUpdateViewArea);
        
        this._pendingUpdateViewArea = null;
    }
};

ViewerImageDecoder.prototype._tilesDecodedCallback = function tilesDecodedCallback(
    regionId, fetchParams, position, decoded) {
    
    if (!this._isReady) {
        return;
    }
    
    var region = this._regions[regionId];
    if (region === undefined) {
        region = {};
        this._regions[regionId] = region;
        
        switch (regionId) {
            case REGION_DYNAMIC:
                region.canvas = this._targetCanvas;
                break;
                
            case REGION_OVERVIEW:
                region.canvas = document.createElement('canvas');
                break;
            
            default:
                throw 'Unexpected regionId ' + regionId;
        }
    }
    
    var partParams = fetchParams.imagePartParams;
    if (!partParams.requestPriorityData.overrideHighestPriority &&
        partParams.requestPriorityData.requestIndex < region.currentDisplayRequestIndex) {
        
        return;
    }
    
    this._checkIfRepositionNeeded(region, partParams, position);
        
    this._pendingCallbackCalls.push({
        type: PENDING_CALL_TYPE_PIXELS_UPDATED,
        region: region,
        decoded: decoded
    });
    
    this._notifyNewPendingCalls();
};

ViewerImageDecoder.prototype._checkIfRepositionNeeded = function checkIfRepositionNeeded(
    region, newPartParams, newPosition) {
    
    var oldPartParams = region.imagePartParams;
	var oldDonePartParams = region.donePartParams;
    var level = newPartParams.level;
    
    var needReposition =
        oldPartParams === undefined ||
        oldPartParams.minX !== newPartParams.minX ||
        oldPartParams.minY !== newPartParams.minY ||
        oldPartParams.maxXExclusive !== newPartParams.maxXExclusive ||
        oldPartParams.maxYExclusive !== newPartParams.maxYExclusive ||
        oldPartParams.level !== level;
    
    if (!needReposition) {
        return false;
    }
    
    var copyData;
    var intersection;
	var newDonePartParams;
    var reuseOldData = false;
    var scaleX;
    var scaleY;
    if (oldPartParams !== undefined) {
        scaleX = this._image.getLevelWidth (level) / this._image.getLevelWidth (oldPartParams.level);
        scaleY = this._image.getLevelHeight(level) / this._image.getLevelHeight(oldPartParams.level);
        
        intersection = {
            minX: Math.max(oldPartParams.minX * scaleX, newPartParams.minX),
            minY: Math.max(oldPartParams.minY * scaleY, newPartParams.minY),
            maxX: Math.min(oldPartParams.maxXExclusive * scaleX, newPartParams.maxXExclusive),
            maxY: Math.min(oldPartParams.maxYExclusive * scaleY, newPartParams.maxYExclusive)
        };
        reuseOldData =
            intersection.maxX > intersection.minX &&
            intersection.maxY > intersection.minY;
    }
    
    if (reuseOldData) {
        copyData = {
            fromX: intersection.minX / scaleX - oldPartParams.minX,
            fromY: intersection.minY / scaleY - oldPartParams.minY,
            fromWidth : (intersection.maxX - intersection.minX) / scaleX,
            fromHeight: (intersection.maxY - intersection.minY) / scaleY,
            toX: intersection.minX - newPartParams.minX,
            toY: intersection.minY - newPartParams.minY,
            toWidth : intersection.maxX - intersection.minX,
            toHeight: intersection.maxY - intersection.minY,
        };
	
		if (oldDonePartParams && oldPartParams.level === level) {
			newDonePartParams = {
				minX: Math.max(oldDonePartParams.minX, newPartParams.minX),
				minY: Math.max(oldDonePartParams.minY, newPartParams.minY),
				maxXExclusive: Math.min(oldDonePartParams.maxXExclusive, newPartParams.maxXExclusive),
				maxYExclusive: Math.min(oldDonePartParams.maxYExclusive, newPartParams.maxYExclusive)
			};
		}
	}
    
    region.imagePartParams = newPartParams;
    region.isDone = false;
    region.currentDisplayRequestIndex = newPartParams.requestPriorityData.requestIndex;
    
    var repositionArgs = {
        type: PENDING_CALL_TYPE_REPOSITION,
        region: region,
        position: newPosition,
		donePartParams: newDonePartParams,
        copyData: copyData,
        pixelsWidth: newPartParams.maxXExclusive - newPartParams.minX,
        pixelsHeight: newPartParams.maxYExclusive - newPartParams.minY
    };
    
    this._pendingCallbackCalls.push(repositionArgs);
    
    return true;
};

ViewerImageDecoder.prototype._notifyNewPendingCalls = function notifyNewPendingCalls() {
    if (!this._isNearCallbackCalled) {
        this._callPendingCallbacks();
    }
};

ViewerImageDecoder.prototype._callPendingCallbacks = function callPendingCallbacks() {
    if (this._pendingCallbackCalls.length === 0 || !this._isReady) {
        this._isNearCallbackCalled = false;
        return;
    }
    
    if (this._isNearCallbackCalled) {
        clearTimeout(this._pendingCallbacksIntervalHandle);
    }
    
    if (this._minFunctionCallIntervalMilliseconds !== undefined) {
        this._pendingCallbacksIntervalHandle =
            setTimeout(this._callPendingCallbacksBound,
            this._minFunctionCallIntervalMilliseconds);
            
        this._isNearCallbackCalled = true;
    }

    var newPosition = null;
    
    for (var i = 0; i < this._pendingCallbackCalls.length; ++i) {
        var callArgs = this._pendingCallbackCalls[i];
        
        if (callArgs.type === PENDING_CALL_TYPE_REPOSITION) {
            this._repositionCanvas(callArgs);
            newPosition = callArgs.position;
        } else if (callArgs.type === PENDING_CALL_TYPE_PIXELS_UPDATED) {
            this._pixelsUpdated(callArgs);
        } else {
            throw 'Internal ViewerImageDecoder Error: Unexpected call type ' +
                callArgs.type;
        }
    }
    
    this._pendingCallbackCalls.length = 0;
    
    this._canvasUpdatedCallback(newPosition);
};

ViewerImageDecoder.prototype._pixelsUpdated = function pixelsUpdated(pixelsUpdatedArgs) {
    var region = pixelsUpdatedArgs.region;
    var decoded = pixelsUpdatedArgs.decoded;
    if (decoded.imageData.width === 0 || decoded.imageData.height === 0) {
        return;
    }
    
    var x = decoded.xInOriginalRequest;
    var y = decoded.yInOriginalRequest;
    
    var context = region.canvas.getContext('2d');
    //var imageData = context.createImageData(decoded.width, decoded.height);
    //imageData.data.set(decoded.pixels);
    
    context.putImageData(decoded.imageData, x, y);
};

ViewerImageDecoder.prototype._repositionCanvas = function repositionCanvas(repositionArgs) {
    var region = repositionArgs.region;
    var position = repositionArgs.position;
	var donePartParams = repositionArgs.donePartParams;
    var copyData = repositionArgs.copyData;
    var pixelsWidth = repositionArgs.pixelsWidth;
    var pixelsHeight = repositionArgs.pixelsHeight;
    
    var imageDataToCopy;
    var context = region.canvas.getContext('2d');
    
    if (copyData !== undefined) {
        if (copyData.fromWidth === copyData.toWidth && copyData.fromHeight === copyData.toHeight) {
            imageDataToCopy = context.getImageData(
                copyData.fromX, copyData.fromY, copyData.fromWidth, copyData.fromHeight);
        } else {
            if (!this._tmpCanvas) {
                this._tmpCanvas = document.createElement('canvas');
                this._tmpCanvasContext = this._tmpCanvas.getContext('2d');
            }
            
            this._tmpCanvas.width  = copyData.toWidth;
            this._tmpCanvas.height = copyData.toHeight;
            this._tmpCanvasContext.drawImage(
                region.canvas,
                copyData.fromX, copyData.fromY, copyData.fromWidth, copyData.fromHeight,
                0, 0, copyData.toWidth, copyData.toHeight);
            
            imageDataToCopy = this._tmpCanvasContext.getImageData(
                0, 0, copyData.toWidth, copyData.toHeight);
        }
    }
    
    region.canvas.width = pixelsWidth;
    region.canvas.height = pixelsHeight;
    
    if (region !== this._regions[REGION_OVERVIEW]) {
        this._copyOverviewToCanvas(
            context, position, pixelsWidth, pixelsHeight);
    }
    
    if (copyData !== undefined) {
        context.putImageData(imageDataToCopy, copyData.toX, copyData.toY);
    }
    
    region.position = position;
	region.donePartParams = donePartParams;
};

ViewerImageDecoder.prototype._copyOverviewToCanvas = function copyOverviewToCanvas(
    context, canvasPosition, canvasPixelsWidth, canvasPixelsHeight) {
    
    var sourcePosition = this._regions[REGION_OVERVIEW].position;
    var sourcePixels =
        this._regions[REGION_OVERVIEW].imagePartParams;
    
    var sourcePixelsWidth =
        sourcePixels.maxXExclusive - sourcePixels.minX;
    var sourcePixelsHeight =
        sourcePixels.maxYExclusive - sourcePixels.minY;
    
    var sourcePositionWidth =
        sourcePosition.east - sourcePosition.west;
    var sourcePositionHeight =
        sourcePosition.north - sourcePosition.south;
        
    var sourceResolutionX =
        sourcePixelsWidth / sourcePositionWidth;
    var sourceResolutionY =
        sourcePixelsHeight / sourcePositionHeight;
    
    var targetPositionWidth =
        canvasPosition.east - canvasPosition.west;
    var targetPositionHeight =
        canvasPosition.north - canvasPosition.south;
        
    var cropWidth = targetPositionWidth * sourceResolutionX;
    var cropHeight = targetPositionHeight * sourceResolutionY;
    
    var cropOffsetPositionX =
        canvasPosition.west - sourcePosition.west;
    var cropOffsetPositionY =
        sourcePosition.north - canvasPosition.north;
        
    var cropPixelOffsetX = cropOffsetPositionX * sourceResolutionX;
    var cropPixelOffsetY = cropOffsetPositionY * sourceResolutionY;
    
    context.drawImage(
        this._regions[REGION_OVERVIEW].canvas,
        cropPixelOffsetX, cropPixelOffsetY, cropWidth, cropHeight,
        0, 0, canvasPixelsWidth, canvasPixelsHeight);
};

ViewerImageDecoder.prototype._opened = function opened() {
    this._isReady = true;
    
    var fixedBounds = {
        west: this._cartographicBounds.west,
        east: this._cartographicBounds.east,
        south: this._cartographicBounds.south,
        north: this._cartographicBounds.north
    };
    imageHelperFunctions.fixBounds(
        fixedBounds, this._image, this._adaptProportions);
    this._cartographicBoundsFixed = fixedBounds;
    
    var level = this._image.getImageLevel();
    var imageWidth = this._image.getLevelWidth(level);
    var imageHeight = this._image.getLevelHeight(level);
    this._quality = this._image.getHighestQuality();

    var rectangleWidth = fixedBounds.east - fixedBounds.west;
    var rectangleHeight = fixedBounds.north - fixedBounds.south;
    this._scaleX = imageWidth / rectangleWidth;
    this._scaleY = -imageHeight / rectangleHeight;
    
    this._translateX = -fixedBounds.west * this._scaleX;
    this._translateY = -fixedBounds.north * this._scaleY;
    
    var overviewParams = {
        minX: 0,
        minY: 0,
        maxXExclusive: imageWidth,
        maxYExclusive: imageHeight,
        screenWidth: this._overviewResolutionX,
        screenHeight: this._overviewResolutionY
    };
    
    var overviewAlignedParams =
        imageHelperFunctions.alignParamsToTilesAndLevel(
            overviewParams, this._image);
            
    overviewAlignedParams.imagePartParams.requestPriorityData =
        overviewAlignedParams.imagePartParams.requestPriorityData || {};
    
    overviewAlignedParams.imagePartParams.requestPriorityData.overrideHighestPriority = true;
    overviewAlignedParams.imagePartParams.quality = this._image.getLowestQuality();
    
    var startDynamicRegionOnTermination =
        !this._allowMultipleChannelsInSession;
        
    this._fetch(
        REGION_OVERVIEW,
        overviewAlignedParams,
        startDynamicRegionOnTermination);
    
    if (this._allowMultipleChannelsInSession) {
        this._startShowingDynamicRegion();
    }
};
},{"imagedecoder.js":5,"imagehelperfunctions.js":12,"workerproxyimagedecoder.js":18}],21:[function(require,module,exports){
'use strict';

module.exports.ViewerImageDecoder = require('viewerimagedecoder.js');
module.exports.ImageDecoder = require('imagedecoder.js');
module.exports.SimpleFetcher = require('simplefetcher.js');
module.exports.SimplePixelsDecoderBase = require('simplepixelsdecoderbase.js');
module.exports.CesiumImageDecoderLayerManager = require('_cesiumimagedecoderlayermanager.js');
module.exports.ImageDecoderImageryProvider = require('imagedecoderimageryprovider.js');
module.exports.ImageDecoderRegionLayer = require('imagedecoderregionlayer.js');
module.exports.Internals = {
    FetchManager: require('fetchmanager.js')
};
},{"_cesiumimagedecoderlayermanager.js":2,"fetchmanager.js":9,"imagedecoder.js":5,"imagedecoderimageryprovider.js":4,"imagedecoderregionlayer.js":22,"simplefetcher.js":25,"simplepixelsdecoderbase.js":28,"viewerimagedecoder.js":20}],22:[function(require,module,exports){
'use strict';

var ViewerImageDecoder = require('viewerimagedecoder.js');
var calculateLeafletFrustum = require('leafletfrustumcalculator.js');

/* global L: false */
/* global self: false */

if (self.L) {
    module.exports = L.Class.extend(createImageDecoderRegionLayerFunctions());
} else {
    module.exports = function() {
        throw new Error('Cannot instantiate ImageDecoderRegionLayer: No Leaflet namespace in scope');
    };
}

function createImageDecoderRegionLayerFunctions() {
    return {
        initialize: function initialize(options) {
            this._options = options || {};
            
            if (this._options.latLngBounds !== undefined) {
                this._options = JSON.parse(JSON.stringify(options));
                this._options.cartographicBounds = {
                    west: options.latLngBounds.getWest(),
                    east: options.latLngBounds.getEast(),
                    south: options.latLngBounds.getSouth(),
                    north: options.latLngBounds.getNorth()
                };
            }
            
            this._targetCanvas = null;
            this._canvasPosition = null;
            this._canvasUpdatedCallbackBound = this._canvasUpdatedCallback.bind(this);
            this._image = null;
            this._exceptionCallback = null;
        },
        
        setExceptionCallback: function setExceptionCallback(exceptionCallback) {
            this._exceptionCallback = exceptionCallback;
            if (this._image !== null) {
                this._image.setExceptionCallback(exceptionCallback);
            }
        },
        
        _createImage: function createImage() {
            if (this._image === null) {
                this._image = new ViewerImageDecoder(
                    this._options.imageImplementationClassName,
                    this._canvasUpdatedCallbackBound,
                    this._options);
                
                if (this._exceptionCallback !== null) {
                    this._image.setExceptionCallback(this._exceptionCallback);
                }
                
                this._image.open(this._options.url);
            }
        },

        onAdd: function onAdd(map) {
            if (this._map !== undefined) {
                throw 'Cannot add this layer to two maps';
            }
            
            this._map = map;
            this._createImage();

            // create a DOM element and put it into one of the map panes
            this._targetCanvas = L.DomUtil.create(
                'canvas', 'image-decoder-layer-canvas leaflet-zoom-animated');
            
            this._image.setTargetCanvas(this._targetCanvas);
            
            this._canvasPosition = null;
                
            map.getPanes().mapPane.appendChild(this._targetCanvas);

            // add a viewreset event listener for updating layer's position, do the latter
            map.on('viewreset', this._moved, this);
            map.on('move', this._moved, this);

            if (L.Browser.any3d) {
                map.on('zoomanim', this._animateZoom, this);
            }

            this._moved();
        },

        onRemove: function onRemove(map) {
            if (map !== this._map) {
                throw 'Removed from wrong map';
            }
            
            map.off('viewreset', this._moved, this);
            map.off('move', this._moved, this);
            map.off('zoomanim', this._animateZoom, this);
            
            // remove layer's DOM elements and listeners
            map.getPanes().mapPane.removeChild(this._targetCanvas);
            this._targetCanvas = null;
            this._canvasPosition = null;

            this._map = undefined;
            
            this._image.close();
            this._image = null;
        },
        
        _moved: function () {
            this._moveCanvases();

            var frustumData = calculateLeafletFrustum(this._map);
            
            this._image.updateViewArea(frustumData);
        },
        
        _canvasUpdatedCallback: function canvasUpdatedCallback(newPosition) {
            if (newPosition !== null) {
                this._canvasPosition = newPosition;
                this._moveCanvases();
            }
        },
        
        _moveCanvases: function moveCanvases() {
            if (this._canvasPosition === null) {
                return;
            }
        
            // update layer's position
            var west = this._canvasPosition.west;
            var east = this._canvasPosition.east;
            var south = this._canvasPosition.south;
            var north = this._canvasPosition.north;
            
            var topLeft = this._map.latLngToLayerPoint([north, west]);
            var bottomRight = this._map.latLngToLayerPoint([south, east]);
            var size = bottomRight.subtract(topLeft);
            
            L.DomUtil.setPosition(this._targetCanvas, topLeft);
            this._targetCanvas.style.width = size.x + 'px';
            this._targetCanvas.style.height = size.y + 'px';
        },
        
        _animateZoom: function animateZoom(options) {
            // NOTE: All method (including using of private method
            // _latLngToNewLayerPoint) was copied from ImageOverlay,
            // as Leaflet documentation recommends.
            
            var west =  this._canvasPosition.west;
            var east =  this._canvasPosition.east;
            var south = this._canvasPosition.south;
            var north = this._canvasPosition.north;

            var topLeft = this._map._latLngToNewLayerPoint(
                [north, west], options.zoom, options.center);
            var bottomRight = this._map._latLngToNewLayerPoint(
                [south, east], options.zoom, options.center);
            
            var scale = this._map.getZoomScale(options.zoom);
            var size = bottomRight.subtract(topLeft);
            var sizeScaled = size.multiplyBy((1 / 2) * (1 - 1 / scale));
            var origin = topLeft.add(sizeScaled);
            
            this._targetCanvas.style[L.DomUtil.TRANSFORM] =
                L.DomUtil.getTranslateString(origin) + ' scale(' + scale + ') ';
        }
    };
}
},{"leafletfrustumcalculator.js":23,"viewerimagedecoder.js":20}],23:[function(require,module,exports){
'use strict';

var imageHelperFunctions = require('imagehelperfunctions.js');

module.exports = function calculateLeafletFrustum(leafletMap) {
    var screenSize = leafletMap.getSize();
    var bounds = leafletMap.getBounds();

    var cartographicBounds = {
        west: bounds.getWest(),
        east: bounds.getEast(),
        south: bounds.getSouth(),
        north: bounds.getNorth()
    };
    
    var frustumData = imageHelperFunctions.calculateFrustum2DFromBounds(
        cartographicBounds, screenSize);

    return frustumData;
};
},{"imagehelperfunctions.js":12}],24:[function(require,module,exports){
'use strict';

module.exports = DataPublisher;

var LinkedList = require('linkedlist.js');
var HashMap = require('hashmap.js');

function DataPublisher(hasher) {
    this._subscribersByKey = new HashMap(hasher);
}

DataPublisher.prototype.publish = function publish(key, data, fetchEnded) {
    var subscribers = this._subscribersByKey.getFromKey(key);
    if (!subscribers) {
        return;
    }
    
    var iterator = subscribers.subscribersList.getFirstIterator();
    var listeners = [];
    while (iterator !== null) {
        var subscriber = subscribers.subscribersList.getValue(iterator);
	
		if (!subscriber.isEnded) {
			listeners.push(subscriber.listener);
			if (fetchEnded) {
				--subscribers.subscribersNotEndedCount;
				subscriber.isEnded = true;
			}
		}
        
        iterator = subscribers.subscribersList.getNextIterator(iterator);
    }
    
    // Call only after collecting all listeners, so the list will not be destroyed while iterating
    for (var i = 0; i < listeners.length; ++i) {
        listeners[i].call(this, key, data, fetchEnded);
    }
};

DataPublisher.prototype.subscribe = function subscribe(key, subscriber) {
    var subscribers = this._subscribersByKey.tryAdd(key, function() {
        return {
            subscribersList: new LinkedList(),
            subscribersNotEndedCount: 0
        };
    });
    
    ++subscribers.value.subscribersNotEndedCount;
    
    var listIterator = subscribers.value.subscribersList.add({
        listener: subscriber,
        isEnded: false
    });
    
    var handle = {
        _listIterator: listIterator,
        _hashIterator: subscribers.iterator
    };
    return handle;
};

DataPublisher.prototype.unsubscribe = function unsubscribe(handle) {
    var subscribers = this._subscribersByKey.getFromIterator(handle._hashIterator);
    
    var subscriber = subscribers.subscribersList.getValue(handle._listIterator);
    subscribers.subscribersList.remove(handle._listIterator);
    if (subscribers.subscribersList.getCount() === 0) {
        this._subscribersByKey.remove(handle._hashIterator);
    } else if (!subscriber.isEnded) {
        --subscribers.subscribersNotEndedCount;
        subscriber.isEnded = true;
    }
};

DataPublisher.prototype.isKeyNeedFetch = function isKeyNeedFetch(key) {
    var subscribers = this._subscribersByKey.getFromKey(key);
    return (!!subscribers) && (subscribers.subscribersNotEndedCount > 0);
};
},{"hashmap.js":11,"linkedlist.js":13}],25:[function(require,module,exports){
'use strict';

module.exports = SimpleFetcher;

var SimpleImageDataContext = require('simpleimagedatacontext.js');
var SimpleNonProgressiveFetchHandle = require('simplenonprogressivefetchhandle.js');
var DataPublisher = require('datapublisher.js');

/* global Promise: false */

function SimpleFetcher(fetcherMethods, options) {
    this._url = null;
    this._fetcherMethods = fetcherMethods;
    this._options = options || {};
    this._isReady = true;
    
    if (!this._fetcherMethods.getDataKeys) {
        throw 'SimpleFetcher error: getDataKeys is not implemented';
    }
    if (!this._fetcherMethods.fetch && !this._fetcherMethods.fetchProgressive) {
        throw 'SimpleFetcher error: Neither fetch nor fetchProgressive methods are implemented';
    }
    
    if (!this._fetcherMethods.getHashCode) {
        throw 'SimpleFetcher error: getHashCode is not implemented';
    }
    if (!this._fetcherMethods.isEqual) {
        throw 'SimpleFetcher error: isEqual is not implemented';
    }

    this._hasher = {
        _fetcherMethods: this._fetcherMethods,
        getHashCode: function(dataKey) {
            return this._fetcherMethods.getHashCode(dataKey);
        },
        isEqual: function(key1, key2) {
            if (key1.maxQuality !== key2.maxQuality) {
                return false;
            }

            return this._fetcherMethods.isEqual(key1.dataKey, key2.dataKey);
        }
    };

    if (this._fetcherMethods.createDataPublisher) {
        this._dataPublisher = this.fetcherMethods.createDataPublisher(this._hasher);
    } else {
        this._dataPublisher = new DataPublisher(this._hasher);
    }
}

SimpleFetcher.prototype.fetchProgressive = function fetchProgressive(imagePartParams, dataKeys, dataCallback, queryIsKeyNeedFetch, maxQuality) {
    this._ensureReady();
    if (!this._fetcherMethods.fetchProgressive) {
        var fetchHandle = new SimpleNonProgressiveFetchHandle(this._fetcherMethods, dataCallback, queryIsKeyNeedFetch, this._options);
        fetchHandle.fetch(dataKeys);
        return fetchHandle;
    }
    
    return this._fetcherMethods.fetchProgressive(imagePartParams, dataKeys, dataCallback, queryIsKeyNeedFetch, maxQuality);
};

SimpleFetcher.prototype.reconnect = function reconnect() {
    this._ensureReady();
    if (!this._fetcherMethods.reconnect) {
        throw 'SimpleFetcher error: reconnect is not implemented';
    }
    this._fetcherMethods.reconnect();
};

// Fetcher implementation

SimpleFetcher.prototype.createImageDataContext = function createImageDataContext(
    imagePartParams) {
    
    this._ensureReady();
    var dataKeys = this._fetcherMethods.getDataKeys(imagePartParams);
    return new SimpleImageDataContext(dataKeys, imagePartParams, this._dataPublisher, this._hasher);
};

SimpleFetcher.prototype.fetch = function fetch(imageDataContext) {
	var maxQuality = imageDataContext.getMaxQuality();
	var self = this;
	
	function dataCallback(dataKey, data, isFetchEnded) {
		var key = {
			dataKey: dataKey,
			maxQuality: maxQuality
		};
		self._dataPublisher.publish(key, data, isFetchEnded);
	}
	
	function queryIsKeyNeedFetch(dataKey) {
		var key = {
			dataKey: dataKey,
			maxQuality: maxQuality
		};
		return self._dataPublisher.isKeyNeedFetch(key);
	}
	
	return this.fetchProgressive(imageDataContext.getImagePartParams(), imageDataContext.getDataKeys(), dataCallback, queryIsKeyNeedFetch, maxQuality);
};

SimpleFetcher.prototype.startMovableFetch = function startMovableFetch(imageDataContext, movableFetchState) {
	movableFetchState.fetchHandle = this.fetch(imageDataContext);
};

SimpleFetcher.prototype.moveFetch = function moveFetch(imageDataContext, movableFetchState) {
	movableFetchState.fetchHandle.abortAsync();
	movableFetchState.fetchHandle = this.fetch(imageDataContext);
};

SimpleFetcher.prototype.close = function close(closedCallback) {
    this._ensureReady();
    this._isReady = false;
    return new Promise(function(resolve, reject) {
        // NOTE: Wait for all fetchHandles to finish?
        resolve();
    });
};

SimpleFetcher.prototype._ensureReady = function ensureReady() {
    if (!this._isReady) {
        throw 'SimpleFetcher error: fetch client is not opened';
    }
};

},{"datapublisher.js":24,"simpleimagedatacontext.js":26,"simplenonprogressivefetchhandle.js":27}],26:[function(require,module,exports){
'use strict';

module.exports = SimpleImageDataContext;

var HashMap = require('hashmap.js');

function SimpleImageDataContext(dataKeys, imagePartParams, dataPublisher, hasher) {
    this._dataByKey = new HashMap(hasher);
    this._dataToReturn = {
        imagePartParams: JSON.parse(JSON.stringify(imagePartParams)),
        fetchedItems: []
    };
	this._maxQuality = imagePartParams.quality;
    this._fetchEndedCount = 0;
	this._fetchedLowQualityCount = 0;
    this._dataListeners = [];
    this._dataKeys = dataKeys;
    this._imagePartParams = imagePartParams;
    this._dataPublisher = dataPublisher;
	this._isProgressive = false;
	this._isDisposed = false;
    
    this._subscribeHandles = [];
    
    var dataFetchedBound = this._dataFetched.bind(this);
    for (var i = 0; i < dataKeys.length; ++i) {
        var subscribeHandle = this._dataPublisher.subscribe(
			{ dataKey: dataKeys[i], maxQuality: this._maxQuality },
			dataFetchedBound);
        
        this._subscribeHandles.push(subscribeHandle);
    }
}

// Not part of ImageDataContext interface, only service for SimpleFetcher
SimpleImageDataContext.prototype.getMaxQuality = function getMaxQuality() {
	return this._maxQuality;
};

SimpleImageDataContext.prototype.getDataKeys = function getDataKeys() {
    return this._dataKeys;
};

SimpleImageDataContext.prototype.getImagePartParams = function getImagePartParams() {
    return this._imagePartParams;
};

SimpleImageDataContext.prototype.hasData = function hasData() {
    return this._fetchedLowQualityCount == this._dataKeys.length;
};

SimpleImageDataContext.prototype.getFetchedData = function getFetchedData() {
    if (!this.hasData()) {
        throw 'SimpleImageDataContext error: cannot call getFetchedData before hasData = true';
    }
    
    return this._dataToReturn;
};

SimpleImageDataContext.prototype.on = function on(event, listener) {
	if (this._isDisposed) {
		throw 'Cannot register to event on disposed ImageDataContext';
	}
    if (event !== 'data') {
        throw 'SimpleImageDataContext error: Unexpected event ' + event;
    }
    
    this._dataListeners.push(listener);
};

SimpleImageDataContext.prototype.isDone = function isDone() {
    return this._fetchEndedCount === this._dataKeys.length;
};

SimpleImageDataContext.prototype.dispose = function dispose() {
	this._isDisposed = true;
    for (var i = 0; i < this._subscribeHandles.length; ++i) {
        this._dataPublisher.unsubscribe(this._subscribeHandles[i]);
    }
    
    this._subscribeHandles = [];
	this._dataListeners = [];
};

SimpleImageDataContext.prototype.setIsProgressive = function setIsProgressive(isProgressive) {
	var oldIsProgressive = this._isProgressive;
    this._isProgressive = isProgressive;
	if (!oldIsProgressive && isProgressive && this.hasData()) {
		for (var i = 0; i < this._dataListeners.length; ++i) {
            this._dataListeners[i](this);
        }
	}
};

SimpleImageDataContext.prototype._dataFetched = function dataFetched(key, data, fetchEnded) {
	if (this._isDisposed) {
		throw 'Unexpected dataFetched listener call on disposed ImageDataContext';
	}

	var self = this;
	var added = this._dataByKey.tryAdd(key, function() {
		// Executed if new item
        self._dataToReturn.fetchedItems.push({
            key: key.dataKey,
            data: data
        });
		++self._fetchedLowQualityCount;
		return {
			fetchEnded: false,
			fetchedItemsOffset: self._dataToReturn.fetchedItems.length - 1
		};
	});
	
    if (added.value.fetchEnded) {
		// Already fetched full quality, nothing to refresh
		return;
	}
	
	this._dataToReturn.fetchedItems[added.value.fetchedItemsOffset].data = data;
	if (fetchEnded)
	{
		added.value.fetchEnded = true;
        ++this._fetchEndedCount;
    }
    
    if (this.isDone() || (this.hasData() && this._isProgressive)) {
        for (var i = 0; i < this._dataListeners.length; ++i) {
            this._dataListeners[i](this);
        }
    }
};
},{"hashmap.js":11}],27:[function(require,module,exports){
'use strict';

module.exports = SimpleNonProgressiveFetchHandle;

/* global Promise: false */

function SimpleNonProgressiveFetchHandle(fetchMethods, dataCallback, queryIsKeyNeedFetch, options) {
    this._fetchMethods = fetchMethods;
	this._dataCallback = dataCallback;
    this._queryIsKeyNeedFetch = queryIsKeyNeedFetch;
    this._fetchLimit = (options || {}).fetchLimitPerFetcher || 2;
    this._keysToFetch = null;
    this._nextKeyToFetch = 0;
    this._activeFetches = {};
    this._activeFetchesCount = 0;
    this._isAborted = false;
    this._isStoppedCalled = false;
    this._resolveAbort = null;
}

SimpleNonProgressiveFetchHandle.prototype.fetch = function fetch(keys) {
    if (this._keysToFetch !== null) {
        throw 'SimpleNonProgressiveFetchHandle error: Request fetcher can fetch only one region';
    }
    
    this._keysToFetch = keys;
    this._nextKeyToFetch = 0;
    while (this._activeFetchesCount < this._fetchLimit) {
        if (!this._fetchSingleKey()) {
            break;
        }
    }
};

SimpleNonProgressiveFetchHandle.prototype.abortAsync = function abortAsync() {
    var self = this;
    return new Promise(function(resolve, reject) {
        if (self._activeFetchesCount === 0) {
            resolve();
        } else {
            this._resolveAbort = resolve;
        }
    });
};

SimpleNonProgressiveFetchHandle.prototype._fetchSingleKey = function fetchSingleKey() {
    var key;
    do {
        if (this._nextKeyToFetch >= this._keysToFetch.length) {
            return false;
        }
        key = this._keysToFetch[this._nextKeyToFetch++];
    } while (!this._queryIsKeyNeedFetch(key));
    
    var self = this;
    this._activeFetches[key] = true;
    ++this._activeFetchesCount;
    
    this._fetchMethods.fetch(key)
        .then(function resolved(result) {
            self._dataCallback(key, result, /*fetchEnded=*/true);
            self._fetchEnded(null, key, result);
        }).catch(function failed(reason) {
            //self._fetchClient._onError(reason);
            self._fetchEnded(reason, key);
        });
    
    return true;
};

SimpleNonProgressiveFetchHandle.prototype._fetchEnded = function fetchEnded(error, key, result) {
    delete this._activeFetches[key];
    --this._activeFetchesCount;
    
    if (!this._resolveAbort) {
        this._fetchSingleKey();
    } else if (this._activeFetchesCount === 0) {
        this._resolveAbort();
        this._resolveAbort = null;
    }
};
},{}],28:[function(require,module,exports){
'use strict';

module.exports = SimplePixelsDecoderBase;

/* global Promise : false */
/* global ImageData : false */

function SimplePixelsDecoderBase() {
    SimplePixelsDecoderBase.prototype.decode = function decode(fetchedData) {
        var imagePartParams = fetchedData.imagePartParams;
        var width  = imagePartParams.maxXExclusive - imagePartParams.minX;
        var height = imagePartParams.maxYExclusive - imagePartParams.minY;
        var result = new ImageData(width, height);
        var promises = [];
        for (var i = 0; i < fetchedData.fetchedItems.length; ++i) {
            promises.push(this.decodeRegion(result, imagePartParams.minX, imagePartParams.minY, fetchedData.fetchedItems[i].key, fetchedData.fetchedItems[i].data));
        }
        
        return Promise.all(promises).then(function() {
            return result;
        });
    };
    
    SimplePixelsDecoderBase.prototype.decodeRegion = function decodeRegion(targetImageData, imagePartParams, key, fetchedData) {
        throw 'SimplePixelsDecoderBase error: decodeRegion is not implemented';
    };
}
},{}]},{},[21])(21)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvY2VzaXVtaW1hZ2VkZWNvZGVyL19jZXNpdW1mcnVzdHVtY2FsY3VsYXRvci5qcyIsInNyYy9jZXNpdW1pbWFnZWRlY29kZXIvX2Nlc2l1bWltYWdlZGVjb2RlcmxheWVybWFuYWdlci5qcyIsInNyYy9jZXNpdW1pbWFnZWRlY29kZXIvY2FudmFzaW1hZ2VyeXByb3ZpZGVyLmpzIiwic3JjL2Nlc2l1bWltYWdlZGVjb2Rlci9pbWFnZWRlY29kZXJpbWFnZXJ5cHJvdmlkZXIuanMiLCJzcmMvaW1hZ2VkZWNvZGVyL2ltYWdlZGVjb2Rlci5qcyIsInNyYy9pbWFnZWRlY29kZXIvaW1hZ2VkZWNvZGVyaGVscGVycy9kZWNvZGVqb2IuanMiLCJzcmMvaW1hZ2VkZWNvZGVyL2ltYWdlZGVjb2RlcmhlbHBlcnMvZGVjb2Rlam9ic3Bvb2wuanMiLCJzcmMvaW1hZ2VkZWNvZGVyL2ltYWdlZGVjb2RlcmhlbHBlcnMvZmV0Y2hqb2IuanMiLCJzcmMvaW1hZ2VkZWNvZGVyL2ltYWdlZGVjb2RlcmhlbHBlcnMvZmV0Y2htYW5hZ2VyLmpzIiwic3JjL2ltYWdlZGVjb2Rlci9pbWFnZWRlY29kZXJoZWxwZXJzL2ZydXN0dW1yZXF1ZXN0c3ByaW9yaXRpemVyLmpzIiwic3JjL2ltYWdlZGVjb2Rlci9pbWFnZWRlY29kZXJoZWxwZXJzL2hhc2htYXAuanMiLCJzcmMvaW1hZ2VkZWNvZGVyL2ltYWdlZGVjb2RlcmhlbHBlcnMvaW1hZ2VoZWxwZXJmdW5jdGlvbnMuanMiLCJzcmMvaW1hZ2VkZWNvZGVyL2ltYWdlZGVjb2RlcmhlbHBlcnMvbGlua2VkbGlzdC5qcyIsInNyYy9pbWFnZWRlY29kZXIvaW1hZ2VkZWNvZGVyd29ya2Vycy9jcmVhdGVpbWFnZWRlY29kZXJvbnNsYXZlc2lkZS5qcyIsInNyYy9pbWFnZWRlY29kZXIvaW1hZ2VkZWNvZGVyd29ya2Vycy9pbWFnZXBhcmFtc3JldHJpZXZlcnByb3h5LmpzIiwic3JjL2ltYWdlZGVjb2Rlci9pbWFnZWRlY29kZXJ3b3JrZXJzL3NlbmRpbWFnZXBhcmFtZXRlcnN0b21hc3Rlci5qcyIsInNyYy9pbWFnZWRlY29kZXIvaW1hZ2VkZWNvZGVyd29ya2Vycy93b3JrZXJwcm94eWZldGNobWFuYWdlci5qcyIsInNyYy9pbWFnZWRlY29kZXIvaW1hZ2VkZWNvZGVyd29ya2Vycy93b3JrZXJwcm94eWltYWdlZGVjb2Rlci5qcyIsInNyYy9pbWFnZWRlY29kZXIvaW1hZ2VkZWNvZGVyd29ya2Vycy93b3JrZXJwcm94eXBpeGVsc2RlY29kZXIuanMiLCJzcmMvaW1hZ2VkZWNvZGVyL3ZpZXdlcmltYWdlZGVjb2Rlci5qcyIsInNyYy9pbWFnZWRlY29kZXJleHBvcnRzLmpzIiwic3JjL2xlYWZsZXRpbWFnZWRlY29kZXIvaW1hZ2VkZWNvZGVycmVnaW9ubGF5ZXIuanMiLCJzcmMvbGVhZmxldGltYWdlZGVjb2Rlci9sZWFmbGV0ZnJ1c3R1bWNhbGN1bGF0b3IuanMiLCJzcmMvc2ltcGxlZmV0Y2hlci9kYXRhcHVibGlzaGVyLmpzIiwic3JjL3NpbXBsZWZldGNoZXIvc2ltcGxlZmV0Y2hlci5qcyIsInNyYy9zaW1wbGVmZXRjaGVyL3NpbXBsZWltYWdlZGF0YWNvbnRleHQuanMiLCJzcmMvc2ltcGxlZmV0Y2hlci9zaW1wbGVub25wcm9ncmVzc2l2ZWZldGNoaGFuZGxlLmpzIiwic3JjL3NpbXBsZWZldGNoZXIvc2ltcGxlcGl4ZWxzZGVjb2RlcmJhc2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4bEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcG9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY2FsY3VsYXRlRnJ1c3R1bTtcclxuXHJcbi8qIGdsb2JhbCBDZXNpdW06IGZhbHNlICovXHJcblxyXG52YXIgaW1hZ2VIZWxwZXJGdW5jdGlvbnMgPSByZXF1aXJlKCdpbWFnZWhlbHBlcmZ1bmN0aW9ucy5qcycpO1xyXG5cclxudmFyIE1BWF9SRUNVUlNJVkVfTEVWRUxfT05fRkFJTEVEX1RSQU5TRk9STSA9IDQ7XHJcblxyXG5mdW5jdGlvbiBjYWxjdWxhdGVGcnVzdHVtKGNlc2l1bVdpZGdldCkge1xyXG4gICAgdmFyIHNjcmVlblNpemUgPSB7XHJcbiAgICAgICAgeDogY2VzaXVtV2lkZ2V0LnNjZW5lLmNhbnZhcy53aWR0aCxcclxuICAgICAgICB5OiBjZXNpdW1XaWRnZXQuc2NlbmUuY2FudmFzLmhlaWdodFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdmFyIHBvaW50cyA9IFtdO1xyXG4gICAgc2VhcmNoQm91bmRpbmdQb2ludHMoXHJcbiAgICAgICAgMCwgMCwgc2NyZWVuU2l6ZS54LCBzY3JlZW5TaXplLnksIHBvaW50cywgY2VzaXVtV2lkZ2V0LCAvKnJlY3Vyc2l2ZT0qLzApO1xyXG5cclxuICAgIHZhciBmcnVzdHVtUmVjdGFuZ2xlID0gQ2VzaXVtLlJlY3RhbmdsZS5mcm9tQ2FydG9ncmFwaGljQXJyYXkocG9pbnRzKTtcclxuICAgIGlmIChmcnVzdHVtUmVjdGFuZ2xlLmVhc3QgPCBmcnVzdHVtUmVjdGFuZ2xlLndlc3QgfHwgZnJ1c3R1bVJlY3RhbmdsZS5ub3J0aCA8IGZydXN0dW1SZWN0YW5nbGUuc291dGgpIHtcclxuICAgICAgICBmcnVzdHVtUmVjdGFuZ2xlID0ge1xyXG4gICAgICAgICAgICBlYXN0OiBNYXRoLm1heChmcnVzdHVtUmVjdGFuZ2xlLmVhc3QsIGZydXN0dW1SZWN0YW5nbGUud2VzdCksXHJcbiAgICAgICAgICAgIHdlc3Q6IE1hdGgubWluKGZydXN0dW1SZWN0YW5nbGUuZWFzdCwgZnJ1c3R1bVJlY3RhbmdsZS53ZXN0KSxcclxuICAgICAgICAgICAgbm9ydGg6IE1hdGgubWF4KGZydXN0dW1SZWN0YW5nbGUubm9ydGgsIGZydXN0dW1SZWN0YW5nbGUuc291dGgpLFxyXG4gICAgICAgICAgICBzb3V0aDogTWF0aC5taW4oZnJ1c3R1bVJlY3RhbmdsZS5ub3J0aCwgZnJ1c3R1bVJlY3RhbmdsZS5zb3V0aClcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBmcnVzdHVtRGF0YSA9IGltYWdlSGVscGVyRnVuY3Rpb25zLmNhbGN1bGF0ZUZydXN0dW0yREZyb21Cb3VuZHMoXHJcbiAgICAgICAgZnJ1c3R1bVJlY3RhbmdsZSwgc2NyZWVuU2l6ZSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgIHJldHVybiBmcnVzdHVtRGF0YTtcclxufVxyXG4gICAgXHJcbmZ1bmN0aW9uIHNlYXJjaEJvdW5kaW5nUG9pbnRzKFxyXG4gICAgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgcG9pbnRzLCBjZXNpdW1XaWRnZXQsIHJlY3Vyc2l2ZUxldmVsKSB7XHJcbiAgICBcclxuICAgIHZhciB0cmFuc2Zvcm1lZFBvaW50cyA9IDA7XHJcbiAgICB0cmFuc2Zvcm1lZFBvaW50cyArPSB0cmFuc2Zvcm1BbmRBZGRQb2ludChcclxuICAgICAgICBtaW5YLCBtaW5ZLCBjZXNpdW1XaWRnZXQsIHBvaW50cyk7XHJcbiAgICB0cmFuc2Zvcm1lZFBvaW50cyArPSB0cmFuc2Zvcm1BbmRBZGRQb2ludChcclxuICAgICAgICBtYXhYLCBtaW5ZLCBjZXNpdW1XaWRnZXQsIHBvaW50cyk7XHJcbiAgICB0cmFuc2Zvcm1lZFBvaW50cyArPSB0cmFuc2Zvcm1BbmRBZGRQb2ludChcclxuICAgICAgICBtaW5YLCBtYXhZLCBjZXNpdW1XaWRnZXQsIHBvaW50cyk7XHJcbiAgICB0cmFuc2Zvcm1lZFBvaW50cyArPSB0cmFuc2Zvcm1BbmRBZGRQb2ludChcclxuICAgICAgICBtYXhYLCBtYXhZLCBjZXNpdW1XaWRnZXQsIHBvaW50cyk7XHJcblxyXG4gICAgdmFyIG1heExldmVsID0gTUFYX1JFQ1VSU0lWRV9MRVZFTF9PTl9GQUlMRURfVFJBTlNGT1JNO1xyXG4gICAgXHJcbiAgICBpZiAodHJhbnNmb3JtZWRQb2ludHMgPT09IDQgfHwgcmVjdXJzaXZlTGV2ZWwgPj0gbWF4TGV2ZWwpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBcclxuICAgICsrcmVjdXJzaXZlTGV2ZWw7XHJcbiAgICBcclxuICAgIHZhciBtaWRkbGVYID0gKG1pblggKyBtYXhYKSAvIDI7XHJcbiAgICB2YXIgbWlkZGxlWSA9IChtaW5ZICsgbWF4WSkgLyAyO1xyXG4gICAgXHJcbiAgICBzZWFyY2hCb3VuZGluZ1BvaW50cyhcclxuICAgICAgICBtaW5YLCBtaW5ZLCBtaWRkbGVYLCBtaWRkbGVZLCBwb2ludHMsIGNlc2l1bVdpZGdldCwgcmVjdXJzaXZlTGV2ZWwpO1xyXG5cclxuICAgIHNlYXJjaEJvdW5kaW5nUG9pbnRzKFxyXG4gICAgICAgIG1pblgsIG1pZGRsZVksIG1pZGRsZVgsIG1heFksIHBvaW50cywgY2VzaXVtV2lkZ2V0LCByZWN1cnNpdmVMZXZlbCk7XHJcblxyXG4gICAgc2VhcmNoQm91bmRpbmdQb2ludHMoXHJcbiAgICAgICAgbWlkZGxlWCwgbWluWSwgbWF4WCwgbWlkZGxlWSwgcG9pbnRzLCBjZXNpdW1XaWRnZXQsIHJlY3Vyc2l2ZUxldmVsKTtcclxuXHJcbiAgICBzZWFyY2hCb3VuZGluZ1BvaW50cyhcclxuICAgICAgICBtaWRkbGVYLCBtaWRkbGVZLCBtYXhYLCBtYXhZLCBwb2ludHMsIGNlc2l1bVdpZGdldCwgcmVjdXJzaXZlTGV2ZWwpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1BbmRBZGRQb2ludCh4LCB5LCBjZXNpdW1XaWRnZXQsIHBvaW50cykge1xyXG4gICAgXHJcbiAgICB2YXIgc2NyZWVuUG9pbnQgPSBuZXcgQ2VzaXVtLkNhcnRlc2lhbjIoeCwgeSk7XHJcbiAgICB2YXIgZWxsaXBzb2lkID0gY2VzaXVtV2lkZ2V0LnNjZW5lLm1hcFByb2plY3Rpb24uZWxsaXBzb2lkO1xyXG4gICAgdmFyIHBvaW50M0QgPSBjZXNpdW1XaWRnZXQuc2NlbmUuY2FtZXJhLnBpY2tFbGxpcHNvaWQoc2NyZWVuUG9pbnQsIGVsbGlwc29pZCk7XHJcbiAgICBcclxuICAgIGlmIChwb2ludDNEID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2FydGVzaWFuID0gZWxsaXBzb2lkLmNhcnRlc2lhblRvQ2FydG9ncmFwaGljKHBvaW50M0QpO1xyXG4gICAgaWYgKGNhcnRlc2lhbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHBvaW50cy5wdXNoKGNhcnRlc2lhbik7XHJcbiAgICByZXR1cm4gMTtcclxufSIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2VzaXVtSW1hZ2VEZWNvZGVyTGF5ZXJNYW5hZ2VyO1xyXG5cclxudmFyIENhbnZhc0ltYWdlcnlQcm92aWRlciA9IHJlcXVpcmUoJ2NhbnZhc2ltYWdlcnlwcm92aWRlci5qcycpO1xyXG52YXIgVmlld2VySW1hZ2VEZWNvZGVyID0gcmVxdWlyZSgndmlld2VyaW1hZ2VkZWNvZGVyLmpzJyk7XHJcbnZhciBjYWxjdWxhdGVDZXNpdW1GcnVzdHVtID0gcmVxdWlyZSgnX2Nlc2l1bWZydXN0dW1jYWxjdWxhdG9yLmpzJyk7XHJcblxyXG4vKiBnbG9iYWwgQ2VzaXVtOiBmYWxzZSAqL1xyXG5cclxuZnVuY3Rpb24gQ2VzaXVtSW1hZ2VEZWNvZGVyTGF5ZXJNYW5hZ2VyKGltYWdlSW1wbGVtZW50YXRpb25DbGFzc05hbWUsIG9wdGlvbnMpIHtcclxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgXHJcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5yZWN0YW5nbGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpKTtcclxuICAgICAgICB0aGlzLl9vcHRpb25zLmNhcnRvZ3JhcGhpY0JvdW5kcyA9IHtcclxuICAgICAgICAgICAgd2VzdDogb3B0aW9ucy5yZWN0YW5nbGUud2VzdCxcclxuICAgICAgICAgICAgZWFzdDogb3B0aW9ucy5yZWN0YW5nbGUuZWFzdCxcclxuICAgICAgICAgICAgc291dGg6IG9wdGlvbnMucmVjdGFuZ2xlLnNvdXRoLFxyXG4gICAgICAgICAgICBub3J0aDogb3B0aW9ucy5yZWN0YW5nbGUubm9ydGhcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aGlzLl9vcHRpb25zLm1pbkZ1bmN0aW9uQ2FsbEludGVydmFsTWlsbGlzZWNvbmRzID1cclxuICAgICAgICBvcHRpb25zLm1pbkZ1bmN0aW9uQ2FsbEludGVydmFsTWlsbGlzZWNvbmRzIHx8IDEwMDtcclxuICAgIHRoaXMuX3VybCA9IG9wdGlvbnMudXJsO1xyXG5cclxuICAgIHRoaXMuX3RhcmdldENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgdGhpcy5faW1hZ2VyeVByb3ZpZGVycyA9IFtcclxuICAgICAgICBuZXcgQ2FudmFzSW1hZ2VyeVByb3ZpZGVyKHRoaXMuX3RhcmdldENhbnZhcyksXHJcbiAgICAgICAgbmV3IENhbnZhc0ltYWdlcnlQcm92aWRlcih0aGlzLl90YXJnZXRDYW52YXMpXHJcbiAgICBdO1xyXG4gICAgdGhpcy5faW1hZ2VyeUxheWVyU2hvd24gPSBuZXcgQ2VzaXVtLkltYWdlcnlMYXllcih0aGlzLl9pbWFnZXJ5UHJvdmlkZXJzWzBdKTtcclxuICAgIHRoaXMuX2ltYWdlcnlMYXllclBlbmRpbmcgPSBuZXcgQ2VzaXVtLkltYWdlcnlMYXllcih0aGlzLl9pbWFnZXJ5UHJvdmlkZXJzWzFdKTtcclxuXHJcbiAgICB0aGlzLl9jYW52YXNVcGRhdGVkQ2FsbGJhY2tCb3VuZCA9IHRoaXMuX2NhbnZhc1VwZGF0ZWRDYWxsYmFjay5iaW5kKHRoaXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLl9pc1BlbmRpbmdVcGRhdGVDYWxsYmFjayA9IGZhbHNlO1xyXG4gICAgdGhpcy5faXNXaGlsZVJlcGxhY2VMYXllclNob3duID0gZmFsc2U7XHJcbiAgICB0aGlzLl9wZW5kaW5nUG9zaXRpb25SZWN0YW5nbGUgPSBudWxsO1xyXG4gICAgXHJcbiAgICB0aGlzLl9pbWFnZSA9IG5ldyBWaWV3ZXJJbWFnZURlY29kZXIoXHJcbiAgICAgICAgaW1hZ2VJbXBsZW1lbnRhdGlvbkNsYXNzTmFtZSxcclxuICAgICAgICB0aGlzLl9jYW52YXNVcGRhdGVkQ2FsbGJhY2tCb3VuZCxcclxuICAgICAgICB0aGlzLl9vcHRpb25zKTtcclxuICAgIFxyXG4gICAgdGhpcy5faW1hZ2Uuc2V0VGFyZ2V0Q2FudmFzKHRoaXMuX3RhcmdldENhbnZhcyk7XHJcbiAgICBcclxuICAgIHRoaXMuX3VwZGF0ZUZydXN0dW1Cb3VuZCA9IHRoaXMuX3VwZGF0ZUZydXN0dW0uYmluZCh0aGlzKTtcclxuICAgIHRoaXMuX3Bvc3RSZW5kZXJCb3VuZCA9IHRoaXMuX3Bvc3RSZW5kZXIuYmluZCh0aGlzKTtcclxufVxyXG5cclxuQ2VzaXVtSW1hZ2VEZWNvZGVyTGF5ZXJNYW5hZ2VyLnByb3RvdHlwZS5zZXRFeGNlcHRpb25DYWxsYmFjayA9IGZ1bmN0aW9uIHNldEV4Y2VwdGlvbkNhbGxiYWNrKGV4Y2VwdGlvbkNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLl9pbWFnZS5zZXRFeGNlcHRpb25DYWxsYmFjayhleGNlcHRpb25DYWxsYmFjayk7XHJcbn07XHJcblxyXG5DZXNpdW1JbWFnZURlY29kZXJMYXllck1hbmFnZXIucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiBvcGVuKHdpZGdldE9yVmlld2VyKSB7XHJcbiAgICB0aGlzLl93aWRnZXQgPSB3aWRnZXRPclZpZXdlcjtcclxuICAgIHRoaXMuX2xheWVycyA9IHdpZGdldE9yVmlld2VyLnNjZW5lLmltYWdlcnlMYXllcnM7XHJcbiAgICB3aWRnZXRPclZpZXdlci5zY2VuZS5wb3N0UmVuZGVyLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fcG9zdFJlbmRlckJvdW5kKTtcclxuICAgIFxyXG4gICAgdGhpcy5faW1hZ2Uub3Blbih0aGlzLl91cmwpO1xyXG4gICAgdGhpcy5fbGF5ZXJzLmFkZCh0aGlzLl9pbWFnZXJ5TGF5ZXJTaG93bik7XHJcbiAgICBcclxuICAgIC8vIE5PVEU6IElzIHRoZXJlIGFuIGV2ZW50IGhhbmRsZXIgdG8gcmVnaXN0ZXIgaW5zdGVhZD9cclxuICAgIC8vIChDZXNpdW0ncyBldmVudCBjb250cm9sbGVycyBvbmx5IGV4cG9zZSBrZXlib2FyZCBhbmQgbW91c2VcclxuICAgIC8vIGV2ZW50cywgYnV0IHRoZXJlIGlzIG5vIGV2ZW50IGZvciBmcnVzdHVtIGNoYW5nZWRcclxuICAgIC8vIHByb2dyYW1tYXRpY2FsbHkpLlxyXG4gICAgdGhpcy5faW50ZXJ2YWxIYW5kbGUgPSBzZXRJbnRlcnZhbChcclxuICAgICAgICB0aGlzLl91cGRhdGVGcnVzdHVtQm91bmQsXHJcbiAgICAgICAgNTAwKTtcclxufTtcclxuXHJcbkNlc2l1bUltYWdlRGVjb2RlckxheWVyTWFuYWdlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiBjbG9zZSgpIHtcclxuICAgIHRoaXMuX2ltYWdlLmNsb3NlKCk7XHJcbiAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsSGFuZGxlKTtcclxuXHJcbiAgICB0aGlzLl9sYXllcnMucmVtb3ZlKHRoaXMuX2ltYWdlcnlMYXllclNob3duKTtcclxuICAgIHRoaXMuX3dpZGdldC5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuX3Bvc3RSZW5kZXJCb3VuZCk7XHJcbiAgICBpZiAodGhpcy5faXNXaGlsZVJlcGxhY2VMYXllclNob3duKSB7XHJcbiAgICAgICAgdGhpcy5faXNXaGlsZVJlcGxhY2VMYXllclNob3duID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faXNQZW5kaW5nVXBkYXRlQ2FsbGJhY2sgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9sYXllcnMucmVtb3ZlKHRoaXMuX2ltYWdlcnlMYXllclBlbmRpbmcpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQ2VzaXVtSW1hZ2VEZWNvZGVyTGF5ZXJNYW5hZ2VyLnByb3RvdHlwZS5nZXRJbWFnZXJ5TGF5ZXJzID0gZnVuY3Rpb24gZ2V0SW1hZ2VyeUxheWVycygpIHtcclxuICAgIHJldHVybiBbdGhpcy5faW1hZ2VyeUxheWVyU2hvd24sIHRoaXMuX2ltYWdlcnlMYXllclBlbmRpbmddO1xyXG59O1xyXG5cclxuQ2VzaXVtSW1hZ2VEZWNvZGVyTGF5ZXJNYW5hZ2VyLnByb3RvdHlwZS5fdXBkYXRlRnJ1c3R1bSA9IGZ1bmN0aW9uIHVwZGF0ZUZydXN0dW0oKSB7XHJcbiAgICB2YXIgZnJ1c3R1bSA9IGNhbGN1bGF0ZUNlc2l1bUZydXN0dW0odGhpcy5fd2lkZ2V0KTtcclxuICAgIGlmIChmcnVzdHVtICE9PSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5faW1hZ2UudXBkYXRlVmlld0FyZWEoZnJ1c3R1bSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5DZXNpdW1JbWFnZURlY29kZXJMYXllck1hbmFnZXIucHJvdG90eXBlLl9jYW52YXNVcGRhdGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiBjYW52YXNVcGRhdGVkQ2FsbGJhY2sobmV3UG9zaXRpb24pIHtcclxuICAgIGlmICh0aGlzLl9pc1doaWxlUmVwbGFjZUxheWVyU2hvd24pIHtcclxuICAgICAgICB0aGlzLl9pc1BlbmRpbmdVcGRhdGVDYWxsYmFjayA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ1Bvc2l0aW9uUmVjdGFuZ2xlID0gbmV3UG9zaXRpb247XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChuZXdQb3NpdGlvbiAhPT0gbnVsbCkge1xyXG4gICAgICAgIHZhciByZWN0YW5nbGUgPSBuZXcgQ2VzaXVtLlJlY3RhbmdsZShcclxuICAgICAgICAgICAgbmV3UG9zaXRpb24ud2VzdCxcclxuICAgICAgICAgICAgbmV3UG9zaXRpb24uc291dGgsXHJcbiAgICAgICAgICAgIG5ld1Bvc2l0aW9uLmVhc3QsXHJcbiAgICAgICAgICAgIG5ld1Bvc2l0aW9uLm5vcnRoKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLl9pbWFnZXJ5UHJvdmlkZXJzWzBdLnNldFJlY3RhbmdsZShyZWN0YW5nbGUpO1xyXG4gICAgICAgIHRoaXMuX2ltYWdlcnlQcm92aWRlcnNbMV0uc2V0UmVjdGFuZ2xlKHJlY3RhbmdsZSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMuX3JlbW92ZUFuZFJlQWRkTGF5ZXIoKTtcclxufTtcclxuXHJcbkNlc2l1bUltYWdlRGVjb2RlckxheWVyTWFuYWdlci5wcm90b3R5cGUuX3JlbW92ZUFuZFJlQWRkTGF5ZXIgPSBmdW5jdGlvbiByZW1vdmVBbmRSZUFkZExheWVyKCkge1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fbGF5ZXJzLmluZGV4T2YodGhpcy5faW1hZ2VyeUxheWVyU2hvd24pO1xyXG4gICAgXHJcbiAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgdGhyb3cgJ0xheWVyIHdhcyByZW1vdmVkIGZyb20gdmlld2VyXFwncyBsYXllcnMgIHdpdGhvdXQgJyArXHJcbiAgICAgICAgICAgICdjbG9zaW5nIGxheWVyIG1hbmFnZXIuIFVzZSBDZXNpdW1JbWFnZURlY29kZXJMYXllck1hbmFnZXIuJyArXHJcbiAgICAgICAgICAgICdjbG9zZSgpIGluc3RlYWQnO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aGlzLl9pc1doaWxlUmVwbGFjZUxheWVyU2hvd24gPSB0cnVlO1xyXG4gICAgdGhpcy5fbGF5ZXJzLmFkZCh0aGlzLl9pbWFnZXJ5TGF5ZXJQZW5kaW5nLCBpbmRleCk7XHJcbn07XHJcblxyXG5DZXNpdW1JbWFnZURlY29kZXJMYXllck1hbmFnZXIucHJvdG90eXBlLl9wb3N0UmVuZGVyID0gZnVuY3Rpb24gcG9zdFJlbmRlcigpIHtcclxuICAgIGlmICghdGhpcy5faXNXaGlsZVJlcGxhY2VMYXllclNob3duKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIFxyXG4gICAgdGhpcy5faXNXaGlsZVJlcGxhY2VMYXllclNob3duID0gZmFsc2U7XHJcbiAgICB0aGlzLl9sYXllcnMucmVtb3ZlKHRoaXMuX2ltYWdlcnlMYXllclNob3duLCAvKmRlc3Ryb3k9Ki9mYWxzZSk7XHJcbiAgICBcclxuICAgIHZhciBzd2FwID0gdGhpcy5faW1hZ2VyeUxheWVyU2hvd247XHJcbiAgICB0aGlzLl9pbWFnZXJ5TGF5ZXJTaG93biA9IHRoaXMuX2ltYWdlcnlMYXllclBlbmRpbmc7XHJcbiAgICB0aGlzLl9pbWFnZXJ5TGF5ZXJQZW5kaW5nID0gc3dhcDtcclxuICAgIFxyXG4gICAgaWYgKHRoaXMuX2lzUGVuZGluZ1VwZGF0ZUNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5faXNQZW5kaW5nVXBkYXRlQ2FsbGJhY2sgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9jYW52YXNVcGRhdGVkQ2FsbGJhY2sodGhpcy5fcGVuZGluZ1Bvc2l0aW9uUmVjdGFuZ2xlKTtcclxuICAgIH1cclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhc0ltYWdlcnlQcm92aWRlcjtcclxuXHJcbi8qIGdsb2JhbCBDZXNpdW06IGZhbHNlICovXHJcbi8qIGdsb2JhbCBEZXZlbG9wZXJFcnJvcjogZmFsc2UgKi9cclxuLyogZ2xvYmFsIENyZWRpdDogZmFsc2UgKi9cclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlcyBhIFNpbmdsZSBDYW52YXMgaW1hZ2VyeSB0aWxlLiAgVGhlIGltYWdlIGlzIGFzc3VtZWQgdG8gdXNlIGFcclxuICoge0BsaW5rIEdlb2dyYXBoaWNUaWxpbmdTY2hlbWV9LlxyXG4gKlxyXG4gKiBAYWxpYXMgQ2FudmFzSW1hZ2VyeVByb3ZpZGVyXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge2NhbnZhc30gQ2FudmFzIGZvciB0aGUgdGlsZS5cclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gKiBAcGFyYW0ge0NyZWRpdHxTdHJpbmd9IFtvcHRpb25zLmNyZWRpdF0gQSBjcmVkaXQgZm9yIHRoZSBkYXRhIHNvdXJjZSwgd2hpY2ggaXMgZGlzcGxheWVkIG9uIHRoZSBjYW52YXMuXHJcbiAqXHJcbiAqIEBzZWUgQXJjR2lzTWFwU2VydmVySW1hZ2VyeVByb3ZpZGVyXHJcbiAqIEBzZWUgQmluZ01hcHNJbWFnZXJ5UHJvdmlkZXJcclxuICogQHNlZSBHb29nbGVFYXJ0aEltYWdlcnlQcm92aWRlclxyXG4gKiBAc2VlIE9wZW5TdHJlZXRNYXBJbWFnZXJ5UHJvdmlkZXJcclxuICogQHNlZSBUaWxlTWFwU2VydmljZUltYWdlcnlQcm92aWRlclxyXG4gKiBAc2VlIFdlYk1hcFNlcnZpY2VJbWFnZXJ5UHJvdmlkZXJcclxuICovXHJcbmZ1bmN0aW9uIENhbnZhc0ltYWdlcnlQcm92aWRlcihjYW52YXMsIG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcclxuICAgIGlmIChjYW52YXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcignY2FudmFzIGlzIHJlcXVpcmVkLicpO1xyXG4gICAgfVxyXG4gICAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XHJcblxyXG4gICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xyXG5cclxuICAgIHRoaXMuX2Vycm9yRXZlbnQgPSBuZXcgRXZlbnQoJ0NhbnZhc0ltYWdlcnlQcm92aWRlclN0YXR1cycpO1xyXG5cclxuICAgIHRoaXMuX3JlYWR5ID0gZmFsc2U7XHJcblxyXG4gICAgdmFyIGNyZWRpdCA9IG9wdGlvbnMuY3JlZGl0O1xyXG4gICAgaWYgKHR5cGVvZiBjcmVkaXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgY3JlZGl0ID0gbmV3IENyZWRpdChjcmVkaXQpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fY3JlZGl0ID0gY3JlZGl0O1xyXG59XHJcblxyXG5DYW52YXNJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB3aWR0aCBvZiBlYWNoIHRpbGUsIGluIHBpeGVscy4gVGhpcyBmdW5jdGlvbiBzaG91bGRcclxuICAgICAqIG5vdCBiZSBjYWxsZWQgYmVmb3JlIHtAbGluayBDYW52YXNJbWFnZXJ5UHJvdmlkZXIjcmVhZHl9IHJldHVybnMgdHJ1ZS5cclxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCB0aWxlV2lkdGgoKSB7XHJcbiAgICAgICAgICAgIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVhZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoJ3RpbGVXaWR0aCBtdXN0IG5vdCBiZSBjYWxsZWQgYmVmb3JlIHRoZSBpbWFnZXJ5IHByb3ZpZGVyIGlzIHJlYWR5LicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhcy53aWR0aDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBoZWlnaHQgb2YgZWFjaCB0aWxlLCBpbiBwaXhlbHMuICBUaGlzIGZ1bmN0aW9uIHNob3VsZFxyXG4gICAgICogbm90IGJlIGNhbGxlZCBiZWZvcmUge0BsaW5rIENhbnZhc0ltYWdlcnlQcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLlxyXG4gICAgICogQG1lbWJlcm9mIENhbnZhc0ltYWdlcnlQcm92aWRlci5wcm90b3R5cGVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgZ2V0IHRpbGVIZWlnaHQoKSB7XHJcbiAgICAgICAgICAgIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVhZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoJ3RpbGVIZWlnaHQgbXVzdCBub3QgYmUgY2FsbGVkIGJlZm9yZSB0aGUgaW1hZ2VyeSBwcm92aWRlciBpcyByZWFkeS4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYW52YXMuaGVpZ2h0O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG1heGltdW0gbGV2ZWwtb2YtZGV0YWlsIHRoYXQgY2FuIGJlIHJlcXVlc3RlZC4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkXHJcbiAgICAgKiBub3QgYmUgY2FsbGVkIGJlZm9yZSB7QGxpbmsgQ2FudmFzSW1hZ2VyeVByb3ZpZGVyI3JlYWR5fSByZXR1cm5zIHRydWUuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2FudmFzSW1hZ2VyeVByb3ZpZGVyLnByb3RvdHlwZVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBnZXQgbWF4aW11bUxldmVsKCkge1xyXG4gICAgICAgICAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3JlYWR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCdtYXhpbXVtTGV2ZWwgbXVzdCBub3QgYmUgY2FsbGVkIGJlZm9yZSB0aGUgaW1hZ2VyeSBwcm92aWRlciBpcyByZWFkeS4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG1pbmltdW0gbGV2ZWwtb2YtZGV0YWlsIHRoYXQgY2FuIGJlIHJlcXVlc3RlZC4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkXHJcbiAgICAgKiBub3QgYmUgY2FsbGVkIGJlZm9yZSB7QGxpbmsgQ2FudmFzSW1hZ2VyeVByb3ZpZGVyI3JlYWR5fSByZXR1cm5zIHRydWUuXHJcbiAgICAgKiBAbWVtYmVyb2YgQ2FudmFzSW1hZ2VyeVByb3ZpZGVyLnByb3RvdHlwZVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBnZXQgbWluaW11bUxldmVsKCkge1xyXG4gICAgICAgICAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3JlYWR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCdtaW5pbXVtTGV2ZWwgbXVzdCBub3QgYmUgY2FsbGVkIGJlZm9yZSB0aGUgaW1hZ2VyeSBwcm92aWRlciBpcyByZWFkeS4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHRpbGluZyBzY2hlbWUgdXNlZCBieSB0aGlzIHByb3ZpZGVyLiAgVGhpcyBmdW5jdGlvbiBzaG91bGRcclxuICAgICAqIG5vdCBiZSBjYWxsZWQgYmVmb3JlIHtAbGluayBDYW52YXNJbWFnZXJ5UHJvdmlkZXIjcmVhZHl9IHJldHVybnMgdHJ1ZS5cclxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlXHJcbiAgICAgKiBAdHlwZSB7VGlsaW5nU2NoZW1lfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCB0aWxpbmdTY2hlbWUoKSB7XHJcbiAgICAgICAgICAgIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVhZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoJ3RpbGluZ1NjaGVtZSBtdXN0IG5vdCBiZSBjYWxsZWQgYmVmb3JlIHRoZSBpbWFnZXJ5IHByb3ZpZGVyIGlzIHJlYWR5LicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGluZ1NjaGVtZTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSByZWN0YW5nbGUsIGluIHJhZGlhbnMsIG9mIHRoZSBpbWFnZXJ5IHByb3ZpZGVkIGJ5IHRoaXMgaW5zdGFuY2UuICBUaGlzIGZ1bmN0aW9uIHNob3VsZFxyXG4gICAgICogbm90IGJlIGNhbGxlZCBiZWZvcmUge0BsaW5rIENhbnZhc0ltYWdlcnlQcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLlxyXG4gICAgICogQG1lbWJlcm9mIENhbnZhc0ltYWdlcnlQcm92aWRlci5wcm90b3R5cGVcclxuICAgICAqIEB0eXBlIHtSZWN0YW5nbGV9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgZ2V0IHJlY3RhbmdsZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGluZ1NjaGVtZS5yZWN0YW5nbGU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgdGlsZSBkaXNjYXJkIHBvbGljeS4gIElmIG5vdCB1bmRlZmluZWQsIHRoZSBkaXNjYXJkIHBvbGljeSBpcyByZXNwb25zaWJsZVxyXG4gICAgICogZm9yIGZpbHRlcmluZyBvdXQgXCJtaXNzaW5nXCIgdGlsZXMgdmlhIGl0cyBzaG91bGREaXNjYXJkSW1hZ2UgZnVuY3Rpb24uICBJZiB0aGlzIGZ1bmN0aW9uXHJcbiAgICAgKiByZXR1cm5zIHVuZGVmaW5lZCwgbm8gdGlsZXMgYXJlIGZpbHRlcmVkLiAgVGhpcyBmdW5jdGlvbiBzaG91bGRcclxuICAgICAqIG5vdCBiZSBjYWxsZWQgYmVmb3JlIHtAbGluayBDYW52YXNJbWFnZXJ5UHJvdmlkZXIjcmVhZHl9IHJldHVybnMgdHJ1ZS5cclxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlXHJcbiAgICAgKiBAdHlwZSB7VGlsZURpc2NhcmRQb2xpY3l9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgZ2V0IHRpbGVEaXNjYXJkUG9saWN5KCkge1xyXG4gICAgICAgICAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3JlYWR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCd0aWxlRGlzY2FyZFBvbGljeSBtdXN0IG5vdCBiZSBjYWxsZWQgYmVmb3JlIHRoZSBpbWFnZXJ5IHByb3ZpZGVyIGlzIHJlYWR5LicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFuIGV2ZW50IHRoYXQgaXMgcmFpc2VkIHdoZW4gdGhlIGltYWdlcnkgcHJvdmlkZXIgZW5jb3VudGVycyBhbiBhc3luY2hyb25vdXMgZXJyb3IuICBCeSBzdWJzY3JpYmluZ1xyXG4gICAgICogdG8gdGhlIGV2ZW50LCB5b3Ugd2lsbCBiZSBub3RpZmllZCBvZiB0aGUgZXJyb3IgYW5kIGNhbiBwb3RlbnRpYWxseSByZWNvdmVyIGZyb20gaXQuICBFdmVudCBsaXN0ZW5lcnNcclxuICAgICAqIGFyZSBwYXNzZWQgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFRpbGVQcm92aWRlckVycm9yfS5cclxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlXHJcbiAgICAgKiBAdHlwZSB7RXZlbnR9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgZ2V0IGVycm9yRXZlbnQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvckV2ZW50O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHRoZSBwcm92aWRlciBpcyByZWFkeSBmb3IgdXNlLlxyXG4gICAgICogQG1lbWJlcm9mIENhbnZhc0ltYWdlcnlQcm92aWRlci5wcm90b3R5cGVcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCByZWFkeSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGNyZWRpdCB0byBkaXNwbGF5IHdoZW4gdGhpcyBpbWFnZXJ5IHByb3ZpZGVyIGlzIGFjdGl2ZS4gIFR5cGljYWxseSB0aGlzIGlzIHVzZWQgdG8gY3JlZGl0XHJcbiAgICAgKiB0aGUgc291cmNlIG9mIHRoZSBpbWFnZXJ5LiAgVGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IGJlIGNhbGxlZCBiZWZvcmUge0BsaW5rIENhbnZhc0ltYWdlcnlQcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLlxyXG4gICAgICogQG1lbWJlcm9mIENhbnZhc0ltYWdlcnlQcm92aWRlci5wcm90b3R5cGVcclxuICAgICAqIEB0eXBlIHtDcmVkaXR9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgZ2V0IGNyZWRpdCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWRpdDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgaW1hZ2VzIHByb3ZpZGVkIGJ5IHRoaXMgaW1hZ2VyeSBwcm92aWRlclxyXG4gICAgICogaW5jbHVkZSBhbiBhbHBoYSBjaGFubmVsLiAgSWYgdGhpcyBwcm9wZXJ0eSBpcyBmYWxzZSwgYW4gYWxwaGEgY2hhbm5lbCwgaWYgcHJlc2VudCwgd2lsbFxyXG4gICAgICogYmUgaWdub3JlZC4gIElmIHRoaXMgcHJvcGVydHkgaXMgdHJ1ZSwgYW55IGltYWdlcyB3aXRob3V0IGFuIGFscGhhIGNoYW5uZWwgd2lsbCBiZSB0cmVhdGVkXHJcbiAgICAgKiBhcyBpZiB0aGVpciBhbHBoYSBpcyAxLjAgZXZlcnl3aGVyZS4gIFdoZW4gdGhpcyBwcm9wZXJ0eSBpcyBmYWxzZSwgbWVtb3J5IHVzYWdlXHJcbiAgICAgKiBhbmQgdGV4dHVyZSB1cGxvYWQgdGltZSBhcmUgcmVkdWNlZC5cclxuICAgICAqIEBtZW1iZXJvZiBDYW52YXNJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBnZXQgaGFzQWxwaGFDaGFubmVsKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufTtcclxuXHJcbkNhbnZhc0ltYWdlcnlQcm92aWRlci5wcm90b3R5cGUuc2V0UmVjdGFuZ2xlID0gZnVuY3Rpb24gc2V0UmVjdGFuZ2xlKHJlY3RhbmdsZSkge1xyXG4gICAgXHJcbiAgICB0aGlzLl90aWxpbmdTY2hlbWUgPSBuZXcgQ2VzaXVtLkdlb2dyYXBoaWNUaWxpbmdTY2hlbWUoe1xyXG4gICAgICAgIHJlY3RhbmdsZTogcmVjdGFuZ2xlLFxyXG4gICAgICAgIG51bWJlck9mTGV2ZWxaZXJvVGlsZXNYOiAxLFxyXG4gICAgICAgIG51bWJlck9mTGV2ZWxaZXJvVGlsZXNZOiAxXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgaWYgKCF0aGlzLl9yZWFkeSkge1xyXG4gICAgICAgIHRoaXMuX3JlYWR5ID0gdHJ1ZTtcclxuICAgICAgICBDZXNpdW0uVGlsZVByb3ZpZGVyRXJyb3IuaGFuZGxlU3VjY2Vzcyh0aGlzLl9lcnJvckV2ZW50KTtcclxuICAgIH1cclxufTtcclxuXHJcbkNhbnZhc0ltYWdlcnlQcm92aWRlci5wcm90b3R5cGUuZ2V0VGlsZVdpZHRoID0gZnVuY3Rpb24gZ2V0VGlsZVdpZHRoKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudGlsZVdpZHRoO1xyXG59O1xyXG5cclxuQ2FudmFzSW1hZ2VyeVByb3ZpZGVyLnByb3RvdHlwZS5nZXRUaWxlSGVpZ2h0ID0gZnVuY3Rpb24gZ2V0VGlsZUhlaWdodCgpIHtcclxuICAgIHJldHVybiB0aGlzLnRpbGVIZWlnaHQ7XHJcbn07XHJcblxyXG5DYW52YXNJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlLmdldE1heGltdW1MZXZlbCA9IGZ1bmN0aW9uIGdldE1heGltdW1MZXZlbCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1heGltdW1MZXZlbDtcclxufTtcclxuXHJcbkNhbnZhc0ltYWdlcnlQcm92aWRlci5wcm90b3R5cGUuZ2V0TWluaW11bUxldmVsID0gZnVuY3Rpb24gZ2V0TWluaW11bUxldmVsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubWluaW11bUxldmVsO1xyXG59O1xyXG5cclxuQ2FudmFzSW1hZ2VyeVByb3ZpZGVyLnByb3RvdHlwZS5pc1JlYWR5ID0gZnVuY3Rpb24gaXNSZWFkeSgpIHtcclxuICAgIHJldHVybiB0aGlzLnJlYWR5O1xyXG59O1xyXG5cclxuQ2FudmFzSW1hZ2VyeVByb3ZpZGVyLnByb3RvdHlwZS5nZXRDcmVkaXQgPSBmdW5jdGlvbiBnZXRDcmVkaXQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jcmVkaXQ7XHJcbn07XHJcblxyXG5DYW52YXNJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlLmdldFJlY3RhbmdsZSA9IGZ1bmN0aW9uIGdldFJlY3RhbmdsZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnRpbGluZ1NjaGVtZS5yZWN0YW5nbGU7XHJcbn07XHJcblxyXG5DYW52YXNJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlLmdldFRpbGluZ1NjaGVtZSA9IGZ1bmN0aW9uIGdldFRpbGluZ1NjaGVtZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnRpbGluZ1NjaGVtZTtcclxufTtcclxuXHJcbkNhbnZhc0ltYWdlcnlQcm92aWRlci5wcm90b3R5cGUuZ2V0VGlsZURpc2NhcmRQb2xpY3kgPSBmdW5jdGlvbiBnZXRUaWxlRGlzY2FyZFBvbGljeSgpIHtcclxuICAgIHJldHVybiB0aGlzLnRpbGVEaXNjYXJkUG9saWN5O1xyXG59O1xyXG5cclxuQ2FudmFzSW1hZ2VyeVByb3ZpZGVyLnByb3RvdHlwZS5nZXRFcnJvckV2ZW50ID0gZnVuY3Rpb24gZ2V0RXJyb3JFdmVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLmVycm9yRXZlbnQ7XHJcbn07XHJcblxyXG5DYW52YXNJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlLmdldEhhc0FscGhhQ2hhbm5lbCA9IGZ1bmN0aW9uIGdldEhhc0FscGhhQ2hhbm5lbCgpIHtcclxuICAgIHJldHVybiB0aGlzLmhhc0FscGhhQ2hhbm5lbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBjcmVkaXRzIHRvIGJlIGRpc3BsYXllZCB3aGVuIGEgZ2l2ZW4gdGlsZSBpcyBkaXNwbGF5ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB0aWxlIFggY29vcmRpbmF0ZS5cclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHRpbGUgWSBjb29yZGluYXRlLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gbGV2ZWwgVGhlIHRpbGUgbGV2ZWw7XHJcbiAqIEByZXR1cm5zIHtDcmVkaXRbXX0gVGhlIGNyZWRpdHMgdG8gYmUgZGlzcGxheWVkIHdoZW4gdGhlIHRpbGUgaXMgZGlzcGxheWVkLlxyXG4gKlxyXG4gKiBAZXhjZXB0aW9uIHtEZXZlbG9wZXJFcnJvcn0gPGNvZGU+Z2V0VGlsZUNyZWRpdHM8L2NvZGU+IG11c3Qgbm90IGJlIGNhbGxlZCBiZWZvcmUgdGhlIGltYWdlcnkgcHJvdmlkZXIgaXMgcmVhZHkuXHJcbiAqL1xyXG5DYW52YXNJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlLmdldFRpbGVDcmVkaXRzID0gZnVuY3Rpb24oeCwgeSwgbGV2ZWwpIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVxdWVzdHMgdGhlIGltYWdlIGZvciBhIGdpdmVuIHRpbGUuICBUaGlzIGZ1bmN0aW9uIHNob3VsZFxyXG4gKiBub3QgYmUgY2FsbGVkIGJlZm9yZSB7QGxpbmsgQ2FudmFzSW1hZ2VyeVByb3ZpZGVyI3JlYWR5fSByZXR1cm5zIHRydWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB0aWxlIFggY29vcmRpbmF0ZS5cclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHRpbGUgWSBjb29yZGluYXRlLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gbGV2ZWwgVGhlIHRpbGUgbGV2ZWwuXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UgZm9yIHRoZSBpbWFnZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIHRoZSBpbWFnZSBpcyBhdmFpbGFibGUsIG9yXHJcbiAqICAgICAgICAgIHVuZGVmaW5lZCBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYWN0aXZlIHJlcXVlc3RzIHRvIHRoZSBzZXJ2ZXIsIGFuZCB0aGUgcmVxdWVzdFxyXG4gKiAgICAgICAgICBzaG91bGQgYmUgcmV0cmllZCBsYXRlci4gIFRoZSByZXNvbHZlZCBpbWFnZSBtYXkgYmUgZWl0aGVyIGFuXHJcbiAqICAgICAgICAgIEltYWdlIG9yIGEgQ2FudmFzIERPTSBvYmplY3QuXHJcbiAqXHJcbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSA8Y29kZT5yZXF1ZXN0SW1hZ2U8L2NvZGU+IG11c3Qgbm90IGJlIGNhbGxlZCBiZWZvcmUgdGhlIGltYWdlcnkgcHJvdmlkZXIgaXMgcmVhZHkuXHJcbiAqL1xyXG5DYW52YXNJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlLnJlcXVlc3RJbWFnZSA9IGZ1bmN0aW9uKHgsIHksIGxldmVsKSB7XHJcbiAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xyXG4gICAgaWYgKCF0aGlzLl9yZWFkeSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoJ3JlcXVlc3RJbWFnZSBtdXN0IG5vdCBiZSBjYWxsZWQgYmVmb3JlIHRoZSBpbWFnZXJ5IHByb3ZpZGVyIGlzIHJlYWR5LicpO1xyXG4gICAgfVxyXG4gICAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQaWNraW5nIGZlYXR1cmVzIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IHRoaXMgaW1hZ2VyeSBwcm92aWRlciwgc28gdGhpcyBmdW5jdGlvbiBzaW1wbHkgcmV0dXJuc1xyXG4gKiB1bmRlZmluZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB0aWxlIFggY29vcmRpbmF0ZS5cclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHRpbGUgWSBjb29yZGluYXRlLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gbGV2ZWwgVGhlIHRpbGUgbGV2ZWwuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb25naXR1ZGUgVGhlIGxvbmdpdHVkZSBhdCB3aGljaCB0byBwaWNrIGZlYXR1cmVzLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gbGF0aXR1ZGUgIFRoZSBsYXRpdHVkZSBhdCB3aGljaCB0byBwaWNrIGZlYXR1cmVzLlxyXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBBIHByb21pc2UgZm9yIHRoZSBwaWNrZWQgZmVhdHVyZXMgdGhhdCB3aWxsIHJlc29sdmUgd2hlbiB0aGUgYXN5bmNocm9ub3VzXHJcbiAqICAgICAgICAgICAgICAgICAgIHBpY2tpbmcgY29tcGxldGVzLiAgVGhlIHJlc29sdmVkIHZhbHVlIGlzIGFuIGFycmF5IG9mIHtAbGluayBJbWFnZXJ5TGF5ZXJGZWF0dXJlSW5mb31cclxuICogICAgICAgICAgICAgICAgICAgaW5zdGFuY2VzLiAgVGhlIGFycmF5IG1heSBiZSBlbXB0eSBpZiBubyBmZWF0dXJlcyBhcmUgZm91bmQgYXQgdGhlIGdpdmVuIGxvY2F0aW9uLlxyXG4gKiAgICAgICAgICAgICAgICAgICBJdCBtYXkgYWxzbyBiZSB1bmRlZmluZWQgaWYgcGlja2luZyBpcyBub3Qgc3VwcG9ydGVkLlxyXG4gKi9cclxuQ2FudmFzSW1hZ2VyeVByb3ZpZGVyLnByb3RvdHlwZS5waWNrRmVhdHVyZXMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VEZWNvZGVySW1hZ2VyeVByb3ZpZGVyO1xyXG5cclxudmFyIFdvcmtlclByb3h5SW1hZ2VEZWNvZGVyID0gcmVxdWlyZSgnd29ya2VycHJveHlpbWFnZWRlY29kZXIuanMnKTtcclxudmFyIGNhbGN1bGF0ZUNlc2l1bUZydXN0dW0gPSByZXF1aXJlKCdfY2VzaXVtZnJ1c3R1bWNhbGN1bGF0b3IuanMnKTtcclxudmFyIGltYWdlSGVscGVyRnVuY3Rpb25zID0gcmVxdWlyZSgnaW1hZ2VoZWxwZXJmdW5jdGlvbnMuanMnKTtcclxuXHJcbi8qIGdsb2JhbCBDZXNpdW06IGZhbHNlICovXHJcbi8qIGdsb2JhbCBEZXZlbG9wZXJFcnJvcjogZmFsc2UgKi9cclxuLyogZ2xvYmFsIENyZWRpdDogZmFsc2UgKi9cclxuLyogZ2xvYmFsIFByb21pc2U6IGZhbHNlICovXHJcblxyXG4vKipcclxuICogUHJvdmlkZXMgYSBJbWFnZURlY29kZXIgY2xpZW50IGltYWdlcnkgdGlsZS4gIFRoZSBpbWFnZSBpcyBhc3N1bWVkIHRvIHVzZSBhXHJcbiAqIHtAbGluayBHZW9ncmFwaGljVGlsaW5nU2NoZW1lfS5cclxuICpcclxuICogQGFsaWFzIEltYWdlRGVjb2RlckltYWdlcnlQcm92aWRlclxyXG4gKiBAY29uc3RydWN0b3JcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy51cmwgVGhlIHVybCBmb3IgdGhlIHRpbGUuXHJcbiAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBbb3B0aW9ucy5yZWN0YW5nbGU9UmVjdGFuZ2xlLk1BWF9WQUxVRV0gVGhlIHJlY3RhbmdsZSwgaW4gcmFkaWFucywgY292ZXJlZCBieSB0aGUgaW1hZ2UuXHJcbiAqIEBwYXJhbSB7Q3JlZGl0fFN0cmluZ30gW29wdGlvbnMuY3JlZGl0XSBBIGNyZWRpdCBmb3IgdGhlIGRhdGEgc291cmNlLCB3aGljaCBpcyBkaXNwbGF5ZWQgb24gdGhlIGNhbnZhcy5cclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnByb3h5XSBBIHByb3h5IHRvIHVzZSBmb3IgcmVxdWVzdHMuIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgYSBnZXRVUkwgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGUgcHJveGllZCBVUkwsIGlmIG5lZWRlZC5cclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hZGFwdFByb3BvcnRpb25zXSBkZXRlcm1pbmVzIGlmIHRvIGFkYXB0IHRoZSBwcm9wb3J0aW9ucyBvZiB0aGUgcmVjdGFuZ2xlIHByb3ZpZGVkIHRvIHRoZSBpbWFnZSBwaXhlbHMgcHJvcG9ydGlvbnMuXHJcbiAqXHJcbiAqIEBzZWUgQXJjR2lzTWFwU2VydmVySW1hZ2VyeVByb3ZpZGVyXHJcbiAqIEBzZWUgQmluZ01hcHNJbWFnZXJ5UHJvdmlkZXJcclxuICogQHNlZSBHb29nbGVFYXJ0aEltYWdlcnlQcm92aWRlclxyXG4gKiBAc2VlIE9wZW5TdHJlZXRNYXBJbWFnZXJ5UHJvdmlkZXJcclxuICogQHNlZSBUaWxlTWFwU2VydmljZUltYWdlcnlQcm92aWRlclxyXG4gKiBAc2VlIFdlYk1hcFNlcnZpY2VJbWFnZXJ5UHJvdmlkZXJcclxuICovXHJcbmZ1bmN0aW9uIEltYWdlRGVjb2RlckltYWdlcnlQcm92aWRlcihpbWFnZUltcGxlbWVudGF0aW9uQ2xhc3NOYW1lLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgdXJsID0gb3B0aW9ucy51cmw7XHJcbiAgICB0aGlzLl9hZGFwdFByb3BvcnRpb25zID0gb3B0aW9ucy5hZGFwdFByb3BvcnRpb25zO1xyXG4gICAgdGhpcy5fcmVjdGFuZ2xlID0gb3B0aW9ucy5yZWN0YW5nbGU7XHJcbiAgICB0aGlzLl9wcm94eSA9IG9wdGlvbnMucHJveHk7XHJcbiAgICB0aGlzLl91cGRhdGVGcnVzdHVtSW50ZXJ2YWwgPSAxMDAwIHx8IG9wdGlvbnMudXBkYXRlRnJ1c3R1bUludGVydmFsO1xyXG4gICAgdGhpcy5fY3JlZGl0ID0gb3B0aW9ucy5jcmVkaXQ7XHJcbiAgICBcclxuICAgIGlmICh0eXBlb2YgdGhpcy5fY3JlZGl0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRoaXMuX2NyZWRpdCA9IG5ldyBDcmVkaXQodGhpcy5fY3JlZGl0KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHRoaXMuX3JlY3RhbmdsZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhpcy5fcmVjdGFuZ2xlID0gQ2VzaXVtLlJlY3RhbmdsZS5mcm9tRGVncmVlcygtMTgwLCAtOTAsIDE4MCwgOTApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAodGhpcy5fYWRhcHRQcm9wb3J0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhpcy5fYWRhcHRQcm9wb3J0aW9ucyA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgb3B0aW9ucyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob3B0aW9ucyB8fCB7fSkpO1xyXG4gICAgb3B0aW9ucy5jYXJ0b2dyYXBoaWNCb3VuZHMgPSB7XHJcbiAgICAgICAgd2VzdDogdGhpcy5fcmVjdGFuZ2xlLndlc3QsXHJcbiAgICAgICAgZWFzdDogdGhpcy5fcmVjdGFuZ2xlLmVhc3QsXHJcbiAgICAgICAgc291dGg6IHRoaXMuX3JlY3RhbmdsZS5zb3V0aCxcclxuICAgICAgICBub3J0aDogdGhpcy5fcmVjdGFuZ2xlLm5vcnRoXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xyXG4gICAgaWYgKHVybCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcigndXJsIGlzIHJlcXVpcmVkLicpO1xyXG4gICAgfVxyXG4gICAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XHJcblxyXG4gICAgdGhpcy5fdXJsID0gdXJsO1xyXG5cclxuICAgIHRoaXMuX3RpbGluZ1NjaGVtZSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICB0aGlzLl90aWxlV2lkdGggPSAwO1xyXG4gICAgdGhpcy5fdGlsZUhlaWdodCA9IDA7XHJcblxyXG4gICAgdGhpcy5fZXJyb3JFdmVudCA9IG5ldyBFdmVudCgnSW1hZ2VEZWNvZGVySW1hZ2VyeVByb3ZpZGVyU3RhdHVzJyk7XHJcblxyXG4gICAgdGhpcy5fcmVhZHkgPSBmYWxzZTtcclxuICAgIHRoaXMuX2V4Y2VwdGlvbkNhbGxiYWNrID0gbnVsbDtcclxuICAgIHRoaXMuX2Nlc2l1bVdpZGdldCA9IG51bGw7XHJcbiAgICB0aGlzLl91cGRhdGVGcnVzdHVtSW50ZXJ2YWxIYW5kbGUgPSBudWxsO1xyXG4gICAgXHJcblxyXG4gICAgdmFyIGltYWdlVXJsID0gdXJsO1xyXG4gICAgaWYgKHRoaXMuX3Byb3h5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvLyBOT1RFOiBJcyB0aGF0IHRoZSBjb3JyZWN0IGxvZ2ljP1xyXG4gICAgICAgIGltYWdlVXJsID0gdGhpcy5fcHJveHkuZ2V0VVJMKGltYWdlVXJsKTtcclxuICAgIH1cclxuICAgICAgICBcclxuICAgIHRoaXMuX2ltYWdlID0gbmV3IFdvcmtlclByb3h5SW1hZ2VEZWNvZGVyKGltYWdlSW1wbGVtZW50YXRpb25DbGFzc05hbWUsIHtcclxuICAgICAgICBzZXJ2ZXJSZXF1ZXN0UHJpb3JpdGl6ZXI6ICdmcnVzdHVtJyxcclxuICAgICAgICBkZWNvZGVQcmlvcml0aXplcjogJ2ZydXN0dW0nXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl91cmwgPSBpbWFnZVVybDtcclxufVxyXG5cclxuSW1hZ2VEZWNvZGVySW1hZ2VyeVByb3ZpZGVyLnByb3RvdHlwZSA9IHtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgVVJMIG9mIHRoZSBJbWFnZURlY29kZXIgc2VydmVyIChpbmNsdWRpbmcgdGFyZ2V0KS5cclxuICAgICAqIEBtZW1iZXJvZiBJbWFnZURlY29kZXJJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCB1cmwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VybDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwcm94eSB1c2VkIGJ5IHRoaXMgcHJvdmlkZXIuXHJcbiAgICAgKiBAbWVtYmVyb2YgSW1hZ2VEZWNvZGVySW1hZ2VyeVByb3ZpZGVyLnByb3RvdHlwZVxyXG4gICAgICogQHR5cGUge1Byb3h5fVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCBwcm94eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJveHk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgd2lkdGggb2YgZWFjaCB0aWxlLCBpbiBwaXhlbHMuIFRoaXMgZnVuY3Rpb24gc2hvdWxkXHJcbiAgICAgKiBub3QgYmUgY2FsbGVkIGJlZm9yZSB7QGxpbmsgSW1hZ2VEZWNvZGVySW1hZ2VyeVByb3ZpZGVyI3JlYWR5fSByZXR1cm5zIHRydWUuXHJcbiAgICAgKiBAbWVtYmVyb2YgSW1hZ2VEZWNvZGVySW1hZ2VyeVByb3ZpZGVyLnByb3RvdHlwZVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBnZXQgdGlsZVdpZHRoKCkge1xyXG4gICAgICAgIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9yZWFkeSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCd0aWxlV2lkdGggbXVzdCBub3QgYmUgY2FsbGVkIGJlZm9yZSB0aGUgaW1hZ2VyeSBwcm92aWRlciBpcyByZWFkeS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl90aWxlV2lkdGg7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgaGVpZ2h0IG9mIGVhY2ggdGlsZSwgaW4gcGl4ZWxzLiAgVGhpcyBmdW5jdGlvbiBzaG91bGRcclxuICAgICAqIG5vdCBiZSBjYWxsZWQgYmVmb3JlIHtAbGluayBJbWFnZURlY29kZXJJbWFnZXJ5UHJvdmlkZXIjcmVhZHl9IHJldHVybnMgdHJ1ZS5cclxuICAgICAqIEBtZW1iZXJvZiBJbWFnZURlY29kZXJJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCB0aWxlSGVpZ2h0KCkge1xyXG4gICAgICAgIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9yZWFkeSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCd0aWxlSGVpZ2h0IG11c3Qgbm90IGJlIGNhbGxlZCBiZWZvcmUgdGhlIGltYWdlcnkgcHJvdmlkZXIgaXMgcmVhZHkuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZUhlaWdodDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBtYXhpbXVtIGxldmVsLW9mLWRldGFpbCB0aGF0IGNhbiBiZSByZXF1ZXN0ZWQuICBUaGlzIGZ1bmN0aW9uIHNob3VsZFxyXG4gICAgICogbm90IGJlIGNhbGxlZCBiZWZvcmUge0BsaW5rIEltYWdlRGVjb2RlckltYWdlcnlQcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLlxyXG4gICAgICogQG1lbWJlcm9mIEltYWdlRGVjb2RlckltYWdlcnlQcm92aWRlci5wcm90b3R5cGVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgZ2V0IG1heGltdW1MZXZlbCgpIHtcclxuICAgICAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xyXG4gICAgICAgIGlmICghdGhpcy5fcmVhZHkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBEZXZlbG9wZXJFcnJvcignbWF4aW11bUxldmVsIG11c3Qgbm90IGJlIGNhbGxlZCBiZWZvcmUgdGhlIGltYWdlcnkgcHJvdmlkZXIgaXMgcmVhZHkuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fbnVtUmVzb2x1dGlvbkxldmVscyAtIDE7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbWluaW11bSBsZXZlbC1vZi1kZXRhaWwgdGhhdCBjYW4gYmUgcmVxdWVzdGVkLiAgVGhpcyBmdW5jdGlvbiBzaG91bGRcclxuICAgICAqIG5vdCBiZSBjYWxsZWQgYmVmb3JlIHtAbGluayBJbWFnZURlY29kZXJJbWFnZXJ5UHJvdmlkZXIjcmVhZHl9IHJldHVybnMgdHJ1ZS5cclxuICAgICAqIEBtZW1iZXJvZiBJbWFnZURlY29kZXJJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCBtaW5pbXVtTGV2ZWwoKSB7XHJcbiAgICAgICAgLy8+PmluY2x1ZGVTdGFydCgnZGVidWcnLCBwcmFnbWFzLmRlYnVnKTtcclxuICAgICAgICBpZiAoIXRoaXMuX3JlYWR5KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoJ21pbmltdW1MZXZlbCBtdXN0IG5vdCBiZSBjYWxsZWQgYmVmb3JlIHRoZSBpbWFnZXJ5IHByb3ZpZGVyIGlzIHJlYWR5LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLz4+aW5jbHVkZUVuZCgnZGVidWcnKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgdGlsaW5nIHNjaGVtZSB1c2VkIGJ5IHRoaXMgcHJvdmlkZXIuICBUaGlzIGZ1bmN0aW9uIHNob3VsZFxyXG4gICAgICogbm90IGJlIGNhbGxlZCBiZWZvcmUge0BsaW5rIEltYWdlRGVjb2RlckltYWdlcnlQcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLlxyXG4gICAgICogQG1lbWJlcm9mIEltYWdlRGVjb2RlckltYWdlcnlQcm92aWRlci5wcm90b3R5cGVcclxuICAgICAqIEB0eXBlIHtUaWxpbmdTY2hlbWV9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgZ2V0IHRpbGluZ1NjaGVtZSgpIHtcclxuICAgICAgICAvLz4+aW5jbHVkZVN0YXJ0KCdkZWJ1ZycsIHByYWdtYXMuZGVidWcpO1xyXG4gICAgICAgIGlmICghdGhpcy5fcmVhZHkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCd0aWxpbmdTY2hlbWUgbXVzdCBub3QgYmUgY2FsbGVkIGJlZm9yZSB0aGUgaW1hZ2VyeSBwcm92aWRlciBpcyByZWFkeS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8+PmluY2x1ZGVFbmQoJ2RlYnVnJyk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl90aWxpbmdTY2hlbWU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcmVjdGFuZ2xlLCBpbiByYWRpYW5zLCBvZiB0aGUgaW1hZ2VyeSBwcm92aWRlZCBieSB0aGlzIGluc3RhbmNlLiAgVGhpcyBmdW5jdGlvbiBzaG91bGRcclxuICAgICAqIG5vdCBiZSBjYWxsZWQgYmVmb3JlIHtAbGluayBJbWFnZURlY29kZXJJbWFnZXJ5UHJvdmlkZXIjcmVhZHl9IHJldHVybnMgdHJ1ZS5cclxuICAgICAqIEBtZW1iZXJvZiBJbWFnZURlY29kZXJJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlXHJcbiAgICAgKiBAdHlwZSB7UmVjdGFuZ2xlfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCByZWN0YW5nbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGluZ1NjaGVtZS5yZWN0YW5nbGU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgdGlsZSBkaXNjYXJkIHBvbGljeS4gIElmIG5vdCB1bmRlZmluZWQsIHRoZSBkaXNjYXJkIHBvbGljeSBpcyByZXNwb25zaWJsZVxyXG4gICAgICogZm9yIGZpbHRlcmluZyBvdXQgXCJtaXNzaW5nXCIgdGlsZXMgdmlhIGl0cyBzaG91bGREaXNjYXJkSW1hZ2UgZnVuY3Rpb24uICBJZiB0aGlzIGZ1bmN0aW9uXHJcbiAgICAgKiByZXR1cm5zIHVuZGVmaW5lZCwgbm8gdGlsZXMgYXJlIGZpbHRlcmVkLiAgVGhpcyBmdW5jdGlvbiBzaG91bGRcclxuICAgICAqIG5vdCBiZSBjYWxsZWQgYmVmb3JlIHtAbGluayBJbWFnZURlY29kZXJJbWFnZXJ5UHJvdmlkZXIjcmVhZHl9IHJldHVybnMgdHJ1ZS5cclxuICAgICAqIEBtZW1iZXJvZiBJbWFnZURlY29kZXJJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlXHJcbiAgICAgKiBAdHlwZSB7VGlsZURpc2NhcmRQb2xpY3l9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgZ2V0IHRpbGVEaXNjYXJkUG9saWN5KCkge1xyXG4gICAgICAgIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9yZWFkeSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoJ3RpbGVEaXNjYXJkUG9saWN5IG11c3Qgbm90IGJlIGNhbGxlZCBiZWZvcmUgdGhlIGltYWdlcnkgcHJvdmlkZXIgaXMgcmVhZHkuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xyXG5cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYW4gZXZlbnQgdGhhdCBpcyByYWlzZWQgd2hlbiB0aGUgaW1hZ2VyeSBwcm92aWRlciBlbmNvdW50ZXJzIGFuIGFzeW5jaHJvbm91cyBlcnJvci4gIEJ5IHN1YnNjcmliaW5nXHJcbiAgICAgKiB0byB0aGUgZXZlbnQsIHlvdSB3aWxsIGJlIG5vdGlmaWVkIG9mIHRoZSBlcnJvciBhbmQgY2FuIHBvdGVudGlhbGx5IHJlY292ZXIgZnJvbSBpdC4gIEV2ZW50IGxpc3RlbmVyc1xyXG4gICAgICogYXJlIHBhc3NlZCBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgVGlsZVByb3ZpZGVyRXJyb3J9LlxyXG4gICAgICogQG1lbWJlcm9mIEltYWdlRGVjb2RlckltYWdlcnlQcm92aWRlci5wcm90b3R5cGVcclxuICAgICAqIEB0eXBlIHtFdmVudH1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBnZXQgZXJyb3JFdmVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3JFdmVudDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZXIgaXMgcmVhZHkgZm9yIHVzZS5cclxuICAgICAqIEBtZW1iZXJvZiBJbWFnZURlY29kZXJJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBnZXQgcmVhZHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGNyZWRpdCB0byBkaXNwbGF5IHdoZW4gdGhpcyBpbWFnZXJ5IHByb3ZpZGVyIGlzIGFjdGl2ZS4gIFR5cGljYWxseSB0aGlzIGlzIHVzZWQgdG8gY3JlZGl0XHJcbiAgICAgKiB0aGUgc291cmNlIG9mIHRoZSBpbWFnZXJ5LiAgVGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IGJlIGNhbGxlZCBiZWZvcmUge0BsaW5rIEltYWdlRGVjb2RlckltYWdlcnlQcm92aWRlciNyZWFkeX0gcmV0dXJucyB0cnVlLlxyXG4gICAgICogQG1lbWJlcm9mIEltYWdlRGVjb2RlckltYWdlcnlQcm92aWRlci5wcm90b3R5cGVcclxuICAgICAqIEB0eXBlIHtDcmVkaXR9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgZ2V0IGNyZWRpdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3JlZGl0O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHRoZSBpbWFnZXMgcHJvdmlkZWQgYnkgdGhpcyBpbWFnZXJ5IHByb3ZpZGVyXHJcbiAgICAgKiBpbmNsdWRlIGFuIGFscGhhIGNoYW5uZWwuICBJZiB0aGlzIHByb3BlcnR5IGlzIGZhbHNlLCBhbiBhbHBoYSBjaGFubmVsLCBpZiBwcmVzZW50LCB3aWxsXHJcbiAgICAgKiBiZSBpZ25vcmVkLiAgSWYgdGhpcyBwcm9wZXJ0eSBpcyB0cnVlLCBhbnkgaW1hZ2VzIHdpdGhvdXQgYW4gYWxwaGEgY2hhbm5lbCB3aWxsIGJlIHRyZWF0ZWRcclxuICAgICAqIGFzIGlmIHRoZWlyIGFscGhhIGlzIDEuMCBldmVyeXdoZXJlLiAgV2hlbiB0aGlzIHByb3BlcnR5IGlzIGZhbHNlLCBtZW1vcnkgdXNhZ2VcclxuICAgICAqIGFuZCB0ZXh0dXJlIHVwbG9hZCB0aW1lIGFyZSByZWR1Y2VkLlxyXG4gICAgICogQG1lbWJlcm9mIEltYWdlRGVjb2RlckltYWdlcnlQcm92aWRlci5wcm90b3R5cGVcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCBoYXNBbHBoYUNoYW5uZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn07XHJcblxyXG5JbWFnZURlY29kZXJJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlLnNldEV4Y2VwdGlvbkNhbGxiYWNrID1cclxuICAgIGZ1bmN0aW9uIHNldEV4Y2VwdGlvbkNhbGxiYWNrKGV4Y2VwdGlvbkNhbGxiYWNrKSB7XHJcbiAgICBcclxuICAgIHRoaXMuX2V4Y2VwdGlvbkNhbGxiYWNrID0gZXhjZXB0aW9uQ2FsbGJhY2s7XHJcbn07XHJcblxyXG5JbWFnZURlY29kZXJJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiBvcGVuKHdpZGdldE9yVmlld2VyKSB7XHJcbiAgICBpZiAodGhpcy5fdXBkYXRlRnJ1c3R1bUludGVydmFsSGFuZGxlICE9PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCdDYW5ub3Qgc2V0IHR3byBwYXJlbnQgdmlld2Vycy4nKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHdpZGdldE9yVmlld2VyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoJ3dpZGdldE9yVmlld2VyIHNob3VsZCBiZSBnaXZlbi4gSXQgaXMgJyArXHJcbiAgICAgICAgICAgICduZWVkZWQgZm9yIGZydXN0dW0gY2FsY3VsYXRpb24gZm9yIHRoZSBwcmlvcml0eSBtZWNoYW5pc20nKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5faW1hZ2Uub3Blbih0aGlzLl91cmwpXHJcblx0XHQudGhlbih0aGlzLl9vcGVuZWQuYmluZCh0aGlzKSlcclxuXHRcdC5jYXRjaCh0aGlzLl9vbkV4Y2VwdGlvbi5iaW5kKHRoaXMpKTtcclxuICAgIFxyXG4gICAgdGhpcy5fY2VzaXVtV2lkZ2V0ID0gd2lkZ2V0T3JWaWV3ZXI7XHJcbiAgICBcclxuICAgIHRoaXMuX3VwZGF0ZUZydXN0dW1JbnRlcnZhbEhhbmRsZSA9IHNldEludGVydmFsKFxyXG4gICAgICAgIHRoaXMuX3NldFByaW9yaXR5QnlGcnVzdHVtLmJpbmQodGhpcyksXHJcbiAgICAgICAgdGhpcy5fdXBkYXRlRnJ1c3R1bUludGVydmFsKTtcclxufTtcclxuXHJcbkltYWdlRGVjb2RlckltYWdlcnlQcm92aWRlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiBjbG9zZSgpIHtcclxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fdXBkYXRlRnJ1c3R1bUludGVydmFsSGFuZGxlKTtcclxuICAgIHRoaXMuX2ltYWdlLmNsb3NlKCk7XHJcbn07XHJcblxyXG5JbWFnZURlY29kZXJJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlLmdldFRpbGVXaWR0aCA9IGZ1bmN0aW9uIGdldFRpbGVXaWR0aCgpIHtcclxuICAgIHJldHVybiB0aGlzLnRpbGVXaWR0aDtcclxufTtcclxuXHJcbkltYWdlRGVjb2RlckltYWdlcnlQcm92aWRlci5wcm90b3R5cGUuZ2V0VGlsZUhlaWdodCA9IGZ1bmN0aW9uIGdldFRpbGVIZWlnaHQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50aWxlSGVpZ2h0O1xyXG59O1xyXG5cclxuSW1hZ2VEZWNvZGVySW1hZ2VyeVByb3ZpZGVyLnByb3RvdHlwZS5nZXRNYXhpbXVtTGV2ZWwgPSBmdW5jdGlvbiBnZXRNYXhpbXVtTGV2ZWwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tYXhpbXVtTGV2ZWw7XHJcbn07XHJcblxyXG5JbWFnZURlY29kZXJJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlLmdldE1pbmltdW1MZXZlbCA9IGZ1bmN0aW9uIGdldE1pbmltdW1MZXZlbCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1pbmltdW1MZXZlbDtcclxufTtcclxuXHJcbkltYWdlRGVjb2RlckltYWdlcnlQcm92aWRlci5wcm90b3R5cGUuZ2V0VXJsID0gZnVuY3Rpb24gZ2V0VXJsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudXJsO1xyXG59O1xyXG5cclxuSW1hZ2VEZWNvZGVySW1hZ2VyeVByb3ZpZGVyLnByb3RvdHlwZS5nZXRQcm94eSA9IGZ1bmN0aW9uIGdldFByb3h5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMucHJveHk7XHJcbn07XHJcblxyXG5JbWFnZURlY29kZXJJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlLmlzUmVhZHkgPSBmdW5jdGlvbiBpc1JlYWR5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMucmVhZHk7XHJcbn07XHJcblxyXG5JbWFnZURlY29kZXJJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlLmdldENyZWRpdCA9IGZ1bmN0aW9uIGdldENyZWRpdCgpIHtcclxuICAgIHJldHVybiB0aGlzLmNyZWRpdDtcclxufTtcclxuXHJcbkltYWdlRGVjb2RlckltYWdlcnlQcm92aWRlci5wcm90b3R5cGUuZ2V0UmVjdGFuZ2xlID0gZnVuY3Rpb24gZ2V0UmVjdGFuZ2xlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudGlsaW5nU2NoZW1lLnJlY3RhbmdsZTtcclxufTtcclxuXHJcbkltYWdlRGVjb2RlckltYWdlcnlQcm92aWRlci5wcm90b3R5cGUuZ2V0VGlsaW5nU2NoZW1lID0gZnVuY3Rpb24gZ2V0VGlsaW5nU2NoZW1lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudGlsaW5nU2NoZW1lO1xyXG59O1xyXG5cclxuSW1hZ2VEZWNvZGVySW1hZ2VyeVByb3ZpZGVyLnByb3RvdHlwZS5nZXRUaWxlRGlzY2FyZFBvbGljeSA9IGZ1bmN0aW9uIGdldFRpbGVEaXNjYXJkUG9saWN5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMudGlsZURpc2NhcmRQb2xpY3k7XHJcbn07XHJcblxyXG5JbWFnZURlY29kZXJJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlLmdldEVycm9yRXZlbnQgPSBmdW5jdGlvbiBnZXRFcnJvckV2ZW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZXJyb3JFdmVudDtcclxufTtcclxuXHJcbkltYWdlRGVjb2RlckltYWdlcnlQcm92aWRlci5wcm90b3R5cGUuZ2V0SGFzQWxwaGFDaGFubmVsID0gZnVuY3Rpb24gZ2V0SGFzQWxwaGFDaGFubmVsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGFzQWxwaGFDaGFubmVsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGNyZWRpdHMgdG8gYmUgZGlzcGxheWVkIHdoZW4gYSBnaXZlbiB0aWxlIGlzIGRpc3BsYXllZC5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHRpbGUgWCBjb29yZGluYXRlLlxyXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgdGlsZSBZIGNvb3JkaW5hdGUuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgdGlsZSBsZXZlbDtcclxuICogQHJldHVybnMge0NyZWRpdFtdfSBUaGUgY3JlZGl0cyB0byBiZSBkaXNwbGF5ZWQgd2hlbiB0aGUgdGlsZSBpcyBkaXNwbGF5ZWQuXHJcbiAqXHJcbiAqIEBleGNlcHRpb24ge0RldmVsb3BlckVycm9yfSA8Y29kZT5nZXRUaWxlQ3JlZGl0czwvY29kZT4gbXVzdCBub3QgYmUgY2FsbGVkIGJlZm9yZSB0aGUgaW1hZ2VyeSBwcm92aWRlciBpcyByZWFkeS5cclxuICovXHJcbkltYWdlRGVjb2RlckltYWdlcnlQcm92aWRlci5wcm90b3R5cGUuZ2V0VGlsZUNyZWRpdHMgPSBmdW5jdGlvbih4LCB5LCBsZXZlbCkge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXF1ZXN0cyB0aGUgaW1hZ2UgZm9yIGEgZ2l2ZW4gdGlsZS4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkXHJcbiAqIG5vdCBiZSBjYWxsZWQgYmVmb3JlIHtAbGluayBJbWFnZURlY29kZXJJbWFnZXJ5UHJvdmlkZXIjcmVhZHl9IHJldHVybnMgdHJ1ZS5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHRpbGUgWCBjb29yZGluYXRlLlxyXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgdGlsZSBZIGNvb3JkaW5hdGUuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZXZlbCBUaGUgdGlsZSBsZXZlbC5cclxuICogQHJldHVybnMge1Byb21pc2V9IEEgcHJvbWlzZSBmb3IgdGhlIGltYWdlIHRoYXQgd2lsbCByZXNvbHZlIHdoZW4gdGhlIGltYWdlIGlzIGF2YWlsYWJsZSwgb3JcclxuICogICAgICAgICAgdW5kZWZpbmVkIGlmIHRoZXJlIGFyZSB0b28gbWFueSBhY3RpdmUgcmVxdWVzdHMgdG8gdGhlIHNlcnZlciwgYW5kIHRoZSByZXF1ZXN0XHJcbiAqICAgICAgICAgIHNob3VsZCBiZSByZXRyaWVkIGxhdGVyLiAgVGhlIHJlc29sdmVkIGltYWdlIG1heSBiZSBlaXRoZXIgYW5cclxuICogICAgICAgICAgSW1hZ2Ugb3IgYSBDYW52YXMgRE9NIG9iamVjdC5cclxuICpcclxuICogQGV4Y2VwdGlvbiB7RGV2ZWxvcGVyRXJyb3J9IDxjb2RlPnJlcXVlc3RJbWFnZTwvY29kZT4gbXVzdCBub3QgYmUgY2FsbGVkIGJlZm9yZSB0aGUgaW1hZ2VyeSBwcm92aWRlciBpcyByZWFkeS5cclxuICovXHJcbkltYWdlRGVjb2RlckltYWdlcnlQcm92aWRlci5wcm90b3R5cGUucmVxdWVzdEltYWdlID0gZnVuY3Rpb24oeCwgeSwgY2VzaXVtTGV2ZWwpIHtcclxuICAgIC8vPj5pbmNsdWRlU3RhcnQoJ2RlYnVnJywgcHJhZ21hcy5kZWJ1Zyk7XHJcbiAgICBpZiAoIXRoaXMuX3JlYWR5KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IERldmVsb3BlckVycm9yKCdyZXF1ZXN0SW1hZ2UgbXVzdCBub3QgYmUgY2FsbGVkIGJlZm9yZSB0aGUgaW1hZ2VyeSBwcm92aWRlciBpcyByZWFkeS4nKTtcclxuICAgIH1cclxuICAgIC8vPj5pbmNsdWRlRW5kKCdkZWJ1ZycpO1xyXG4gICAgXHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICBcclxuICAgIHZhciBsZXZlbEZhY3RvciA9IE1hdGgucG93KDIsIHRoaXMuX251bVJlc29sdXRpb25MZXZlbHMgLSBjZXNpdW1MZXZlbCAtIDEpO1xyXG4gICAgdmFyIG1pblggPSB4ICogdGhpcy5fdGlsZVdpZHRoICAqIGxldmVsRmFjdG9yO1xyXG4gICAgdmFyIG1pblkgPSB5ICogdGhpcy5fdGlsZUhlaWdodCAqIGxldmVsRmFjdG9yO1xyXG4gICAgdmFyIG1heFhFeGNsdXNpdmUgPSAoeCArIDEpICogdGhpcy5fdGlsZVdpZHRoICAqIGxldmVsRmFjdG9yO1xyXG4gICAgdmFyIG1heFlFeGNsdXNpdmUgPSAoeSArIDEpICogdGhpcy5fdGlsZUhlaWdodCAqIGxldmVsRmFjdG9yO1xyXG4gICAgXHJcbiAgICB2YXIgYWxpZ25lZFBhcmFtcyA9IGltYWdlSGVscGVyRnVuY3Rpb25zLmFsaWduUGFyYW1zVG9UaWxlc0FuZExldmVsKHtcclxuICAgICAgICBtaW5YOiBtaW5YLFxyXG4gICAgICAgIG1pblk6IG1pblksXHJcbiAgICAgICAgbWF4WEV4Y2x1c2l2ZTogbWF4WEV4Y2x1c2l2ZSxcclxuICAgICAgICBtYXhZRXhjbHVzaXZlOiBtYXhZRXhjbHVzaXZlLFxyXG4gICAgICAgIHNjcmVlbldpZHRoOiB0aGlzLl90aWxlV2lkdGgsXHJcbiAgICAgICAgc2NyZWVuSGVpZ2h0OiB0aGlzLl90aWxlSGVpZ2h0XHJcbiAgICB9LCB0aGlzLl9pbWFnZSk7XHJcbiAgICBcclxuICAgIHZhciBsZXZlbCA9IGFsaWduZWRQYXJhbXMuaW1hZ2VQYXJ0UGFyYW1zLmxldmVsO1xyXG4gICAgdmFyIGxldmVsV2lkdGggPSB0aGlzLl9pbWFnZS5nZXRMZXZlbFdpZHRoKGxldmVsKTtcclxuICAgIHZhciBsZXZlbEhlaWdodCA9IHRoaXMuX2ltYWdlLmdldExldmVsSGVpZ2h0KGxldmVsKTtcclxuICAgIFxyXG4gICAgdmFyIHNjYWxlZENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgc2NhbGVkQ2FudmFzLndpZHRoID0gdGhpcy5fdGlsZVdpZHRoO1xyXG4gICAgc2NhbGVkQ2FudmFzLmhlaWdodCA9IHRoaXMuX3RpbGVIZWlnaHQ7XHJcbiAgICBcclxuICAgIHZhciBzY2FsZWRDb250ZXh0ID0gc2NhbGVkQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICBzY2FsZWRDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl90aWxlV2lkdGgsIHRoaXMuX3RpbGVIZWlnaHQpO1xyXG4gICAgXHJcbiAgICB2YXIgdGVtcFBpeGVsV2lkdGggID0gYWxpZ25lZFBhcmFtcy5pbWFnZVBhcnRQYXJhbXMubWF4WEV4Y2x1c2l2ZSAtIGFsaWduZWRQYXJhbXMuaW1hZ2VQYXJ0UGFyYW1zLm1pblg7XHJcbiAgICB2YXIgdGVtcFBpeGVsSGVpZ2h0ID0gYWxpZ25lZFBhcmFtcy5pbWFnZVBhcnRQYXJhbXMubWF4WUV4Y2x1c2l2ZSAtIGFsaWduZWRQYXJhbXMuaW1hZ2VQYXJ0UGFyYW1zLm1pblk7XHJcbiAgICBpZiAodGVtcFBpeGVsV2lkdGggPD0gMCB8fCB0ZW1wUGl4ZWxIZWlnaHQgPD0gMCkge1xyXG4gICAgICAgIHJldHVybiBzY2FsZWRDYW52YXM7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciB0ZW1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICB0ZW1wQ2FudmFzLndpZHRoID0gdGVtcFBpeGVsV2lkdGg7XHJcbiAgICB0ZW1wQ2FudmFzLmhlaWdodCA9IHRlbXBQaXhlbEhlaWdodDtcclxuICAgIHZhciB0ZW1wQ29udGV4dCA9IHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgIHRlbXBDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0ZW1wUGl4ZWxXaWR0aCwgdGVtcFBpeGVsSGVpZ2h0KTtcclxuICAgIFxyXG4gICAgYWxpZ25lZFBhcmFtcy5pbWFnZVBhcnRQYXJhbXMucXVhbGl0eSA9IHRoaXMuX3F1YWxpdHk7XHJcbiAgICBhbGlnbmVkUGFyYW1zLmltYWdlUGFydFBhcmFtcy5yZXF1ZXN0UHJpb3JpdHlEYXRhID0ge1xyXG4gICAgICAgIGltYWdlUmVjdGFuZ2xlOiB0aGlzLl9yZWN0YW5nbGVcclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciByZXNvbHZlLCByZWplY3Q7XHJcbiAgICB2YXIgcmVxdWVzdFBpeGVsc1Byb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlXywgcmVqZWN0Xykge1xyXG4gICAgICAgIHJlc29sdmUgPSByZXNvbHZlXztcclxuICAgICAgICByZWplY3QgPSByZWplY3RfO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHNlbGYuX2ltYWdlLnJlcXVlc3RQaXhlbHNQcm9ncmVzc2l2ZShcclxuICAgICAgICAgICAgYWxpZ25lZFBhcmFtcy5pbWFnZVBhcnRQYXJhbXMsXHJcbiAgICAgICAgICAgIHBpeGVsc0RlY29kZWRDYWxsYmFjayxcclxuICAgICAgICAgICAgdGVybWluYXRlZENhbGxiYWNrKTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBwaXhlbHNEZWNvZGVkQ2FsbGJhY2soZGVjb2RlZCkge1xyXG4gICAgICAgIHZhciBwYXJ0aWFsVGlsZVdpZHRoID0gZGVjb2RlZC5pbWFnZURhdGEud2lkdGg7XHJcbiAgICAgICAgdmFyIHBhcnRpYWxUaWxlSGVpZ2h0ID0gZGVjb2RlZC5pbWFnZURhdGEuaGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAocGFydGlhbFRpbGVXaWR0aCA+IDAgJiYgcGFydGlhbFRpbGVIZWlnaHQgPiAwKSB7XHJcbiAgICAgICAgICAgIHRlbXBDb250ZXh0LnB1dEltYWdlRGF0YShcclxuICAgICAgICAgICAgICAgIGRlY29kZWQuaW1hZ2VEYXRhLFxyXG4gICAgICAgICAgICAgICAgZGVjb2RlZC54SW5PcmlnaW5hbFJlcXVlc3QsXHJcbiAgICAgICAgICAgICAgICBkZWNvZGVkLnlJbk9yaWdpbmFsUmVxdWVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlcm1pbmF0ZWRDYWxsYmFjayhpc0Fib3J0ZWQpIHtcclxuICAgICAgICBpZiAoaXNBYm9ydGVkKSB7XHJcbiAgICAgICAgICAgIHJlamVjdCgnRmV0Y2ggcmVxdWVzdCBvciBkZWNvZGUgYWJvcnRlZCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNjYWxlZENvbnRleHQuZHJhd0ltYWdlKFxyXG4gICAgICAgICAgICAgICAgdGVtcENhbnZhcyxcclxuICAgICAgICAgICAgICAgIDAsIDAsIHRlbXBQaXhlbFdpZHRoLCB0ZW1wUGl4ZWxIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBhbGlnbmVkUGFyYW1zLmNyb3BwZWRTY3JlZW4ubWluWCwgYWxpZ25lZFBhcmFtcy5jcm9wcGVkU2NyZWVuLm1pblksXHJcbiAgICAgICAgICAgICAgICBhbGlnbmVkUGFyYW1zLmNyb3BwZWRTY3JlZW4ubWF4WEV4Y2x1c2l2ZSwgYWxpZ25lZFBhcmFtcy5jcm9wcGVkU2NyZWVuLm1heFlFeGNsdXNpdmUpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJlc29sdmUoc2NhbGVkQ2FudmFzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlcXVlc3RQaXhlbHNQcm9taXNlO1xyXG59O1xyXG5cclxuSW1hZ2VEZWNvZGVySW1hZ2VyeVByb3ZpZGVyLnByb3RvdHlwZS5fc2V0UHJpb3JpdHlCeUZydXN0dW0gPVxyXG4gICAgZnVuY3Rpb24gc2V0UHJpb3JpdHlCeUZydXN0dW0oKSB7XHJcbiAgICBcclxuICAgIGlmICghdGhpcy5fcmVhZHkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciBmcnVzdHVtRGF0YSA9IGNhbGN1bGF0ZUNlc2l1bUZydXN0dW0oXHJcbiAgICAgICAgdGhpcy5fY2VzaXVtV2lkZ2V0LCB0aGlzKTtcclxuICAgIFxyXG4gICAgaWYgKGZydXN0dW1EYXRhID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmcnVzdHVtRGF0YS5pbWFnZVJlY3RhbmdsZSA9IHRoaXMuZ2V0UmVjdGFuZ2xlKCk7XHJcbiAgICBmcnVzdHVtRGF0YS5leGFjdGxldmVsID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl9pbWFnZS5zZXRTZXJ2ZXJSZXF1ZXN0UHJpb3JpdGl6ZXJEYXRhKGZydXN0dW1EYXRhKTtcclxuICAgIHRoaXMuX2ltYWdlLnNldERlY29kZVByaW9yaXRpemVyRGF0YShmcnVzdHVtRGF0YSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUGlja2luZyBmZWF0dXJlcyBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSB0aGlzIGltYWdlcnkgcHJvdmlkZXIsIHNvIHRoaXMgZnVuY3Rpb24gc2ltcGx5IHJldHVybnNcclxuICogdW5kZWZpbmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgdGlsZSBYIGNvb3JkaW5hdGUuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB0aWxlIFkgY29vcmRpbmF0ZS5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIFRoZSB0aWxlIGxldmVsLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gbG9uZ2l0dWRlIFRoZSBsb25naXR1ZGUgYXQgd2hpY2ggdG8gcGljayBmZWF0dXJlcy5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGxhdGl0dWRlICBUaGUgbGF0aXR1ZGUgYXQgd2hpY2ggdG8gcGljayBmZWF0dXJlcy5cclxuICogQHJldHVybiB7UHJvbWlzZX0gQSBwcm9taXNlIGZvciB0aGUgcGlja2VkIGZlYXR1cmVzIHRoYXQgd2lsbCByZXNvbHZlIHdoZW4gdGhlIGFzeW5jaHJvbm91c1xyXG4gKiAgICAgICAgICAgICAgICAgICBwaWNraW5nIGNvbXBsZXRlcy4gIFRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhbiBhcnJheSBvZiB7QGxpbmsgSW1hZ2VyeUxheWVyRmVhdHVyZUluZm99XHJcbiAqICAgICAgICAgICAgICAgICAgIGluc3RhbmNlcy4gIFRoZSBhcnJheSBtYXkgYmUgZW1wdHkgaWYgbm8gZmVhdHVyZXMgYXJlIGZvdW5kIGF0IHRoZSBnaXZlbiBsb2NhdGlvbi5cclxuICogICAgICAgICAgICAgICAgICAgSXQgbWF5IGFsc28gYmUgdW5kZWZpbmVkIGlmIHBpY2tpbmcgaXMgbm90IHN1cHBvcnRlZC5cclxuICovXHJcbkltYWdlRGVjb2RlckltYWdlcnlQcm92aWRlci5wcm90b3R5cGUucGlja0ZlYXR1cmVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufTtcclxuXHJcbkltYWdlRGVjb2RlckltYWdlcnlQcm92aWRlci5wcm90b3R5cGUuX29uRXhjZXB0aW9uID0gZnVuY3Rpb24gb25FeGNlcHRpb24ocmVhc29uKSB7XHJcbiAgICBpZiAodGhpcy5fZXhjZXB0aW9uQ2FsbGJhY2sgIT09IG51bGwpIHtcclxuXHRcdHRoaXMuX2V4Y2VwdGlvbkNhbGxiYWNrKHJlYXNvbik7XHJcbiAgICB9XHJcbn07XHJcblxyXG5JbWFnZURlY29kZXJJbWFnZXJ5UHJvdmlkZXIucHJvdG90eXBlLl9vcGVuZWQgPSBmdW5jdGlvbiBvcGVuZWQoKSB7XHJcbiAgICBpZiAodGhpcy5fcmVhZHkpIHtcclxuICAgICAgICB0aHJvdyAnSW1hZ2VEZWNvZGVySW1hZ2VyeVByb3ZpZGVyIGVycm9yOiBvcGVuZWQoKSB3YXMgY2FsbGVkIG1vcmUgdGhhbiBvbmNlISc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMuX3JlYWR5ID0gdHJ1ZTtcclxuICAgIFxyXG4gICAgLy8gVGhpcyBpcyB3cm9uZyBpZiBDT0Qgb3IgQ09DIGV4aXN0cyBiZXNpZGVzIG1haW4gaGVhZGVyIENPRFxyXG4gICAgdGhpcy5fbnVtUmVzb2x1dGlvbkxldmVscyA9IHRoaXMuX2ltYWdlLmdldE51bVJlc29sdXRpb25MZXZlbHNGb3JMaW1pdHRlZFZpZXdlcigpO1xyXG4gICAgdGhpcy5fcXVhbGl0eSA9IHRoaXMuX2ltYWdlLmdldEhpZ2hlc3RRdWFsaXR5KCk7XHJcbiAgICB2YXIgbWF4aW11bUNlc2l1bUxldmVsID0gdGhpcy5fbnVtUmVzb2x1dGlvbkxldmVscyAtIDE7XHJcbiAgICAgICAgXHJcbiAgICB0aGlzLl90aWxlV2lkdGggPSB0aGlzLl9pbWFnZS5nZXRUaWxlV2lkdGgoKTtcclxuICAgIHRoaXMuX3RpbGVIZWlnaHQgPSB0aGlzLl9pbWFnZS5nZXRUaWxlSGVpZ2h0KCk7XHJcbiAgICAgICAgXHJcbiAgICB2YXIgYmVzdExldmVsID0gdGhpcy5faW1hZ2UuZ2V0SW1hZ2VMZXZlbCgpO1xyXG4gICAgdmFyIGJlc3RMZXZlbFdpZHRoICA9IHRoaXMuX2ltYWdlLmdldExldmVsV2lkdGggKGJlc3RMZXZlbCk7XHJcbiAgICB2YXIgYmVzdExldmVsSGVpZ2h0ID0gdGhpcy5faW1hZ2UuZ2V0TGV2ZWxIZWlnaHQoYmVzdExldmVsKTtcclxuICAgIFxyXG4gICAgdmFyIGxvd2VzdExldmVsVGlsZXNYID0gTWF0aC5jZWlsKGJlc3RMZXZlbFdpZHRoICAvIHRoaXMuX3RpbGVXaWR0aCApID4+IG1heGltdW1DZXNpdW1MZXZlbDtcclxuICAgIHZhciBsb3dlc3RMZXZlbFRpbGVzWSA9IE1hdGguY2VpbChiZXN0TGV2ZWxIZWlnaHQgLyB0aGlzLl90aWxlSGVpZ2h0KSA+PiBtYXhpbXVtQ2VzaXVtTGV2ZWw7XHJcblxyXG4gICAgaW1hZ2VIZWxwZXJGdW5jdGlvbnMuZml4Qm91bmRzKFxyXG4gICAgICAgIHRoaXMuX3JlY3RhbmdsZSxcclxuICAgICAgICB0aGlzLl9pbWFnZSxcclxuICAgICAgICB0aGlzLl9hZGFwdFByb3BvcnRpb25zKTtcclxuICAgIHZhciByZWN0YW5nbGVXaWR0aCAgPSB0aGlzLl9yZWN0YW5nbGUuZWFzdCAgLSB0aGlzLl9yZWN0YW5nbGUud2VzdDtcclxuICAgIHZhciByZWN0YW5nbGVIZWlnaHQgPSB0aGlzLl9yZWN0YW5nbGUubm9ydGggLSB0aGlzLl9yZWN0YW5nbGUuc291dGg7XHJcbiAgICBcclxuICAgIHZhciBiZXN0TGV2ZWxTY2FsZSA9IDEgPDwgbWF4aW11bUNlc2l1bUxldmVsO1xyXG4gICAgdmFyIHBpeGVsc1dpZHRoRm9yQ2VzaXVtICA9IHRoaXMuX3RpbGVXaWR0aCAgKiBsb3dlc3RMZXZlbFRpbGVzWCAqIGJlc3RMZXZlbFNjYWxlO1xyXG4gICAgdmFyIHBpeGVsc0hlaWdodEZvckNlc2l1bSA9IHRoaXMuX3RpbGVIZWlnaHQgKiBsb3dlc3RMZXZlbFRpbGVzWSAqIGJlc3RMZXZlbFNjYWxlO1xyXG4gICAgXHJcbiAgICAvLyBDZXNpdW0gd29ya3Mgd2l0aCBmdWxsIHRpbGVzIG9ubHksIHRodXMgZml4IHRoZSBnZW9ncmFwaGljIGJvdW5kcyBzb1xyXG4gICAgLy8gdGhlIHBpeGVscyBsaWVzIGV4YWN0bHkgb24gdGhlIG9yaWdpbmFsIGJvdW5kc1xyXG4gICAgXHJcbiAgICB2YXIgZ2VvZ3JhcGhpY1dpZHRoRm9yQ2VzaXVtID1cclxuICAgICAgICByZWN0YW5nbGVXaWR0aCAqIHBpeGVsc1dpZHRoRm9yQ2VzaXVtIC8gYmVzdExldmVsV2lkdGg7XHJcbiAgICB2YXIgZ2VvZ3JhcGhpY0hlaWdodEZvckNlc2l1bSA9XHJcbiAgICAgICAgcmVjdGFuZ2xlSGVpZ2h0ICogcGl4ZWxzSGVpZ2h0Rm9yQ2VzaXVtIC8gYmVzdExldmVsSGVpZ2h0O1xyXG4gICAgXHJcbiAgICB2YXIgZml4ZWRFYXN0ICA9IHRoaXMuX3JlY3RhbmdsZS53ZXN0ICArIGdlb2dyYXBoaWNXaWR0aEZvckNlc2l1bTtcclxuICAgIHZhciBmaXhlZFNvdXRoID0gdGhpcy5fcmVjdGFuZ2xlLm5vcnRoIC0gZ2VvZ3JhcGhpY0hlaWdodEZvckNlc2l1bTtcclxuICAgIFxyXG4gICAgdGhpcy5fdGlsaW5nU2NoZW1lUGFyYW1zID0ge1xyXG4gICAgICAgIHdlc3Q6IHRoaXMuX3JlY3RhbmdsZS53ZXN0LFxyXG4gICAgICAgIGVhc3Q6IGZpeGVkRWFzdCxcclxuICAgICAgICBzb3V0aDogZml4ZWRTb3V0aCxcclxuICAgICAgICBub3J0aDogdGhpcy5fcmVjdGFuZ2xlLm5vcnRoLFxyXG4gICAgICAgIGxldmVsWmVyb1RpbGVzWDogbG93ZXN0TGV2ZWxUaWxlc1gsXHJcbiAgICAgICAgbGV2ZWxaZXJvVGlsZXNZOiBsb3dlc3RMZXZlbFRpbGVzWSxcclxuICAgICAgICBtYXhpbXVtTGV2ZWw6IG1heGltdW1DZXNpdW1MZXZlbFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5fdGlsaW5nU2NoZW1lID0gY3JlYXRlVGlsaW5nU2NoZW1lKHRoaXMuX3RpbGluZ1NjaGVtZVBhcmFtcyk7XHJcbiAgICAgICAgXHJcbiAgICBDZXNpdW0uVGlsZVByb3ZpZGVyRXJyb3IuaGFuZGxlU3VjY2Vzcyh0aGlzLl9lcnJvckV2ZW50KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVRpbGluZ1NjaGVtZShwYXJhbXMpIHtcclxuICAgIHZhciBnZW9ncmFwaGljUmVjdGFuZ2xlRm9yQ2VzaXVtID0gbmV3IENlc2l1bS5SZWN0YW5nbGUoXHJcbiAgICAgICAgcGFyYW1zLndlc3QsIHBhcmFtcy5zb3V0aCwgcGFyYW1zLmVhc3QsIHBhcmFtcy5ub3J0aCk7XHJcbiAgICBcclxuICAgIHZhciB0aWxpbmdTY2hlbWUgPSBuZXcgQ2VzaXVtLkdlb2dyYXBoaWNUaWxpbmdTY2hlbWUoe1xyXG4gICAgICAgIHJlY3RhbmdsZTogZ2VvZ3JhcGhpY1JlY3RhbmdsZUZvckNlc2l1bSxcclxuICAgICAgICBudW1iZXJPZkxldmVsWmVyb1RpbGVzWDogcGFyYW1zLmxldmVsWmVyb1RpbGVzWCxcclxuICAgICAgICBudW1iZXJPZkxldmVsWmVyb1RpbGVzWTogcGFyYW1zLmxldmVsWmVyb1RpbGVzWVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiB0aWxpbmdTY2hlbWU7XHJcbn0iLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlRGVjb2RlcjtcclxuXHJcbnZhciBXb3JrZXJQcm94eUZldGNoTWFuYWdlciA9IHJlcXVpcmUoJ3dvcmtlcnByb3h5ZmV0Y2htYW5hZ2VyLmpzJyk7XHJcbnZhciBpbWFnZUhlbHBlckZ1bmN0aW9ucyA9IHJlcXVpcmUoJ2ltYWdlSGVscGVyRnVuY3Rpb25zLmpzJyk7XHJcbnZhciBEZWNvZGVKb2JzUG9vbCA9IHJlcXVpcmUoJ2RlY29kZWpvYnNwb29sLmpzJyk7XHJcbnZhciBXb3JrZXJQcm94eVBpeGVsc0RlY29kZXIgPSByZXF1aXJlKCd3b3JrZXJwcm94eXBpeGVsc2RlY29kZXIuanMnKTtcclxudmFyIEltYWdlUGFyYW1zUmV0cmlldmVyUHJveHkgPSByZXF1aXJlKCdpbWFnZXBhcmFtc3JldHJpZXZlcnByb3h5LmpzJyk7XHJcblxyXG4vKiBnbG9iYWwgY29uc29sZTogZmFsc2UgKi9cclxuLyogZ2xvYmFsIFByb21pc2U6IGZhbHNlICovXHJcblxyXG5mdW5jdGlvbiBJbWFnZURlY29kZXIoaW1hZ2VJbXBsZW1lbnRhdGlvbkNsYXNzTmFtZSwgb3B0aW9ucykge1xyXG4gICAgSW1hZ2VQYXJhbXNSZXRyaWV2ZXJQcm94eS5jYWxsKHRoaXMsIGltYWdlSW1wbGVtZW50YXRpb25DbGFzc05hbWUpO1xyXG4gICAgXHJcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIHRoaXMuX29wdGlvbnNXZWJXb3JrZXJzID0gaW1hZ2VIZWxwZXJGdW5jdGlvbnMuY3JlYXRlSW50ZXJuYWxPcHRpb25zKGltYWdlSW1wbGVtZW50YXRpb25DbGFzc05hbWUsIHRoaXMuX29wdGlvbnMpO1xyXG4gICAgdmFyIGRlY29kZVdvcmtlcnNMaW1pdCA9IHRoaXMuX29wdGlvbnMud29ya2Vyc0xpbWl0IHx8IDU7XHJcbiAgICBcclxuICAgIHRoaXMuX3RpbGVXaWR0aCA9IHRoaXMuX29wdGlvbnMudGlsZVdpZHRoIHx8IDI1NjtcclxuICAgIHRoaXMuX3RpbGVIZWlnaHQgPSB0aGlzLl9vcHRpb25zLnRpbGVIZWlnaHQgfHwgMjU2O1xyXG4gICAgdGhpcy5fc2hvd0xvZyA9ICEhdGhpcy5fb3B0aW9ucy5zaG93TG9nO1xyXG4gICAgXHJcbiAgICAvKmlmICh0aGlzLl9zaG93TG9nKSB7XHJcbiAgICAgICAgLy8gT2xkIElFXHJcbiAgICAgICAgdGhyb3cgJ3Nob3dMb2cgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXInO1xyXG4gICAgfSovXHJcblxyXG4gICAgdGhpcy5fY2hhbm5lbFN0YXRlcyA9IFtdO1xyXG4gICAgdGhpcy5fZGVjb2RlcnMgPSBbXTtcclxuXHJcbiAgICB0aGlzLl9mZXRjaE1hbmFnZXIgPSBuZXcgV29ya2VyUHJveHlGZXRjaE1hbmFnZXIodGhpcy5fb3B0aW9uc1dlYldvcmtlcnMpO1xyXG4gICAgXHJcbiAgICB2YXIgZGVjb2RlU2NoZWR1bGVyID0gaW1hZ2VIZWxwZXJGdW5jdGlvbnMuY3JlYXRlU2NoZWR1bGVyKFxyXG4gICAgICAgIHRoaXMuX3Nob3dMb2csXHJcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5kZWNvZGVQcmlvcml0aXplcixcclxuICAgICAgICAnZGVjb2RlJyxcclxuICAgICAgICB0aGlzLl9jcmVhdGVEZWNvZGVyLmJpbmQodGhpcyksXHJcbiAgICAgICAgZGVjb2RlV29ya2Vyc0xpbWl0KTtcclxuICAgIFxyXG4gICAgdGhpcy5fZGVjb2RlUHJpb3JpdGl6ZXIgPSBkZWNvZGVTY2hlZHVsZXIucHJpb3JpdGl6ZXI7XHJcblxyXG4gICAgdGhpcy5fcmVxdWVzdHNEZWNvZGVKb2JzUG9vbCA9IG5ldyBEZWNvZGVKb2JzUG9vbChcclxuICAgICAgICB0aGlzLl9mZXRjaE1hbmFnZXIsXHJcbiAgICAgICAgZGVjb2RlU2NoZWR1bGVyLnNjaGVkdWxlcixcclxuICAgICAgICB0aGlzLl90aWxlV2lkdGgsXHJcbiAgICAgICAgdGhpcy5fdGlsZUhlaWdodCxcclxuICAgICAgICAvKm9ubHlXYWl0Rm9yRGF0YUFuZERlY29kZT0qL2ZhbHNlKTtcclxuICAgICAgICBcclxuICAgIHRoaXMuX2NoYW5uZWxzRGVjb2RlSm9ic1Bvb2wgPSBuZXcgRGVjb2RlSm9ic1Bvb2woXHJcbiAgICAgICAgdGhpcy5fZmV0Y2hNYW5hZ2VyLFxyXG4gICAgICAgIGRlY29kZVNjaGVkdWxlci5zY2hlZHVsZXIsXHJcbiAgICAgICAgdGhpcy5fdGlsZVdpZHRoLFxyXG4gICAgICAgIHRoaXMuX3RpbGVIZWlnaHQsXHJcbiAgICAgICAgLypvbmx5V2FpdEZvckRhdGFBbmREZWNvZGU9Ki90cnVlKTtcclxufVxyXG5cclxuSW1hZ2VEZWNvZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSW1hZ2VQYXJhbXNSZXRyaWV2ZXJQcm94eS5wcm90b3R5cGUpO1xyXG5cclxuSW1hZ2VEZWNvZGVyLnByb3RvdHlwZS5nZXRUaWxlV2lkdGggPSBmdW5jdGlvbiBnZXRUaWxlV2lkdGgoKSB7XHJcbiAgICB0aGlzLl92YWxpZGF0ZVNpemVzQ2FsY3VsYXRvcigpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3RpbGVXaWR0aDtcclxufTtcclxuXHJcbkltYWdlRGVjb2Rlci5wcm90b3R5cGUuZ2V0VGlsZUhlaWdodCA9IGZ1bmN0aW9uIGdldFRpbGVIZWlnaHQoKSB7XHJcbiAgICB0aGlzLl92YWxpZGF0ZVNpemVzQ2FsY3VsYXRvcigpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3RpbGVIZWlnaHQ7XHJcbn07XHJcbiAgICBcclxuSW1hZ2VEZWNvZGVyLnByb3RvdHlwZS5zZXRTZXJ2ZXJSZXF1ZXN0UHJpb3JpdGl6ZXJEYXRhID1cclxuICAgIGZ1bmN0aW9uIHNldFNlcnZlclJlcXVlc3RQcmlvcml0aXplckRhdGEocHJpb3JpdGl6ZXJEYXRhKSB7XHJcbiAgICBcclxuICAgIHRoaXMuX2ZldGNoTWFuYWdlci5zZXRTZXJ2ZXJSZXF1ZXN0UHJpb3JpdGl6ZXJEYXRhKFxyXG4gICAgICAgIHByaW9yaXRpemVyRGF0YSk7XHJcbn07XHJcblxyXG5JbWFnZURlY29kZXIucHJvdG90eXBlLnNldERlY29kZVByaW9yaXRpemVyRGF0YSA9XHJcbiAgICBmdW5jdGlvbiBzZXREZWNvZGVQcmlvcml0aXplckRhdGEocHJpb3JpdGl6ZXJEYXRhKSB7XHJcbiAgICBcclxuICAgIGlmICh0aGlzLl9kZWNvZGVQcmlvcml0aXplciA9PT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93ICdObyBkZWNvZGUgcHJpb3JpdGl6ZXIgaGFzIGJlZW4gc2V0JztcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHRoaXMuX3Nob3dMb2cpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnc2V0RGVjb2RlUHJpb3JpdGl6ZXJEYXRhKCcgKyBwcmlvcml0aXplckRhdGEgKyAnKScpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2YXIgcHJpb3JpdGl6ZXJEYXRhTW9kaWZpZWQgPSBPYmplY3QuY3JlYXRlKHByaW9yaXRpemVyRGF0YSk7XHJcbiAgICBwcmlvcml0aXplckRhdGFNb2RpZmllZC5pbWFnZSA9IHRoaXM7XHJcbiAgICBcclxuICAgIHRoaXMuX2RlY29kZVByaW9yaXRpemVyLnNldFByaW9yaXRpemVyRGF0YShwcmlvcml0aXplckRhdGFNb2RpZmllZCk7XHJcbn07XHJcblxyXG5JbWFnZURlY29kZXIucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiBvcGVuKHVybCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZldGNoTWFuYWdlci5vcGVuKHVybCkudGhlbihmdW5jdGlvbiAoc2l6ZXNQYXJhbXMpIHtcclxuICAgICAgICBzZWxmLl9pbnRlcm5hbFNpemVzUGFyYW1zID0gc2l6ZXNQYXJhbXM7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2l6ZXNQYXJhbXM6IHNpemVzUGFyYW1zLFxyXG4gICAgICAgICAgICBhcHBsaWNhdGl2ZVRpbGVXaWR0aCA6IHNlbGYuZ2V0VGlsZVdpZHRoKCksXHJcbiAgICAgICAgICAgIGFwcGxpY2F0aXZlVGlsZUhlaWdodDogc2VsZi5nZXRUaWxlSGVpZ2h0KClcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5JbWFnZURlY29kZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gY2xvc2UoKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2RlY29kZXJzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgdGhpcy5fZGVjb2RlcnNbaV0udGVybWluYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2ZldGNoTWFuYWdlci5jbG9zZSgpO1xyXG59O1xyXG5cclxuSW1hZ2VEZWNvZGVyLnByb3RvdHlwZS5jcmVhdGVDaGFubmVsID0gZnVuY3Rpb24gY3JlYXRlQ2hhbm5lbChcclxuICAgIGNyZWF0ZWRDYWxsYmFjaykge1xyXG4gICAgXHJcbiAgICB0aGlzLl92YWxpZGF0ZVNpemVzQ2FsY3VsYXRvcigpO1xyXG4gICAgXHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGNoYW5uZWxDcmVhdGVkKGNoYW5uZWxIYW5kbGUpIHtcclxuICAgICAgICBzZWxmLl9jaGFubmVsU3RhdGVzW2NoYW5uZWxIYW5kbGVdID0ge1xyXG4gICAgICAgICAgICBkZWNvZGVKb2JzTGlzdGVuZXJIYW5kbGU6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNyZWF0ZWRDYWxsYmFjayhjaGFubmVsSGFuZGxlKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5fZmV0Y2hNYW5hZ2VyLmNyZWF0ZUNoYW5uZWwoXHJcbiAgICAgICAgY2hhbm5lbENyZWF0ZWQpO1xyXG59O1xyXG5cclxuSW1hZ2VEZWNvZGVyLnByb3RvdHlwZS5yZXF1ZXN0UGl4ZWxzID0gZnVuY3Rpb24gcmVxdWVzdFBpeGVscyhpbWFnZVBhcnRQYXJhbXMpIHtcclxuICAgIHRoaXMuX3ZhbGlkYXRlU2l6ZXNDYWxjdWxhdG9yKCk7XHJcbiAgICBcclxuICAgIHZhciBsZXZlbCA9IGltYWdlUGFydFBhcmFtcy5sZXZlbDtcclxuICAgIHZhciBsZXZlbFdpZHRoID0gdGhpcy5fc2l6ZXNDYWxjdWxhdG9yLmdldExldmVsV2lkdGgobGV2ZWwpO1xyXG4gICAgdmFyIGxldmVsSGVpZ2h0ID0gdGhpcy5fc2l6ZXNDYWxjdWxhdG9yLmdldExldmVsSGVpZ2h0KGxldmVsKTtcclxuICAgIFxyXG4gICAgdmFyIHJlc29sdmUsIHJlamVjdDtcclxuICAgIHZhciBhY2N1bXVsYXRlZFJlc3VsdCA9IHt9O1xyXG4gICAgXHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHN0YXJ0UHJvbWlzZSk7XHJcbiAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIFxyXG4gICAgZnVuY3Rpb24gc3RhcnRQcm9taXNlKHJlc29sdmVfLCByZWplY3RfKSB7XHJcbiAgICAgICAgcmVzb2x2ZSA9IHJlc29sdmVfO1xyXG4gICAgICAgIHJlamVjdCA9IHJlamVjdF87XHJcbiAgICAgICAgXHJcbiAgICAgICAgc2VsZi5fcmVxdWVzdHNEZWNvZGVKb2JzUG9vbC5mb3JrRGVjb2RlSm9icyhcclxuICAgICAgICAgICAgaW1hZ2VQYXJ0UGFyYW1zLFxyXG4gICAgICAgICAgICBpbnRlcm5hbENhbGxiYWNrLFxyXG4gICAgICAgICAgICBpbnRlcm5hbFRlcm1pbmF0ZWRDYWxsYmFjayxcclxuICAgICAgICAgICAgbGV2ZWxXaWR0aCxcclxuICAgICAgICAgICAgbGV2ZWxIZWlnaHQsXHJcbiAgICAgICAgICAgIC8qaXNQcm9ncmVzc2l2ZT0qL2ZhbHNlKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gaW50ZXJuYWxDYWxsYmFjayhkZWNvZGVkRGF0YSkge1xyXG4gICAgICAgIGNvcHlQaXhlbHNUb0FjY3VtdWxhdGVkUmVzdWx0KGRlY29kZWREYXRhLCBhY2N1bXVsYXRlZFJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGludGVybmFsVGVybWluYXRlZENhbGxiYWNrKGlzQWJvcnRlZCkge1xyXG4gICAgICAgIGlmIChpc0Fib3J0ZWQpIHtcclxuICAgICAgICAgICAgcmVqZWN0KCdSZXF1ZXN0IHdhcyBhYm9ydGVkIGR1ZSB0byBmYWlsdXJlIG9yIHByaW9yaXR5Jyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzb2x2ZShhY2N1bXVsYXRlZFJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuSW1hZ2VEZWNvZGVyLnByb3RvdHlwZS5yZXF1ZXN0UGl4ZWxzUHJvZ3Jlc3NpdmUgPSBmdW5jdGlvbiByZXF1ZXN0UGl4ZWxzUHJvZ3Jlc3NpdmUoXHJcbiAgICBpbWFnZVBhcnRQYXJhbXMsXHJcbiAgICBjYWxsYmFjayxcclxuICAgIHRlcm1pbmF0ZWRDYWxsYmFjayxcclxuICAgIGltYWdlUGFydFBhcmFtc05vdE5lZWRlZCxcclxuICAgIGNoYW5uZWxIYW5kbGUpIHtcclxuICAgIFxyXG4gICAgdGhpcy5fdmFsaWRhdGVTaXplc0NhbGN1bGF0b3IoKTtcclxuICAgIFxyXG4gICAgdmFyIGxldmVsID0gaW1hZ2VQYXJ0UGFyYW1zLmxldmVsO1xyXG4gICAgdmFyIGxldmVsV2lkdGggPSB0aGlzLl9zaXplc0NhbGN1bGF0b3IuZ2V0TGV2ZWxXaWR0aChsZXZlbCk7XHJcbiAgICB2YXIgbGV2ZWxIZWlnaHQgPSB0aGlzLl9zaXplc0NhbGN1bGF0b3IuZ2V0TGV2ZWxIZWlnaHQobGV2ZWwpO1xyXG4gICAgXHJcbiAgICB2YXIgY2hhbm5lbFN0YXRlID0gbnVsbDtcclxuICAgIHZhciBkZWNvZGVKb2JzUG9vbDtcclxuICAgIGlmIChjaGFubmVsSGFuZGxlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBkZWNvZGVKb2JzUG9vbCA9IHRoaXMuX3JlcXVlc3RzRGVjb2RlSm9ic1Bvb2w7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRlY29kZUpvYnNQb29sID0gdGhpcy5fY2hhbm5lbHNEZWNvZGVKb2JzUG9vbDtcclxuICAgICAgICBcclxuICAgICAgICBjaGFubmVsU3RhdGUgPSB0aGlzLl9jaGFubmVsU3RhdGVzW2NoYW5uZWxIYW5kbGVdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChjaGFubmVsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyAnQ2hhbm5lbCBoYW5kbGUgZG9lcyBub3QgZXhpc3QnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgdmFyIGxpc3RlbmVySGFuZGxlID0gZGVjb2RlSm9ic1Bvb2wuZm9ya0RlY29kZUpvYnMoXHJcbiAgICAgICAgaW1hZ2VQYXJ0UGFyYW1zLFxyXG4gICAgICAgIGNhbGxiYWNrLFxyXG4gICAgICAgIHRlcm1pbmF0ZWRDYWxsYmFjayxcclxuICAgICAgICBsZXZlbFdpZHRoLFxyXG4gICAgICAgIGxldmVsSGVpZ2h0LFxyXG4gICAgICAgIC8qaXNQcm9ncmVzc2l2ZT0qL3RydWUsXHJcbiAgICAgICAgaW1hZ2VQYXJ0UGFyYW1zTm90TmVlZGVkKTtcclxuICAgICAgICBcclxuICAgIGlmIChjaGFubmVsSGFuZGxlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAoY2hhbm5lbFN0YXRlLmRlY29kZUpvYnNMaXN0ZW5lckhhbmRsZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBVbnJlZ2lzdGVyIGFmdGVyIGZvcmtlZCBuZXcgam9icywgc28gbm8gdGVybWluYXRpb24gb2NjdXJzIG1lYW53aGlsZVxyXG4gICAgICAgICAgICBkZWNvZGVKb2JzUG9vbC51bnJlZ2lzdGVyRm9ya2VkSm9icyhcclxuICAgICAgICAgICAgICAgIGNoYW5uZWxTdGF0ZS5kZWNvZGVKb2JzTGlzdGVuZXJIYW5kbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGFubmVsU3RhdGUuZGVjb2RlSm9ic0xpc3RlbmVySGFuZGxlID0gbGlzdGVuZXJIYW5kbGU7XHJcbiAgICAgICAgdGhpcy5fZmV0Y2hNYW5hZ2VyLm1vdmVDaGFubmVsKGNoYW5uZWxIYW5kbGUsIGltYWdlUGFydFBhcmFtcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5JbWFnZURlY29kZXIucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uIHJlY29ubmVjdCgpIHtcclxuICAgIHRoaXMuX2ZldGNoTWFuYWdlci5yZWNvbm5lY3QoKTtcclxufTtcclxuXHJcbkltYWdlRGVjb2Rlci5wcm90b3R5cGUuYWxpZ25QYXJhbXNUb1RpbGVzQW5kTGV2ZWwgPSBmdW5jdGlvbiBhbGlnblBhcmFtc1RvVGlsZXNBbmRMZXZlbChyZWdpb24pIHtcclxuXHRyZXR1cm4gaW1hZ2VIZWxwZXJGdW5jdGlvbnMuYWxpZ25QYXJhbXNUb1RpbGVzQW5kTGV2ZWwocmVnaW9uLCB0aGlzKTtcclxufTtcclxuXHJcbkltYWdlRGVjb2Rlci5wcm90b3R5cGUuX2dldFNpemVzUGFyYW1zSW50ZXJuYWwgPSBmdW5jdGlvbiBnZXRTaXplc1BhcmFtc0ludGVybmFsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ludGVybmFsU2l6ZXNQYXJhbXM7XHJcbn07XHJcblxyXG5JbWFnZURlY29kZXIucHJvdG90eXBlLl9jcmVhdGVEZWNvZGVyID0gZnVuY3Rpb24gY3JlYXRlRGVjb2RlcigpIHtcclxuICAgIHZhciBkZWNvZGVyID0gbmV3IFdvcmtlclByb3h5UGl4ZWxzRGVjb2Rlcih0aGlzLl9vcHRpb25zV2ViV29ya2Vycyk7XHJcbiAgICB0aGlzLl9kZWNvZGVycy5wdXNoKGRlY29kZXIpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gZGVjb2RlcjtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNvcHlQaXhlbHNUb0FjY3VtdWxhdGVkUmVzdWx0KGRlY29kZWREYXRhLCBhY2N1bXVsYXRlZFJlc3VsdCkge1xyXG4gICAgdmFyIGJ5dGVzUGVyUGl4ZWwgPSA0O1xyXG4gICAgdmFyIHNvdXJjZVN0cmlkZSA9IGRlY29kZWREYXRhLndpZHRoICogYnl0ZXNQZXJQaXhlbDtcclxuICAgIHZhciB0YXJnZXRTdHJpZGUgPVxyXG4gICAgICAgIGRlY29kZWREYXRhLm9yaWdpbmFsUmVxdWVzdFdpZHRoICogYnl0ZXNQZXJQaXhlbDtcclxuICAgIFxyXG4gICAgaWYgKGFjY3VtdWxhdGVkUmVzdWx0LnBpeGVscyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdmFyIHNpemUgPVxyXG4gICAgICAgICAgICB0YXJnZXRTdHJpZGUgKiBkZWNvZGVkRGF0YS5vcmlnaW5hbFJlcXVlc3RIZWlnaHQ7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIGFjY3VtdWxhdGVkUmVzdWx0LnBpeGVscyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xyXG4gICAgICAgIGFjY3VtdWxhdGVkUmVzdWx0LnhJbk9yaWdpbmFsUmVxdWVzdCA9IDA7XHJcbiAgICAgICAgYWNjdW11bGF0ZWRSZXN1bHQueUluT3JpZ2luYWxSZXF1ZXN0ID0gMDtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgd2lkdGggPSBkZWNvZGVkRGF0YS5vcmlnaW5hbFJlcXVlc3RXaWR0aDtcclxuICAgICAgICBhY2N1bXVsYXRlZFJlc3VsdC5vcmlnaW5hbFJlcXVlc3RXaWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIGFjY3VtdWxhdGVkUmVzdWx0LndpZHRoID0gd2lkdGg7XHJcblxyXG4gICAgICAgIHZhciBoZWlnaHQgPSBkZWNvZGVkRGF0YS5vcmlnaW5hbFJlcXVlc3RIZWlnaHQ7XHJcbiAgICAgICAgYWNjdW11bGF0ZWRSZXN1bHQub3JpZ2luYWxSZXF1ZXN0SGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIGFjY3VtdWxhdGVkUmVzdWx0LmhlaWdodCA9IGhlaWdodDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgYWNjdW11bGF0ZWRSZXN1bHQuYWxsUmVsZXZhbnRCeXRlc0xvYWRlZCA9XHJcbiAgICAgICAgZGVjb2RlZERhdGEuYWxsUmVsZXZhbnRCeXRlc0xvYWRlZDtcclxuXHJcbiAgICB2YXIgc291cmNlT2Zmc2V0ID0gMDtcclxuICAgIHZhciB0YXJnZXRPZmZzZXQgPVxyXG4gICAgICAgIGRlY29kZWREYXRhLnhJbk9yaWdpbmFsUmVxdWVzdCAqIGJ5dGVzUGVyUGl4ZWwgKyBcclxuICAgICAgICBkZWNvZGVkRGF0YS55SW5PcmlnaW5hbFJlcXVlc3QgKiB0YXJnZXRTdHJpZGU7XHJcbiAgICBcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVjb2RlZERhdGEuaGVpZ2h0OyArK2kpIHtcclxuICAgICAgICB2YXIgc291cmNlU3ViQXJyYXkgPSBkZWNvZGVkRGF0YS5waXhlbHMuc3ViYXJyYXkoXHJcbiAgICAgICAgICAgIHNvdXJjZU9mZnNldCwgc291cmNlT2Zmc2V0ICsgc291cmNlU3RyaWRlKTtcclxuICAgICAgICBcclxuICAgICAgICBhY2N1bXVsYXRlZFJlc3VsdC5waXhlbHMuc2V0KHNvdXJjZVN1YkFycmF5LCB0YXJnZXRPZmZzZXQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHNvdXJjZU9mZnNldCArPSBzb3VyY2VTdHJpZGU7XHJcbiAgICAgICAgdGFyZ2V0T2Zmc2V0ICs9IHRhcmdldFN0cmlkZTtcclxuICAgIH1cclxufSIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGVjb2RlSm9iO1xyXG5cclxudmFyIExpbmtlZExpc3QgPSByZXF1aXJlKCdsaW5rZWRsaXN0LmpzJyk7XHJcblxyXG52YXIgcmVxdWVzdElkQ291bnRlciA9IDA7XHJcblxyXG5mdW5jdGlvbiBEZWNvZGVKb2IoXHJcbiAgICBpbWFnZVBhcnRQYXJhbXMsXHJcbiAgICBmZXRjaE1hbmFnZXIsXHJcbiAgICBkZWNvZGVTY2hlZHVsZXIsXHJcbiAgICBvbmx5V2FpdEZvckRhdGFBbmREZWNvZGUpIHtcclxuICAgIFxyXG4gICAgdGhpcy5faXNBYm9ydGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9pc1Rlcm1pbmF0ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX2lzRmV0Y2hSZXF1ZXN0VGVybWluYXRlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5faXNGaXJzdFN0YWdlID0gdHJ1ZTtcclxuICAgIHRoaXMuX2lzTWFudWFsbHlBYm9ydGVkID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5fZmlyc3REZWNvZGVJbnB1dCA9IG51bGw7XHJcbiAgICB0aGlzLl9wZW5kaW5nRGVjb2RlSW5wdXQgPSBudWxsO1xyXG4gICAgdGhpcy5fYWN0aXZlU3ViSm9icyA9IDE7XHJcbiAgICB0aGlzLl9pbWFnZVBhcnRQYXJhbXMgPSBpbWFnZVBhcnRQYXJhbXM7XHJcbiAgICB0aGlzLl9kZWNvZGVTY2hlZHVsZXIgPSBkZWNvZGVTY2hlZHVsZXI7XHJcbiAgICB0aGlzLl9qb2JTZXF1ZW5jZUlkID0gMDtcclxuICAgIHRoaXMuX2xhc3RGaW5pc2hlZEpvYlNlcXVlbmNlSWQgPSAtMTtcclxuICAgIHRoaXMuX3Byb2dyZXNzaXZlU3RhZ2VzRG9uZSA9IDA7XHJcbiAgICB0aGlzLl9saXN0ZW5lcnNMaW5rZWRMaXN0ID0gbmV3IExpbmtlZExpc3QoKTtcclxuICAgIHRoaXMuX3Byb2dyZXNzaXZlTGlzdGVuZXJzQ291bnQgPSAwO1xyXG4gICAgdGhpcy5fcmVxdWVzdElkID0gKytyZXF1ZXN0SWRDb3VudGVyO1xyXG4gICAgdGhpcy5fYWxsUmVsZXZhbnRCeXRlc0xvYWRlZCA9IDA7XHJcbiAgICB0aGlzLl9mZXRjaE1hbmFnZXIgPSBmZXRjaE1hbmFnZXI7XHJcbiAgICB0aGlzLl9zdGFydERlY29kZUJvdW5kID0gdGhpcy5fc3RhcnREZWNvZGUuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuX2RlY29kZUFib3J0ZWRCb3VuZCA9IHRoaXMuX2RlY29kZUFib3J0ZWQuYmluZCh0aGlzKTtcclxuICAgIFxyXG4gICAgZmV0Y2hNYW5hZ2VyLmNyZWF0ZVJlcXVlc3QoXHJcbiAgICAgICAgaW1hZ2VQYXJ0UGFyYW1zLFxyXG4gICAgICAgIHRoaXMsXHJcbiAgICAgICAgdGhpcy5fZGF0YVJlYWR5Rm9yRGVjb2RlLFxyXG4gICAgICAgIHRoaXMuX2ZldGNoVGVybWluYXRlZCxcclxuICAgICAgICBvbmx5V2FpdEZvckRhdGFBbmREZWNvZGUsXHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdElkKTtcclxufVxyXG5cclxuRGVjb2RlSm9iLnByb3RvdHlwZS5yZWdpc3Rlckxpc3RlbmVyID0gZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcihsaXN0ZW5lckhhbmRsZSkge1xyXG4gICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5fbGlzdGVuZXJzTGlua2VkTGlzdC5hZGQobGlzdGVuZXJIYW5kbGUpO1xyXG4gICAgXHJcbiAgICBpZiAobGlzdGVuZXJIYW5kbGUuaXNQcm9ncmVzc2l2ZSkge1xyXG4gICAgICAgICsrdGhpcy5fcHJvZ3Jlc3NpdmVMaXN0ZW5lcnNDb3VudDtcclxuICAgICAgICBcclxuICAgICAgICBpZiAodGhpcy5fcHJvZ3Jlc3NpdmVMaXN0ZW5lcnNDb3VudCA9PT0gMSkge1xyXG4gICAgICAgICAgICB0aGlzLl9mZXRjaE1hbmFnZXIuc2V0SXNQcm9ncmVzc2l2ZVJlcXVlc3QoXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SWQsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgdmFyIHVucmVnaXN0ZXJIYW5kbGUgPSBpdGVyYXRvcjtcclxuICAgIHJldHVybiB1bnJlZ2lzdGVySGFuZGxlO1xyXG59O1xyXG5cclxuRGVjb2RlSm9iLnByb3RvdHlwZS51bnJlZ2lzdGVyTGlzdGVuZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTGlzdGVuZXIodW5yZWdpc3RlckhhbmRsZSkge1xyXG4gICAgdmFyIGl0ZXJhdG9yID0gdW5yZWdpc3RlckhhbmRsZTtcclxuICAgIHZhciBsaXN0ZW5lckhhbmRsZSA9IHRoaXMuX2xpc3RlbmVyc0xpbmtlZExpc3QuZ2V0VmFsdWUoaXRlcmF0b3IpO1xyXG5cclxuICAgIHRoaXMuX2xpc3RlbmVyc0xpbmtlZExpc3QucmVtb3ZlKHVucmVnaXN0ZXJIYW5kbGUpO1xyXG4gICAgXHJcbiAgICBpZiAobGlzdGVuZXJIYW5kbGUuaXNQcm9ncmVzc2l2ZSkge1xyXG4gICAgICAgIC0tdGhpcy5fcHJvZ3Jlc3NpdmVMaXN0ZW5lcnNDb3VudDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHRoaXMuX2xpc3RlbmVyc0xpbmtlZExpc3QuZ2V0Q291bnQoKSA9PT0gMCkge1xyXG4gICAgICAgIHRoaXMuX2ZldGNoTWFuYWdlci5tYW51YWxBYm9ydFJlcXVlc3QoXHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RJZCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5faXNBYm9ydGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9pc1Rlcm1pbmF0ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2lzRmV0Y2hSZXF1ZXN0VGVybWluYXRlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5faXNNYW51YWxseUFib3J0ZWQgPSB0cnVlO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9wcm9ncmVzc2l2ZUxpc3RlbmVyc0NvdW50ID09PSAwKSB7XHJcbiAgICAgICAgdGhpcy5fZmV0Y2hNYW5hZ2VyLnNldElzUHJvZ3Jlc3NpdmVSZXF1ZXN0KFxyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SWQsIGZhbHNlKTtcclxuICAgIH1cclxufTtcclxuXHJcbkRlY29kZUpvYi5wcm90b3R5cGUuZ2V0SXNUZXJtaW5hdGVkID0gZnVuY3Rpb24gZ2V0SXNUZXJtaW5hdGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2lzVGVybWluYXRlZDtcclxufTtcclxuXHJcbkRlY29kZUpvYi5wcm90b3R5cGUuX2RhdGFSZWFkeUZvckRlY29kZSA9IGZ1bmN0aW9uIGRhdGFSZWFkeUZvckRlY29kZShkYXRhRm9yRGVjb2RlKSB7XHJcbiAgICBpZiAodGhpcy5faXNBYm9ydGVkTm9UZXJtaW5hdGlvbigpIHx8XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzTGlua2VkTGlzdC5nZXRDb3VudCgpID09PSAwKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTk9URTogU2hvdWxkIGZpbmQgYmV0dGVyIHdheSB0byBjbGVhbiBqb2IgaWYgbGlzdGVuZXJzIGxpc3RcclxuICAgICAgICAvLyBpcyBlbXB0eVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIFxyXG5cdC8vIEltcGxlbWVudGF0aW9uIGlkZWE6XHJcblx0Ly8gMS4gV2UgaGF2ZSBhdCBtb3N0IG9uZSBhY3RpdmUgZGVjb2RlIHBlciBEZWNvZGVKb2IuIFRodXMgaWYgYWxyZWFkeVxyXG5cdC8vICAgIGFjdGl2ZSBkZWNvZGUgaXMgZG9uZSwgd2UgcHV0IHRoZSBuZXcgZGF0YSBpbiBhIFwicGVuZGluZ0RlY29kZUlucHV0XCJcclxuXHQvLyAgICB2YXJpYWJsZSB3aGljaCB3aWxsIGJlIGRlY29kZWQgd2hlbiBjdXJyZW50IGRlY29kZSBpcyBkb25lLlxyXG5cdC8vIDIuIFdoZW4gd2UgaGF2ZSBtb3JlIHRoYW4gYSBzaW5nbGUgZGVjb2RlIHdlIG5lZWQgdG8gZGVjb2RlIG9ubHkgbGFzdFxyXG5cdC8vICAgIGZldGNoZWQgZGF0YSAoYmVjYXVzZSBpdCBpcyBvZiBoaWdoZXN0IHF1YWxpdHkpLiBUaHVzIG9sZGVyIHBlbmRpbmdcclxuXHQvLyAgICBkYXRhIGlzIG92ZXJyaWRlbiBieSBsYXN0IG9uZS5cclxuXHQvLyAzLiBUaGUgb25seSBjYXNlIHRoYXQgb2xkZXIgZGF0YSBzaG91bGQgYmUgZGVjb2RlZCBpcyB0aGUgbG93ZXN0IHF1YWxpdHlcclxuXHQvLyAgICAod2hpY2ggaXMgdGhlIGZpcnN0IGZldGNoZWQgZGF0YSBhcnJpdmVkKS4gVGhpcyBpcyBiZWNhdXNlIHdlIHdhbnQgdG9cclxuXHQvLyAgICBzaG93IGEgcHJpbWFyeSBpbWFnZSBBU0FQLCBhbmQgdGhlIHRoZSBsb3dlc3QgcXVhbGl0eSBpcyBlYXNpZXIgdG9cclxuXHQvLyAgICB0aGFuIG90aGVycyBkZWNvZGUuXHJcblx0Ly8gVGhlIGlkZWEgZGVzY3JpYmVkIGJlbG93IGlzIGNvcnJlY3QgZm9yIEpQSVAsIGFuZCBJIGd1ZXNzIGZvciBvdGhlclxyXG5cdC8vIGhlYXZ5LWRlY29kZWQgaW1hZ2UgdHlwZXMuIE9uZSBtYXkgYWRkIG9wdGlvbnMgdG8gdGhlIEltYWdlRGVjb2RlclxyXG5cdC8vIGxpYnJhcnkgaW4gb3JkZXIgdG8gY29uZmlndXJlIGFub3RoZXIgYmVoYXZpb3IsIGFuZCBjaGFuZ2UgdGhlXHJcblx0Ly8gaW1wbGVtZW50YXRpb24gaW4gdGhlIERlY29kZUpvYiBjbGFzcyBhY2NvcmRpbmdseS5cclxuXHRcclxuICAgIGlmICh0aGlzLl9pc0ZpcnN0U3RhZ2UpIHtcclxuICAgICAgICB0aGlzLl9maXJzdERlY29kZUlucHV0ID0ge1xyXG4gICAgICAgICAgICBkYXRhRm9yRGVjb2RlOiBkYXRhRm9yRGVjb2RlXHJcbiAgICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ0RlY29kZUlucHV0ID0ge1xyXG4gICAgICAgICAgICBkYXRhRm9yRGVjb2RlOiBkYXRhRm9yRGVjb2RlXHJcbiAgICAgICAgfTtcclxuICAgIFxyXG4gICAgICAgIGlmICh0aGlzLl9pc0FscmVhZHlTY2hlZHVsZWROb25GaXJzdEpvYikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX2lzQWxyZWFkeVNjaGVkdWxlZE5vbkZpcnN0Sm9iID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHRoaXMuX2lzVGVybWluYXRlZCkge1xyXG4gICAgICAgIHRocm93ICdKb2IgaGFzIGFscmVhZHkgYmVlbiB0ZXJtaW5hdGVkJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5faXNGaXJzdFN0YWdlID0gZmFsc2U7XHJcbiAgICArK3RoaXMuX2FjdGl2ZVN1YkpvYnM7XHJcbiAgICBcclxuICAgIHZhciBqb2JDb250ZXh0ID0ge1xyXG4gICAgICAgIHNlbGY6IHRoaXMsXHJcbiAgICAgICAgaW1hZ2VQYXJ0UGFyYW1zOiB0aGlzLl9pbWFnZVBhcnRQYXJhbXMsXHJcbiAgICAgICAgcHJvZ3Jlc3NpdmVTdGFnZXNEb25lOiB0aGlzLl9wcm9ncmVzc2l2ZVN0YWdlc0RvbmVcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuX2RlY29kZVNjaGVkdWxlci5lbnF1ZXVlSm9iKFxyXG4gICAgICAgIHRoaXMuX3N0YXJ0RGVjb2RlQm91bmQsIGpvYkNvbnRleHQsIHRoaXMuX2RlY29kZUFib3J0ZWRCb3VuZCk7XHJcbn07XHJcblxyXG5EZWNvZGVKb2IucHJvdG90eXBlLl9zdGFydERlY29kZSA9IGZ1bmN0aW9uIHN0YXJ0RGVjb2RlKGRlY29kZXIsIGpvYkNvbnRleHQpIHtcclxuICAgIHZhciBkZWNvZGVJbnB1dDtcclxuICAgIGlmICh0aGlzLl9maXJzdERlY29kZUlucHV0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgZGVjb2RlSW5wdXQgPSB0aGlzLl9maXJzdERlY29kZUlucHV0O1xyXG4gICAgICAgIHRoaXMuX2ZpcnN0RGVjb2RlSW5wdXQgPSBudWxsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBkZWNvZGVJbnB1dCA9IHRoaXMuX3BlbmRpbmdEZWNvZGVJbnB1dDtcclxuICAgICAgICB0aGlzLl9wZW5kaW5nRGVjb2RlSW5wdXQgPSBudWxsO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX2lzQWxyZWFkeVNjaGVkdWxlZE5vbkZpcnN0Sm9iID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGpvYkNvbnRleHQuYWxsUmVsZXZhbnRCeXRlc0xvYWRlZCA9IGRlY29kZUlucHV0LmRhdGFGb3JEZWNvZGUuYWxsUmVsZXZhbnRCeXRlc0xvYWRlZDtcclxuICAgIFxyXG4gICAgaWYgKHRoaXMuX2lzQWJvcnRlZE5vVGVybWluYXRpb24oKSkge1xyXG4gICAgICAgIC0tdGhpcy5fYWN0aXZlU3ViSm9icztcclxuICAgICAgICB0aGlzLl9kZWNvZGVTY2hlZHVsZXIuam9iRG9uZShkZWNvZGVyLCBqb2JDb250ZXh0KTtcclxuICAgICAgICB0aGlzLl9jaGVja0lmQWxsVGVybWluYXRlZCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmFyIGpvYlNlcXVlbmNlSWQgPSArK3RoaXMuX2pvYlNlcXVlbmNlSWQ7XHJcbiAgICBcclxuICAgIHZhciBwYXJhbXMgPSB0aGlzLl9pbWFnZVBhcnRQYXJhbXM7XHJcbiAgICB2YXIgd2lkdGggPSBwYXJhbXMubWF4WEV4Y2x1c2l2ZSAtIHBhcmFtcy5taW5YO1xyXG4gICAgdmFyIGhlaWdodCA9IHBhcmFtcy5tYXhZRXhjbHVzaXZlIC0gcGFyYW1zLm1pblk7XHJcblxyXG4gICAgZGVjb2Rlci5kZWNvZGUoZGVjb2RlSW5wdXQuZGF0YUZvckRlY29kZSkudGhlbihwaXhlbHNEZWNvZGVkQ2FsbGJhY2tJbkNsb3N1cmUpO1xyXG4gICAgICAgIFxyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBwaXhlbHNEZWNvZGVkQ2FsbGJhY2tJbkNsb3N1cmUoZGVjb2RlUmVzdWx0KSB7XHJcbiAgICAgICAgc2VsZi5fcGl4ZWxzRGVjb2RlZENhbGxiYWNrKFxyXG4gICAgICAgICAgICBkZWNvZGVyLFxyXG4gICAgICAgICAgICBkZWNvZGVSZXN1bHQsXHJcbiAgICAgICAgICAgIGpvYlNlcXVlbmNlSWQsXHJcbiAgICAgICAgICAgIGpvYkNvbnRleHQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHNlbGYgPSBudWxsO1xyXG4gICAgfVxyXG59O1xyXG5cclxuRGVjb2RlSm9iLnByb3RvdHlwZS5fcGl4ZWxzRGVjb2RlZENhbGxiYWNrID0gZnVuY3Rpb24gcGl4ZWxzRGVjb2RlZENhbGxiYWNrKFxyXG4gICAgZGVjb2RlciwgZGVjb2RlUmVzdWx0LCBqb2JTZXF1ZW5jZUlkLCBqb2JDb250ZXh0KSB7XHJcbiAgICBcclxuICAgIHRoaXMuX2RlY29kZVNjaGVkdWxlci5qb2JEb25lKGRlY29kZXIsIGpvYkNvbnRleHQpO1xyXG4gICAgLS10aGlzLl9hY3RpdmVTdWJKb2JzO1xyXG4gICAgXHJcbiAgICB2YXIgcmVsZXZhbnRCeXRlc0xvYWRlZERpZmYgPVxyXG4gICAgICAgIGpvYkNvbnRleHQuYWxsUmVsZXZhbnRCeXRlc0xvYWRlZCAtIHRoaXMuX2FsbFJlbGV2YW50Qnl0ZXNMb2FkZWQ7XHJcbiAgICB0aGlzLl9hbGxSZWxldmFudEJ5dGVzTG9hZGVkID0gam9iQ29udGV4dC5hbGxSZWxldmFudEJ5dGVzTG9hZGVkO1xyXG4gICAgXHJcbiAgICBpZiAodGhpcy5faXNBYm9ydGVkTm9UZXJtaW5hdGlvbigpKSB7XHJcbiAgICAgICAgdGhpcy5fY2hlY2tJZkFsbFRlcm1pbmF0ZWQoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciBsYXN0RmluaXNoZWQgPSB0aGlzLl9sYXN0RmluaXNoZWRKb2JTZXF1ZW5jZUlkO1xyXG4gICAgaWYgKGxhc3RGaW5pc2hlZCA+IGpvYlNlcXVlbmNlSWQpIHtcclxuICAgICAgICAvLyBEbyBub3QgcmVmcmVzaCBwaXhlbHMgd2l0aCBsb3dlciBxdWFsaXR5IHRoYW5cclxuICAgICAgICAvLyB3aGF0IHdhcyBhbHJlYWR5IHJldHVybmVkXHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5fY2hlY2tJZkFsbFRlcm1pbmF0ZWQoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMuX2xhc3RGaW5pc2hlZEpvYlNlcXVlbmNlSWQgPSBqb2JTZXF1ZW5jZUlkO1xyXG4gICAgXHJcbiAgICB2YXIgdGlsZVBhcmFtcyA9IHRoaXMuX2ltYWdlUGFydFBhcmFtcztcclxuICAgIFxyXG4gICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5fbGlzdGVuZXJzTGlua2VkTGlzdC5nZXRGaXJzdEl0ZXJhdG9yKCk7XHJcbiAgICB3aGlsZSAoaXRlcmF0b3IgIT09IG51bGwpIHtcclxuICAgICAgICB2YXIgbGlzdGVuZXJIYW5kbGUgPSB0aGlzLl9saXN0ZW5lcnNMaW5rZWRMaXN0LmdldFZhbHVlKGl0ZXJhdG9yKTtcclxuICAgICAgICB2YXIgb3JpZ2luYWxQYXJhbXMgPSBsaXN0ZW5lckhhbmRsZS5pbWFnZVBhcnRQYXJhbXM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIG9mZnNldFggPSB0aWxlUGFyYW1zLm1pblggLSBvcmlnaW5hbFBhcmFtcy5taW5YO1xyXG4gICAgICAgIHZhciBvZmZzZXRZID0gdGlsZVBhcmFtcy5taW5ZIC0gb3JpZ2luYWxQYXJhbXMubWluWTtcclxuICAgICAgICB2YXIgd2lkdGggPSBvcmlnaW5hbFBhcmFtcy5tYXhYRXhjbHVzaXZlIC0gb3JpZ2luYWxQYXJhbXMubWluWDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gb3JpZ2luYWxQYXJhbXMubWF4WUV4Y2x1c2l2ZSAtIG9yaWdpbmFsUGFyYW1zLm1pblk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGlzdGVuZXJIYW5kbGUuYWxsUmVsZXZhbnRCeXRlc0xvYWRlZCArPSByZWxldmFudEJ5dGVzTG9hZGVkRGlmZjtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgZGVjb2RlZE9mZnNldHRlZCA9IHtcclxuICAgICAgICAgICAgb3JpZ2luYWxSZXF1ZXN0V2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICBvcmlnaW5hbFJlcXVlc3RIZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgICAgeEluT3JpZ2luYWxSZXF1ZXN0OiBvZmZzZXRYLFxyXG4gICAgICAgICAgICB5SW5PcmlnaW5hbFJlcXVlc3Q6IG9mZnNldFksXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpbWFnZURhdGE6IGRlY29kZVJlc3VsdCxcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGFsbFJlbGV2YW50Qnl0ZXNMb2FkZWQ6IGxpc3RlbmVySGFuZGxlLmFsbFJlbGV2YW50Qnl0ZXNMb2FkZWRcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxpc3RlbmVySGFuZGxlLmNhbGxiYWNrKGRlY29kZWRPZmZzZXR0ZWQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGl0ZXJhdG9yID0gdGhpcy5fbGlzdGVuZXJzTGlua2VkTGlzdC5nZXROZXh0SXRlcmF0b3IoaXRlcmF0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2NoZWNrSWZBbGxUZXJtaW5hdGVkKCk7XHJcbn07XHJcblxyXG5EZWNvZGVKb2IucHJvdG90eXBlLl9mZXRjaFRlcm1pbmF0ZWQgPSBmdW5jdGlvbiBmZXRjaFRlcm1pbmF0ZWQoaXNBYm9ydGVkKSB7XHJcbiAgICBpZiAodGhpcy5faXNNYW51YWxseUFib3J0ZWQpIHtcclxuICAgICAgICAvLyBUaGlzIHNpdHVhdGlvbiBtaWdodCBvY2N1ciBpZiByZXF1ZXN0IGhhcyBiZWVuIHRlcm1pbmF0ZWQsXHJcbiAgICAgICAgLy8gYnV0IHVzZXIncyB0ZXJtaW5hdGVkQ2FsbGJhY2sgaGFzIG5vdCBiZWVuIGNhbGxlZCB5ZXQuIEl0XHJcbiAgICAgICAgLy8gaGFwcGVucyBvbiBXb3JrZXJQcm94eUZldGNoTWFuYWdlciBkdWUgdG8gdGhyZWFkXHJcbiAgICAgICAgLy8gbWVzc2FnZSBkZWxheS5cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2lzRmV0Y2hSZXF1ZXN0VGVybWluYXRlZCkge1xyXG4gICAgICAgIHRocm93ICdEb3VibGUgdGVybWluYXRpb24gb2YgZmV0Y2ggcmVxdWVzdCc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMuX2lzRmV0Y2hSZXF1ZXN0VGVybWluYXRlZCA9IHRydWU7XHJcbiAgICAtLXRoaXMuX2FjdGl2ZVN1YkpvYnM7XHJcbiAgICB0aGlzLl9pc0Fib3J0ZWQgfD0gaXNBYm9ydGVkO1xyXG4gICAgXHJcbiAgICB0aGlzLl9jaGVja0lmQWxsVGVybWluYXRlZCgpO1xyXG59O1xyXG5cclxuRGVjb2RlSm9iLnByb3RvdHlwZS5fZGVjb2RlQWJvcnRlZCA9IGZ1bmN0aW9uIGRlY29kZUFib3J0ZWQoam9iQ29udGV4dCkge1xyXG4gICAgdGhpcy5faXNBYm9ydGVkID0gdHJ1ZTtcclxuICAgIFxyXG4gICAgaWYgKHRoaXMuX2ZpcnN0RGVjb2RlSW5wdXQgIT09IG51bGwpIHtcclxuICAgICAgICB0aGlzLl9maXJzdERlY29kZUlucHV0ID0gbnVsbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ0RlY29kZUlucHV0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9pc0FscmVhZHlTY2hlZHVsZWROb25GaXJzdEpvYiA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAtLXRoaXMuX2FjdGl2ZVN1YkpvYnM7XHJcbiAgICBcclxuICAgIHRoaXMuX2NoZWNrSWZBbGxUZXJtaW5hdGVkKCk7XHJcbn07XHJcblxyXG5EZWNvZGVKb2IucHJvdG90eXBlLl9pc0Fib3J0ZWROb1Rlcm1pbmF0aW9uID0gZnVuY3Rpb24gX2lzQWJvcnRlZE5vVGVybWluYXRpb24oKSB7XHJcbiAgICBpZiAodGhpcy5faXNNYW51YWxseUFib3J0ZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICh0aGlzLl9pc1Rlcm1pbmF0ZWQpIHtcclxuICAgICAgICB0aHJvdyAnVW5leHBlY3RlZCBqb2Igc3RhdGUgb2YgdGVybWluYXRlZDogU3RpbGwgcnVubmluIHN1Yi1qb2JzJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHRoaXMuX2lzQWJvcnRlZDtcclxufTtcclxuXHJcbkRlY29kZUpvYi5wcm90b3R5cGUuX2NoZWNrSWZBbGxUZXJtaW5hdGVkID0gZnVuY3Rpb24gY2hlY2tJZkFsbFRlcm1pbmF0ZWQoKSB7XHJcbiAgICBpZiAodGhpcy5fYWN0aXZlU3ViSm9icyA8IDApIHtcclxuICAgICAgICB0aHJvdyAnSW5jb25zaXN0ZW50IG51bWJlciBvZiBkZWNvZGUgam9icyc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICh0aGlzLl9hY3RpdmVTdWJKb2JzID4gMCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHRoaXMuX2lzQWxyZWFkeVNjaGVkdWxlZE5vbkZpcnN0Sm9iKSB7XHJcbiAgICAgICAgdGhyb3cgJ0luY29uc2lzdGVudCBpc0FscmVhZHlTY2hlZHVsZWROb25GaXJzdEpvYiBmbGFnJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5faXNUZXJtaW5hdGVkID0gdHJ1ZTtcclxuICAgIHZhciBsaW5rZWRMaXN0ID0gdGhpcy5fbGlzdGVuZXJzTGlua2VkTGlzdDtcclxuICAgIHRoaXMuX2xpc3RlbmVyc0xpbmtlZExpc3QgPSBudWxsO1xyXG5cclxuICAgIHZhciBpdGVyYXRvciA9IGxpbmtlZExpc3QuZ2V0Rmlyc3RJdGVyYXRvcigpO1xyXG4gICAgXHJcbiAgICB3aGlsZSAoaXRlcmF0b3IgIT09IG51bGwpIHtcclxuICAgICAgICB2YXIgbGlzdGVuZXJIYW5kbGUgPSBsaW5rZWRMaXN0LmdldFZhbHVlKGl0ZXJhdG9yKTtcclxuICAgICAgICBsaXN0ZW5lckhhbmRsZS5pc0FueURlY29kZXJBYm9ydGVkIHw9IHRoaXMuX2lzQWJvcnRlZDtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgcmVtYWluaW5nID0gLS1saXN0ZW5lckhhbmRsZS5yZW1haW5pbmdEZWNvZGVKb2JzO1xyXG4gICAgICAgIGlmIChyZW1haW5pbmcgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93ICdJbmNvbnNpc3RlbnQgbnVtYmVyIG9mIGRvbmUgcmVxdWVzdHMnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgaXNMaXN0ZW5lckRvbmUgPSByZW1haW5pbmcgPT09IDA7XHJcbiAgICAgICAgaWYgKGlzTGlzdGVuZXJEb25lKSB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVySGFuZGxlLmlzVGVybWluYXRlZENhbGxiYWNrQ2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgbGlzdGVuZXJIYW5kbGUudGVybWluYXRlZENhbGxiYWNrKFxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJIYW5kbGUuaXNBbnlEZWNvZGVyQWJvcnRlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGl0ZXJhdG9yID0gbGlua2VkTGlzdC5nZXROZXh0SXRlcmF0b3IoaXRlcmF0b3IpO1xyXG4gICAgfVxyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGVjb2RlSm9ic1Bvb2w7XHJcblxyXG52YXIgRGVjb2RlSm9iID0gcmVxdWlyZSgnZGVjb2Rlam9iLmpzJyk7XHJcblxyXG5mdW5jdGlvbiBEZWNvZGVKb2JzUG9vbChcclxuICAgIGZldGNoTWFuYWdlcixcclxuICAgIGRlY29kZVNjaGVkdWxlcixcclxuICAgIHRpbGVXaWR0aCxcclxuICAgIHRpbGVIZWlnaHQsXHJcbiAgICBvbmx5V2FpdEZvckRhdGFBbmREZWNvZGUpIHtcclxuICAgIFxyXG4gICAgdGhpcy5fdGlsZVdpZHRoID0gdGlsZVdpZHRoO1xyXG4gICAgdGhpcy5fdGlsZUhlaWdodCA9IHRpbGVIZWlnaHQ7XHJcbiAgICB0aGlzLl9hY3RpdmVSZXF1ZXN0cyA9IFtdO1xyXG4gICAgdGhpcy5fb25seVdhaXRGb3JEYXRhQW5kRGVjb2RlID0gb25seVdhaXRGb3JEYXRhQW5kRGVjb2RlO1xyXG4gICAgXHJcbiAgICB0aGlzLl9mZXRjaE1hbmFnZXIgPSBmZXRjaE1hbmFnZXI7XHJcbiAgICBcclxuICAgIHRoaXMuX2RlY29kZVNjaGVkdWxlciA9IGRlY29kZVNjaGVkdWxlcjtcclxufVxyXG5cclxuRGVjb2RlSm9ic1Bvb2wucHJvdG90eXBlLmZvcmtEZWNvZGVKb2JzID0gZnVuY3Rpb24gZm9ya0RlY29kZUpvYnMoXHJcbiAgICBpbWFnZVBhcnRQYXJhbXMsXHJcbiAgICBjYWxsYmFjayxcclxuICAgIHRlcm1pbmF0ZWRDYWxsYmFjayxcclxuICAgIGxldmVsV2lkdGgsXHJcbiAgICBsZXZlbEhlaWdodCxcclxuICAgIGlzUHJvZ3Jlc3NpdmUsXHJcbiAgICBpbWFnZVBhcnRQYXJhbXNOb3ROZWVkZWQpIHtcclxuICAgIFxyXG4gICAgdmFyIG1pblggPSBpbWFnZVBhcnRQYXJhbXMubWluWDtcclxuICAgIHZhciBtaW5ZID0gaW1hZ2VQYXJ0UGFyYW1zLm1pblk7XHJcbiAgICB2YXIgbWF4WCA9IGltYWdlUGFydFBhcmFtcy5tYXhYRXhjbHVzaXZlO1xyXG4gICAgdmFyIG1heFkgPSBpbWFnZVBhcnRQYXJhbXMubWF4WUV4Y2x1c2l2ZTtcclxuICAgIHZhciBsZXZlbCA9IGltYWdlUGFydFBhcmFtcy5sZXZlbCB8fCAwO1xyXG4gICAgdmFyIHF1YWxpdHkgPSBpbWFnZVBhcnRQYXJhbXMucXVhbGl0eTtcclxuICAgIHZhciBwcmlvcml0eURhdGEgPSBpbWFnZVBhcnRQYXJhbXMucmVxdWVzdFByaW9yaXR5RGF0YTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgdmFyIGlzTWluQWxpZ25lZCA9XHJcbiAgICAgICAgbWluWCAlIHRoaXMuX3RpbGVXaWR0aCA9PT0gMCAmJiBtaW5ZICUgdGhpcy5fdGlsZUhlaWdodCA9PT0gMDtcclxuICAgIHZhciBpc01heFhBbGlnbmVkID0gbWF4WCAlIHRoaXMuX3RpbGVXaWR0aCA9PT0gMCB8fCBtYXhYID09PSBsZXZlbFdpZHRoO1xyXG4gICAgdmFyIGlzTWF4WUFsaWduZWQgPSBtYXhZICUgdGhpcy5fdGlsZUhlaWdodCA9PT0gMCB8fCBtYXhZID09PSBsZXZlbEhlaWdodDtcclxuICAgIHZhciBpc09yZGVyVmFsaWQgPSBtaW5YIDwgbWF4WCAmJiBtaW5ZIDwgbWF4WTtcclxuICAgIFxyXG4gICAgaWYgKCFpc01pbkFsaWduZWQgfHwgIWlzTWF4WEFsaWduZWQgfHwgIWlzTWF4WUFsaWduZWQgfHwgIWlzT3JkZXJWYWxpZCkge1xyXG4gICAgICAgIHRocm93ICdpbWFnZVBhcnRQYXJhbXMgZm9yIGRlY29kZXJzIGlzIG5vdCBhbGlnbmVkIHRvICcgK1xyXG4gICAgICAgICAgICAndGlsZSBzaXplIG9yIG5vdCBpbiB2YWxpZCBvcmRlcic7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciByZXF1ZXN0c0luTGV2ZWwgPSBnZXRPckFkZFZhbHVlKHRoaXMuX2FjdGl2ZVJlcXVlc3RzLCBsZXZlbCwgW10pO1xyXG4gICAgdmFyIHJlcXVlc3RzSW5RdWFsaXR5ID0gZ2V0T3JBZGRWYWx1ZShcclxuICAgICAgICByZXF1ZXN0c0luTGV2ZWwsIGltYWdlUGFydFBhcmFtcy5xdWFsaXR5LCBbXSk7XHJcbiAgICAgICAgXHJcbiAgICB2YXIgbnVtVGlsZXNYID0gTWF0aC5jZWlsKChtYXhYIC0gbWluWCkgLyB0aGlzLl90aWxlV2lkdGgpO1xyXG4gICAgdmFyIG51bVRpbGVzWSA9IE1hdGguY2VpbCgobWF4WSAtIG1pblkpIC8gdGhpcy5fdGlsZUhlaWdodCk7XHJcbiAgICBcclxuICAgIHZhciBsaXN0ZW5lckhhbmRsZSA9IHtcclxuICAgICAgICBpbWFnZVBhcnRQYXJhbXM6IGltYWdlUGFydFBhcmFtcyxcclxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXHJcbiAgICAgICAgdGVybWluYXRlZENhbGxiYWNrOiB0ZXJtaW5hdGVkQ2FsbGJhY2ssXHJcbiAgICAgICAgcmVtYWluaW5nRGVjb2RlSm9iczogbnVtVGlsZXNYICogbnVtVGlsZXNZLFxyXG4gICAgICAgIGlzUHJvZ3Jlc3NpdmU6IGlzUHJvZ3Jlc3NpdmUsXHJcbiAgICAgICAgaXNBbnlEZWNvZGVyQWJvcnRlZDogZmFsc2UsXHJcbiAgICAgICAgaXNUZXJtaW5hdGVkQ2FsbGJhY2tDYWxsZWQ6IGZhbHNlLFxyXG4gICAgICAgIGFsbFJlbGV2YW50Qnl0ZXNMb2FkZWQ6IDAsXHJcbiAgICAgICAgdW5yZWdpc3RlckhhbmRsZXM6IFtdXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmb3IgKHZhciB4ID0gbWluWDsgeCA8IG1heFg7IHggKz0gdGhpcy5fdGlsZVdpZHRoKSB7XHJcbiAgICAgICAgdmFyIHJlcXVlc3RzSW5YID0gZ2V0T3JBZGRWYWx1ZShyZXF1ZXN0c0luUXVhbGl0eSwgeCwgW10pO1xyXG4gICAgICAgIHZhciBzaW5nbGVUaWxlTWF4WCA9IE1hdGgubWluKHggKyB0aGlzLl90aWxlV2lkdGgsIGxldmVsV2lkdGgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAodmFyIHkgPSBtaW5ZOyB5IDwgbWF4WTsgeSArPSB0aGlzLl90aWxlSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHZhciBzaW5nbGVUaWxlTWF4WSA9IE1hdGgubWluKHkgKyB0aGlzLl90aWxlSGVpZ2h0LCBsZXZlbEhlaWdodCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgaXNUaWxlTm90TmVlZGVkID0gaXNVbm5lZWRlZChcclxuICAgICAgICAgICAgICAgIHgsXHJcbiAgICAgICAgICAgICAgICB5LFxyXG4gICAgICAgICAgICAgICAgc2luZ2xlVGlsZU1heFgsXHJcbiAgICAgICAgICAgICAgICBzaW5nbGVUaWxlTWF4WSxcclxuICAgICAgICAgICAgICAgIGltYWdlUGFydFBhcmFtc05vdE5lZWRlZCk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGlzVGlsZU5vdE5lZWRlZCkge1xyXG4gICAgICAgICAgICAgICAgLS1saXN0ZW5lckhhbmRsZS5yZW1haW5pbmdEZWNvZGVKb2JzO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGRlY29kZUpvYkNvbnRhaW5lciA9IGdldE9yQWRkVmFsdWUocmVxdWVzdHNJblgsIHksIHt9KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChkZWNvZGVKb2JDb250YWluZXIuam9iID09PSB1bmRlZmluZWQgfHxcclxuICAgICAgICAgICAgICAgIGRlY29kZUpvYkNvbnRhaW5lci5qb2IuZ2V0SXNUZXJtaW5hdGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIHNpbmdsZVRpbGVJbWFnZVBhcnRQYXJhbXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluWDogeCxcclxuICAgICAgICAgICAgICAgICAgICBtaW5ZOiB5LFxyXG4gICAgICAgICAgICAgICAgICAgIG1heFhFeGNsdXNpdmU6IHNpbmdsZVRpbGVNYXhYLFxyXG4gICAgICAgICAgICAgICAgICAgIG1heFlFeGNsdXNpdmU6IHNpbmdsZVRpbGVNYXhZLFxyXG4gICAgICAgICAgICAgICAgICAgIGxldmVsOiBsZXZlbCxcclxuICAgICAgICAgICAgICAgICAgICBxdWFsaXR5OiBxdWFsaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RQcmlvcml0eURhdGE6IHByaW9yaXR5RGF0YVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgZGVjb2RlSm9iQ29udGFpbmVyLmpvYiA9IG5ldyBEZWNvZGVKb2IoXHJcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlVGlsZUltYWdlUGFydFBhcmFtcyxcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mZXRjaE1hbmFnZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVjb2RlU2NoZWR1bGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29ubHlXYWl0Rm9yRGF0YUFuZERlY29kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciB1bnJlZ2lzdGVySGFuZGxlID1cclxuICAgICAgICAgICAgICAgIGRlY29kZUpvYkNvbnRhaW5lci5qb2IucmVnaXN0ZXJMaXN0ZW5lcihsaXN0ZW5lckhhbmRsZSk7XHJcbiAgICAgICAgICAgIGxpc3RlbmVySGFuZGxlLnVucmVnaXN0ZXJIYW5kbGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdW5yZWdpc3RlckhhbmRsZTogdW5yZWdpc3RlckhhbmRsZSxcclxuICAgICAgICAgICAgICAgIGpvYjogZGVjb2RlSm9iQ29udGFpbmVyLmpvYlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICghbGlzdGVuZXJIYW5kbGUuaXNUZXJtaW5hdGVkQ2FsbGJhY2tDYWxsZWQgJiZcclxuICAgICAgICBsaXN0ZW5lckhhbmRsZS5yZW1haW5pbmdEZWNvZGVKb2JzID09PSAwKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGlzdGVuZXJIYW5kbGUuaXNUZXJtaW5hdGVkQ2FsbGJhY2tDYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgIGxpc3RlbmVySGFuZGxlLnRlcm1pbmF0ZWRDYWxsYmFjayhsaXN0ZW5lckhhbmRsZS5pc0FueURlY29kZXJBYm9ydGVkKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIGxpc3RlbmVySGFuZGxlO1xyXG59O1xyXG5cclxuRGVjb2RlSm9ic1Bvb2wucHJvdG90eXBlLnVucmVnaXN0ZXJGb3JrZWRKb2JzID0gZnVuY3Rpb24gdW5yZWdpc3RlckZvcmtlZEpvYnMobGlzdGVuZXJIYW5kbGUpIHtcclxuICAgIGlmIChsaXN0ZW5lckhhbmRsZS5yZW1haW5pbmdEZWNvZGVKb2JzID09PSAwKSB7XHJcbiAgICAgICAgLy8gQWxsIGpvYnMgaGFzIGFscmVhZHkgYmVlbiB0ZXJtaW5hdGVkLCBubyBuZWVkIHRvIHVucmVnaXN0ZXJcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJIYW5kbGUudW5yZWdpc3RlckhhbmRsZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICB2YXIgaGFuZGxlID0gbGlzdGVuZXJIYW5kbGUudW5yZWdpc3RlckhhbmRsZXNbaV07XHJcbiAgICAgICAgaWYgKGhhbmRsZS5qb2IuZ2V0SXNUZXJtaW5hdGVkKCkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGhhbmRsZS5qb2IudW5yZWdpc3Rlckxpc3RlbmVyKGhhbmRsZS51bnJlZ2lzdGVySGFuZGxlKTtcclxuICAgIH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIGlzVW5uZWVkZWQoXHJcbiAgICBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCBpbWFnZVBhcnRQYXJhbXNOb3ROZWVkZWQpIHtcclxuICAgIFxyXG4gICAgaWYgKGltYWdlUGFydFBhcmFtc05vdE5lZWRlZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGltYWdlUGFydFBhcmFtc05vdE5lZWRlZC5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhciBub3ROZWVkZWQgPSBpbWFnZVBhcnRQYXJhbXNOb3ROZWVkZWRbaV07XHJcbiAgICAgICAgdmFyIGlzSW5YID0gbWluWCA+PSBub3ROZWVkZWQubWluWCAmJiBtYXhYIDw9IG5vdE5lZWRlZC5tYXhYRXhjbHVzaXZlO1xyXG4gICAgICAgIHZhciBpc0luWSA9IG1pblkgPj0gbm90TmVlZGVkLm1pblkgJiYgbWF4WSA8PSBub3ROZWVkZWQubWF4WUV4Y2x1c2l2ZTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoaXNJblggJiYgaXNJblkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldE9yQWRkVmFsdWUocGFyZW50QXJyYXksIGluZGV4LCBkZWZhdWx0VmFsdWUpIHtcclxuICAgIHZhciBzdWJBcnJheSA9IHBhcmVudEFycmF5W2luZGV4XTtcclxuICAgIGlmIChzdWJBcnJheSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgc3ViQXJyYXkgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgcGFyZW50QXJyYXlbaW5kZXhdID0gc3ViQXJyYXk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBzdWJBcnJheTtcclxufSIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmV0Y2hKb2I7XHJcblxyXG5GZXRjaEpvYi5GRVRDSF9UWVBFX1JFUVVFU1QgPSAxO1xyXG5GZXRjaEpvYi5GRVRDSF9UWVBFX0NIQU5ORUwgPSAyOyAvLyBtb3ZhYmxlXHJcbkZldGNoSm9iLkZFVENIX1RZUEVfT05MWV9XQUlUX0ZPUl9EQVRBID0gMztcclxuXHJcbmZ1bmN0aW9uIEZldGNoSm9iKGZldGNoZXIsIHNjaGVkdWxlciwgZmV0Y2hUeXBlLCBjb250ZXh0VmFycykge1xyXG4gICAgdGhpcy5fZmV0Y2hlciA9IGZldGNoZXI7XHJcbiAgICB0aGlzLl9zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XHJcbiAgICBcclxuICAgIHRoaXMuX2RhdGFMaXN0ZW5lcnMgPSBbXTtcclxuICAgIHRoaXMuX3Rlcm1pbmF0ZWRMaXN0ZW5lcnMgPSBbXTtcclxuICAgIFxyXG4gICAgdGhpcy5faW1hZ2VQYXJ0UGFyYW1zID0gbnVsbDtcclxuICAgIHRoaXMuX3Byb2dyZXNzaXZlU3RhZ2VzRG9uZSA9IDA7XHJcbiAgICBcclxuICAgIHRoaXMuX2lzWWllbGRlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5faXNGYWlsdXJlID0gZmFsc2U7XHJcbiAgICB0aGlzLl9pc1Rlcm1pbmF0ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX2lzTWFudWFsbHlBYm9ydGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9pc0NoYW5uZWwgPSBmZXRjaFR5cGUgPT09IEZldGNoSm9iLkZFVENIX1RZUEVfQ0hBTk5FTDtcclxuXHR0aGlzLl9pc0NoYW5uZWxTdGFydGVkRmV0Y2ggPSBmYWxzZTtcclxuICAgIHRoaXMuX2NvbnRleHRWYXJzID0gY29udGV4dFZhcnM7XHJcbiAgICB0aGlzLl9pc09ubHlXYWl0Rm9yRGF0YSA9IGZldGNoVHlwZSA9PT0gRmV0Y2hKb2IuRkVUQ0hfVFlQRV9PTkxZX1dBSVRfRk9SX0RBVEE7XHJcbiAgICB0aGlzLl91c2VTY2hlZHVsZXIgPSBmZXRjaFR5cGUgPT09IEZldGNoSm9iLkZFVENIX1RZUEVfUkVRVUVTVDtcclxuICAgIHRoaXMuX2ltYWdlRGF0YUNvbnRleHQgPSBudWxsO1xyXG4gICAgdGhpcy5fcmVzb3VyY2UgPSBudWxsO1xyXG4gICAgdGhpcy5fYWJvcnRlZEJvdW5kID0gdGhpcy5fYWJvcnRlZC5iaW5kKHRoaXMpO1xyXG5cdHRoaXMuX2ZldGNoSGFuZGxlID0gbnVsbDtcclxuICAgIC8vdGhpcy5fYWxyZWFkeVRlcm1pbmF0ZWRXaGVuQWxsRGF0YUFycml2ZWQgPSBmYWxzZTtcclxuICAgIFxyXG4gICAgaWYgKGZldGNoVHlwZSA9PT0gRmV0Y2hKb2IuRkVUQ0hfVFlQRV9DSEFOTkVMKSB7XHJcbiAgICAgICAgdGhpcy5fbW92YWJsZUZldGNoU3RhdGUgPSB7fTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fbW92YWJsZUZldGNoU3RhdGUgPSBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5GZXRjaEpvYi5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiBmZXRjaChpbWFnZVBhcnRQYXJhbXMpIHtcclxuICAgIGlmICh0aGlzLl9pc0NoYW5uZWwpIHtcclxuXHRcdGlmICh0aGlzLl9pbWFnZURhdGFDb250ZXh0ICE9PSBudWxsKSB7XHJcblx0XHRcdHRoaXMuX2ltYWdlRGF0YUNvbnRleHQuZGlzcG9zZSgpO1xyXG5cdFx0fVxyXG4gICAgICAgIHRoaXMuX2ltYWdlUGFydFBhcmFtcyA9IGltYWdlUGFydFBhcmFtcztcclxuICAgICAgICB0aGlzLl9zdGFydEZldGNoKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAodGhpcy5faW1hZ2VQYXJ0UGFyYW1zICE9PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgJ0Nhbm5vdCBmZXRjaCB0d2ljZSBvbiBmZXRjaCB0eXBlIG9mIFwicmVxdWVzdFwiJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5faW1hZ2VQYXJ0UGFyYW1zID0gaW1hZ2VQYXJ0UGFyYW1zO1xyXG4gICAgXHJcbiAgICBpZiAoIXRoaXMuX3VzZVNjaGVkdWxlcikge1xyXG4gICAgICAgIHN0YXJ0UmVxdWVzdCgvKnJlc291cmNlPSovbnVsbCwgdGhpcyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aGlzLl9zY2hlZHVsZXIuZW5xdWV1ZUpvYihzdGFydFJlcXVlc3QsIHRoaXMsIGZldGNoQWJvcnRlZEJ5U2NoZWR1bGVyKTtcclxufTtcclxuXHJcbkZldGNoSm9iLnByb3RvdHlwZS5tYW51YWxBYm9ydFJlcXVlc3QgPSBmdW5jdGlvbiBtYW51YWxBYm9ydFJlcXVlc3QoKSB7XHJcbiAgICB0aGlzLl9pc01hbnVhbGx5QWJvcnRlZCA9IHRydWU7XHJcbiAgICB0aGlzLl9pc1Rlcm1pbmF0ZWQgPSB0cnVlO1xyXG4gICAgXHJcbiAgICBpZiAodGhpcy5fZmV0Y2hIYW5kbGUgIT09IG51bGwpIHtcclxuICAgICAgICB0aGlzLl9mZXRjaEhhbmRsZS5hYm9ydEFzeW5jKCkudGhlbih0aGlzLl9hYm9ydGVkQm91bmQpO1xyXG4gICAgfSBlbHNlIHtcclxuXHRcdHRoaXMuX2ltYWdlRGF0YUNvbnRleHQuZGlzcG9zZSgpO1xyXG5cdH1cclxufTtcclxuXHJcbkZldGNoSm9iLnByb3RvdHlwZS5nZXRDb250ZXh0VmFycyA9IGZ1bmN0aW9uIGdldENvbnRleHRWYXJzKHJlcXVlc3RJZCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHRWYXJzO1xyXG59O1xyXG5cclxuRmV0Y2hKb2IucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGxpc3RlbmVyKSB7XHJcbiAgICBzd2l0Y2ggKGV2ZW50KSB7XHJcbiAgICAgICAgY2FzZSAnZGF0YSc6XHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGFMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3Rlcm1pbmF0ZWQnOlxyXG4gICAgICAgICAgICB0aGlzLl90ZXJtaW5hdGVkTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyAnVW5leHBlY3RlZCBldmVudCAnICsgZXZlbnQ7XHJcbiAgICB9XHJcbn07XHJcblxyXG5GZXRjaEpvYi5wcm90b3R5cGUuc2V0SXNQcm9ncmVzc2l2ZSA9IGZ1bmN0aW9uIHNldElzUHJvZ3Jlc3NpdmUoaXNQcm9ncmVzc2l2ZSkge1xyXG4gICAgdGhpcy5faXNQcm9ncmVzc2l2ZSA9IGlzUHJvZ3Jlc3NpdmU7XHJcblx0aWYgKHRoaXMuX2ltYWdlRGF0YUNvbnRleHQgIT09IG51bGwpIHtcclxuXHRcdHRoaXMuX2ltYWdlRGF0YUNvbnRleHQuc2V0SXNQcm9ncmVzc2l2ZShpc1Byb2dyZXNzaXZlKTtcclxuXHR9XHJcbn07XHJcblxyXG5GZXRjaEpvYi5wcm90b3R5cGUuZ2V0SXNQcm9ncmVzc2l2ZSA9IGZ1bmN0aW9uIGdldElzUHJvZ3Jlc3NpdmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faXNQcm9ncmVzc2l2ZTtcclxufTtcclxuXHJcbkZldGNoSm9iLnByb3RvdHlwZS5fc3RhcnRGZXRjaCA9IGZ1bmN0aW9uIHN0YXJ0RmV0Y2goKSB7XHJcbiAgICB2YXIgaW1hZ2VEYXRhQ29udGV4dCA9IHRoaXMuX2ZldGNoZXIuY3JlYXRlSW1hZ2VEYXRhQ29udGV4dChcclxuICAgICAgICB0aGlzLl9pbWFnZVBhcnRQYXJhbXMpO1xyXG4gICAgXHJcbiAgICB0aGlzLl9pbWFnZURhdGFDb250ZXh0ID0gaW1hZ2VEYXRhQ29udGV4dDtcclxuXHR0aGlzLl9pbWFnZURhdGFDb250ZXh0LnNldElzUHJvZ3Jlc3NpdmUodGhpcy5faXNQcm9ncmVzc2l2ZSk7XHJcblxyXG4gICAgaWYgKGltYWdlRGF0YUNvbnRleHQuaXNEb25lKCkpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2RhdGFMaXN0ZW5lcnMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGF0YUxpc3RlbmVyc1tpXS5jYWxsKHRoaXMsIHRoaXMuX2NvbnRleHRWYXJzLCBpbWFnZURhdGFDb250ZXh0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2ZldGNoVGVybWluYXRlZCgvKmlzQWJvcnRlZD0qL2ZhbHNlKTtcclxuICAgICAgICAvL3RoaXMuX2FscmVhZHlUZXJtaW5hdGVkV2hlbkFsbERhdGFBcnJpdmVkID0gdHJ1ZTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChpbWFnZURhdGFDb250ZXh0Lmhhc0RhdGEoKSkge1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fZGF0YUxpc3RlbmVycy5sZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRhTGlzdGVuZXJzW2pdLmNhbGwodGhpcywgdGhpcy5fY29udGV4dFZhcnMsIGltYWdlRGF0YUNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgaW1hZ2VEYXRhQ29udGV4dC5vbignZGF0YScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHNlbGYuX2RhdGFDYWxsYmFjayhpbWFnZURhdGFDb250ZXh0KTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBpZiAoIXRoaXMuX2lzT25seVdhaXRGb3JEYXRhKSB7XHJcblx0XHRpZiAoIXRoaXMuX2lzQ2hhbm5lbCkge1xyXG5cdFx0XHR0aGlzLl9mZXRjaEhhbmRsZSA9IHRoaXMuX2ZldGNoZXIuZmV0Y2goaW1hZ2VEYXRhQ29udGV4dCk7XHJcblx0XHR9IGVsc2UgaWYgKHRoaXMuX2lzQ2hhbm5lbFN0YXJ0ZWRGZXRjaCkge1xyXG5cdFx0XHR0aGlzLl9mZXRjaGVyLm1vdmVGZXRjaChpbWFnZURhdGFDb250ZXh0LCB0aGlzLl9tb3ZhYmxlRmV0Y2hTdGF0ZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9mZXRjaGVyLnN0YXJ0TW92YWJsZUZldGNoKGltYWdlRGF0YUNvbnRleHQsIHRoaXMuX21vdmFibGVGZXRjaFN0YXRlKTtcclxuXHRcdFx0dGhpcy5faXNDaGFubmVsU3RhcnRlZEZldGNoID0gdHJ1ZTtcclxuXHRcdH1cclxuICAgIH1cclxufTtcclxuXHJcbkZldGNoSm9iLnByb3RvdHlwZS5fZmV0Y2hUZXJtaW5hdGVkID0gZnVuY3Rpb24gZmV0Y2hUZXJtaW5hdGVkKGlzQWJvcnRlZCkge1xyXG4gICAgaWYgKHRoaXMuX2lzWWllbGRlZCB8fCB0aGlzLl9pc1Rlcm1pbmF0ZWQpIHtcclxuICAgICAgICB0aHJvdyAnVW5leHBlY3RlZCByZXF1ZXN0IHN0YXRlIG9uIHRlcm1pbmF0ZWQnO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAodGhpcy5fcmVzb3VyY2UgIT09IG51bGwpIHtcclxuICAgICAgICBpZiAoaXNBYm9ydGVkKSB7XHJcbiAgICAgICAgICAgIHRocm93ICdVbmV4cGVjdGVkIHJlcXVlc3QgdGVybWluYXRpb24gd2l0aG91dCByZXNvdXJjZSBhbGxvY2F0ZWQnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVyLmpvYkRvbmUodGhpcy5fcmVzb3VyY2UsIHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLl9yZXNvdXJjZSA9IG51bGw7XHJcbiAgICB9IGVsc2UgaWYgKCFpc0Fib3J0ZWQgJiYgdGhpcy5fdXNlU2NoZWR1bGVyKSB7XHJcbiAgICAgICAgdGhyb3cgJ0pvYiBleHBlY3RlZCB0byBoYXZlIHJlc291cmNlIG9uIHN1Y2Nlc3NmdWwgdGVybWluYXRpb24nO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDaGFubmVsIGlzIG5vdCByZWFsbHkgdGVybWluYXRlZCwgYnV0IG9ubHkgZmV0Y2hlcyBhIG5ldyByZWdpb25cclxuICAgIC8vIChzZWUgbW92ZUNoYW5uZWwoKSkuXHJcbiAgICBpZiAoIXRoaXMuX2lzQ2hhbm5lbCkge1xyXG4gICAgICAgIHRoaXMuX2lzVGVybWluYXRlZCA9IHRydWU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90ZXJtaW5hdGVkTGlzdGVuZXJzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmF0ZWRMaXN0ZW5lcnNbaV0oXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0VmFycywgdGhpcy5faW1hZ2VEYXRhQ29udGV4dCwgaXNBYm9ydGVkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICh0aGlzLl9pbWFnZURhdGFDb250ZXh0ICE9PSBudWxsICYmICF0aGlzLl9pc0ZhaWx1cmUpIHtcclxuICAgICAgICB0aGlzLl9pbWFnZURhdGFDb250ZXh0LmRpc3Bvc2UoKTtcclxuICAgIH1cclxufTtcclxuXHJcbkZldGNoSm9iLnByb3RvdHlwZS5fY29udGludWVGZXRjaCA9IGZ1bmN0aW9uIGNvbnRpbnVlRmV0Y2goKSB7XHJcbiAgICBpZiAodGhpcy5pc0NoYW5uZWwpIHtcclxuICAgICAgICB0aHJvdyAnVW5leHBlY3RlZCBjYWxsIHRvIGNvbnRpbnVlRmV0Y2ggb24gY2hhbm5lbCc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMuX2ZldGNoSGFuZGxlID0gdGhpcy5fZmV0Y2hlci5mZXRjaCh0aGlzLl9pbWFnZURhdGFDb250ZXh0KTtcclxufTtcclxuXHJcbkZldGNoSm9iLnByb3RvdHlwZS5fZGF0YUNhbGxiYWNrID0gZnVuY3Rpb24gZGF0YUNhbGxiYWNrKGltYWdlRGF0YUNvbnRleHQpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzWWllbGRlZCB8fCB0aGlzLl9pc1Rlcm1pbmF0ZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgJ1VuZXhwZWN0ZWQgcmVxdWVzdCBzdGF0ZSBvbiBmZXRjaCBjYWxsYmFjayc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICBpZiAoaW1hZ2VEYXRhQ29udGV4dCAhPT0gdGhpcy5faW1hZ2VEYXRhQ29udGV4dCkge1xyXG4gICAgICAgICAgICB0aHJvdyAnVW5leHBlY3RlZCBpbWFnZURhdGFDb250ZXh0JztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICsrdGhpcy5fcHJvZ3Jlc3NpdmVTdGFnZXNEb25lO1xyXG4gICAgICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZGF0YUxpc3RlbmVycy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRhTGlzdGVuZXJzW2ldLmNhbGwodGhpcywgdGhpcy5fY29udGV4dFZhcnMsIGltYWdlRGF0YUNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoaW1hZ2VEYXRhQ29udGV4dC5pc0RvbmUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9mZXRjaFRlcm1pbmF0ZWQoLyppc0Fib3J0ZWQ9Ki9mYWxzZSk7XHJcbiAgICAgICAgICAgIC8vdGhpcy5fYWxyZWFkeVRlcm1pbmF0ZWRXaGVuQWxsRGF0YUFycml2ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh0aGlzLl91c2VTY2hlZHVsZXIpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc291cmNlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyAnTm8gcmVzb3VyY2UgYWxsb2NhdGVkIGJ1dCBmZXRjaCBjYWxsYmFjayBjYWxsZWQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG5cdFx0XHR2YXIgaXNZaWVsZGVkID0gdGhpcy5fc2NoZWR1bGVyLnRyeVlpZWxkKFxyXG5cdFx0XHRcdGNvbnRpbnVlWWllbGRlZFJlcXVlc3QsXHJcblx0XHRcdFx0dGhpcyxcclxuXHRcdFx0XHRmZXRjaEFib3J0ZWRCeVNjaGVkdWxlcixcclxuXHRcdFx0XHRmZXRjaFlpZWxkZWRCeVNjaGVkdWxlcixcclxuXHRcdFx0XHR0aGlzLl9yZXNvdXJjZSk7XHJcbiAgICAgICAgICAgIFxyXG5cdFx0XHRpZiAoaXNZaWVsZGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mZXRjaEhhbmRsZS5hYm9ydEFzeW5jKCkudGhlbih0aGlzLl9hYm9ydGVkQm91bmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHRoaXMuX2lzRmFpbHVyZSA9IHRydWU7XHJcbiAgICAgICAgZmV0Y2hBYm9ydGVkQnlTY2hlZHVsZXIodGhpcyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5GZXRjaEpvYi5wcm90b3R5cGUuX2Fib3J0ZWQgPSBmdW5jdGlvbiBhYm9ydGVkKCkge1xyXG4gICAgLy8gVE9ETzogSXQgc2VlbXMgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIHRvdGFsbHkgaGlzdG9yaWNhbCBjb2RlLiBTaG91bGQgcmV2aWV3IGl0LlxyXG4gICAgXHJcbiAgICAvL2lmICh0aGlzLl9hbHJlYWR5VGVybWluYXRlZFdoZW5BbGxEYXRhQXJyaXZlZCkge1xyXG4gICAgLy8gICAgLy8gUmVzb3VyY2VzIHdlcmUgYWxyZWFkeSByZWxlYXNlZCBBU0FQXHJcbiAgICAvLyAgICByZXR1cm47XHJcbiAgICAvL31cclxuICAgIFxyXG4gICAgaWYgKHRoaXMuX2lzWWllbGRlZCB8fCB0aGlzLl9yZXNvdXJjZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93ICdVbmV4cGVjdGVkIHJlcXVlc3Qgc3RhdGUgb24gc3RvcHBlZCc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICh0aGlzLl9pc09ubHlXYWl0Rm9yRGF0YSB8fFxyXG4gICAgICAgIHRoaXMuX2ZldGNoSGFuZGxlID09PSBudWxsKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhyb3cgJ1VuZXhwZWN0ZWQgcmVxdWVzdCB0eXBlIG9uIHN0b3BwZWQnO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKlxyXG4gICAgaWYgKCFpc0Fib3J0ZWQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzVGVybWluYXRlZCkge1xyXG4gICAgICAgICAgICB0aHJvdyAnXCJzdG9wcGVkXCIgbGlzdGVuZXIgd2FzIGNhbGxlZCB3aXRoIGlzQWJvcnRlZD1mYWxzZSBidXQgJyArXHJcbiAgICAgICAgICAgICAgICAnaW1hZ2VEYXRhQ29udGV4dCBcImRhdGFcIiBsaXN0ZW5lciB3YXMgbm90IGNhbGxlZCB5ZXQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyovXHJcbiAgICBcclxuICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLl9zY2hlZHVsZXI7XHJcbiAgICBcclxuICAgIHZhciBpc1lpZWxkZWQgPSBzY2hlZHVsZXIudHJ5WWllbGQoXHJcbiAgICAgICAgY29udGludWVZaWVsZGVkUmVxdWVzdCxcclxuICAgICAgICB0aGlzLFxyXG4gICAgICAgIGZldGNoQWJvcnRlZEJ5U2NoZWR1bGVyLFxyXG4gICAgICAgIGZldGNoWWllbGRlZEJ5U2NoZWR1bGVyLFxyXG4gICAgICAgIHRoaXMuX3Jlc291cmNlKTtcclxuICAgIFxyXG4gICAgaWYgKGlzWWllbGRlZCB8fCB0aGlzLl9pc1Rlcm1pbmF0ZWQpIHtcclxuICAgICAgICB0aGlzLl9mZXRjaEhhbmRsZSA9IG51bGw7XHJcbiAgICAgICAgc2NoZWR1bGVyLmpvYkRvbmUodGhpcy5fcmVzb3VyY2UsIHRoaXMpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5fY29udGludWVGZXRjaCgpO1xyXG59O1xyXG5cclxuLy8gUHJvcGVydGllcyBmb3IgRnJ1c3R1bVJlcXVlc2V0UHJpb3JpdGl6ZXJcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShGZXRjaEpvYi5wcm90b3R5cGUsICdpbWFnZVBhcnRQYXJhbXMnLCB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldEltYWdlUGFydFBhcmFtcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW1hZ2VQYXJ0UGFyYW1zO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShGZXRjaEpvYi5wcm90b3R5cGUsICdwcm9ncmVzc2l2ZVN0YWdlc0RvbmUnLCB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldFByb2dyZXNzaXZlU3RhZ2VzRG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvZ3Jlc3NpdmVTdGFnZXNEb25lO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIHN0YXJ0UmVxdWVzdChyZXNvdXJjZSwgc2VsZikge1xyXG4gICAgaWYgKHNlbGYuX2ltYWdlRGF0YUNvbnRleHQgIT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyAnVW5leHBlY3RlZCByZXN0YXJ0IG9mIGFscmVhZHkgc3RhcnRlZCByZXF1ZXN0JztcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHNlbGYuX2lzTWFudWFsbHlBYm9ydGVkKSB7XHJcbiAgICAgICAgaWYgKHJlc291cmNlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNlbGYuX3NjaGVkdWxlci5qb2JEb25lKHJlc291cmNlLCBzZWxmKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBzZWxmLl9yZXNvdXJjZSA9IHJlc291cmNlO1xyXG4gICAgXHJcbiAgICBzZWxmLl9zdGFydEZldGNoKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbnRpbnVlWWllbGRlZFJlcXVlc3QocmVzb3VyY2UsIHNlbGYpIHtcclxuICAgIGlmIChzZWxmLl9pc01hbnVhbGx5QWJvcnRlZCB8fCBzZWxmLl9pc0ZhaWx1cmUpIHtcclxuICAgICAgICBzZWxmLl9zY2hlZHVsZXIuam9iRG9uZShzZWxmLl9yZXNvdXJjZSwgc2VsZik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoIXNlbGYuaXNZaWVsZGVkIHx8IHNlbGYuaXNUZXJtaW5hdGVkKSB7XHJcbiAgICAgICAgdGhyb3cgJ1VuZXhwZWN0ZWQgcmVxdWVzdCBzdGF0ZSBvbiBjb250aW51ZSc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHNlbGYuaXNZaWVsZGVkID0gZmFsc2U7XHJcbiAgICBzZWxmLnJlc291cmNlID0gcmVzb3VyY2U7XHJcbiAgICBcclxuICAgIHNlbGYuX2NvbnRpbnVlRmV0Y2goKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZmV0Y2hZaWVsZGVkQnlTY2hlZHVsZXIoc2VsZikge1xyXG4gICAgaWYgKHNlbGYuX2lzWWllbGRlZCB8fCBzZWxmLl9pc1Rlcm1pbmF0ZWQpIHtcclxuICAgICAgICB0aHJvdyAnVW5leHBlY3RlZCByZXF1ZXN0IHN0YXRlIG9uIHlpZWxkJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgc2VsZi5faXNZaWVsZGVkID0gdHJ1ZTtcclxuICAgIHNlbGYuX3Jlc291cmNlID0gbnVsbDtcclxufVxyXG5cclxuZnVuY3Rpb24gZmV0Y2hBYm9ydGVkQnlTY2hlZHVsZXIoc2VsZikge1xyXG4gICAgc2VsZi5faXNZaWVsZGVkID0gZmFsc2U7XHJcbiAgICBzZWxmLl9yZXNvdXJjZSA9IG51bGw7XHJcbiAgICBzZWxmLl9mZXRjaFRlcm1pbmF0ZWQoLyppc0Fib3J0ZWQ9Ki90cnVlKTtcclxufSIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmV0Y2hNYW5hZ2VyO1xyXG5cclxudmFyIGltYWdlSGVscGVyRnVuY3Rpb25zID0gcmVxdWlyZSgnaW1hZ2VoZWxwZXJmdW5jdGlvbnMuanMnKTtcclxudmFyIEZldGNoSm9iID0gcmVxdWlyZSgnZmV0Y2hqb2IuanMnKTtcclxudmFyIEltYWdlUGFyYW1zUmV0cmlldmVyUHJveHkgPSByZXF1aXJlKCdpbWFnZXBhcmFtc3JldHJpZXZlcnByb3h5LmpzJyk7XHJcblxyXG4vKiBnbG9iYWwgY29uc29sZTogZmFsc2UgKi9cclxuXHJcbmZ1bmN0aW9uIEZldGNoTWFuYWdlcihvcHRpb25zKSB7XHJcbiAgICBJbWFnZVBhcmFtc1JldHJpZXZlclByb3h5LmNhbGwodGhpcywgb3B0aW9ucy5pbWFnZUltcGxlbWVudGF0aW9uQ2xhc3NOYW1lKTtcclxuXHJcbiAgICB2YXIgc2VydmVyUmVxdWVzdHNMaW1pdCA9IG9wdGlvbnMuc2VydmVyUmVxdWVzdHNMaW1pdCB8fCA1O1xyXG4gICAgXHJcbiAgICB0aGlzLl9mZXRjaGVyID0gbnVsbDtcclxuICAgIHRoaXMuX2ludGVybmFsU2l6ZXNQYXJhbXMgPSBudWxsO1xyXG4gICAgdGhpcy5fc2hvd0xvZyA9IG9wdGlvbnMuc2hvd0xvZztcclxuICAgIFxyXG4gICAgaWYgKHRoaXMuX3Nob3dMb2cpIHtcclxuICAgICAgICAvLyBPbGQgSUVcclxuICAgICAgICB0aHJvdyAnc2hvd0xvZyBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlcic7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciBzZXJ2ZXJSZXF1ZXN0U2NoZWR1bGVyID0gaW1hZ2VIZWxwZXJGdW5jdGlvbnMuY3JlYXRlU2NoZWR1bGVyKFxyXG4gICAgICAgIG9wdGlvbnMuc2hvd0xvZyxcclxuICAgICAgICBvcHRpb25zLnNlcnZlclJlcXVlc3RQcmlvcml0aXplcixcclxuICAgICAgICAnc2VydmVyUmVxdWVzdCcsXHJcbiAgICAgICAgY3JlYXRlU2VydmVyUmVxdWVzdER1bW15UmVzb3VyY2UsXHJcbiAgICAgICAgc2VydmVyUmVxdWVzdHNMaW1pdCk7XHJcbiAgICBcclxuICAgIHRoaXMuX3NlcnZlclJlcXVlc3RQcmlvcml0aXplciA9IHNlcnZlclJlcXVlc3RTY2hlZHVsZXIucHJpb3JpdGl6ZXI7XHJcbiAgICBcclxuICAgIHRoaXMuX3NjaGVkdWxlciA9IHNlcnZlclJlcXVlc3RTY2hlZHVsZXIuc2NoZWR1bGVyO1xyXG4gICAgdGhpcy5fY2hhbm5lbEhhbmRsZUNvdW50ZXIgPSAwO1xyXG4gICAgdGhpcy5fY2hhbm5lbEhhbmRsZXMgPSBbXTtcclxuICAgIHRoaXMuX3JlcXVlc3RCeUlkID0gW107XHJcbn1cclxuXHJcbkZldGNoTWFuYWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEltYWdlUGFyYW1zUmV0cmlldmVyUHJveHkucHJvdG90eXBlKTtcclxuXHJcbkZldGNoTWFuYWdlci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIG9wZW4odXJsKSB7XHJcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX2ltYWdlSW1wbGVtZW50YXRpb24uY3JlYXRlRmV0Y2hlcih1cmwsIHtpc1JldHVyblByb21pc2U6IHRydWV9KTtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiAgICAgICAgc2VsZi5fZmV0Y2hlciA9IHJlc3VsdC5mZXRjaGVyO1xyXG4gICAgICAgIHNlbGYuX2ludGVybmFsU2l6ZXNQYXJhbXMgPSByZXN1bHQuc2l6ZXNQYXJhbXM7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zaXplc1BhcmFtcztcclxuICAgIH0pO1xyXG59O1xyXG5cclxuRmV0Y2hNYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZldGNoZXIuY2xvc2Uoe2lzUmV0dXJuUHJvbWlzZTogdHJ1ZX0pO1xyXG59O1xyXG5cclxuRmV0Y2hNYW5hZ2VyLnByb3RvdHlwZS5zZXRJc1Byb2dyZXNzaXZlUmVxdWVzdCA9IGZ1bmN0aW9uIHNldElzUHJvZ3Jlc3NpdmVSZXF1ZXN0KFxyXG4gICAgcmVxdWVzdElkLCBpc1Byb2dyZXNzaXZlKSB7XHJcbiAgICBcclxuICAgIHZhciBmZXRjaEpvYiA9IHRoaXMuX3JlcXVlc3RCeUlkW3JlcXVlc3RJZF07XHJcbiAgICBpZiAoZmV0Y2hKb2IgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vIFRoaXMgc2l0dWF0aW9uIG1pZ2h0IG9jY3VyIGlmIHJlcXVlc3QgaGFzIGJlZW4gdGVybWluYXRlZCxcclxuICAgICAgICAvLyBidXQgdXNlcidzIHRlcm1pbmF0ZWRDYWxsYmFjayBoYXMgbm90IGJlZW4gY2FsbGVkIHlldC4gSXRcclxuICAgICAgICAvLyBoYXBwZW5zIG9uIFdvcmtlclByb3h5RmV0Y2hNYW5hZ2VyIGR1ZSB0byB0aHJlYWRcclxuICAgICAgICAvLyBtZXNzYWdlIGRlbGF5LlxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmZXRjaEpvYi5zZXRJc1Byb2dyZXNzaXZlKGlzUHJvZ3Jlc3NpdmUpO1xyXG59O1xyXG5cclxuRmV0Y2hNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVDaGFubmVsID0gZnVuY3Rpb24gY3JlYXRlQ2hhbm5lbChcclxuICAgIGNyZWF0ZWRDYWxsYmFjaykge1xyXG4gICAgXHJcbiAgICB2YXIgY2hhbm5lbEhhbmRsZSA9ICsrdGhpcy5fY2hhbm5lbEhhbmRsZUNvdW50ZXI7XHJcbiAgICB0aGlzLl9jaGFubmVsSGFuZGxlc1tjaGFubmVsSGFuZGxlXSA9IG5ldyBGZXRjaEpvYihcclxuICAgICAgICB0aGlzLl9mZXRjaGVyLFxyXG4gICAgICAgIHRoaXMuX3NjaGVkdWxlcixcclxuICAgICAgICBGZXRjaEpvYi5GRVRDSF9UWVBFX0NIQU5ORUwsXHJcbiAgICAgICAgLypjb250ZXh0VmFycz0qL251bGwpO1xyXG5cclxuICAgIGNyZWF0ZWRDYWxsYmFjayhjaGFubmVsSGFuZGxlKTtcclxufTtcclxuXHJcbkZldGNoTWFuYWdlci5wcm90b3R5cGUubW92ZUNoYW5uZWwgPSBmdW5jdGlvbiBtb3ZlQ2hhbm5lbChcclxuICAgIGNoYW5uZWxIYW5kbGUsIGltYWdlUGFydFBhcmFtcykge1xyXG4gICAgXHJcbiAgICB2YXIgY2hhbm5lbCA9IHRoaXMuX2NoYW5uZWxIYW5kbGVzW2NoYW5uZWxIYW5kbGVdO1xyXG4gICAgY2hhbm5lbC5mZXRjaChpbWFnZVBhcnRQYXJhbXMpO1xyXG59O1xyXG5cclxuRmV0Y2hNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24gY3JlYXRlUmVxdWVzdChcclxuICAgIGZldGNoUGFyYW1zLFxyXG4gICAgY2FsbGJhY2tUaGlzLFxyXG4gICAgY2FsbGJhY2ssXHJcbiAgICB0ZXJtaW5hdGVkQ2FsbGJhY2ssXHJcbiAgICBpc09ubHlXYWl0Rm9yRGF0YSxcclxuICAgIHJlcXVlc3RJZCkge1xyXG4gICAgXHJcbiAgICB2YXIgY29udGV4dFZhcnMgPSB7XHJcbiAgICAgICAgcHJvZ3Jlc3NpdmVTdGFnZXNEb25lOiAwLFxyXG4gICAgICAgIGlzTGFzdENhbGxiYWNrQ2FsbGVkV2l0aG91dExvd1F1YWxpdHlMaW1pdDogZmFsc2UsXHJcbiAgICAgICAgY2FsbGJhY2tUaGlzOiBjYWxsYmFja1RoaXMsXHJcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxyXG4gICAgICAgIHRlcm1pbmF0ZWRDYWxsYmFjazogdGVybWluYXRlZENhbGxiYWNrLFxyXG4gICAgICAgIHJlcXVlc3RJZDogcmVxdWVzdElkLFxyXG4gICAgICAgIGZldGNoSm9iOiBudWxsLFxyXG4gICAgICAgIHNlbGY6IHRoaXNcclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciBmZXRjaFR5cGUgPSBpc09ubHlXYWl0Rm9yRGF0YSA/XHJcbiAgICAgICAgRmV0Y2hKb2IuRkVUQ0hfVFlQRV9PTkxZX1dBSVRfRk9SX0RBVEEgOiBGZXRjaEpvYi5GRVRDSF9UWVBFX1JFUVVFU1Q7XHJcbiAgICBcclxuICAgIHZhciBmZXRjaEpvYiA9IG5ldyBGZXRjaEpvYihcclxuICAgICAgICB0aGlzLl9mZXRjaGVyLCB0aGlzLl9zY2hlZHVsZXIsIGZldGNoVHlwZSwgY29udGV4dFZhcnMpO1xyXG4gICAgXHJcbiAgICBjb250ZXh0VmFycy5mZXRjaEpvYiA9IGZldGNoSm9iO1xyXG4gICAgXHJcbiAgICBpZiAodGhpcy5fcmVxdWVzdEJ5SWRbcmVxdWVzdElkXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhyb3cgJ0R1cGxpY2F0aW9uIG9mIHJlcXVlc3RJZCAnICsgcmVxdWVzdElkO1xyXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0SWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRoaXMuX3JlcXVlc3RCeUlkW3JlcXVlc3RJZF0gPSBmZXRjaEpvYjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZmV0Y2hKb2Iub24oJ2RhdGEnLCBpbnRlcm5hbENhbGxiYWNrKTtcclxuICAgIGZldGNoSm9iLm9uKCd0ZXJtaW5hdGVkJywgaW50ZXJuYWxUZXJtaW5hdGVkQ2FsbGJhY2spO1xyXG4gICAgXHJcbiAgICBmZXRjaEpvYi5mZXRjaChmZXRjaFBhcmFtcyk7XHJcbn07XHJcblxyXG5GZXRjaE1hbmFnZXIucHJvdG90eXBlLm1hbnVhbEFib3J0UmVxdWVzdCA9IGZ1bmN0aW9uIG1hbnVhbEFib3J0UmVxdWVzdChcclxuICAgIHJlcXVlc3RJZCkge1xyXG4gICAgXHJcbiAgICB2YXIgZmV0Y2hKb2IgPSB0aGlzLl9yZXF1ZXN0QnlJZFtyZXF1ZXN0SWRdO1xyXG4gICAgXHJcbiAgICBpZiAoZmV0Y2hKb2IgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vIFRoaXMgc2l0dWF0aW9uIG1pZ2h0IG9jY3VyIGlmIHJlcXVlc3QgaGFzIGJlZW4gdGVybWluYXRlZCxcclxuICAgICAgICAvLyBidXQgdXNlcidzIHRlcm1pbmF0ZWRDYWxsYmFjayBoYXMgbm90IGJlZW4gY2FsbGVkIHlldC4gSXRcclxuICAgICAgICAvLyBoYXBwZW5zIG9uIFdvcmtlclByb3h5RmV0Y2hNYW5hZ2VyIGR1ZSB0byB3ZWIgd29ya2VyXHJcbiAgICAgICAgLy8gbWVzc2FnZSBkZWxheS5cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZldGNoSm9iLm1hbnVhbEFib3J0UmVxdWVzdCgpO1xyXG4gICAgZGVsZXRlIHRoaXMuX3JlcXVlc3RCeUlkW3JlcXVlc3RJZF07XHJcbn07XHJcblxyXG5GZXRjaE1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uIHJlY29ubmVjdCgpIHtcclxuICAgIHRoaXMuX2ZldGNoZXIucmVjb25uZWN0KCk7XHJcbn07XHJcblxyXG5GZXRjaE1hbmFnZXIucHJvdG90eXBlLnNldFNlcnZlclJlcXVlc3RQcmlvcml0aXplckRhdGEgPVxyXG4gICAgZnVuY3Rpb24gc2V0U2VydmVyUmVxdWVzdFByaW9yaXRpemVyRGF0YShwcmlvcml0aXplckRhdGEpIHtcclxuICAgICAgICBpZiAodGhpcy5fc2VydmVyUmVxdWVzdFByaW9yaXRpemVyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93ICdObyBzZXJ2ZXJSZXF1ZXN0IHByaW9yaXRpemVyIGhhcyBiZWVuIHNldCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh0aGlzLl9zaG93TG9nKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdzZXRTZXJ2ZXJSZXF1ZXN0UHJpb3JpdGl6ZXJEYXRhKCcgKyBwcmlvcml0aXplckRhdGEgKyAnKScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBwcmlvcml0aXplckRhdGEuaW1hZ2UgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX3NlcnZlclJlcXVlc3RQcmlvcml0aXplci5zZXRQcmlvcml0aXplckRhdGEocHJpb3JpdGl6ZXJEYXRhKTtcclxuICAgIH07XHJcblxyXG5GZXRjaE1hbmFnZXIucHJvdG90eXBlLl9nZXRTaXplc1BhcmFtc0ludGVybmFsID0gZnVuY3Rpb24gZ2V0U2l6ZXNQYXJhbXNJbnRlcm5hbCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFNpemVzUGFyYW1zO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gaW50ZXJuYWxDYWxsYmFjayhjb250ZXh0VmFycywgaW1hZ2VEYXRhQ29udGV4dCkge1xyXG4gICAgdmFyIGlzUHJvZ3Jlc3NpdmUgPSBjb250ZXh0VmFycy5mZXRjaEpvYi5nZXRJc1Byb2dyZXNzaXZlKCk7XHJcbiAgICB2YXIgaXNMaW1pdFRvTG93UXVhbGl0eSA9IFxyXG4gICAgICAgIGNvbnRleHRWYXJzLnByb2dyZXNzaXZlU3RhZ2VzRG9uZSA9PT0gMDtcclxuICAgIFxyXG4gICAgLy8gU2VlIGNvbW1lbnQgYXQgaW50ZXJuYWxUZXJtaW5hdGVkQ2FsbGJhY2sgbWV0aG9kXHJcbiAgICBjb250ZXh0VmFycy5pc0xhc3RDYWxsYmFja0NhbGxlZFdpdGhvdXRMb3dRdWFsaXR5TGltaXQgfD1cclxuICAgICAgICBpc1Byb2dyZXNzaXZlICYmICFpc0xpbWl0VG9Mb3dRdWFsaXR5O1xyXG4gICAgXHJcbiAgICBpZiAoIWlzUHJvZ3Jlc3NpdmUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciBxdWFsaXR5ID0gaXNMaW1pdFRvTG93UXVhbGl0eSA/IGNvbnRleHRWYXJzLnNlbGYuZ2V0TG93ZXN0UXVhbGl0eSgpIDogdW5kZWZpbmVkO1xyXG4gICAgXHJcbiAgICArK2NvbnRleHRWYXJzLnByb2dyZXNzaXZlU3RhZ2VzRG9uZTtcclxuICAgIFxyXG4gICAgZXh0cmFjdERhdGFBbmRDYWxsQ2FsbGJhY2soY29udGV4dFZhcnMsIGltYWdlRGF0YUNvbnRleHQsIHF1YWxpdHkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbnRlcm5hbFRlcm1pbmF0ZWRDYWxsYmFjayhjb250ZXh0VmFycywgaW1hZ2VEYXRhQ29udGV4dCwgaXNBYm9ydGVkKSB7XHJcbiAgICBpZiAoIWNvbnRleHRWYXJzLmlzTGFzdENhbGxiYWNrQ2FsbGVkV2l0aG91dExvd1F1YWxpdHlMaW1pdCkge1xyXG4gICAgICAgIC8vIFRoaXMgY29uZGl0aW9uIGNvbWUgdG8gY2hlY2sgaWYgYW5vdGhlciBkZWNvZGluZyBzaG91bGQgYmUgZG9uZS5cclxuICAgICAgICAvLyBPbmUgc2l0dWF0aW9uIGl0IG1heSBoYXBwZW4gaXMgd2hlbiB0aGUgcmVxdWVzdCBpcyBub3RcclxuICAgICAgICAvLyBwcm9ncmVzc2l2ZSwgdGhlbiB0aGUgZGVjb2RpbmcgaXMgZG9uZSBvbmx5IG9uIHRlcm1pbmF0aW9uLlxyXG4gICAgICAgIC8vIEFub3RoZXIgc2l0dWF0aW9uIGlzIHdoZW4gb25seSB0aGUgZmlyc3Qgc3RhZ2UgaGFzIGJlZW4gcmVhY2hlZCxcclxuICAgICAgICAvLyB0aHVzIHRoZSBjYWxsYmFjayB3YXMgY2FsbGVkIHdpdGggb25seSB0aGUgZmlyc3QgcXVhbGl0eSAoZm9yXHJcbiAgICAgICAgLy8gcGVyZm9ybWFuY2UgcmVhc29ucykuIFRodXMgYW5vdGhlciBkZWNvZGluZyBzaG91bGQgYmUgZG9uZS5cclxuICAgICAgICBcclxuICAgICAgICBleHRyYWN0RGF0YUFuZENhbGxDYWxsYmFjayhjb250ZXh0VmFycywgaW1hZ2VEYXRhQ29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnRleHRWYXJzLnRlcm1pbmF0ZWRDYWxsYmFjay5jYWxsKFxyXG4gICAgICAgIGNvbnRleHRWYXJzLmNhbGxiYWNrVGhpcywgaXNBYm9ydGVkKTtcclxuICAgIFxyXG4gICAgZGVsZXRlIGNvbnRleHRWYXJzLnNlbGYuX3JlcXVlc3RCeUlkW2NvbnRleHRWYXJzLnJlcXVlc3RJZF07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4dHJhY3REYXRhQW5kQ2FsbENhbGxiYWNrKGNvbnRleHRWYXJzLCBpbWFnZURhdGFDb250ZXh0LCBxdWFsaXR5KSB7XHJcbiAgICB2YXIgZGF0YUZvckRlY29kZSA9IGltYWdlRGF0YUNvbnRleHQuZ2V0RmV0Y2hlZERhdGEocXVhbGl0eSk7XHJcbiAgICBcclxuICAgIGNvbnRleHRWYXJzLmNhbGxiYWNrLmNhbGwoXHJcbiAgICAgICAgY29udGV4dFZhcnMuY2FsbGJhY2tUaGlzLCBkYXRhRm9yRGVjb2RlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU2VydmVyUmVxdWVzdER1bW15UmVzb3VyY2UoKSB7XHJcbiAgICByZXR1cm4ge307XHJcbn0iLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZydXN0dW1SZXF1ZXN0c1ByaW9yaXRpemVyO1xyXG52YXIgUFJJT1JJVFlfQUJPUlRfTk9UX0lOX0ZSVVNUVU0gPSAtMTtcclxudmFyIFBSSU9SSVRZX0NBTENVTEFUSU9OX0ZBSUxFRCA9IDA7XHJcbnZhciBQUklPUklUWV9UT09fR09PRF9SRVNPTFVUSU9OID0gMTtcclxudmFyIFBSSU9SSVRZX05PVF9JTl9GUlVTVFVNID0gMjtcclxudmFyIFBSSU9SSVRZX0xPV0VSX1JFU09MVVRJT04gPSAzO1xyXG5cclxudmFyIFBSSU9SSVRZX01JTk9SSVRZX0lOX0ZSVVNUVU0gPSA0O1xyXG52YXIgUFJJT1JJVFlfUEFSVElBTF9JTl9GUlVTVFVNID0gNTtcclxudmFyIFBSSU9SSVRZX01BSk9SSVRZX0lOX0ZSVVNUVU0gPSA2O1xyXG52YXIgUFJJT1JJVFlfRlVMTFlfSU5fRlJVU1RVTSA9IDc7XHJcblxyXG52YXIgQUREX1BSSU9SSVRZX1RPX0xPV19RVUFMSVRZID0gNTtcclxuXHJcbnZhciBQUklPUklUWV9ISUdIRVNUID0gMTM7XHJcblxyXG52YXIgbG9nMiA9IE1hdGgubG9nKDIpO1xyXG5cclxuZnVuY3Rpb24gRnJ1c3R1bVJlcXVlc3RzUHJpb3JpdGl6ZXIoXHJcbiAgICBpc0Fib3J0UmVxdWVzdHNOb3RJbkZydXN0dW0sIGlzUHJpb3JpdGl6ZUxvd1Byb2dyZXNzaXZlU3RhZ2UpIHtcclxuICAgIFxyXG4gICAgdGhpcy5fZnJ1c3R1bURhdGEgPSBudWxsO1xyXG4gICAgdGhpcy5faXNBYm9ydFJlcXVlc3RzTm90SW5GcnVzdHVtID0gaXNBYm9ydFJlcXVlc3RzTm90SW5GcnVzdHVtO1xyXG4gICAgdGhpcy5faXNQcmlvcml0aXplTG93UHJvZ3Jlc3NpdmVTdGFnZSA9IGlzUHJpb3JpdGl6ZUxvd1Byb2dyZXNzaXZlU3RhZ2U7XHJcbn1cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShcclxuICAgIEZydXN0dW1SZXF1ZXN0c1ByaW9yaXRpemVyLnByb3RvdHlwZSwgJ21pbmltYWxMb3dRdWFsaXR5UHJpb3JpdHknLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBtaW5pbWFsTG93UXVhbGl0eVByaW9yaXR5KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUFJJT1JJVFlfTUlOT1JJVFlfSU5fRlJVU1RVTSArIEFERF9QUklPUklUWV9UT19MT1dfUVVBTElUWTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbik7XHJcbiAgICBcclxuRnJ1c3R1bVJlcXVlc3RzUHJpb3JpdGl6ZXIucHJvdG90eXBlLnNldFByaW9yaXRpemVyRGF0YSA9IGZ1bmN0aW9uIHNldFByaW9yaXRpemVyRGF0YShwcmlvcml0aXplckRhdGEpIHtcclxuICAgIHRoaXMuX2ZydXN0dW1EYXRhID0gcHJpb3JpdGl6ZXJEYXRhO1xyXG59O1xyXG5cclxuRnJ1c3R1bVJlcXVlc3RzUHJpb3JpdGl6ZXIucHJvdG90eXBlLmdldFByaW9yaXR5ID0gZnVuY3Rpb24gZ2V0UHJpb3JpdHkoam9iQ29udGV4dCkge1xyXG4gICAgdmFyIGltYWdlUGFydFBhcmFtcyA9IGpvYkNvbnRleHQuaW1hZ2VQYXJ0UGFyYW1zO1xyXG4gICAgaWYgKGltYWdlUGFydFBhcmFtcy5yZXF1ZXN0UHJpb3JpdHlEYXRhLm92ZXJyaWRlSGlnaGVzdFByaW9yaXR5KSB7XHJcbiAgICAgICAgcmV0dXJuIFBSSU9SSVRZX0hJR0hFU1Q7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHByaW9yaXR5ID0gdGhpcy5fZ2V0UHJpb3JpdHlJbnRlcm5hbChpbWFnZVBhcnRQYXJhbXMpO1xyXG4gICAgdmFyIGlzSW5GcnVzdHVtID0gcHJpb3JpdHkgPj0gUFJJT1JJVFlfTUlOT1JJVFlfSU5fRlJVU1RVTTtcclxuICAgIFxyXG4gICAgaWYgKHRoaXMuX2lzQWJvcnRSZXF1ZXN0c05vdEluRnJ1c3R1bSAmJiAhaXNJbkZydXN0dW0pIHtcclxuICAgICAgICByZXR1cm4gUFJJT1JJVFlfQUJPUlRfTk9UX0lOX0ZSVVNUVU07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciBwcmlvcml0aXplTG93UHJvZ3Jlc3NpdmVTdGFnZSA9IDA7XHJcbiAgICBcclxuICAgIGlmICh0aGlzLl9pc1ByaW9yaXRpemVMb3dQcm9ncmVzc2l2ZVN0YWdlICYmIGlzSW5GcnVzdHVtKSB7XHJcbiAgICAgICAgaWYgKGpvYkNvbnRleHQucHJvZ3Jlc3NpdmVTdGFnZXNEb25lID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgJ01pc3NpbmcgcHJvZ3Jlc3NpdmUgc3RhZ2UgaW5mb3JtYXRpb24nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBwcmlvcml0aXplTG93UHJvZ3Jlc3NpdmVTdGFnZSA9XHJcbiAgICAgICAgICAgIGpvYkNvbnRleHQucHJvZ3Jlc3NpdmVTdGFnZXNEb25lID09PSAwID8gQUREX1BSSU9SSVRZX1RPX0xPV19RVUFMSVRZIDpcclxuICAgICAgICAgICAgam9iQ29udGV4dC5wcm9ncmVzc2l2ZVN0YWdlc0RvbmUgPT09IDEgPyAxIDpcclxuICAgICAgICAgICAgMDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHByaW9yaXR5ICsgcHJpb3JpdGl6ZUxvd1Byb2dyZXNzaXZlU3RhZ2U7XHJcbn07XHJcblxyXG5GcnVzdHVtUmVxdWVzdHNQcmlvcml0aXplci5wcm90b3R5cGUuX2dldFByaW9yaXR5SW50ZXJuYWwgPSBmdW5jdGlvbiBnZXRQcmlvcml0eUludGVybmFsKGltYWdlUGFydFBhcmFtcykge1xyXG4gICAgaWYgKHRoaXMuX2ZydXN0dW1EYXRhID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIFBSSU9SSVRZX0NBTENVTEFUSU9OX0ZBSUxFRDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHRoaXMuX2ZydXN0dW1EYXRhLmltYWdlUmVjdGFuZ2xlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aHJvdyAnTm8gaW1hZ2VSZWN0YW5nbGUgaW5mb3JtYXRpb24gcGFzc2VkIGluIHNldFByaW9yaXRpemVyRGF0YSc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciBleGFjdEZydXN0dW1MZXZlbCA9IHRoaXMuX2ZydXN0dW1EYXRhLmV4YWN0bGV2ZWw7XHJcbiAgICBcclxuICAgIGlmICh0aGlzLl9mcnVzdHVtRGF0YS5leGFjdGxldmVsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aHJvdyAnTm8gZXhhY3RsZXZlbCBpbmZvcm1hdGlvbiBwYXNzZWQgaW4gJyArXHJcbiAgICAgICAgICAgICdzZXRQcmlvcml0aXplckRhdGEuIFVzZSBudWxsIGlmIHVua25vd24nO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2YXIgdGlsZVdlc3QgPSB0aGlzLl9waXhlbFRvQ2FydG9ncmFwaGljWChcclxuICAgICAgICBpbWFnZVBhcnRQYXJhbXMubWluWCwgaW1hZ2VQYXJ0UGFyYW1zKTtcclxuICAgIHZhciB0aWxlRWFzdCA9IHRoaXMuX3BpeGVsVG9DYXJ0b2dyYXBoaWNYKFxyXG4gICAgICAgIGltYWdlUGFydFBhcmFtcy5tYXhYRXhjbHVzaXZlLCBpbWFnZVBhcnRQYXJhbXMpO1xyXG4gICAgdmFyIHRpbGVOb3J0aCA9IHRoaXMuX3BpeGVsVG9DYXJ0b2dyYXBoaWNZKFxyXG4gICAgICAgIGltYWdlUGFydFBhcmFtcy5taW5ZLCBpbWFnZVBhcnRQYXJhbXMpO1xyXG4gICAgdmFyIHRpbGVTb3V0aCA9IHRoaXMuX3BpeGVsVG9DYXJ0b2dyYXBoaWNZKFxyXG4gICAgICAgIGltYWdlUGFydFBhcmFtcy5tYXhZRXhjbHVzaXZlLCBpbWFnZVBhcnRQYXJhbXMpO1xyXG4gICAgXHJcbiAgICB2YXIgdGlsZVBpeGVsc1dpZHRoID1cclxuICAgICAgICBpbWFnZVBhcnRQYXJhbXMubWF4WEV4Y2x1c2l2ZSAtIGltYWdlUGFydFBhcmFtcy5taW5YO1xyXG4gICAgdmFyIHRpbGVQaXhlbHNIZWlnaHQgPVxyXG4gICAgICAgIGltYWdlUGFydFBhcmFtcy5tYXhZRXhjbHVzaXZlIC0gaW1hZ2VQYXJ0UGFyYW1zLm1pblk7XHJcbiAgICBcclxuICAgIHZhciByZXF1ZXN0VG9GcnVzdHVtUmVzb2x1dGlvblJhdGlvO1xyXG4gICAgdmFyIHRpbGVMZXZlbCA9IGltYWdlUGFydFBhcmFtcy5sZXZlbCB8fCAwO1xyXG4gICAgaWYgKGV4YWN0RnJ1c3R1bUxldmVsID09PSBudWxsKSB7XHJcbiAgICAgICAgdmFyIHRpbGVSZXNvbHV0aW9uWCA9IHRpbGVQaXhlbHNXaWR0aCAvICh0aWxlRWFzdCAtIHRpbGVXZXN0KTtcclxuICAgICAgICB2YXIgdGlsZVJlc29sdXRpb25ZID0gdGlsZVBpeGVsc0hlaWdodCAvICh0aWxlTm9ydGggLSB0aWxlU291dGgpO1xyXG4gICAgICAgIHZhciB0aWxlUmVzb2x1dGlvbiA9IE1hdGgubWF4KHRpbGVSZXNvbHV0aW9uWCwgdGlsZVJlc29sdXRpb25ZKTtcclxuICAgICAgICB2YXIgZnJ1c3R1bVJlc29sdXRpb24gPSB0aGlzLl9mcnVzdHVtRGF0YS5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHJlcXVlc3RUb0ZydXN0dW1SZXNvbHV0aW9uUmF0aW8gPSB0aWxlUmVzb2x1dGlvbiAvIGZydXN0dW1SZXNvbHV0aW9uO1xyXG4gICAgXHJcbiAgICAgICAgaWYgKHJlcXVlc3RUb0ZydXN0dW1SZXNvbHV0aW9uUmF0aW8gPiAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQUklPUklUWV9UT09fR09PRF9SRVNPTFVUSU9OO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGlsZUxldmVsIDwgZXhhY3RGcnVzdHVtTGV2ZWwpIHtcclxuICAgICAgICByZXR1cm4gUFJJT1JJVFlfVE9PX0dPT0RfUkVTT0xVVElPTjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmFyIGZydXN0dW1SZWN0YW5nbGUgPSB0aGlzLl9mcnVzdHVtRGF0YS5yZWN0YW5nbGU7XHJcbiAgICB2YXIgaW50ZXJzZWN0aW9uV2VzdCA9IE1hdGgubWF4KGZydXN0dW1SZWN0YW5nbGUud2VzdCwgdGlsZVdlc3QpO1xyXG4gICAgdmFyIGludGVyc2VjdGlvbkVhc3QgPSBNYXRoLm1pbihmcnVzdHVtUmVjdGFuZ2xlLmVhc3QsIHRpbGVFYXN0KTtcclxuICAgIHZhciBpbnRlcnNlY3Rpb25Tb3V0aCA9IE1hdGgubWF4KGZydXN0dW1SZWN0YW5nbGUuc291dGgsIHRpbGVTb3V0aCk7XHJcbiAgICB2YXIgaW50ZXJzZWN0aW9uTm9ydGggPSBNYXRoLm1pbihmcnVzdHVtUmVjdGFuZ2xlLm5vcnRoLCB0aWxlTm9ydGgpO1xyXG4gICAgXHJcbiAgICB2YXIgaW50ZXJzZWN0aW9uV2lkdGggPSBpbnRlcnNlY3Rpb25FYXN0IC0gaW50ZXJzZWN0aW9uV2VzdDtcclxuICAgIHZhciBpbnRlcnNlY3Rpb25IZWlnaHQgPSBpbnRlcnNlY3Rpb25Ob3J0aCAtIGludGVyc2VjdGlvblNvdXRoO1xyXG4gICAgXHJcbiAgICBpZiAoaW50ZXJzZWN0aW9uV2lkdGggPCAwIHx8IGludGVyc2VjdGlvbkhlaWdodCA8IDApIHtcclxuICAgICAgICByZXR1cm4gUFJJT1JJVFlfTk9UX0lOX0ZSVVNUVU07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChleGFjdEZydXN0dW1MZXZlbCAhPT0gbnVsbCkge1xyXG4gICAgICAgIGlmICh0aWxlTGV2ZWwgPiBleGFjdEZydXN0dW1MZXZlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUFJJT1JJVFlfTE9XRVJfUkVTT0xVVElPTjtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRpbGVMZXZlbCA+IDAgJiYgcmVxdWVzdFRvRnJ1c3R1bVJlc29sdXRpb25SYXRpbyA8IDAuMjUpIHtcclxuICAgICAgICByZXR1cm4gUFJJT1JJVFlfTE9XRVJfUkVTT0xVVElPTjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmFyIGludGVyc2VjdGlvbkFyZWEgPSBpbnRlcnNlY3Rpb25XaWR0aCAqIGludGVyc2VjdGlvbkhlaWdodDtcclxuICAgIHZhciB0aWxlQXJlYSA9ICh0aWxlRWFzdCAtIHRpbGVXZXN0KSAqICh0aWxlTm9ydGggLSB0aWxlU291dGgpO1xyXG4gICAgdmFyIHBhcnRJbkZydXN0dW0gPSBpbnRlcnNlY3Rpb25BcmVhIC8gdGlsZUFyZWE7XHJcbiAgICBcclxuICAgIGlmIChwYXJ0SW5GcnVzdHVtID4gMC45OSkge1xyXG4gICAgICAgIHJldHVybiBQUklPUklUWV9GVUxMWV9JTl9GUlVTVFVNO1xyXG4gICAgfSBlbHNlIGlmIChwYXJ0SW5GcnVzdHVtID4gMC43KSB7XHJcbiAgICAgICAgcmV0dXJuIFBSSU9SSVRZX01BSk9SSVRZX0lOX0ZSVVNUVU07XHJcbiAgICB9IGVsc2UgaWYgKHBhcnRJbkZydXN0dW0gPiAwLjMpIHtcclxuICAgICAgICByZXR1cm4gUFJJT1JJVFlfUEFSVElBTF9JTl9GUlVTVFVNO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gUFJJT1JJVFlfTUlOT1JJVFlfSU5fRlJVU1RVTTtcclxuICAgIH1cclxufTtcclxuXHJcbkZydXN0dW1SZXF1ZXN0c1ByaW9yaXRpemVyLnByb3RvdHlwZS5fcGl4ZWxUb0NhcnRvZ3JhcGhpY1ggPSBmdW5jdGlvbiBwaXhlbFRvQ2FydG9ncmFwaGljWChcclxuICAgIHgsIGltYWdlUGFydFBhcmFtcykge1xyXG4gICAgXHJcbiAgICB2YXIgcmVsYXRpdmVYID0geCAvIHRoaXMuX2ZydXN0dW1EYXRhLmltYWdlLmdldExldmVsV2lkdGgoXHJcbiAgICAgICAgaW1hZ2VQYXJ0UGFyYW1zLmxldmVsKTtcclxuICAgIFxyXG4gICAgdmFyIGltYWdlUmVjdGFuZ2xlID0gdGhpcy5fZnJ1c3R1bURhdGEuaW1hZ2VSZWN0YW5nbGU7XHJcbiAgICB2YXIgcmVjdGFuZ2xlV2lkdGggPSBpbWFnZVJlY3RhbmdsZS5lYXN0IC0gaW1hZ2VSZWN0YW5nbGUud2VzdDtcclxuICAgIFxyXG4gICAgdmFyIHhQcm9qZWN0ZWQgPSBpbWFnZVJlY3RhbmdsZS53ZXN0ICsgcmVsYXRpdmVYICogcmVjdGFuZ2xlV2lkdGg7XHJcbiAgICByZXR1cm4geFByb2plY3RlZDtcclxufTtcclxuXHJcbkZydXN0dW1SZXF1ZXN0c1ByaW9yaXRpemVyLnByb3RvdHlwZS5fcGl4ZWxUb0NhcnRvZ3JhcGhpY1kgPSBmdW5jdGlvbiB0aWxlVG9DYXJ0b2dyYXBoaWNZKFxyXG4gICAgeSwgaW1hZ2VQYXJ0UGFyYW1zLCBpbWFnZSkge1xyXG4gICAgXHJcbiAgICB2YXIgcmVsYXRpdmVZID0geSAvIHRoaXMuX2ZydXN0dW1EYXRhLmltYWdlLmdldExldmVsSGVpZ2h0KFxyXG4gICAgICAgIGltYWdlUGFydFBhcmFtcy5sZXZlbCk7XHJcbiAgICBcclxuICAgIHZhciBpbWFnZVJlY3RhbmdsZSA9IHRoaXMuX2ZydXN0dW1EYXRhLmltYWdlUmVjdGFuZ2xlO1xyXG4gICAgdmFyIHJlY3RhbmdsZUhlaWdodCA9IGltYWdlUmVjdGFuZ2xlLm5vcnRoIC0gaW1hZ2VSZWN0YW5nbGUuc291dGg7XHJcbiAgICBcclxuICAgIHZhciB5UHJvamVjdGVkID0gaW1hZ2VSZWN0YW5nbGUubm9ydGggLSByZWxhdGl2ZVkgKiByZWN0YW5nbGVIZWlnaHQ7XHJcbiAgICByZXR1cm4geVByb2plY3RlZDtcclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2hNYXA7XHJcblxyXG52YXIgTGlua2VkTGlzdCA9IHJlcXVpcmUoJ2xpbmtlZGxpc3QuanMnKTtcclxuXHJcbmZ1bmN0aW9uIEhhc2hNYXAoaGFzaGVyKSB7XHJcbiAgICB0aGlzLl9ieUtleSA9IFtdO1xyXG4gICAgdGhpcy5faGFzaGVyID0gaGFzaGVyO1xyXG59XHJcblxyXG5IYXNoTWFwLnByb3RvdHlwZS5nZXRGcm9tS2V5ID0gZnVuY3Rpb24gZ2V0RnJvbUtleShrZXkpIHtcclxuICAgIHZhciBoYXNoQ29kZSA9IHRoaXMuX2hhc2hlci5nZXRIYXNoQ29kZShrZXkpO1xyXG4gICAgdmFyIGhhc2hFbGVtZW50cyA9IHRoaXMuX2J5S2V5W2hhc2hDb2RlXTtcclxuICAgIGlmICghaGFzaEVsZW1lbnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciBpdGVyYXRvciA9IGhhc2hFbGVtZW50cy5nZXRGaXJzdEl0ZXJhdG9yKCk7XHJcbiAgICB3aGlsZSAoaXRlcmF0b3IgIT09IG51bGwpIHtcclxuICAgICAgICB2YXIgaXRlbSA9IGhhc2hFbGVtZW50cy5nZXRWYWx1ZShpdGVyYXRvcik7XHJcbiAgICAgICAgaWYgKHRoaXMuX2hhc2hlci5pc0VxdWFsKGl0ZW0ua2V5LCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpdGVyYXRvciA9IGhhc2hFbGVtZW50cy5nZXROZXh0SXRlcmF0b3IoaXRlcmF0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuSGFzaE1hcC5wcm90b3R5cGUuZ2V0RnJvbUl0ZXJhdG9yID0gZnVuY3Rpb24gZ2V0RnJvbUl0ZXJhdG9yKGl0ZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gaXRlcmF0b3IuX2hhc2hFbGVtZW50cy5nZXRWYWx1ZShpdGVyYXRvci5faW50ZXJuYWxJdGVyYXRvcikudmFsdWU7XHJcbn07XHJcblxyXG5IYXNoTWFwLnByb3RvdHlwZS50cnlBZGQgPSBmdW5jdGlvbiB0cnlBZGQoa2V5LCBjcmVhdGVWYWx1ZSkge1xyXG4gICAgdmFyIGhhc2hDb2RlID0gdGhpcy5faGFzaGVyLmdldEhhc2hDb2RlKGtleSk7XHJcbiAgICB2YXIgaGFzaEVsZW1lbnRzID0gdGhpcy5fYnlLZXlbaGFzaENvZGVdO1xyXG4gICAgaWYgKCFoYXNoRWxlbWVudHMpIHtcclxuICAgICAgICBoYXNoRWxlbWVudHMgPSBuZXcgTGlua2VkTGlzdCgpO1xyXG4gICAgICAgIHRoaXMuX2J5S2V5W2hhc2hDb2RlXSA9IGhhc2hFbGVtZW50cyA7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciBpdGVyYXRvciA9IHtcclxuICAgICAgICBfaGFzaENvZGU6IGhhc2hDb2RlLFxyXG4gICAgICAgIF9oYXNoRWxlbWVudHM6IGhhc2hFbGVtZW50cyxcclxuICAgICAgICBfaW50ZXJuYWxJdGVyYXRvcjogbnVsbFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgaXRlcmF0b3IuX2ludGVybmFsSXRlcmF0b3IgPSBoYXNoRWxlbWVudHMuZ2V0Rmlyc3RJdGVyYXRvcigpO1xyXG4gICAgd2hpbGUgKGl0ZXJhdG9yLl9pbnRlcm5hbEl0ZXJhdG9yICE9PSBudWxsKSB7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSBoYXNoRWxlbWVudHMuZ2V0VmFsdWUoaXRlcmF0b3IuX2ludGVybmFsSXRlcmF0b3IpO1xyXG4gICAgICAgIGlmICh0aGlzLl9oYXNoZXIuaXNFcXVhbChpdGVtLmtleSwga2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgaXRlcmF0b3I6IGl0ZXJhdG9yLFxyXG4gICAgICAgICAgICAgICAgaXNOZXc6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW0udmFsdWVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaXRlcmF0b3IuX2ludGVybmFsSXRlcmF0b3IgPSBoYXNoRWxlbWVudHMuZ2V0TmV4dEl0ZXJhdG9yKGl0ZXJhdG9yLl9pbnRlcm5hbEl0ZXJhdG9yKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmFyIHZhbHVlID0gY3JlYXRlVmFsdWUoKTtcclxuICAgIGl0ZXJhdG9yLl9pbnRlcm5hbEl0ZXJhdG9yID0gaGFzaEVsZW1lbnRzLmFkZCh7XHJcbiAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgdmFsdWU6IHZhbHVlXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpdGVyYXRvcjogaXRlcmF0b3IsXHJcbiAgICAgICAgaXNOZXc6IHRydWUsXHJcbiAgICAgICAgdmFsdWU6IHZhbHVlXHJcbiAgICB9O1xyXG59O1xyXG5cclxuSGFzaE1hcC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGl0ZXJhdG9yKSB7XHJcbiAgICBpdGVyYXRvci5faGFzaEVsZW1lbnRzLnJlbW92ZShpdGVyYXRvci5faW50ZXJuYWxJdGVyYXRvcik7XHJcbiAgICBpZiAoaXRlcmF0b3IuX2hhc2hFbGVtZW50cy5nZXRDb3VudCgpID09PSAwKSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX2J5S2V5W2l0ZXJhdG9yLl9oYXNoQ29kZV07XHJcbiAgICB9XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEZydXN0dW1SZXF1ZXN0c1ByaW9yaXRpemVyID0gcmVxdWlyZSgnZnJ1c3R1bXJlcXVlc3RzcHJpb3JpdGl6ZXIuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgY2FsY3VsYXRlRnJ1c3R1bTJERnJvbUJvdW5kczogY2FsY3VsYXRlRnJ1c3R1bTJERnJvbUJvdW5kcyxcclxuICAgIGNyZWF0ZVNjaGVkdWxlcjogY3JlYXRlU2NoZWR1bGVyLFxyXG4gICAgZml4Qm91bmRzOiBmaXhCb3VuZHMsXHJcbiAgICBhbGlnblBhcmFtc1RvVGlsZXNBbmRMZXZlbDogYWxpZ25QYXJhbXNUb1RpbGVzQW5kTGV2ZWwsXHJcbiAgICBnZXRJbWFnZUltcGxlbWVudGF0aW9uOiBnZXRJbWFnZUltcGxlbWVudGF0aW9uLFxyXG4gICAgZ2V0U2NyaXB0c0ZvcldvcmtlckltcG9ydDogZ2V0U2NyaXB0c0ZvcldvcmtlckltcG9ydCxcclxuICAgIGNyZWF0ZUludGVybmFsT3B0aW9uczogY3JlYXRlSW50ZXJuYWxPcHRpb25zXHJcbn07XHJcblxyXG4vLyBBdm9pZCBqc2hpbnQgZXJyb3JcclxuLyogZ2xvYmFsIHNlbGY6IGZhbHNlICovXHJcbi8qIGdsb2JhbCBnbG9iYWxzOiBmYWxzZSAqL1xyXG4gICAgXHJcbi8vdmFyIGxvZzIgPSBNYXRoLmxvZygyKTtcclxuXHJcbnZhciBpbWFnZURlY29kZXJGcmFtZXdvcmtTY3JpcHQgPSBuZXcgQXN5bmNQcm94eS5TY3JpcHRzVG9JbXBvcnRQb29sKCk7XHJcbmltYWdlRGVjb2RlckZyYW1ld29ya1NjcmlwdC5hZGRTY3JpcHRGcm9tRXJyb3JXaXRoU3RhY2tUcmFjZShuZXcgRXJyb3IoKSk7XHJcbnZhciBzY3JpcHRzRm9yV29ya2VyVG9JbXBvcnQgPSBpbWFnZURlY29kZXJGcmFtZXdvcmtTY3JpcHQuZ2V0U2NyaXB0c0ZvcldvcmtlckltcG9ydCgpO1xyXG5cclxuZnVuY3Rpb24gY2FsY3VsYXRlRnJ1c3R1bTJERnJvbUJvdW5kcyhcclxuICAgIGJvdW5kcywgc2NyZWVuU2l6ZSkge1xyXG4gICAgXHJcbiAgICB2YXIgc2NyZWVuUGl4ZWxzID1cclxuICAgICAgICBzY3JlZW5TaXplLnggKiBzY3JlZW5TaXplLnggKyBzY3JlZW5TaXplLnkgKiBzY3JlZW5TaXplLnk7XHJcbiAgICBcclxuICAgIHZhciBib3VuZHNXaWR0aCA9IGJvdW5kcy5lYXN0IC0gYm91bmRzLndlc3Q7XHJcbiAgICB2YXIgYm91bmRzSGVpZ2h0ID0gYm91bmRzLm5vcnRoIC0gYm91bmRzLnNvdXRoO1xyXG4gICAgdmFyIGJvdW5kc0Rpc3RhbmNlID1cclxuICAgICAgICBib3VuZHNXaWR0aCAqIGJvdW5kc1dpZHRoICsgYm91bmRzSGVpZ2h0ICogYm91bmRzSGVpZ2h0O1xyXG4gICAgXHJcbiAgICB2YXIgcmVzb2x1dGlvbiA9IE1hdGguc3FydChzY3JlZW5QaXhlbHMgLyBib3VuZHNEaXN0YW5jZSk7XHJcbiAgICBcclxuICAgIHZhciBmcnVzdHVtRGF0YSA9IHtcclxuICAgICAgICByZXNvbHV0aW9uOiByZXNvbHV0aW9uLFxyXG4gICAgICAgIHJlY3RhbmdsZTogYm91bmRzLFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFJlZHVuZGFudCwgYnV0IGVuYWJsZXMgdG8gYXZvaWQgYWxyZWFkeS1wZXJmb3JtZWQgY2FsY3VsYXRpb25cclxuICAgICAgICBzY3JlZW5TaXplOiBzY3JlZW5TaXplXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICByZXR1cm4gZnJ1c3R1bURhdGE7XHJcbn1cclxuICAgIFxyXG5mdW5jdGlvbiBjcmVhdGVTY2hlZHVsZXIoXHJcbiAgICBzaG93TG9nLCBwcmlvcml0aXplclR5cGUsIHNjaGVkdWxlck5hbWUsIGNyZWF0ZVJlc291cmNlLCByZXNvdXJjZUxpbWl0KSB7XHJcbiAgICBcclxuICAgIHZhciBwcmlvcml0aXplcjtcclxuICAgIHZhciBzY2hlZHVsZXI7XHJcbiAgICBcclxuICAgIGlmIChwcmlvcml0aXplclR5cGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHByaW9yaXRpemVyID0gbnVsbDtcclxuICAgICAgICBcclxuICAgICAgICBzY2hlZHVsZXIgPSBuZXcgUmVzb3VyY2VTY2hlZHVsZXIuTGlmb1NjaGVkdWxlcihcclxuICAgICAgICAgICAgY3JlYXRlUmVzb3VyY2UsXHJcbiAgICAgICAgICAgIHJlc291cmNlTGltaXQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgbGltaXRSZXNvdXJjZUJ5TG93UXVhbGl0eVByaW9yaXR5ID0gZmFsc2U7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHByaW9yaXRpemVyVHlwZSA9PT0gJ2ZydXN0dW0nKSB7XHJcbiAgICAgICAgICAgIGxpbWl0UmVzb3VyY2VCeUxvd1F1YWxpdHlQcmlvcml0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHByaW9yaXRpemVyID0gbmV3IEZydXN0dW1SZXF1ZXN0c1ByaW9yaXRpemVyKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwcmlvcml0aXplclR5cGUgPT09ICdmcnVzdHVtT25seScpIHtcclxuICAgICAgICAgICAgbGltaXRSZXNvdXJjZUJ5TG93UXVhbGl0eVByaW9yaXR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgcHJpb3JpdGl6ZXIgPSBuZXcgRnJ1c3R1bVJlcXVlc3RzUHJpb3JpdGl6ZXIoXHJcbiAgICAgICAgICAgICAgICAvKmlzQWJvcnRSZXF1ZXN0c05vdEluRnJ1c3R1bT0qL3RydWUsXHJcbiAgICAgICAgICAgICAgICAvKmlzUHJpb3JpdGl6ZUxvd1F1YWxpdHlTdGFnZT0qL3RydWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHByaW9yaXRpemVyID0gcHJpb3JpdGl6ZXJUeXBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgc2NoZWR1bGVyTmFtZTogc2NoZWR1bGVyTmFtZSxcclxuICAgICAgICAgICAgc2hvd0xvZzogc2hvd0xvZ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGxpbWl0UmVzb3VyY2VCeUxvd1F1YWxpdHlQcmlvcml0eSkge1xyXG4gICAgICAgICAgICBvcHRpb25zLnJlc291cmNlR3VhcmFudGVlZEZvckhpZ2hQcmlvcml0eSA9IHJlc291cmNlTGltaXQgLSAyO1xyXG4gICAgICAgICAgICBvcHRpb25zLmhpZ2hQcmlvcml0eVRvR3VhcmFudGVlUmVzb3VyY2UgPVxyXG4gICAgICAgICAgICAgICAgcHJpb3JpdGl6ZXIubWluaW1hbExvd1F1YWxpdHlQcmlvcml0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgc2NoZWR1bGVyID0gbmV3IFJlc291cmNlU2NoZWR1bGVyLlByaW9yaXR5U2NoZWR1bGVyKFxyXG4gICAgICAgICAgICBjcmVhdGVSZXNvdXJjZSxcclxuICAgICAgICAgICAgcmVzb3VyY2VMaW1pdCxcclxuICAgICAgICAgICAgcHJpb3JpdGl6ZXIsXHJcbiAgICAgICAgICAgIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByaW9yaXRpemVyOiBwcmlvcml0aXplcixcclxuICAgICAgICBzY2hlZHVsZXI6IHNjaGVkdWxlclxyXG4gICAgfTtcclxufVxyXG4gICAgXHJcbmZ1bmN0aW9uIGZpeEJvdW5kcyhib3VuZHMsIGltYWdlLCBhZGFwdFByb3BvcnRpb25zKSB7XHJcbiAgICBpZiAoIWFkYXB0UHJvcG9ydGlvbnMpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlY3RhbmdsZVdpZHRoID0gYm91bmRzLmVhc3QgLSBib3VuZHMud2VzdDtcclxuICAgIHZhciByZWN0YW5nbGVIZWlnaHQgPSBib3VuZHMubm9ydGggLSBib3VuZHMuc291dGg7XHJcblxyXG4gICAgdmFyIGxldmVsID0gaW1hZ2UuZ2V0SW1hZ2VMZXZlbCgpO1xyXG4gICAgdmFyIHBpeGVsc0FzcGVjdFJhdGlvID1cclxuICAgICAgICBpbWFnZS5nZXRMZXZlbFdpZHRoKGxldmVsKSAvIGltYWdlLmdldExldmVsSGVpZ2h0KGxldmVsKTtcclxuICAgIHZhciByZWN0YW5nbGVBc3BlY3RSYXRpbyA9IHJlY3RhbmdsZVdpZHRoIC8gcmVjdGFuZ2xlSGVpZ2h0O1xyXG4gICAgXHJcbiAgICBpZiAocGl4ZWxzQXNwZWN0UmF0aW8gPCByZWN0YW5nbGVBc3BlY3RSYXRpbykge1xyXG4gICAgICAgIHZhciBvbGRXaWR0aCA9IHJlY3RhbmdsZVdpZHRoO1xyXG4gICAgICAgIHJlY3RhbmdsZVdpZHRoID0gcmVjdGFuZ2xlSGVpZ2h0ICogcGl4ZWxzQXNwZWN0UmF0aW87XHJcbiAgICAgICAgdmFyIHN1YnN0cmFjdEZyb21XaWR0aCA9IG9sZFdpZHRoIC0gcmVjdGFuZ2xlV2lkdGg7XHJcbiAgICAgICAgXHJcbiAgICAgICAgYm91bmRzLmVhc3QgLT0gc3Vic3RyYWN0RnJvbVdpZHRoIC8gMjtcclxuICAgICAgICBib3VuZHMud2VzdCArPSBzdWJzdHJhY3RGcm9tV2lkdGggLyAyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgb2xkSGVpZ2h0ID0gcmVjdGFuZ2xlSGVpZ2h0O1xyXG4gICAgICAgIHJlY3RhbmdsZUhlaWdodCA9IHJlY3RhbmdsZVdpZHRoIC8gcGl4ZWxzQXNwZWN0UmF0aW87XHJcbiAgICAgICAgdmFyIHN1YnN0cmFjdEZyb21IZWlnaHQgPSBvbGRIZWlnaHQgLSByZWN0YW5nbGVIZWlnaHQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgYm91bmRzLm5vcnRoIC09IHN1YnN0cmFjdEZyb21IZWlnaHQgLyAyO1xyXG4gICAgICAgIGJvdW5kcy5zb3V0aCArPSBzdWJzdHJhY3RGcm9tSGVpZ2h0IC8gMjtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYWxpZ25QYXJhbXNUb1RpbGVzQW5kTGV2ZWwoXHJcbiAgICByZWdpb24sIGltYWdlRGVjb2Rlcikge1xyXG4gICAgXHJcbiAgICB2YXIgc2l6ZXNDYWxjdWxhdG9yID0gaW1hZ2VEZWNvZGVyLl9nZXRTaXplc0NhbGN1bGF0b3IoKTtcclxuICAgIHZhciB0aWxlV2lkdGggPSBpbWFnZURlY29kZXIuZ2V0VGlsZVdpZHRoKCk7XHJcbiAgICB2YXIgdGlsZUhlaWdodCA9IGltYWdlRGVjb2Rlci5nZXRUaWxlSGVpZ2h0KCk7XHJcbiAgICBcclxuICAgIHZhciByZWdpb25NaW5YID0gcmVnaW9uLm1pblg7XHJcbiAgICB2YXIgcmVnaW9uTWluWSA9IHJlZ2lvbi5taW5ZO1xyXG4gICAgdmFyIHJlZ2lvbk1heFggPSByZWdpb24ubWF4WEV4Y2x1c2l2ZTtcclxuICAgIHZhciByZWdpb25NYXhZID0gcmVnaW9uLm1heFlFeGNsdXNpdmU7XHJcbiAgICB2YXIgc2NyZWVuV2lkdGggPSByZWdpb24uc2NyZWVuV2lkdGg7XHJcbiAgICB2YXIgc2NyZWVuSGVpZ2h0ID0gcmVnaW9uLnNjcmVlbkhlaWdodDtcclxuICAgIFxyXG4gICAgdmFyIGlzVmFsaWRPcmRlciA9IHJlZ2lvbk1pblggPCByZWdpb25NYXhYICYmIHJlZ2lvbk1pblkgPCByZWdpb25NYXhZO1xyXG4gICAgaWYgKCFpc1ZhbGlkT3JkZXIpIHtcclxuICAgICAgICB0aHJvdyAnUGFyYW1ldGVycyBvcmRlciBpcyBpbnZhbGlkJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmFyIGltYWdlTGV2ZWwgPSBzaXplc0NhbGN1bGF0b3IuZ2V0SW1hZ2VMZXZlbCgpO1xyXG4gICAgdmFyIGRlZmF1bHRMZXZlbFdpZHRoID0gc2l6ZXNDYWxjdWxhdG9yLmdldExldmVsV2lkdGgoaW1hZ2VMZXZlbCk7XHJcbiAgICB2YXIgZGVmYXVsdExldmVsSGVpZ2h0ID0gc2l6ZXNDYWxjdWxhdG9yLmdldExldmVsSGVpZ2h0KGltYWdlTGV2ZWwpO1xyXG4gICAgaWYgKHJlZ2lvbk1heFggPCAwIHx8IHJlZ2lvbk1pblggPj0gZGVmYXVsdExldmVsV2lkdGggfHxcclxuICAgICAgICByZWdpb25NYXhZIDwgMCB8fCByZWdpb25NaW5ZID49IGRlZmF1bHRMZXZlbEhlaWdodCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvL3ZhciBtYXhMZXZlbCA9XHJcbiAgICAvLyAgICBzaXplc0NhbGN1bGF0b3IuZ2V0RGVmYXVsdE51bVJlc29sdXRpb25MZXZlbHMoKSAtIDE7XHJcblxyXG4gICAgLy92YXIgbGV2ZWxYID0gTWF0aC5sb2coKHJlZ2lvbk1heFggLSByZWdpb25NaW5YKSAvIHNjcmVlbldpZHRoICkgLyBsb2cyO1xyXG4gICAgLy92YXIgbGV2ZWxZID0gTWF0aC5sb2coKHJlZ2lvbk1heFkgLSByZWdpb25NaW5ZKSAvIHNjcmVlbkhlaWdodCkgLyBsb2cyO1xyXG4gICAgLy92YXIgbGV2ZWwgPSBNYXRoLmNlaWwoTWF0aC5taW4obGV2ZWxYLCBsZXZlbFkpKTtcclxuICAgIC8vbGV2ZWwgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXhMZXZlbCwgbGV2ZWwpKTtcclxuICAgIHZhciBsZXZlbCA9IHNpemVzQ2FsY3VsYXRvci5nZXRMZXZlbChyZWdpb24pO1xyXG4gICAgdmFyIGxldmVsV2lkdGggPSBzaXplc0NhbGN1bGF0b3IuZ2V0TGV2ZWxXaWR0aChsZXZlbCk7XHJcbiAgICB2YXIgbGV2ZWxIZWlnaHQgPSBzaXplc0NhbGN1bGF0b3IuZ2V0TGV2ZWxIZWlnaHQobGV2ZWwpO1xyXG4gICAgXHJcbiAgICB2YXIgc2NhbGVYID0gZGVmYXVsdExldmVsV2lkdGggLyBsZXZlbFdpZHRoO1xyXG4gICAgdmFyIHNjYWxlWSA9IGRlZmF1bHRMZXZlbEhlaWdodCAvIGxldmVsSGVpZ2h0O1xyXG4gICAgXHJcbiAgICB2YXIgbWluVGlsZVggPSBNYXRoLmZsb29yKHJlZ2lvbk1pblggLyAoc2NhbGVYICogdGlsZVdpZHRoICkpO1xyXG4gICAgdmFyIG1pblRpbGVZID0gTWF0aC5mbG9vcihyZWdpb25NaW5ZIC8gKHNjYWxlWSAqIHRpbGVIZWlnaHQpKTtcclxuICAgIHZhciBtYXhUaWxlWCA9IE1hdGguY2VpbCAocmVnaW9uTWF4WCAvIChzY2FsZVggKiB0aWxlV2lkdGggKSk7XHJcbiAgICB2YXIgbWF4VGlsZVkgPSBNYXRoLmNlaWwgKHJlZ2lvbk1heFkgLyAoc2NhbGVZICogdGlsZUhlaWdodCkpO1xyXG4gICAgXHJcbiAgICB2YXIgbWluWCA9IG1pblRpbGVYICogdGlsZVdpZHRoO1xyXG4gICAgdmFyIG1pblkgPSBtaW5UaWxlWSAqIHRpbGVIZWlnaHQ7XHJcbiAgICB2YXIgbWF4WCA9IG1heFRpbGVYICogdGlsZVdpZHRoO1xyXG4gICAgdmFyIG1heFkgPSBtYXhUaWxlWSAqIHRpbGVIZWlnaHQ7XHJcbiAgICBcclxuICAgIHZhciBjcm9wcGVkTWluWCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxldmVsV2lkdGggLCBtaW5YKSk7XHJcbiAgICB2YXIgY3JvcHBlZE1pblkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsZXZlbEhlaWdodCwgbWluWSkpO1xyXG4gICAgdmFyIGNyb3BwZWRNYXhYID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obGV2ZWxXaWR0aCAsIG1heFgpKTtcclxuICAgIHZhciBjcm9wcGVkTWF4WSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxldmVsSGVpZ2h0LCBtYXhZKSk7XHJcbiAgICBcclxuICAgIHZhciBpbWFnZVBhcmFtc1RvU2NyZWVuU2NhbGVYID0gc2NyZWVuV2lkdGggIC8gKG1heFggLSBtaW5YKTtcclxuICAgIHZhciBpbWFnZVBhcmFtc1RvU2NyZWVuU2NhbGVZID0gc2NyZWVuSGVpZ2h0IC8gKG1heFkgLSBtaW5ZKTtcclxuICAgIFxyXG4gICAgdmFyIGltYWdlUGFydFBhcmFtcyA9IHtcclxuICAgICAgICBtaW5YOiBjcm9wcGVkTWluWCxcclxuICAgICAgICBtaW5ZOiBjcm9wcGVkTWluWSxcclxuICAgICAgICBtYXhYRXhjbHVzaXZlOiBjcm9wcGVkTWF4WCxcclxuICAgICAgICBtYXhZRXhjbHVzaXZlOiBjcm9wcGVkTWF4WSxcclxuICAgICAgICBsZXZlbDogbGV2ZWxcclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciBwb3NpdGlvbkluSW1hZ2UgPSB7XHJcbiAgICAgICAgbWluWDogY3JvcHBlZE1pblggKiBzY2FsZVgsXHJcbiAgICAgICAgbWluWTogY3JvcHBlZE1pblkgKiBzY2FsZVksXHJcbiAgICAgICAgbWF4WEV4Y2x1c2l2ZTogY3JvcHBlZE1heFggKiBzY2FsZVgsXHJcbiAgICAgICAgbWF4WUV4Y2x1c2l2ZTogY3JvcHBlZE1heFkgKiBzY2FsZVlcclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciBjcm9wcGVkU2NyZWVuID0ge1xyXG4gICAgICAgIG1pblggOiBNYXRoLmZsb29yKChjcm9wcGVkTWluWCAtIG1pblgpICogaW1hZ2VQYXJhbXNUb1NjcmVlblNjYWxlWCksXHJcbiAgICAgICAgbWluWSA6IE1hdGguZmxvb3IoKGNyb3BwZWRNaW5ZIC0gbWluWSkgKiBpbWFnZVBhcmFtc1RvU2NyZWVuU2NhbGVZKSxcclxuICAgICAgICBtYXhYRXhjbHVzaXZlIDogTWF0aC5jZWlsKChjcm9wcGVkTWF4WCAtIG1pblgpICogaW1hZ2VQYXJhbXNUb1NjcmVlblNjYWxlWCksXHJcbiAgICAgICAgbWF4WUV4Y2x1c2l2ZSA6IE1hdGguY2VpbCgoY3JvcHBlZE1heFkgLSBtaW5ZKSAqIGltYWdlUGFyYW1zVG9TY3JlZW5TY2FsZVkpXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGltYWdlUGFydFBhcmFtczogaW1hZ2VQYXJ0UGFyYW1zLFxyXG4gICAgICAgIHBvc2l0aW9uSW5JbWFnZTogcG9zaXRpb25JbkltYWdlLFxyXG4gICAgICAgIGNyb3BwZWRTY3JlZW46IGNyb3BwZWRTY3JlZW5cclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEltYWdlSW1wbGVtZW50YXRpb24oaW1hZ2VJbXBsZW1lbnRhdGlvbkNsYXNzTmFtZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gd2luZG93ICYmIHdpbmRvd1tpbWFnZUltcGxlbWVudGF0aW9uQ2xhc3NOYW1lXTtcclxuICAgIH0gY2F0Y2goZSkgeyB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gZ2xvYmFscyAmJiBnbG9iYWxzW2ltYWdlSW1wbGVtZW50YXRpb25DbGFzc05hbWVdO1xyXG4gICAgfSBjYXRjaChlKSB7IH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBzZWxmICYmIHNlbGZbaW1hZ2VJbXBsZW1lbnRhdGlvbkNsYXNzTmFtZV07XHJcbiAgICB9IGNhdGNoKGUpIHsgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTY3JpcHRzRm9yV29ya2VySW1wb3J0KGltYWdlSW1wbGVtZW50YXRpb24sIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBzY3JpcHRzRm9yV29ya2VyVG9JbXBvcnQuY29uY2F0KFxyXG4gICAgICAgIGltYWdlSW1wbGVtZW50YXRpb24uZ2V0U2NyaXB0c1RvSW1wb3J0KCkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVJbnRlcm5hbE9wdGlvbnMoaW1hZ2VJbXBsZW1lbnRhdGlvbkNsYXNzTmFtZSwgb3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICBcclxuICAgIGlmIChvcHRpb25zLmltYWdlSW1wbGVtZW50YXRpb25DbGFzc05hbWUgJiZcclxuICAgICAgICBvcHRpb25zLnNjcmlwdHNUb0ltcG9ydCkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmFyIGltYWdlSW1wbGVtZW50YXRpb24gPSBnZXRJbWFnZUltcGxlbWVudGF0aW9uKGltYWdlSW1wbGVtZW50YXRpb25DbGFzc05hbWUpO1xyXG4gICAgXHJcbiAgICB2YXIgb3B0aW9uc0ludGVybmFsID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvcHRpb25zKSk7XHJcbiAgICBvcHRpb25zSW50ZXJuYWwuaW1hZ2VJbXBsZW1lbnRhdGlvbkNsYXNzTmFtZSA9IG9wdGlvbnMuaW1hZ2VJbXBsZW1lbnRhdGlvbkNsYXNzTmFtZSB8fCBpbWFnZUltcGxlbWVudGF0aW9uQ2xhc3NOYW1lO1xyXG4gICAgb3B0aW9uc0ludGVybmFsLnNjcmlwdHNUb0ltcG9ydCA9IG9wdGlvbnMuc2NyaXB0c1RvSW1wb3J0IHx8IGdldFNjcmlwdHNGb3JXb3JrZXJJbXBvcnQoaW1hZ2VJbXBsZW1lbnRhdGlvbiwgb3B0aW9ucyk7XHJcbiAgICBcclxuICAgIHJldHVybiBvcHRpb25zSW50ZXJuYWw7XHJcbn0iLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtlZExpc3Q7XHJcblxyXG5mdW5jdGlvbiBMaW5rZWRMaXN0KCkge1xyXG4gICAgdGhpcy5fZmlyc3QgPSB7IF9wcmV2OiBudWxsLCBfcGFyZW50OiB0aGlzIH07XHJcbiAgICB0aGlzLl9sYXN0ID0geyBfbmV4dDogbnVsbCwgX3BhcmVudDogdGhpcyB9O1xyXG4gICAgdGhpcy5fY291bnQgPSAwO1xyXG4gICAgXHJcbiAgICB0aGlzLl9sYXN0Ll9wcmV2ID0gdGhpcy5fZmlyc3Q7XHJcbiAgICB0aGlzLl9maXJzdC5fbmV4dCA9IHRoaXMuX2xhc3Q7XHJcbn1cclxuXHJcbkxpbmtlZExpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCh2YWx1ZSwgYWRkQmVmb3JlKSB7XHJcbiAgICBpZiAoYWRkQmVmb3JlID09PSBudWxsIHx8IGFkZEJlZm9yZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgYWRkQmVmb3JlID0gdGhpcy5fbGFzdDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5fdmFsaWRhdGVJdGVyYXRvck9mVGhpcyhhZGRCZWZvcmUpO1xyXG4gICAgXHJcbiAgICArK3RoaXMuX2NvdW50O1xyXG4gICAgXHJcbiAgICB2YXIgbmV3Tm9kZSA9IHtcclxuICAgICAgICBfdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgIF9uZXh0OiBhZGRCZWZvcmUsXHJcbiAgICAgICAgX3ByZXY6IGFkZEJlZm9yZS5fcHJldixcclxuICAgICAgICBfcGFyZW50OiB0aGlzXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBuZXdOb2RlLl9wcmV2Ll9uZXh0ID0gbmV3Tm9kZTtcclxuICAgIGFkZEJlZm9yZS5fcHJldiA9IG5ld05vZGU7XHJcbiAgICBcclxuICAgIHJldHVybiBuZXdOb2RlO1xyXG59O1xyXG5cclxuTGlua2VkTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGl0ZXJhdG9yKSB7XHJcbiAgICB0aGlzLl92YWxpZGF0ZUl0ZXJhdG9yT2ZUaGlzKGl0ZXJhdG9yKTtcclxuICAgIFxyXG4gICAgLS10aGlzLl9jb3VudDtcclxuICAgIFxyXG4gICAgaXRlcmF0b3IuX3ByZXYuX25leHQgPSBpdGVyYXRvci5fbmV4dDtcclxuICAgIGl0ZXJhdG9yLl9uZXh0Ll9wcmV2ID0gaXRlcmF0b3IuX3ByZXY7XHJcbiAgICBpdGVyYXRvci5fcGFyZW50ID0gbnVsbDtcclxufTtcclxuXHJcbkxpbmtlZExpc3QucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoaXRlcmF0b3IpIHtcclxuICAgIHRoaXMuX3ZhbGlkYXRlSXRlcmF0b3JPZlRoaXMoaXRlcmF0b3IpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gaXRlcmF0b3IuX3ZhbHVlO1xyXG59O1xyXG5cclxuTGlua2VkTGlzdC5wcm90b3R5cGUuZ2V0Rmlyc3RJdGVyYXRvciA9IGZ1bmN0aW9uIGdldEZpcnN0SXRlcmF0b3IoKSB7XHJcbiAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLmdldE5leHRJdGVyYXRvcih0aGlzLl9maXJzdCk7XHJcbiAgICByZXR1cm4gaXRlcmF0b3I7XHJcbn07XHJcblxyXG5MaW5rZWRMaXN0LnByb3RvdHlwZS5nZXRMYXN0SXRlcmF0b3IgPSBmdW5jdGlvbiBnZXRGaXJzdEl0ZXJhdG9yKCkge1xyXG4gICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5nZXRQcmV2SXRlcmF0b3IodGhpcy5fbGFzdCk7XHJcbiAgICByZXR1cm4gaXRlcmF0b3I7XHJcbn07XHJcblxyXG5MaW5rZWRMaXN0LnByb3RvdHlwZS5nZXROZXh0SXRlcmF0b3IgPSBmdW5jdGlvbiBnZXROZXh0SXRlcmF0b3IoaXRlcmF0b3IpIHtcclxuICAgIHRoaXMuX3ZhbGlkYXRlSXRlcmF0b3JPZlRoaXMoaXRlcmF0b3IpO1xyXG5cclxuICAgIGlmIChpdGVyYXRvci5fbmV4dCA9PT0gdGhpcy5fbGFzdCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gaXRlcmF0b3IuX25leHQ7XHJcbn07XHJcblxyXG5MaW5rZWRMaXN0LnByb3RvdHlwZS5nZXRQcmV2SXRlcmF0b3IgPSBmdW5jdGlvbiBnZXRQcmV2SXRlcmF0b3IoaXRlcmF0b3IpIHtcclxuICAgIHRoaXMuX3ZhbGlkYXRlSXRlcmF0b3JPZlRoaXMoaXRlcmF0b3IpO1xyXG5cclxuICAgIGlmIChpdGVyYXRvci5fcHJldiA9PT0gdGhpcy5fZmlyc3QpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIGl0ZXJhdG9yLl9wcmV2O1xyXG59O1xyXG5cclxuTGlua2VkTGlzdC5wcm90b3R5cGUuZ2V0Q291bnQgPSBmdW5jdGlvbiBnZXRDb3VudCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9jb3VudDtcclxufTtcclxuXHJcbkxpbmtlZExpc3QucHJvdG90eXBlLl92YWxpZGF0ZUl0ZXJhdG9yT2ZUaGlzID1cclxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlcmF0b3JPZlRoaXMoaXRlcmF0b3IpIHtcclxuICAgIFxyXG4gICAgaWYgKGl0ZXJhdG9yLl9wYXJlbnQgIT09IHRoaXMpIHtcclxuICAgICAgICB0aHJvdyAnaXRlcmF0b3IgbXVzdCBiZSBvZiB0aGUgY3VycmVudCBMaW5rZWRMaXN0JztcclxuICAgIH1cclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG4vLyBTdXBwcmVzcyBcIlVubmVjZXNzYXJ5IGRpcmVjdGl2ZSAndXNlIHN0cmljdCdcIiBmb3IgdGhlIHNsYXZlU2NyaXB0Q29udGVudCBmdW5jdGlvblxyXG4vKmpzaGludCAtVzAzNCAqL1xyXG5cclxudmFyIEltYWdlRGVjb2RlciA9IHJlcXVpcmUoJ2ltYWdlZGVjb2Rlci5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuZ2V0U2NyaXB0VXJsID0gZnVuY3Rpb24gZ2V0U2NyaXB0VXJsKCkge1xyXG4gICAgcmV0dXJuIHNsYXZlU2NyaXB0VXJsO1xyXG59O1xyXG5cclxudmFyIHNsYXZlU2NyaXB0QmxvYiA9IG5ldyBCbG9iKFxyXG4gICAgWycoJywgc2xhdmVTY3JpcHRDb250ZW50LnRvU3RyaW5nKCksICcpKCknXSxcclxuICAgIHsgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnIH0pO1xyXG52YXIgc2xhdmVTY3JpcHRVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHNsYXZlU2NyaXB0QmxvYik7XHJcblxyXG5mdW5jdGlvbiBzbGF2ZVNjcmlwdENvbnRlbnQoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICBBc3luY1Byb3h5LkFzeW5jUHJveHlTbGF2ZS5zZXRTbGF2ZVNpZGVDcmVhdG9yKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBhcmd1bWVudHNBc0FycmF5ID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggKyAxKTtcclxuICAgICAgICBhcmd1bWVudHNBc0FycmF5WzBdID0gbnVsbDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBhcmd1bWVudHNBc0FycmF5W2kgKyAxXSA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGluc3RhbmNlID0gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShpbWFnZURlY29kZXJGcmFtZXdvcmsuSW1hZ2VEZWNvZGVyLCBhcmd1bWVudHNBc0FycmF5KSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgfSk7XHJcbn0iLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlUGFyYW1zUmV0cmlldmVyUHJveHk7XHJcblxyXG52YXIgaW1hZ2VIZWxwZXJGdW5jdGlvbnMgPSByZXF1aXJlKCdpbWFnZWhlbHBlcmZ1bmN0aW9ucy5qcycpO1xyXG5cclxuZnVuY3Rpb24gSW1hZ2VQYXJhbXNSZXRyaWV2ZXJQcm94eShpbWFnZUltcGxlbWVudGF0aW9uQ2xhc3NOYW1lKSB7XHJcbiAgICB0aGlzLl9pbWFnZUltcGxlbWVudGF0aW9uID0gaW1hZ2VIZWxwZXJGdW5jdGlvbnMuZ2V0SW1hZ2VJbXBsZW1lbnRhdGlvbihpbWFnZUltcGxlbWVudGF0aW9uQ2xhc3NOYW1lKTtcclxuICAgIHRoaXMuX3NpemVzUGFyYW1zID0gbnVsbDtcclxuICAgIHRoaXMuX3NpemVzQ2FsY3VsYXRvciA9IG51bGw7XHJcbn1cclxuXHJcbkltYWdlUGFyYW1zUmV0cmlldmVyUHJveHkucHJvdG90eXBlLmdldEltYWdlTGV2ZWwgPSBmdW5jdGlvbiBnZXRJbWFnZUxldmVsKCkge1xyXG4gICAgdGhpcy5fdmFsaWRhdGVTaXplc0NhbGN1bGF0b3IoKTtcclxuICAgIHZhciBsZXZlbCA9IHRoaXMuX3NpemVzQ2FsY3VsYXRvci5nZXRJbWFnZUxldmVsKCk7XHJcblxyXG4gICAgcmV0dXJuIGxldmVsO1xyXG59O1xyXG5cclxuSW1hZ2VQYXJhbXNSZXRyaWV2ZXJQcm94eS5wcm90b3R5cGUuZ2V0TnVtUmVzb2x1dGlvbkxldmVsc0ZvckxpbWl0dGVkVmlld2VyID0gZnVuY3Rpb24gZ2V0TnVtUmVzb2x1dGlvbkxldmVsc0ZvckxpbWl0dGVkVmlld2VyKCkge1xyXG4gICAgdGhpcy5fdmFsaWRhdGVTaXplc0NhbGN1bGF0b3IoKTtcclxuICAgIHZhciBsZXZlbHMgPSB0aGlzLl9zaXplc0NhbGN1bGF0b3IuZ2V0TnVtUmVzb2x1dGlvbkxldmVsc0ZvckxpbWl0dGVkVmlld2VyKCk7XHJcblxyXG4gICAgcmV0dXJuIGxldmVscztcclxufTtcclxuXHJcbkltYWdlUGFyYW1zUmV0cmlldmVyUHJveHkucHJvdG90eXBlLmdldExldmVsV2lkdGggPSBmdW5jdGlvbiBnZXRMZXZlbFdpZHRoKGxldmVsKSB7XHJcbiAgICB0aGlzLl92YWxpZGF0ZVNpemVzQ2FsY3VsYXRvcigpO1xyXG4gICAgdmFyIHdpZHRoID0gdGhpcy5fc2l6ZXNDYWxjdWxhdG9yLmdldExldmVsV2lkdGgoXHJcbiAgICAgICAgbGV2ZWwpO1xyXG5cclxuICAgIHJldHVybiB3aWR0aDtcclxufTtcclxuXHJcbkltYWdlUGFyYW1zUmV0cmlldmVyUHJveHkucHJvdG90eXBlLmdldExldmVsSGVpZ2h0ID0gZnVuY3Rpb24gZ2V0TGV2ZWxIZWlnaHQobGV2ZWwpIHtcclxuICAgIHRoaXMuX3ZhbGlkYXRlU2l6ZXNDYWxjdWxhdG9yKCk7XHJcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5fc2l6ZXNDYWxjdWxhdG9yLmdldExldmVsSGVpZ2h0KFxyXG4gICAgICAgIGxldmVsKTtcclxuXHJcbiAgICByZXR1cm4gaGVpZ2h0O1xyXG59O1xyXG5cclxuSW1hZ2VQYXJhbXNSZXRyaWV2ZXJQcm94eS5wcm90b3R5cGUuZ2V0TGV2ZWwgPSBmdW5jdGlvbiBnZXRMZXZlbChyZWdpb25MZXZlbDApIHtcclxuICAgIHRoaXMuX3ZhbGlkYXRlU2l6ZXNDYWxjdWxhdG9yKCk7XHJcbiAgICB2YXIgbGV2ZWwgPSB0aGlzLl9zaXplc0NhbGN1bGF0b3IuZ2V0TGV2ZWwocmVnaW9uTGV2ZWwwKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIGxldmVsO1xyXG59O1xyXG5cclxuSW1hZ2VQYXJhbXNSZXRyaWV2ZXJQcm94eS5wcm90b3R5cGUuZ2V0TG93ZXN0UXVhbGl0eSA9IGZ1bmN0aW9uIGdldExvd2VzdFF1YWxpdHkoKSB7XHJcbiAgICB0aGlzLl92YWxpZGF0ZVNpemVzQ2FsY3VsYXRvcigpO1xyXG4gICAgdmFyIHF1YWxpdHkgPSB0aGlzLl9zaXplc0NhbGN1bGF0b3IuZ2V0TG93ZXN0UXVhbGl0eSgpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gcXVhbGl0eTtcclxufTtcclxuXHJcbkltYWdlUGFyYW1zUmV0cmlldmVyUHJveHkucHJvdG90eXBlLmdldEhpZ2hlc3RRdWFsaXR5ID0gZnVuY3Rpb24gZ2V0SGlnaGVzdFF1YWxpdHkoKSB7XHJcbiAgICB0aGlzLl92YWxpZGF0ZVNpemVzQ2FsY3VsYXRvcigpO1xyXG4gICAgdmFyIHF1YWxpdHkgPSB0aGlzLl9zaXplc0NhbGN1bGF0b3IuZ2V0SGlnaGVzdFF1YWxpdHkoKTtcclxuXHJcbiAgICByZXR1cm4gcXVhbGl0eTtcclxufTtcclxuXHJcbkltYWdlUGFyYW1zUmV0cmlldmVyUHJveHkucHJvdG90eXBlLl9nZXRTaXplc0NhbGN1bGF0b3IgPSBmdW5jdGlvbiBnZXRTaXplc0NhbGN1bGF0b3IoKSB7XHJcbiAgICB0aGlzLl92YWxpZGF0ZVNpemVzQ2FsY3VsYXRvcih0aGlzKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHRoaXMuX3NpemVzQ2FsY3VsYXRvcjtcclxufTtcclxuXHJcbkltYWdlUGFyYW1zUmV0cmlldmVyUHJveHkucHJvdG90eXBlLl9nZXRTaXplc1BhcmFtcyA9IGZ1bmN0aW9uIGdldFNpemVzUGFyYW1zKCkge1xyXG4gICAgaWYgKCF0aGlzLl9zaXplc1BhcmFtcykge1xyXG4gICAgICAgIHRoaXMuX3NpemVzUGFyYW1zID0gdGhpcy5fZ2V0U2l6ZXNQYXJhbXNJbnRlcm5hbCgpO1xyXG4gICAgICAgIGlmICghdGhpcy5fc2l6ZXNQYXJhbXMpIHtcclxuICAgICAgICAgICAgdGhyb3cgJ2dldFNpemVzUGFyYW1zKCkgcmV0dXJuIGZhbHN5IHZhbHVlOyBNYXliZSBpbWFnZSBub3QgcmVhZHkgeWV0Pyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gdGhpcy5fc2l6ZXNQYXJhbXM7XHJcbn07XHJcblxyXG5JbWFnZVBhcmFtc1JldHJpZXZlclByb3h5LnByb3RvdHlwZS5fZ2V0U2l6ZXNQYXJhbXNJbnRlcm5hbCA9IGZ1bmN0aW9uIGdldFNpemVzUGFyYW1zSW50ZXJuYWwoKSB7XHJcbiAgICB0aHJvdyAnSW1hZ2VQYXJhbXNSZXRyaWV2ZXJQcm94eSBpbXBsZW1lbnRlZCBkaWQgbm90IGltcGxlbWVudCBfZ2V0U2l6ZXNQYXJhbXNJbnRlcm5hbCgpJztcclxufTtcclxuXHJcbkltYWdlUGFyYW1zUmV0cmlldmVyUHJveHkucHJvdG90eXBlLl92YWxpZGF0ZVNpemVzQ2FsY3VsYXRvciA9IGZ1bmN0aW9uIHZhbGlkYXRlU2l6ZXNDYWxjdWxhdG9yKCkge1xyXG4gICAgaWYgKHRoaXMuX3NpemVzQ2FsY3VsYXRvciAhPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmFyIHNpemVzUGFyYW1zID0gdGhpcy5fZ2V0U2l6ZXNQYXJhbXMoKTtcclxuICAgIHRoaXMuX3NpemVzQ2FsY3VsYXRvciA9IHRoaXMuX2ltYWdlSW1wbGVtZW50YXRpb24uY3JlYXRlSW1hZ2VQYXJhbXNSZXRyaWV2ZXIoXHJcbiAgICAgICAgc2l6ZXNQYXJhbXMpO1xyXG59IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gU3VwcHJlc3MgXCJVbm5lY2Vzc2FyeSBkaXJlY3RpdmUgJ3VzZSBzdHJpY3QnXCIgZm9yIHRoZSBzbGF2ZVNjcmlwdENvbnRlbnQgZnVuY3Rpb25cclxuLypqc2hpbnQgLVcwMzQgKi9cclxuXHJcbm1vZHVsZS5leHBvcnRzLmdldFNjcmlwdFVybCA9IGZ1bmN0aW9uIGdldFNjcmlwdFVybCgpIHtcclxuICAgIHJldHVybiBzbGF2ZVNjcmlwdFVybDtcclxufTtcclxuXHJcbnZhciBzbGF2ZVNjcmlwdEJsb2IgPSBuZXcgQmxvYihcclxuICAgIFsnKCcsIHNsYXZlU2NyaXB0Q29udGVudC50b1N0cmluZygpLCAnKSgpJ10sXHJcbiAgICB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyB9KTtcclxudmFyIHNsYXZlU2NyaXB0VXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChzbGF2ZVNjcmlwdEJsb2IpO1xyXG5cclxuZnVuY3Rpb24gc2xhdmVTY3JpcHRDb250ZW50KCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgXHJcbiAgICB2YXIgaXNSZWFkeSA9IGZhbHNlO1xyXG5cclxuICAgIEFzeW5jUHJveHkuQXN5bmNQcm94eVNsYXZlLnNldEJlZm9yZU9wZXJhdGlvbkxpc3RlbmVyKGJlZm9yZU9wZXJhdGlvbkxpc3RlbmVyKTtcclxuXHJcbiAgICBmdW5jdGlvbiBiZWZvcmVPcGVyYXRpb25MaXN0ZW5lcihvcGVyYXRpb25UeXBlLCBvcGVyYXRpb25OYW1lLCBhcmdzKSB7XHJcbiAgICAgICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChvcGVyYXRpb25UeXBlICE9PSAnY2FsbGJhY2snIHx8IG9wZXJhdGlvbk5hbWUgIT09ICdzdGF0dXNDYWxsYmFjaycpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoaXNSZWFkeSB8fCAhYXJnc1swXS5pc1JlYWR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgZGF0YSA9IHsgc2l6ZXNQYXJhbXM6IHRoaXMuX2dldFNpemVzUGFyYW1zKCkgfTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBnZXRUaWxlV2lkdGggYW5kIGdldFRpbGVIZWlnaHQgZXhpc3RzIG9ubHkgaW4gSW1hZ2VEZWNvZGVyIGJ1dCBub3QgaW4gRmV0Y2hNYW5hZ2VyXHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0VGlsZVdpZHRoKSB7XHJcbiAgICAgICAgICAgIGRhdGEuYXBwbGljYXRpdmVUaWxlV2lkdGggPSB0aGlzLmdldFRpbGVXaWR0aCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5nZXRUaWxlSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGRhdGEuYXBwbGljYXRpdmVUaWxlSGVpZ2h0ID0gdGhpcy5nZXRUaWxlSGVpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIEFzeW5jUHJveHkuQXN5bmNQcm94eVNsYXZlLnNlbmRVc2VyRGF0YVRvTWFzdGVyKGRhdGEpO1xyXG4gICAgICAgIGlzUmVhZHkgPSB0cnVlO1xyXG4gICAgfVxyXG59IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXb3JrZXJQcm94eUZldGNoTWFuYWdlcjtcclxuXHJcbnZhciBpbWFnZUhlbHBlckZ1bmN0aW9ucyA9IHJlcXVpcmUoJ2ltYWdlaGVscGVyZnVuY3Rpb25zLmpzJyk7XHJcbnZhciBzZW5kSW1hZ2VQYXJhbWV0ZXJzVG9NYXN0ZXIgPSByZXF1aXJlKCdzZW5kaW1hZ2VwYXJhbWV0ZXJzdG9tYXN0ZXIuanMnKTtcclxudmFyIEltYWdlUGFyYW1zUmV0cmlldmVyUHJveHkgPSByZXF1aXJlKCdpbWFnZXBhcmFtc3JldHJpZXZlcnByb3h5LmpzJyk7XHJcblxyXG5mdW5jdGlvbiBXb3JrZXJQcm94eUZldGNoTWFuYWdlcihvcHRpb25zKSB7XHJcbiAgICBJbWFnZVBhcmFtc1JldHJpZXZlclByb3h5LmNhbGwodGhpcywgb3B0aW9ucy5pbWFnZUltcGxlbWVudGF0aW9uQ2xhc3NOYW1lKTtcclxuXHJcbiAgICB0aGlzLl9pbWFnZVdpZHRoID0gbnVsbDtcclxuICAgIHRoaXMuX2ltYWdlSGVpZ2h0ID0gbnVsbDtcclxuICAgIHRoaXMuX2ludGVybmFsU2l6ZXNQYXJhbXMgPSBudWxsO1xyXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICBcclxuICAgIHZhciBjdG9yQXJncyA9IFtvcHRpb25zXTtcclxuICAgIHZhciBzY3JpcHRzVG9JbXBvcnQgPSBvcHRpb25zLnNjcmlwdHNUb0ltcG9ydC5jb25jYXQoW3NlbmRJbWFnZVBhcmFtZXRlcnNUb01hc3Rlci5nZXRTY3JpcHRVcmwoKV0pO1xyXG4gICAgXHJcbiAgICB0aGlzLl93b3JrZXJIZWxwZXIgPSBuZXcgQXN5bmNQcm94eS5Bc3luY1Byb3h5TWFzdGVyKFxyXG4gICAgICAgIHNjcmlwdHNUb0ltcG9ydCwgJ2ltYWdlRGVjb2RlckZyYW1ld29yay5JbnRlcm5hbHMuRmV0Y2hNYW5hZ2VyJywgY3RvckFyZ3MpO1xyXG4gICAgXHJcbiAgICB2YXIgYm91bmRVc2VyRGF0YUhhbmRsZXIgPSB0aGlzLl91c2VyRGF0YUhhbmRsZXIuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuX3dvcmtlckhlbHBlci5zZXRVc2VyRGF0YUhhbmRsZXIoYm91bmRVc2VyRGF0YUhhbmRsZXIpO1xyXG59XHJcblxyXG5Xb3JrZXJQcm94eUZldGNoTWFuYWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEltYWdlUGFyYW1zUmV0cmlldmVyUHJveHkucHJvdG90eXBlKTtcclxuXHJcbldvcmtlclByb3h5RmV0Y2hNYW5hZ2VyLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gb3Blbih1cmwpIHtcclxuICAgIHJldHVybiB0aGlzLl93b3JrZXJIZWxwZXIuY2FsbEZ1bmN0aW9uKCdvcGVuJywgW3VybF0sIHsgaXNSZXR1cm5Qcm9taXNlOiB0cnVlIH0pO1xyXG59O1xyXG5cclxuV29ya2VyUHJveHlGZXRjaE1hbmFnZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gY2xvc2UoKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICByZXR1cm4gdGhpcy5fd29ya2VySGVscGVyLmNhbGxGdW5jdGlvbignY2xvc2UnLCBbXSwgeyBpc1JldHVyblByb21pc2U6IHRydWUgfSkudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICBzZWxmLl93b3JrZXJIZWxwZXIudGVybWluYXRlKCk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcbldvcmtlclByb3h5RmV0Y2hNYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVDaGFubmVsID0gZnVuY3Rpb24gY3JlYXRlQ2hhbm5lbChcclxuICAgIGNyZWF0ZWRDYWxsYmFjaykge1xyXG4gICAgXHJcbiAgICB2YXIgY2FsbGJhY2tXcmFwcGVyID0gdGhpcy5fd29ya2VySGVscGVyLndyYXBDYWxsYmFjayhcclxuICAgICAgICBjcmVhdGVkQ2FsbGJhY2ssXHJcbiAgICAgICAgJ0ZldGNoTWFuYWdlcl9jcmVhdGVDaGFubmVsQ2FsbGJhY2snKTtcclxuICAgIFxyXG4gICAgdmFyIGFyZ3MgPSBbY2FsbGJhY2tXcmFwcGVyXTtcclxuICAgIHRoaXMuX3dvcmtlckhlbHBlci5jYWxsRnVuY3Rpb24oJ2NyZWF0ZUNoYW5uZWwnLCBhcmdzKTtcclxufTtcclxuXHJcbldvcmtlclByb3h5RmV0Y2hNYW5hZ2VyLnByb3RvdHlwZS5tb3ZlQ2hhbm5lbCA9IGZ1bmN0aW9uIG1vdmVDaGFubmVsKFxyXG4gICAgY2hhbm5lbEhhbmRsZSwgaW1hZ2VQYXJ0UGFyYW1zKSB7XHJcbiAgICBcclxuICAgIHZhciBhcmdzID0gW2NoYW5uZWxIYW5kbGUsIGltYWdlUGFydFBhcmFtc107XHJcbiAgICB0aGlzLl93b3JrZXJIZWxwZXIuY2FsbEZ1bmN0aW9uKCdtb3ZlQ2hhbm5lbCcsIGFyZ3MpO1xyXG59O1xyXG5cclxuV29ya2VyUHJveHlGZXRjaE1hbmFnZXIucHJvdG90eXBlLmNyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbiBjcmVhdGVSZXF1ZXN0KFxyXG4gICAgZmV0Y2hQYXJhbXMsXHJcbiAgICBjYWxsYmFja1RoaXMsXHJcbiAgICBjYWxsYmFjayxcclxuICAgIHRlcm1pbmF0ZWRDYWxsYmFjayxcclxuICAgIGlzT25seVdhaXRGb3JEYXRhLFxyXG4gICAgcmVxdWVzdElkKSB7XHJcbiAgICBcclxuICAgIC8vdmFyIHBhdGhUb0FycmF5SW5QYWNrZXRzRGF0YSA9IFswLCAnZGF0YScsICdidWZmZXInXTtcclxuICAgIC8vdmFyIHBhdGhUb0hlYWRlcnNDb2Rlc3RyZWFtID0gWzEsICdjb2Rlc3RyZWFtJywgJ2J1ZmZlciddO1xyXG4gICAgLy92YXIgdHJhbnNmZXJhYmxlUGF0aHMgPSBbXHJcbiAgICAvLyAgICBwYXRoVG9BcnJheUluUGFja2V0c0RhdGEsXHJcbiAgICAvLyAgICBwYXRoVG9IZWFkZXJzQ29kZXN0cmVhbVxyXG4gICAgLy9dO1xyXG4gICAgXHJcbiAgICB2YXIgdHJhbnNmZXJhYmxlUGF0aHMgPSB0aGlzLl9vcHRpb25zLnRyYW5zZmVyYWJsZVBhdGhzT2ZSZXF1ZXN0Q2FsbGJhY2s7XHJcbiAgICBcclxuICAgIHZhciBpbnRlcm5hbENhbGxiYWNrV3JhcHBlciA9XHJcbiAgICAgICAgdGhpcy5fd29ya2VySGVscGVyLndyYXBDYWxsYmFjayhcclxuICAgICAgICAgICAgY2FsbGJhY2suYmluZChjYWxsYmFja1RoaXMpLCAncmVxdWVzdFRpbGVzUHJvZ3Jlc3NpdmVDYWxsYmFjaycsIHtcclxuICAgICAgICAgICAgICAgIGlzTXVsdGlwbGVUaW1lQ2FsbGJhY2s6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBwYXRoc1RvVHJhbnNmZXJhYmxlczogdHJhbnNmZXJhYmxlUGF0aHNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcbiAgICBcclxuICAgIHZhciBpbnRlcm5hbFRlcm1pbmF0ZWRDYWxsYmFja1dyYXBwZXIgPVxyXG4gICAgICAgIHRoaXMuX3dvcmtlckhlbHBlci53cmFwQ2FsbGJhY2soXHJcbiAgICAgICAgICAgIGludGVybmFsVGVybWluYXRlZENhbGxiYWNrLCAncmVxdWVzdFRpbGVzUHJvZ3Jlc3NpdmVUZXJtaW5hdGVkQ2FsbGJhY2snLCB7XHJcbiAgICAgICAgICAgICAgICBpc011bHRpcGxlVGltZUNhbGxiYWNrOiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuICAgICAgICAgICAgXHJcbiAgICB2YXIgYXJncyA9IFtcclxuICAgICAgICBmZXRjaFBhcmFtcyxcclxuICAgICAgICAvKmNhbGxiYWNrVGhpcz0qL3sgZHVtbXlUaGlzOiAnZHVtbXlUaGlzJyB9LFxyXG4gICAgICAgIGludGVybmFsQ2FsbGJhY2tXcmFwcGVyLFxyXG4gICAgICAgIGludGVybmFsVGVybWluYXRlZENhbGxiYWNrV3JhcHBlcixcclxuICAgICAgICBpc09ubHlXYWl0Rm9yRGF0YSxcclxuICAgICAgICByZXF1ZXN0SWRdO1xyXG4gICAgICAgIFxyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgXHJcbiAgICB0aGlzLl93b3JrZXJIZWxwZXIuY2FsbEZ1bmN0aW9uKCdjcmVhdGVSZXF1ZXN0JywgYXJncyk7XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGludGVybmFsVGVybWluYXRlZENhbGxiYWNrKGlzQWJvcnRlZCkge1xyXG4gICAgICAgIHNlbGYuX3dvcmtlckhlbHBlci5mcmVlQ2FsbGJhY2soaW50ZXJuYWxDYWxsYmFja1dyYXBwZXIpO1xyXG4gICAgICAgIHRlcm1pbmF0ZWRDYWxsYmFjay5jYWxsKGNhbGxiYWNrVGhpcywgaXNBYm9ydGVkKTtcclxuICAgIH1cclxufTtcclxuXHJcbldvcmtlclByb3h5RmV0Y2hNYW5hZ2VyLnByb3RvdHlwZS5tYW51YWxBYm9ydFJlcXVlc3QgPSBmdW5jdGlvbiBtYW51YWxBYm9ydFJlcXVlc3QoXHJcbiAgICByZXF1ZXN0SWQpIHtcclxuICAgIFxyXG4gICAgdmFyIGFyZ3MgPSBbcmVxdWVzdElkXTtcclxuICAgIHRoaXMuX3dvcmtlckhlbHBlci5jYWxsRnVuY3Rpb24oXHJcbiAgICAgICAgJ21hbnVhbEFib3J0UmVxdWVzdCcsIGFyZ3MpO1xyXG59O1xyXG5cclxuV29ya2VyUHJveHlGZXRjaE1hbmFnZXIucHJvdG90eXBlLnNldElzUHJvZ3Jlc3NpdmVSZXF1ZXN0ID0gZnVuY3Rpb24gc2V0SXNQcm9ncmVzc2l2ZVJlcXVlc3QoXHJcbiAgICByZXF1ZXN0SWQsIGlzUHJvZ3Jlc3NpdmUpIHtcclxuICAgIFxyXG4gICAgdmFyIGFyZ3MgPSBbcmVxdWVzdElkLCBpc1Byb2dyZXNzaXZlXTtcclxuICAgIHRoaXMuX3dvcmtlckhlbHBlci5jYWxsRnVuY3Rpb24oJ3NldElzUHJvZ3Jlc3NpdmVSZXF1ZXN0JywgYXJncyk7XHJcbn07XHJcblxyXG5Xb3JrZXJQcm94eUZldGNoTWFuYWdlci5wcm90b3R5cGUuc2V0U2VydmVyUmVxdWVzdFByaW9yaXRpemVyRGF0YSA9XHJcbiAgICBmdW5jdGlvbiBzZXRTZXJ2ZXJSZXF1ZXN0UHJpb3JpdGl6ZXJEYXRhKHByaW9yaXRpemVyRGF0YSkge1xyXG4gICAgXHJcbiAgICB0aGlzLl93b3JrZXJIZWxwZXIuY2FsbEZ1bmN0aW9uKFxyXG4gICAgICAgICdzZXRTZXJ2ZXJSZXF1ZXN0UHJpb3JpdGl6ZXJEYXRhJyxcclxuICAgICAgICBbIHByaW9yaXRpemVyRGF0YSBdLFxyXG4gICAgICAgIHsgaXNTZW5kSW1tZWRpYXRlbHk6IHRydWUgfSk7XHJcbn07XHJcblxyXG5Xb3JrZXJQcm94eUZldGNoTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gcmVjb25uZWN0KCkge1xyXG4gICAgdGhpcy5fd29ya2VySGVscGVyLmNhbGxGdW5jdGlvbigncmVjb25uZWN0Jyk7XHJcbn07XHJcblxyXG5Xb3JrZXJQcm94eUZldGNoTWFuYWdlci5wcm90b3R5cGUuX2dldFNpemVzUGFyYW1zSW50ZXJuYWwgPSBmdW5jdGlvbiBnZXRTaXplc1BhcmFtc0ludGVybmFsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ludGVybmFsU2l6ZXNQYXJhbXM7XHJcbn07XHJcblxyXG5Xb3JrZXJQcm94eUZldGNoTWFuYWdlci5wcm90b3R5cGUuX3VzZXJEYXRhSGFuZGxlciA9IGZ1bmN0aW9uIHVzZXJEYXRhSGFuZGxlcihkYXRhKSB7XHJcbiAgICB0aGlzLl9pbnRlcm5hbFNpemVzUGFyYW1zID0gZGF0YS5zaXplc1BhcmFtcztcclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmtlclByb3h5SW1hZ2VEZWNvZGVyO1xyXG5cclxudmFyIGltYWdlSGVscGVyRnVuY3Rpb25zID0gcmVxdWlyZSgnaW1hZ2VoZWxwZXJmdW5jdGlvbnMuanMnKTtcclxudmFyIHNlbmRJbWFnZVBhcmFtZXRlcnNUb01hc3RlciA9IHJlcXVpcmUoJ3NlbmRpbWFnZXBhcmFtZXRlcnN0b21hc3Rlci5qcycpO1xyXG52YXIgY3JlYXRlSW1hZ2VEZWNvZGVyU2xhdmVTaWRlID0gcmVxdWlyZSgnY3JlYXRlaW1hZ2VkZWNvZGVyb25zbGF2ZXNpZGUuanMnKTtcclxudmFyIEltYWdlUGFyYW1zUmV0cmlldmVyUHJveHkgPSByZXF1aXJlKCdpbWFnZXBhcmFtc3JldHJpZXZlcnByb3h5LmpzJyk7XHJcblxyXG5mdW5jdGlvbiBXb3JrZXJQcm94eUltYWdlRGVjb2RlcihpbWFnZUltcGxlbWVudGF0aW9uQ2xhc3NOYW1lLCBvcHRpb25zKSB7XHJcbiAgICBJbWFnZVBhcmFtc1JldHJpZXZlclByb3h5LmNhbGwodGhpcywgaW1hZ2VJbXBsZW1lbnRhdGlvbkNsYXNzTmFtZSk7XHJcblxyXG4gICAgdGhpcy5faW1hZ2VXaWR0aCA9IG51bGw7XHJcbiAgICB0aGlzLl9pbWFnZUhlaWdodCA9IG51bGw7XHJcbiAgICB0aGlzLl90aWxlV2lkdGggPSAwO1xyXG4gICAgdGhpcy5fdGlsZUhlaWdodCA9IDA7XHJcbiAgICB0aGlzLl9zaXplc0NhbGN1bGF0b3IgPSBudWxsO1xyXG4gICAgXHJcbiAgICB2YXIgb3B0aW9uc0ludGVybmFsID0gaW1hZ2VIZWxwZXJGdW5jdGlvbnMuY3JlYXRlSW50ZXJuYWxPcHRpb25zKGltYWdlSW1wbGVtZW50YXRpb25DbGFzc05hbWUsIG9wdGlvbnMpO1xyXG4gICAgdmFyIGN0b3JBcmdzID0gW2ltYWdlSW1wbGVtZW50YXRpb25DbGFzc05hbWUsIG9wdGlvbnNJbnRlcm5hbF07XHJcbiAgICBcclxuICAgIHZhciBzY3JpcHRzVG9JbXBvcnQgPSBpbWFnZUhlbHBlckZ1bmN0aW9ucy5nZXRTY3JpcHRzRm9yV29ya2VySW1wb3J0KFxyXG4gICAgICAgIHRoaXMuX2ltYWdlSW1wbGVtZW50YXRpb24sIG9wdGlvbnMpO1xyXG4gICAgc2NyaXB0c1RvSW1wb3J0ID0gc2NyaXB0c1RvSW1wb3J0LmNvbmNhdChbXHJcbiAgICAgICAgc2VuZEltYWdlUGFyYW1ldGVyc1RvTWFzdGVyLmdldFNjcmlwdFVybCgpLFxyXG4gICAgICAgIGNyZWF0ZUltYWdlRGVjb2RlclNsYXZlU2lkZS5nZXRTY3JpcHRVcmwoKV0pO1xyXG5cclxuICAgIHRoaXMuX3dvcmtlckhlbHBlciA9IG5ldyBBc3luY1Byb3h5LkFzeW5jUHJveHlNYXN0ZXIoXHJcbiAgICAgICAgc2NyaXB0c1RvSW1wb3J0LCAnaW1hZ2VEZWNvZGVyRnJhbWV3b3JrLkltYWdlRGVjb2RlcicsIGN0b3JBcmdzKTtcclxuICAgIFxyXG4gICAgdmFyIGJvdW5kSW1hZ2VPcGVuZWQgPSB0aGlzLl9pbWFnZU9wZW5lZC5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5fd29ya2VySGVscGVyLnNldFVzZXJEYXRhSGFuZGxlcihib3VuZEltYWdlT3BlbmVkKTtcclxufVxyXG5cclxuV29ya2VyUHJveHlJbWFnZURlY29kZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJbWFnZVBhcmFtc1JldHJpZXZlclByb3h5LnByb3RvdHlwZSk7XHJcblxyXG5Xb3JrZXJQcm94eUltYWdlRGVjb2Rlci5wcm90b3R5cGUuZ2V0VGlsZVdpZHRoID0gZnVuY3Rpb24gZ2V0VGlsZVdpZHRoKCkge1xyXG4gICAgdGhpcy5fdmFsaWRhdGVTaXplc0NhbGN1bGF0b3IoKTtcclxuICAgIHJldHVybiB0aGlzLl90aWxlV2lkdGg7XHJcbn07XHJcblxyXG5Xb3JrZXJQcm94eUltYWdlRGVjb2Rlci5wcm90b3R5cGUuZ2V0VGlsZUhlaWdodCA9IGZ1bmN0aW9uIGdldFRpbGVIZWlnaHQoKSB7XHJcbiAgICB0aGlzLl92YWxpZGF0ZVNpemVzQ2FsY3VsYXRvcigpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3RpbGVIZWlnaHQ7XHJcbn07XHJcblxyXG5Xb3JrZXJQcm94eUltYWdlRGVjb2Rlci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIG9wZW4odXJsKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICByZXR1cm4gdGhpcy5fd29ya2VySGVscGVyLmNhbGxGdW5jdGlvbignb3BlbicsIFt1cmxdLCB7IGlzUmV0dXJuUHJvbWlzZTogdHJ1ZSB9KVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKGltYWdlUGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHNlbGYuX2ltYWdlT3BlbmVkKGltYWdlUGFyYW1zKTtcclxuICAgICAgICAgICAgcmV0dXJuIGltYWdlUGFyYW1zO1xyXG4gICAgICAgIH0pO1xyXG59O1xyXG5cclxuV29ya2VyUHJveHlJbWFnZURlY29kZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gY2xvc2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fd29ya2VySGVscGVyLmNhbGxGdW5jdGlvbignY2xvc2UnLCBbXSwgeyBpc1JldHVyblByb21pc2U6IHRydWUgfSk7XHJcbn07XHJcblxyXG5Xb3JrZXJQcm94eUltYWdlRGVjb2Rlci5wcm90b3R5cGUuY3JlYXRlQ2hhbm5lbCA9IGZ1bmN0aW9uIGNyZWF0ZUNoYW5uZWwoXHJcbiAgICBjcmVhdGVkQ2FsbGJhY2spIHtcclxuICAgIFxyXG4gICAgdmFyIGNhbGxiYWNrV3JhcHBlciA9IHRoaXMuX3dvcmtlckhlbHBlci53cmFwQ2FsbGJhY2soXHJcbiAgICAgICAgY3JlYXRlZENhbGxiYWNrLCAnSW1hZ2VEZWNvZGVyX2NyZWF0ZUNoYW5uZWxDYWxsYmFjaycpO1xyXG4gICAgXHJcbiAgICB2YXIgYXJncyA9IFtjYWxsYmFja1dyYXBwZXJdO1xyXG4gICAgdGhpcy5fd29ya2VySGVscGVyLmNhbGxGdW5jdGlvbignY3JlYXRlQ2hhbm5lbCcsIGFyZ3MpO1xyXG59O1xyXG5cclxuV29ya2VyUHJveHlJbWFnZURlY29kZXIucHJvdG90eXBlLnJlcXVlc3RQaXhlbHMgPSBmdW5jdGlvbiByZXF1ZXN0UGl4ZWxzKGltYWdlUGFydFBhcmFtcykge1xyXG4gICAgdmFyIHBhdGhUb1BpeGVsc0FycmF5ID0gWydkYXRhJywgJ2J1ZmZlciddO1xyXG4gICAgdmFyIHRyYW5zZmVyYWJsZXMgPSBbcGF0aFRvUGl4ZWxzQXJyYXldO1xyXG4gICAgXHJcbiAgICB2YXIgYXJncyA9IFtpbWFnZVBhcnRQYXJhbXNdO1xyXG4gICAgXHJcbiAgICB0aGlzLl93b3JrZXJIZWxwZXIuY2FsbEZ1bmN0aW9uKCdyZXF1ZXN0UGl4ZWxzJywgYXJncywge1xyXG4gICAgICAgIGlzUmV0dXJuUHJvbWlzZTogdHJ1ZSxcclxuICAgICAgICBwYXRoc1RvVHJhbnNmZXJhYmxlc0luUHJvbWlzZVJlc3VsdDogdHJhbnNmZXJhYmxlc1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5Xb3JrZXJQcm94eUltYWdlRGVjb2Rlci5wcm90b3R5cGUucmVxdWVzdFBpeGVsc1Byb2dyZXNzaXZlID0gZnVuY3Rpb24gcmVxdWVzdFBpeGVsc1Byb2dyZXNzaXZlKFxyXG4gICAgaW1hZ2VQYXJ0UGFyYW1zLFxyXG4gICAgY2FsbGJhY2ssXHJcbiAgICB0ZXJtaW5hdGVkQ2FsbGJhY2ssXHJcbiAgICBpbWFnZVBhcnRQYXJhbXNOb3ROZWVkZWQsXHJcbiAgICBjaGFubmVsSGFuZGxlKSB7XHJcbiAgICBcclxuICAgIHZhciB0cmFuc2ZlcmFibGVzO1xyXG4gICAgXHJcbiAgICAvLyBOT1RFOiBDYW5ub3QgcGFzcyBpdCBhcyB0cmFuc2ZlcmFibGVzIGJlY2F1c2UgaXQgaXMgcGFzc2VkIHRvIGFsbFxyXG4gICAgLy8gbGlzdGVuZXIgY2FsbGJhY2tzLCB0aHVzIGFmdGVyIHRoZSBmaXJzdCBvbmUgdGhlIGJ1ZmZlciBpcyBub3QgdmFsaWRcclxuICAgIFxyXG4gICAgLy92YXIgcGF0aFRvUGl4ZWxzQXJyYXkgPSBbMCwgJ3BpeGVscycsICdidWZmZXInXTtcclxuICAgIC8vdHJhbnNmZXJhYmxlcyA9IFtwYXRoVG9QaXhlbHNBcnJheV07XHJcbiAgICBcclxuICAgIHZhciBpbnRlcm5hbENhbGxiYWNrV3JhcHBlciA9XHJcbiAgICAgICAgdGhpcy5fd29ya2VySGVscGVyLndyYXBDYWxsYmFjayhcclxuICAgICAgICAgICAgY2FsbGJhY2ssICdyZXF1ZXN0UGl4ZWxzUHJvZ3Jlc3NpdmVDYWxsYmFjaycsIHtcclxuICAgICAgICAgICAgICAgIGlzTXVsdGlwbGVUaW1lQ2FsbGJhY2s6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBwYXRoc1RvVHJhbnNmZXJhYmxlczogdHJhbnNmZXJhYmxlc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuICAgIFxyXG4gICAgdmFyIGludGVybmFsVGVybWluYXRlZENhbGxiYWNrV3JhcHBlciA9XHJcbiAgICAgICAgdGhpcy5fd29ya2VySGVscGVyLndyYXBDYWxsYmFjayhcclxuICAgICAgICAgICAgaW50ZXJuYWxUZXJtaW5hdGVkQ2FsbGJhY2ssICdyZXF1ZXN0UGl4ZWxzUHJvZ3Jlc3NpdmVUZXJtaW5hdGVkQ2FsbGJhY2snLCB7XHJcbiAgICAgICAgICAgICAgICBpc011bHRpcGxlVGltZUNhbGxiYWNrOiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuICAgICAgICAgICAgXHJcbiAgICB2YXIgYXJncyA9IFtcclxuICAgICAgICBpbWFnZVBhcnRQYXJhbXMsXHJcbiAgICAgICAgaW50ZXJuYWxDYWxsYmFja1dyYXBwZXIsXHJcbiAgICAgICAgaW50ZXJuYWxUZXJtaW5hdGVkQ2FsbGJhY2tXcmFwcGVyLFxyXG4gICAgICAgIGltYWdlUGFydFBhcmFtc05vdE5lZWRlZCxcclxuICAgICAgICBjaGFubmVsSGFuZGxlXTtcclxuICAgIFxyXG4gICAgdGhpcy5fd29ya2VySGVscGVyLmNhbGxGdW5jdGlvbigncmVxdWVzdFBpeGVsc1Byb2dyZXNzaXZlJywgYXJncyk7XHJcbiAgICAgICAgXHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGludGVybmFsVGVybWluYXRlZENhbGxiYWNrKGlzQWJvcnRlZCkge1xyXG4gICAgICAgIHNlbGYuX3dvcmtlckhlbHBlci5mcmVlQ2FsbGJhY2soaW50ZXJuYWxDYWxsYmFja1dyYXBwZXIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRlcm1pbmF0ZWRDYWxsYmFjayhpc0Fib3J0ZWQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuV29ya2VyUHJveHlJbWFnZURlY29kZXIucHJvdG90eXBlLnNldFNlcnZlclJlcXVlc3RQcmlvcml0aXplckRhdGEgPVxyXG4gICAgZnVuY3Rpb24gc2V0U2VydmVyUmVxdWVzdFByaW9yaXRpemVyRGF0YShwcmlvcml0aXplckRhdGEpIHtcclxuICAgIFxyXG4gICAgdGhpcy5fd29ya2VySGVscGVyLmNhbGxGdW5jdGlvbihcclxuICAgICAgICAnc2V0U2VydmVyUmVxdWVzdFByaW9yaXRpemVyRGF0YScsXHJcbiAgICAgICAgWyBwcmlvcml0aXplckRhdGEgXSxcclxuICAgICAgICB7IGlzU2VuZEltbWVkaWF0ZWx5OiB0cnVlIH0pO1xyXG59O1xyXG5cclxuV29ya2VyUHJveHlJbWFnZURlY29kZXIucHJvdG90eXBlLnNldERlY29kZVByaW9yaXRpemVyRGF0YSA9XHJcbiAgICBmdW5jdGlvbiBzZXREZWNvZGVQcmlvcml0aXplckRhdGEocHJpb3JpdGl6ZXJEYXRhKSB7XHJcbiAgICBcclxuICAgIHRoaXMuX3dvcmtlckhlbHBlci5jYWxsRnVuY3Rpb24oXHJcbiAgICAgICAgJ3NldERlY29kZVByaW9yaXRpemVyRGF0YScsXHJcbiAgICAgICAgWyBwcmlvcml0aXplckRhdGEgXSxcclxuICAgICAgICB7IGlzU2VuZEltbWVkaWF0ZWx5OiB0cnVlIH0pO1xyXG59O1xyXG5cclxuV29ya2VyUHJveHlJbWFnZURlY29kZXIucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uIHJlY29ubmVjdCgpIHtcclxuICAgIHRoaXMuX3dvcmtlckhlbHBlci5jYWxsRnVuY3Rpb24oJ3JlY29ubmVjdCcpO1xyXG59O1xyXG5cclxuV29ya2VyUHJveHlJbWFnZURlY29kZXIucHJvdG90eXBlLmFsaWduUGFyYW1zVG9UaWxlc0FuZExldmVsID0gZnVuY3Rpb24gYWxpZ25QYXJhbXNUb1RpbGVzQW5kTGV2ZWwocmVnaW9uKSB7XHJcblx0cmV0dXJuIGltYWdlSGVscGVyRnVuY3Rpb25zLmFsaWduUGFyYW1zVG9UaWxlc0FuZExldmVsKHJlZ2lvbiwgdGhpcyk7XHJcbn07XHJcblxyXG5Xb3JrZXJQcm94eUltYWdlRGVjb2Rlci5wcm90b3R5cGUuX2ltYWdlT3BlbmVkID0gZnVuY3Rpb24gaW1hZ2VPcGVuZWQoZGF0YSkge1xyXG4gICAgdGhpcy5faW50ZXJuYWxTaXplc1BhcmFtcyA9IGRhdGEuc2l6ZXNQYXJhbXM7XHJcbiAgICB0aGlzLl90aWxlV2lkdGggPSBkYXRhLmFwcGxpY2F0aXZlVGlsZVdpZHRoO1xyXG4gICAgdGhpcy5fdGlsZUhlaWdodCA9IGRhdGEuYXBwbGljYXRpdmVUaWxlSGVpZ2h0O1xyXG4gICAgdGhpcy5fdmFsaWRhdGVTaXplc0NhbGN1bGF0b3IoKTtcclxufTtcclxuXHJcbldvcmtlclByb3h5SW1hZ2VEZWNvZGVyLnByb3RvdHlwZS5fZ2V0U2l6ZXNQYXJhbXNJbnRlcm5hbCA9IGZ1bmN0aW9uIGdldFNpemVzUGFyYW1zSW50ZXJuYWwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxTaXplc1BhcmFtcztcclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG4vLyBTdXBwcmVzcyBcIlVubmVjZXNzYXJ5IGRpcmVjdGl2ZSAndXNlIHN0cmljdCdcIiBmb3IgdGhlIHNsYXZlU2NyaXB0Q29udGVudCBmdW5jdGlvblxyXG4vKmpzaGludCAtVzAzNCAqL1xyXG5cclxuLyogZ2xvYmFsIHNlbGY6IGZhbHNlICovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmtlclByb3h5UGl4ZWxzRGVjb2RlcjtcclxuXHJcbnZhciBpbWFnZUhlbHBlckZ1bmN0aW9ucyA9IHJlcXVpcmUoJ2ltYWdlaGVscGVyZnVuY3Rpb25zLmpzJyk7XHJcblxyXG52YXIgZGVjb2RlclNsYXZlU2NyaXB0QmxvYiA9IG5ldyBCbG9iKFxyXG4gICAgWycoJywgZGVjb2RlclNsYXZlU2NyaXB0Qm9keS50b1N0cmluZygpLCAnKSgpJ10sXHJcbiAgICB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyB9KTtcclxudmFyIGRlY29kZXJTbGF2ZVNjcmlwdFVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZGVjb2RlclNsYXZlU2NyaXB0QmxvYik7XHJcblxyXG5mdW5jdGlvbiBXb3JrZXJQcm94eVBpeGVsc0RlY29kZXIob3B0aW9ucykge1xyXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICB0aGlzLl9pbWFnZUltcGxlbWVudGF0aW9uID0gaW1hZ2VIZWxwZXJGdW5jdGlvbnMuZ2V0SW1hZ2VJbXBsZW1lbnRhdGlvbihcclxuICAgICAgICBvcHRpb25zLmltYWdlSW1wbGVtZW50YXRpb25DbGFzc05hbWUpO1xyXG4gICAgXHJcbiAgICB2YXIgc2NyaXB0c1RvSW1wb3J0ID0gKHRoaXMuX29wdGlvbnMuc2NyaXB0c1RvSW1wb3J0IHx8IFtdKS5jb25jYXQoW2RlY29kZXJTbGF2ZVNjcmlwdFVybF0pO1xyXG4gICAgdmFyIGFyZ3MgPSBbdGhpcy5fb3B0aW9uc107XHJcbiAgICBcclxuICAgIHRoaXMuX3dvcmtlckhlbHBlciA9IG5ldyBBc3luY1Byb3h5LkFzeW5jUHJveHlNYXN0ZXIoXHJcbiAgICAgICAgc2NyaXB0c1RvSW1wb3J0LFxyXG4gICAgICAgICdBcmJpdHJhcnlDbGFzc05hbWUnLFxyXG4gICAgICAgIGFyZ3MpO1xyXG59XHJcblxyXG5Xb3JrZXJQcm94eVBpeGVsc0RlY29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShkYXRhRm9yRGVjb2RlKSB7XHJcbiAgICAvL3ZhciB0cmFuc2ZlcmFibGVzID0gdGhpcy5faW1hZ2VJbXBsZW1lbnRhdGlvbi5nZXRUcmFuc2ZlcmFibGVPZkRlY29kZUFyZ3VtZW50cyhkYXRhRm9yRGVjb2RlKTtcclxuICAgIHZhciByZXN1bHRUcmFuc2ZlcmFibGVzID0gW1snZGF0YScsICdidWZmZXInXV07XHJcbiAgICBcclxuICAgIHZhciBhcmdzID0gW2RhdGFGb3JEZWNvZGVdO1xyXG4gICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgLy90cmFuc2ZlcmFibGVzOiB0cmFuc2ZlcmFibGVzLFxyXG4gICAgICAgIHBhdGhzVG9UcmFuc2ZlcmFibGVzSW5Qcm9taXNlUmVzdWx0OiByZXN1bHRUcmFuc2ZlcmFibGVzLFxyXG4gICAgICAgIGlzUmV0dXJuUHJvbWlzZTogdHJ1ZVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHRoaXMuX3dvcmtlckhlbHBlci5jYWxsRnVuY3Rpb24oJ2RlY29kZScsIGFyZ3MsIG9wdGlvbnMpO1xyXG59O1xyXG5cclxuV29ya2VyUHJveHlQaXhlbHNEZWNvZGVyLnByb3RvdHlwZS50ZXJtaW5hdGUgPSBmdW5jdGlvbiB0ZXJtaW5hdGUoKSB7XHJcbiAgICB0aGlzLl93b3JrZXJIZWxwZXIudGVybWluYXRlKCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBkZWNvZGVyU2xhdmVTY3JpcHRCb2R5KCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIEFzeW5jUHJveHkuQXN5bmNQcm94eVNsYXZlLnNldFNsYXZlU2lkZUNyZWF0b3IoZnVuY3Rpb24gY3JlYXRlRGVjb2RlcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGltYWdlSW1wbGVtZW50YXRpb24gPSBzZWxmW29wdGlvbnMuaW1hZ2VJbXBsZW1lbnRhdGlvbkNsYXNzTmFtZV07XHJcbiAgICAgICAgcmV0dXJuIGltYWdlSW1wbGVtZW50YXRpb24uY3JlYXRlUGl4ZWxzRGVjb2RlcigpO1xyXG4gICAgfSk7XHJcbn0iLCIndXNlIHN0cmljdCc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXdlckltYWdlRGVjb2RlcjtcclxuXHJcbnZhciBJbWFnZURlY29kZXIgPSByZXF1aXJlKCdpbWFnZWRlY29kZXIuanMnKTtcclxudmFyIFdvcmtlclByb3h5SW1hZ2VEZWNvZGVyID0gcmVxdWlyZSgnd29ya2VycHJveHlpbWFnZWRlY29kZXIuanMnKTtcclxudmFyIGltYWdlSGVscGVyRnVuY3Rpb25zID0gcmVxdWlyZSgnaW1hZ2VoZWxwZXJmdW5jdGlvbnMuanMnKTtcclxuXHJcbnZhciBQRU5ESU5HX0NBTExfVFlQRV9QSVhFTFNfVVBEQVRFRCA9IDE7XHJcbnZhciBQRU5ESU5HX0NBTExfVFlQRV9SRVBPU0lUSU9OID0gMjtcclxuXHJcbnZhciBSRUdJT05fT1ZFUlZJRVcgPSAwO1xyXG52YXIgUkVHSU9OX0RZTkFNSUMgPSAxO1xyXG5cclxuZnVuY3Rpb24gVmlld2VySW1hZ2VEZWNvZGVyKGltYWdlSW1wbGVtZW50YXRpb25DbGFzc05hbWUsIGNhbnZhc1VwZGF0ZWRDYWxsYmFjaywgb3B0aW9ucykge1xyXG4gICAgdGhpcy5faW1hZ2VJbXBsZW1lbnRhdGlvbkNsYXNzTmFtZSA9IGltYWdlSW1wbGVtZW50YXRpb25DbGFzc05hbWU7XHJcbiAgICB0aGlzLl9jYW52YXNVcGRhdGVkQ2FsbGJhY2sgPSBjYW52YXNVcGRhdGVkQ2FsbGJhY2s7XHJcbiAgICBcclxuICAgIHRoaXMuX2FkYXB0UHJvcG9ydGlvbnMgPSBvcHRpb25zLmFkYXB0UHJvcG9ydGlvbnM7XHJcbiAgICB0aGlzLl9jYXJ0b2dyYXBoaWNCb3VuZHMgPSBvcHRpb25zLmNhcnRvZ3JhcGhpY0JvdW5kcztcclxuICAgIHRoaXMuX2lzTWFpbkltYWdlT25VaSA9IG9wdGlvbnMuaXNNYWluSW1hZ2VPblVpO1xyXG4gICAgdGhpcy5fc2hvd0xvZyA9IG9wdGlvbnMuc2hvd0xvZztcclxuICAgIHRoaXMuX2FsbG93TXVsdGlwbGVDaGFubmVsc0luU2Vzc2lvbiA9XHJcbiAgICAgICAgb3B0aW9ucy5hbGxvd011bHRpcGxlQ2hhbm5lbHNJblNlc3Npb247XHJcbiAgICB0aGlzLl9taW5GdW5jdGlvbkNhbGxJbnRlcnZhbE1pbGxpc2Vjb25kcyA9XHJcbiAgICAgICAgb3B0aW9ucy5taW5GdW5jdGlvbkNhbGxJbnRlcnZhbE1pbGxpc2Vjb25kcztcclxuICAgIHRoaXMuX292ZXJ2aWV3UmVzb2x1dGlvblggPSBvcHRpb25zLm92ZXJ2aWV3UmVzb2x1dGlvblggfHwgMTAwO1xyXG4gICAgdGhpcy5fb3ZlcnZpZXdSZXNvbHV0aW9uWSA9IG9wdGlvbnMub3ZlcnZpZXdSZXNvbHV0aW9uWSB8fCAxMDA7XHJcbiAgICB0aGlzLl93b3JrZXJzTGltaXQgPSBvcHRpb25zLndvcmtlcnNMaW1pdDtcclxuICAgICAgICBcclxuICAgIHRoaXMuX2xhc3RSZXF1ZXN0SW5kZXggPSAwO1xyXG4gICAgdGhpcy5fcGVuZGluZ1VwZGF0ZVZpZXdBcmVhID0gbnVsbDtcclxuICAgIHRoaXMuX3JlZ2lvbnMgPSBbXTtcclxuICAgIHRoaXMuX3RhcmdldENhbnZhcyA9IG51bGw7XHJcbiAgICBcclxuICAgIHRoaXMuX2NhbGxQZW5kaW5nQ2FsbGJhY2tzQm91bmQgPSB0aGlzLl9jYWxsUGVuZGluZ0NhbGxiYWNrcy5iaW5kKHRoaXMpO1xyXG4gICAgdGhpcy5fY3JlYXRlZENoYW5uZWxCb3VuZCA9IHRoaXMuX2NyZWF0ZWRDaGFubmVsLmJpbmQodGhpcyk7XHJcbiAgICBcclxuICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFja3NJbnRlcnZhbEhhbmRsZSA9IDA7XHJcbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tDYWxscyA9IFtdO1xyXG4gICAgdGhpcy5fY2FuU2hvd0R5bmFtaWNSZWdpb24gPSBmYWxzZTtcclxuICAgIFxyXG4gICAgaWYgKHRoaXMuX2NhcnRvZ3JhcGhpY0JvdW5kcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhpcy5fY2FydG9ncmFwaGljQm91bmRzID0ge1xyXG4gICAgICAgICAgICB3ZXN0OiAtMTc1LjAsXHJcbiAgICAgICAgICAgIGVhc3Q6IDE3NS4wLFxyXG4gICAgICAgICAgICBzb3V0aDogLTg1LjAsXHJcbiAgICAgICAgICAgIG5vcnRoOiA4NS4wXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHRoaXMuX2FkYXB0UHJvcG9ydGlvbnMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRoaXMuX2FkYXB0UHJvcG9ydGlvbnMgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2YXIgSW1hZ2VUeXBlID0gdGhpcy5faXNNYWluSW1hZ2VPblVpID9cclxuICAgICAgICBJbWFnZURlY29kZXI6IFdvcmtlclByb3h5SW1hZ2VEZWNvZGVyO1xyXG4gICAgICAgIFxyXG4gICAgdGhpcy5faW1hZ2UgPSBuZXcgSW1hZ2VUeXBlKGltYWdlSW1wbGVtZW50YXRpb25DbGFzc05hbWUsIHtcclxuICAgICAgICBzZXJ2ZXJSZXF1ZXN0UHJpb3JpdGl6ZXI6ICdmcnVzdHVtT25seScsXHJcbiAgICAgICAgZGVjb2RlUHJpb3JpdGl6ZXI6ICdmcnVzdHVtT25seScsXHJcbiAgICAgICAgc2hvd0xvZzogdGhpcy5fc2hvd0xvZyxcclxuICAgICAgICB3b3JrZXJzTGltaXQ6IHRoaXMuX3dvcmtlcnNMaW1pdFxyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG5WaWV3ZXJJbWFnZURlY29kZXIucHJvdG90eXBlLnNldEV4Y2VwdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24gc2V0RXhjZXB0aW9uQ2FsbGJhY2soZXhjZXB0aW9uQ2FsbGJhY2spIHtcclxuICAgIC8vIFRPRE86IFN1cHBvcnQgZXhjZXB0aW9uQ2FsbGJhY2sgaW4gZXZlcnkgcGxhY2UgbmVlZGVkXHJcblx0dGhpcy5fZXhjZXB0aW9uQ2FsbGJhY2sgPSBleGNlcHRpb25DYWxsYmFjaztcclxufTtcclxuICAgIFxyXG5WaWV3ZXJJbWFnZURlY29kZXIucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiBvcGVuKHVybCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ltYWdlLm9wZW4odXJsKVxyXG4gICAgICAgIC50aGVuKHRoaXMuX29wZW5lZC5iaW5kKHRoaXMpKVxyXG4gICAgICAgIC5jYXRjaCh0aGlzLl9leGNlcHRpb25DYWxsYmFjayk7XHJcbn07XHJcblxyXG5WaWV3ZXJJbWFnZURlY29kZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gY2xvc2UoKSB7XHJcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX2ltYWdlLmNsb3NlKCk7XHJcbiAgICBwcm9taXNlLmNhdGNoKHRoaXMuX2V4Y2VwdGlvbkNhbGxiYWNrKTtcclxuICAgIHRoaXMuX2lzUmVhZHkgPSBmYWxzZTtcclxuICAgIHRoaXMuX2NhblNob3dEeW5hbWljUmVnaW9uID0gZmFsc2U7XHJcbiAgICB0aGlzLl90YXJnZXRDYW52YXMgPSBudWxsO1xyXG5cdHJldHVybiBwcm9taXNlO1xyXG59O1xyXG5cclxuVmlld2VySW1hZ2VEZWNvZGVyLnByb3RvdHlwZS5zZXRUYXJnZXRDYW52YXMgPSBmdW5jdGlvbiBzZXRUYXJnZXRDYW52YXMoY2FudmFzKSB7XHJcbiAgICB0aGlzLl90YXJnZXRDYW52YXMgPSBjYW52YXM7XHJcbn07XHJcblxyXG5WaWV3ZXJJbWFnZURlY29kZXIucHJvdG90eXBlLnVwZGF0ZVZpZXdBcmVhID0gZnVuY3Rpb24gdXBkYXRlVmlld0FyZWEoZnJ1c3R1bURhdGEpIHtcclxuICAgIGlmICh0aGlzLl90YXJnZXRDYW52YXMgPT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyAnQ2Fubm90IHVwZGF0ZSBkeW5hbWljIHJlZ2lvbiBiZWZvcmUgc2V0VGFyZ2V0Q2FudmFzKCknO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoIXRoaXMuX2NhblNob3dEeW5hbWljUmVnaW9uKSB7XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ1VwZGF0ZVZpZXdBcmVhID0gZnJ1c3R1bURhdGE7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB2YXIgYm91bmRzID0gZnJ1c3R1bURhdGEucmVjdGFuZ2xlO1xyXG4gICAgdmFyIHNjcmVlblNpemUgPSBmcnVzdHVtRGF0YS5zY3JlZW5TaXplO1xyXG4gICAgXHJcbiAgICB2YXIgcmVnaW9uUGFyYW1zID0ge1xyXG4gICAgICAgIG1pblg6IGJvdW5kcy53ZXN0ICogdGhpcy5fc2NhbGVYICsgdGhpcy5fdHJhbnNsYXRlWCxcclxuICAgICAgICBtaW5ZOiBib3VuZHMubm9ydGggKiB0aGlzLl9zY2FsZVkgKyB0aGlzLl90cmFuc2xhdGVZLFxyXG4gICAgICAgIG1heFhFeGNsdXNpdmU6IGJvdW5kcy5lYXN0ICogdGhpcy5fc2NhbGVYICsgdGhpcy5fdHJhbnNsYXRlWCxcclxuICAgICAgICBtYXhZRXhjbHVzaXZlOiBib3VuZHMuc291dGggKiB0aGlzLl9zY2FsZVkgKyB0aGlzLl90cmFuc2xhdGVZLFxyXG4gICAgICAgIHNjcmVlbldpZHRoOiBzY3JlZW5TaXplLngsXHJcbiAgICAgICAgc2NyZWVuSGVpZ2h0OiBzY3JlZW5TaXplLnlcclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciBhbGlnbmVkUGFyYW1zID1cclxuICAgICAgICBpbWFnZUhlbHBlckZ1bmN0aW9ucy5hbGlnblBhcmFtc1RvVGlsZXNBbmRMZXZlbChcclxuICAgICAgICAgICAgcmVnaW9uUGFyYW1zLCB0aGlzLl9pbWFnZSk7XHJcbiAgICBcclxuICAgIHZhciBpc091dHNpZGVTY3JlZW4gPSBhbGlnbmVkUGFyYW1zID09PSBudWxsO1xyXG4gICAgaWYgKGlzT3V0c2lkZVNjcmVlbikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgYWxpZ25lZFBhcmFtcy5pbWFnZVBhcnRQYXJhbXMucXVhbGl0eSA9IHRoaXMuX3F1YWxpdHk7XHJcblxyXG4gICAgdmFyIGlzU2FtZVJlZ2lvbiA9XHJcbiAgICAgICAgdGhpcy5fZHluYW1pY0ZldGNoUGFyYW1zICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICB0aGlzLl9pc0ltYWdlUGFydHNFcXVhbChcclxuICAgICAgICAgICAgYWxpZ25lZFBhcmFtcy5pbWFnZVBhcnRQYXJhbXMsXHJcbiAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNGZXRjaFBhcmFtcy5pbWFnZVBhcnRQYXJhbXMpO1xyXG4gICAgXHJcbiAgICBpZiAoaXNTYW1lUmVnaW9uKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmcnVzdHVtRGF0YS5pbWFnZVJlY3RhbmdsZSA9IHRoaXMuX2NhcnRvZ3JhcGhpY0JvdW5kc0ZpeGVkO1xyXG4gICAgZnJ1c3R1bURhdGEuZXhhY3RsZXZlbCA9XHJcbiAgICAgICAgYWxpZ25lZFBhcmFtcy5pbWFnZVBhcnRQYXJhbXMubGV2ZWw7XHJcbiAgICBcclxuICAgIHRoaXMuX2ltYWdlLnNldERlY29kZVByaW9yaXRpemVyRGF0YShmcnVzdHVtRGF0YSk7XHJcbiAgICB0aGlzLl9pbWFnZS5zZXRTZXJ2ZXJSZXF1ZXN0UHJpb3JpdGl6ZXJEYXRhKGZydXN0dW1EYXRhKTtcclxuXHJcbiAgICB0aGlzLl9keW5hbWljRmV0Y2hQYXJhbXMgPSBhbGlnbmVkUGFyYW1zO1xyXG4gICAgXHJcbiAgICB2YXIgc3RhcnREeW5hbWljUmVnaW9uT25UZXJtaW5hdGlvbiA9IGZhbHNlO1xyXG4gICAgdmFyIG1vdmVFeGlzdGluZ0NoYW5uZWwgPSAhdGhpcy5fYWxsb3dNdWx0aXBsZUNoYW5uZWxzSW5TZXNzaW9uO1xyXG4gICAgdGhpcy5fZmV0Y2goXHJcbiAgICAgICAgUkVHSU9OX0RZTkFNSUMsXHJcbiAgICAgICAgYWxpZ25lZFBhcmFtcyxcclxuICAgICAgICBzdGFydER5bmFtaWNSZWdpb25PblRlcm1pbmF0aW9uLFxyXG4gICAgICAgIG1vdmVFeGlzdGluZ0NoYW5uZWwpO1xyXG59O1xyXG5cclxuVmlld2VySW1hZ2VEZWNvZGVyLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiBnZXRDYXJ0b2dyYXBoaWNCb3VuZHMoKSB7XHJcbiAgICBpZiAoIXRoaXMuX2lzUmVhZHkpIHtcclxuICAgICAgICB0aHJvdyAnVmlld2VySW1hZ2VEZWNvZGVyIGVycm9yOiBJbWFnZSBpcyBub3QgcmVhZHkgeWV0JztcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9jYXJ0b2dyYXBoaWNCb3VuZHNGaXhlZDtcclxufTtcclxuXHJcblZpZXdlckltYWdlRGVjb2Rlci5wcm90b3R5cGUuX2lzSW1hZ2VQYXJ0c0VxdWFsID0gZnVuY3Rpb24gaXNJbWFnZVBhcnRzRXF1YWwoZmlyc3QsIHNlY29uZCkge1xyXG4gICAgdmFyIGlzRXF1YWwgPVxyXG4gICAgICAgIHRoaXMuX2R5bmFtaWNGZXRjaFBhcmFtcyAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgZmlyc3QubWluWCA9PT0gc2Vjb25kLm1pblggJiZcclxuICAgICAgICBmaXJzdC5taW5ZID09PSBzZWNvbmQubWluWSAmJlxyXG4gICAgICAgIGZpcnN0Lm1heFhFeGNsdXNpdmUgPT09IHNlY29uZC5tYXhYRXhjbHVzaXZlICYmXHJcbiAgICAgICAgZmlyc3QubWF4WUV4Y2x1c2l2ZSA9PT0gc2Vjb25kLm1heFlFeGNsdXNpdmUgJiZcclxuICAgICAgICBmaXJzdC5sZXZlbCA9PT0gc2Vjb25kLmxldmVsO1xyXG4gICAgXHJcbiAgICByZXR1cm4gaXNFcXVhbDtcclxufTtcclxuXHJcblZpZXdlckltYWdlRGVjb2Rlci5wcm90b3R5cGUuX2ZldGNoID0gZnVuY3Rpb24gZmV0Y2goXHJcbiAgICByZWdpb25JZCxcclxuICAgIGZldGNoUGFyYW1zLFxyXG4gICAgc3RhcnREeW5hbWljUmVnaW9uT25UZXJtaW5hdGlvbixcclxuICAgIG1vdmVFeGlzdGluZ0NoYW5uZWwpIHtcclxuICAgIFxyXG4gICAgdmFyIHJlcXVlc3RJbmRleCA9ICsrdGhpcy5fbGFzdFJlcXVlc3RJbmRleDtcclxuICAgIFxyXG4gICAgdmFyIGltYWdlUGFydFBhcmFtcyA9IGZldGNoUGFyYW1zLmltYWdlUGFydFBhcmFtcztcclxuICAgIGltYWdlUGFydFBhcmFtcy5yZXF1ZXN0UHJpb3JpdHlEYXRhID1cclxuICAgICAgICBpbWFnZVBhcnRQYXJhbXMucmVxdWVzdFByaW9yaXR5RGF0YSB8fCB7fTtcclxuICAgIFxyXG4gICAgaW1hZ2VQYXJ0UGFyYW1zLnJlcXVlc3RQcmlvcml0eURhdGEucmVxdWVzdEluZGV4ID0gcmVxdWVzdEluZGV4O1xyXG5cclxuICAgIHZhciBtaW5YID0gZmV0Y2hQYXJhbXMucG9zaXRpb25JbkltYWdlLm1pblg7XHJcbiAgICB2YXIgbWluWSA9IGZldGNoUGFyYW1zLnBvc2l0aW9uSW5JbWFnZS5taW5ZO1xyXG4gICAgdmFyIG1heFggPSBmZXRjaFBhcmFtcy5wb3NpdGlvbkluSW1hZ2UubWF4WEV4Y2x1c2l2ZTtcclxuICAgIHZhciBtYXhZID0gZmV0Y2hQYXJhbXMucG9zaXRpb25JbkltYWdlLm1heFlFeGNsdXNpdmU7XHJcbiAgICBcclxuICAgIHZhciB3ZXN0ID0gKG1pblggLSB0aGlzLl90cmFuc2xhdGVYKSAvIHRoaXMuX3NjYWxlWDtcclxuICAgIHZhciBlYXN0ID0gKG1heFggLSB0aGlzLl90cmFuc2xhdGVYKSAvIHRoaXMuX3NjYWxlWDtcclxuICAgIHZhciBub3J0aCA9IChtaW5ZIC0gdGhpcy5fdHJhbnNsYXRlWSkgLyB0aGlzLl9zY2FsZVk7XHJcbiAgICB2YXIgc291dGggPSAobWF4WSAtIHRoaXMuX3RyYW5zbGF0ZVkpIC8gdGhpcy5fc2NhbGVZO1xyXG4gICAgXHJcbiAgICB2YXIgcG9zaXRpb24gPSB7XHJcbiAgICAgICAgd2VzdDogd2VzdCxcclxuICAgICAgICBlYXN0OiBlYXN0LFxyXG4gICAgICAgIG5vcnRoOiBub3J0aCxcclxuICAgICAgICBzb3V0aDogc291dGhcclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciBjYW5SZXVzZU9sZERhdGEgPSBmYWxzZTtcclxuICAgIHZhciBmZXRjaFBhcmFtc05vdE5lZWRlZDtcclxuICAgIFxyXG4gICAgdmFyIHJlZ2lvbiA9IHRoaXMuX3JlZ2lvbnNbcmVnaW9uSWRdO1xyXG4gICAgaWYgKHJlZ2lvbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdmFyIG5ld1Jlc29sdXRpb24gPSBpbWFnZVBhcnRQYXJhbXMubGV2ZWw7XHJcbiAgICAgICAgdmFyIG9sZFJlc29sdXRpb24gPSByZWdpb24uaW1hZ2VQYXJ0UGFyYW1zLmxldmVsO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNhblJldXNlT2xkRGF0YSA9IG5ld1Jlc29sdXRpb24gPT09IG9sZFJlc29sdXRpb247XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGNhblJldXNlT2xkRGF0YSAmJiByZWdpb24uZG9uZVBhcnRQYXJhbXMpIHtcclxuICAgICAgICAgICAgZmV0Y2hQYXJhbXNOb3ROZWVkZWQgPSBbIHJlZ2lvbi5kb25lUGFydFBhcmFtcyBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJlZ2lvbklkICE9PSBSRUdJT05fT1ZFUlZJRVcpIHtcclxuICAgICAgICAgICAgdmFyIGFkZGVkUGVuZGluZ0NhbGwgPSB0aGlzLl9jaGVja0lmUmVwb3NpdGlvbk5lZWRlZChcclxuICAgICAgICAgICAgICAgIHJlZ2lvbiwgaW1hZ2VQYXJ0UGFyYW1zLCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoYWRkZWRQZW5kaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbm90aWZ5TmV3UGVuZGluZ0NhbGxzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIFxyXG4gICAgdmFyIGNoYW5uZWxIYW5kbGUgPSBtb3ZlRXhpc3RpbmdDaGFubmVsID8gdGhpcy5fY2hhbm5lbEhhbmRsZTogdW5kZWZpbmVkO1xyXG5cclxuICAgIHRoaXMuX2ltYWdlLnJlcXVlc3RQaXhlbHNQcm9ncmVzc2l2ZShcclxuICAgICAgICBmZXRjaFBhcmFtcy5pbWFnZVBhcnRQYXJhbXMsXHJcbiAgICAgICAgY2FsbGJhY2ssXHJcbiAgICAgICAgdGVybWluYXRlZENhbGxiYWNrLFxyXG4gICAgICAgIGZldGNoUGFyYW1zTm90TmVlZGVkLFxyXG4gICAgICAgIGNoYW5uZWxIYW5kbGUpO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBjYWxsYmFjayhkZWNvZGVkKSB7XHJcbiAgICAgICAgc2VsZi5fdGlsZXNEZWNvZGVkQ2FsbGJhY2soXHJcbiAgICAgICAgICAgIHJlZ2lvbklkLFxyXG4gICAgICAgICAgICBmZXRjaFBhcmFtcyxcclxuICAgICAgICAgICAgcG9zaXRpb24sXHJcbiAgICAgICAgICAgIGRlY29kZWQpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiB0ZXJtaW5hdGVkQ2FsbGJhY2soaXNBYm9ydGVkKSB7XHJcbiAgICAgICAgaWYgKGlzQWJvcnRlZCAmJlxyXG4gICAgICAgICAgICBpbWFnZVBhcnRQYXJhbXMucmVxdWVzdFByaW9yaXR5RGF0YS5vdmVycmlkZUhpZ2hlc3RQcmlvcml0eSkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gTk9URTogQnVnIGluIGtkdV9zZXJ2ZXIgY2F1c2VzIGZpcnN0IHJlcXVlc3QgdG8gYmUgc2VudCB3cm9uZ2x5LlxyXG4gICAgICAgICAgICAvLyBUaGVuIENocm9tZSByYWlzZXMgRVJSX0lOVkFMSURfQ0hVTktFRF9FTkNPRElORyBhbmQgdGhlIHJlcXVlc3RcclxuICAgICAgICAgICAgLy8gbmV2ZXIgcmV0dXJucy4gVGh1cyBwZXJmb3JtIHNlY29uZCByZXF1ZXN0LlxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgc2VsZi5faW1hZ2UucmVxdWVzdFBpeGVsc1Byb2dyZXNzaXZlKFxyXG4gICAgICAgICAgICAgICAgZmV0Y2hQYXJhbXMuaW1hZ2VQYXJ0UGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2ssXHJcbiAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkQ2FsbGJhY2ssXHJcbiAgICAgICAgICAgICAgICBmZXRjaFBhcmFtc05vdE5lZWRlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHNlbGYuX2ZldGNoVGVybWluYXRlZENhbGxiYWNrKFxyXG4gICAgICAgICAgICByZWdpb25JZCxcclxuICAgICAgICAgICAgZmV0Y2hQYXJhbXMuaW1hZ2VQYXJ0UGFyYW1zLnJlcXVlc3RQcmlvcml0eURhdGEsXHJcbiAgICAgICAgICAgIGlzQWJvcnRlZCxcclxuICAgICAgICAgICAgc3RhcnREeW5hbWljUmVnaW9uT25UZXJtaW5hdGlvbik7XHJcbiAgICB9XHJcbn07XHJcblxyXG5WaWV3ZXJJbWFnZURlY29kZXIucHJvdG90eXBlLl9mZXRjaFRlcm1pbmF0ZWRDYWxsYmFjayA9IGZ1bmN0aW9uIGZldGNoVGVybWluYXRlZENhbGxiYWNrKFxyXG4gICAgcmVnaW9uSWQsIHByaW9yaXR5RGF0YSwgaXNBYm9ydGVkLCBzdGFydER5bmFtaWNSZWdpb25PblRlcm1pbmF0aW9uKSB7XHJcbiAgICBcclxuICAgIHZhciByZWdpb24gPSB0aGlzLl9yZWdpb25zW3JlZ2lvbklkXTtcclxuICAgIGlmIChyZWdpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKCFwcmlvcml0eURhdGEub3ZlcnJpZGVIaWdoZXN0UHJpb3JpdHkgJiZcclxuICAgICAgICBwcmlvcml0eURhdGEucmVxdWVzdEluZGV4ICE9PSB0aGlzLl9sYXN0UmVxdWVzdEluZGV4KSB7XHJcbiAgICBcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJlZ2lvbi5pc0RvbmUgPSAhaXNBYm9ydGVkICYmIHRoaXMuX2lzUmVhZHk7XHJcblx0aWYgKHJlZ2lvbi5pc0RvbmUpIHtcclxuXHRcdHJlZ2lvbi5kb25lUGFydFBhcmFtcyA9IHJlZ2lvbi5pbWFnZVBhcnRQYXJhbXM7XHJcblx0fVxyXG4gICAgXHJcbiAgICBpZiAoc3RhcnREeW5hbWljUmVnaW9uT25UZXJtaW5hdGlvbikge1xyXG4gICAgICAgIHRoaXMuX2ltYWdlLmNyZWF0ZUNoYW5uZWwoXHJcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZWRDaGFubmVsQm91bmQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVmlld2VySW1hZ2VEZWNvZGVyLnByb3RvdHlwZS5fY3JlYXRlZENoYW5uZWwgPSBmdW5jdGlvbiBjcmVhdGVkQ2hhbm5lbChjaGFubmVsSGFuZGxlKSB7XHJcbiAgICB0aGlzLl9jaGFubmVsSGFuZGxlID0gY2hhbm5lbEhhbmRsZTtcclxuICAgIHRoaXMuX3N0YXJ0U2hvd2luZ0R5bmFtaWNSZWdpb24oKTtcclxufTtcclxuXHJcblZpZXdlckltYWdlRGVjb2Rlci5wcm90b3R5cGUuX3N0YXJ0U2hvd2luZ0R5bmFtaWNSZWdpb24gPSBmdW5jdGlvbiBzdGFydFNob3dpbmdEeW5hbWljUmVnaW9uKCkge1xyXG4gICAgdGhpcy5fY2FuU2hvd0R5bmFtaWNSZWdpb24gPSB0cnVlO1xyXG4gICAgXHJcbiAgICBpZiAodGhpcy5fcGVuZGluZ1VwZGF0ZVZpZXdBcmVhICE9PSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVWaWV3QXJlYSh0aGlzLl9wZW5kaW5nVXBkYXRlVmlld0FyZWEpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX3BlbmRpbmdVcGRhdGVWaWV3QXJlYSA9IG51bGw7XHJcbiAgICB9XHJcbn07XHJcblxyXG5WaWV3ZXJJbWFnZURlY29kZXIucHJvdG90eXBlLl90aWxlc0RlY29kZWRDYWxsYmFjayA9IGZ1bmN0aW9uIHRpbGVzRGVjb2RlZENhbGxiYWNrKFxyXG4gICAgcmVnaW9uSWQsIGZldGNoUGFyYW1zLCBwb3NpdGlvbiwgZGVjb2RlZCkge1xyXG4gICAgXHJcbiAgICBpZiAoIXRoaXMuX2lzUmVhZHkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciByZWdpb24gPSB0aGlzLl9yZWdpb25zW3JlZ2lvbklkXTtcclxuICAgIGlmIChyZWdpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJlZ2lvbiA9IHt9O1xyXG4gICAgICAgIHRoaXMuX3JlZ2lvbnNbcmVnaW9uSWRdID0gcmVnaW9uO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHN3aXRjaCAocmVnaW9uSWQpIHtcclxuICAgICAgICAgICAgY2FzZSBSRUdJT05fRFlOQU1JQzpcclxuICAgICAgICAgICAgICAgIHJlZ2lvbi5jYW52YXMgPSB0aGlzLl90YXJnZXRDYW52YXM7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjYXNlIFJFR0lPTl9PVkVSVklFVzpcclxuICAgICAgICAgICAgICAgIHJlZ2lvbi5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93ICdVbmV4cGVjdGVkIHJlZ2lvbklkICcgKyByZWdpb25JZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciBwYXJ0UGFyYW1zID0gZmV0Y2hQYXJhbXMuaW1hZ2VQYXJ0UGFyYW1zO1xyXG4gICAgaWYgKCFwYXJ0UGFyYW1zLnJlcXVlc3RQcmlvcml0eURhdGEub3ZlcnJpZGVIaWdoZXN0UHJpb3JpdHkgJiZcclxuICAgICAgICBwYXJ0UGFyYW1zLnJlcXVlc3RQcmlvcml0eURhdGEucmVxdWVzdEluZGV4IDwgcmVnaW9uLmN1cnJlbnREaXNwbGF5UmVxdWVzdEluZGV4KSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aGlzLl9jaGVja0lmUmVwb3NpdGlvbk5lZWRlZChyZWdpb24sIHBhcnRQYXJhbXMsIHBvc2l0aW9uKTtcclxuICAgICAgICBcclxuICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFja0NhbGxzLnB1c2goe1xyXG4gICAgICAgIHR5cGU6IFBFTkRJTkdfQ0FMTF9UWVBFX1BJWEVMU19VUERBVEVELFxyXG4gICAgICAgIHJlZ2lvbjogcmVnaW9uLFxyXG4gICAgICAgIGRlY29kZWQ6IGRlY29kZWRcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICB0aGlzLl9ub3RpZnlOZXdQZW5kaW5nQ2FsbHMoKTtcclxufTtcclxuXHJcblZpZXdlckltYWdlRGVjb2Rlci5wcm90b3R5cGUuX2NoZWNrSWZSZXBvc2l0aW9uTmVlZGVkID0gZnVuY3Rpb24gY2hlY2tJZlJlcG9zaXRpb25OZWVkZWQoXHJcbiAgICByZWdpb24sIG5ld1BhcnRQYXJhbXMsIG5ld1Bvc2l0aW9uKSB7XHJcbiAgICBcclxuICAgIHZhciBvbGRQYXJ0UGFyYW1zID0gcmVnaW9uLmltYWdlUGFydFBhcmFtcztcclxuXHR2YXIgb2xkRG9uZVBhcnRQYXJhbXMgPSByZWdpb24uZG9uZVBhcnRQYXJhbXM7XHJcbiAgICB2YXIgbGV2ZWwgPSBuZXdQYXJ0UGFyYW1zLmxldmVsO1xyXG4gICAgXHJcbiAgICB2YXIgbmVlZFJlcG9zaXRpb24gPVxyXG4gICAgICAgIG9sZFBhcnRQYXJhbXMgPT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgIG9sZFBhcnRQYXJhbXMubWluWCAhPT0gbmV3UGFydFBhcmFtcy5taW5YIHx8XHJcbiAgICAgICAgb2xkUGFydFBhcmFtcy5taW5ZICE9PSBuZXdQYXJ0UGFyYW1zLm1pblkgfHxcclxuICAgICAgICBvbGRQYXJ0UGFyYW1zLm1heFhFeGNsdXNpdmUgIT09IG5ld1BhcnRQYXJhbXMubWF4WEV4Y2x1c2l2ZSB8fFxyXG4gICAgICAgIG9sZFBhcnRQYXJhbXMubWF4WUV4Y2x1c2l2ZSAhPT0gbmV3UGFydFBhcmFtcy5tYXhZRXhjbHVzaXZlIHx8XHJcbiAgICAgICAgb2xkUGFydFBhcmFtcy5sZXZlbCAhPT0gbGV2ZWw7XHJcbiAgICBcclxuICAgIGlmICghbmVlZFJlcG9zaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciBjb3B5RGF0YTtcclxuICAgIHZhciBpbnRlcnNlY3Rpb247XHJcblx0dmFyIG5ld0RvbmVQYXJ0UGFyYW1zO1xyXG4gICAgdmFyIHJldXNlT2xkRGF0YSA9IGZhbHNlO1xyXG4gICAgdmFyIHNjYWxlWDtcclxuICAgIHZhciBzY2FsZVk7XHJcbiAgICBpZiAob2xkUGFydFBhcmFtcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgc2NhbGVYID0gdGhpcy5faW1hZ2UuZ2V0TGV2ZWxXaWR0aCAobGV2ZWwpIC8gdGhpcy5faW1hZ2UuZ2V0TGV2ZWxXaWR0aCAob2xkUGFydFBhcmFtcy5sZXZlbCk7XHJcbiAgICAgICAgc2NhbGVZID0gdGhpcy5faW1hZ2UuZ2V0TGV2ZWxIZWlnaHQobGV2ZWwpIC8gdGhpcy5faW1hZ2UuZ2V0TGV2ZWxIZWlnaHQob2xkUGFydFBhcmFtcy5sZXZlbCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaW50ZXJzZWN0aW9uID0ge1xyXG4gICAgICAgICAgICBtaW5YOiBNYXRoLm1heChvbGRQYXJ0UGFyYW1zLm1pblggKiBzY2FsZVgsIG5ld1BhcnRQYXJhbXMubWluWCksXHJcbiAgICAgICAgICAgIG1pblk6IE1hdGgubWF4KG9sZFBhcnRQYXJhbXMubWluWSAqIHNjYWxlWSwgbmV3UGFydFBhcmFtcy5taW5ZKSxcclxuICAgICAgICAgICAgbWF4WDogTWF0aC5taW4ob2xkUGFydFBhcmFtcy5tYXhYRXhjbHVzaXZlICogc2NhbGVYLCBuZXdQYXJ0UGFyYW1zLm1heFhFeGNsdXNpdmUpLFxyXG4gICAgICAgICAgICBtYXhZOiBNYXRoLm1pbihvbGRQYXJ0UGFyYW1zLm1heFlFeGNsdXNpdmUgKiBzY2FsZVksIG5ld1BhcnRQYXJhbXMubWF4WUV4Y2x1c2l2ZSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldXNlT2xkRGF0YSA9XHJcbiAgICAgICAgICAgIGludGVyc2VjdGlvbi5tYXhYID4gaW50ZXJzZWN0aW9uLm1pblggJiZcclxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uLm1heFkgPiBpbnRlcnNlY3Rpb24ubWluWTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHJldXNlT2xkRGF0YSkge1xyXG4gICAgICAgIGNvcHlEYXRhID0ge1xyXG4gICAgICAgICAgICBmcm9tWDogaW50ZXJzZWN0aW9uLm1pblggLyBzY2FsZVggLSBvbGRQYXJ0UGFyYW1zLm1pblgsXHJcbiAgICAgICAgICAgIGZyb21ZOiBpbnRlcnNlY3Rpb24ubWluWSAvIHNjYWxlWSAtIG9sZFBhcnRQYXJhbXMubWluWSxcclxuICAgICAgICAgICAgZnJvbVdpZHRoIDogKGludGVyc2VjdGlvbi5tYXhYIC0gaW50ZXJzZWN0aW9uLm1pblgpIC8gc2NhbGVYLFxyXG4gICAgICAgICAgICBmcm9tSGVpZ2h0OiAoaW50ZXJzZWN0aW9uLm1heFkgLSBpbnRlcnNlY3Rpb24ubWluWSkgLyBzY2FsZVksXHJcbiAgICAgICAgICAgIHRvWDogaW50ZXJzZWN0aW9uLm1pblggLSBuZXdQYXJ0UGFyYW1zLm1pblgsXHJcbiAgICAgICAgICAgIHRvWTogaW50ZXJzZWN0aW9uLm1pblkgLSBuZXdQYXJ0UGFyYW1zLm1pblksXHJcbiAgICAgICAgICAgIHRvV2lkdGggOiBpbnRlcnNlY3Rpb24ubWF4WCAtIGludGVyc2VjdGlvbi5taW5YLFxyXG4gICAgICAgICAgICB0b0hlaWdodDogaW50ZXJzZWN0aW9uLm1heFkgLSBpbnRlcnNlY3Rpb24ubWluWSxcclxuICAgICAgICB9O1xyXG5cdFxyXG5cdFx0aWYgKG9sZERvbmVQYXJ0UGFyYW1zICYmIG9sZFBhcnRQYXJhbXMubGV2ZWwgPT09IGxldmVsKSB7XHJcblx0XHRcdG5ld0RvbmVQYXJ0UGFyYW1zID0ge1xyXG5cdFx0XHRcdG1pblg6IE1hdGgubWF4KG9sZERvbmVQYXJ0UGFyYW1zLm1pblgsIG5ld1BhcnRQYXJhbXMubWluWCksXHJcblx0XHRcdFx0bWluWTogTWF0aC5tYXgob2xkRG9uZVBhcnRQYXJhbXMubWluWSwgbmV3UGFydFBhcmFtcy5taW5ZKSxcclxuXHRcdFx0XHRtYXhYRXhjbHVzaXZlOiBNYXRoLm1pbihvbGREb25lUGFydFBhcmFtcy5tYXhYRXhjbHVzaXZlLCBuZXdQYXJ0UGFyYW1zLm1heFhFeGNsdXNpdmUpLFxyXG5cdFx0XHRcdG1heFlFeGNsdXNpdmU6IE1hdGgubWluKG9sZERvbmVQYXJ0UGFyYW1zLm1heFlFeGNsdXNpdmUsIG5ld1BhcnRQYXJhbXMubWF4WUV4Y2x1c2l2ZSlcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHR9XHJcbiAgICBcclxuICAgIHJlZ2lvbi5pbWFnZVBhcnRQYXJhbXMgPSBuZXdQYXJ0UGFyYW1zO1xyXG4gICAgcmVnaW9uLmlzRG9uZSA9IGZhbHNlO1xyXG4gICAgcmVnaW9uLmN1cnJlbnREaXNwbGF5UmVxdWVzdEluZGV4ID0gbmV3UGFydFBhcmFtcy5yZXF1ZXN0UHJpb3JpdHlEYXRhLnJlcXVlc3RJbmRleDtcclxuICAgIFxyXG4gICAgdmFyIHJlcG9zaXRpb25BcmdzID0ge1xyXG4gICAgICAgIHR5cGU6IFBFTkRJTkdfQ0FMTF9UWVBFX1JFUE9TSVRJT04sXHJcbiAgICAgICAgcmVnaW9uOiByZWdpb24sXHJcbiAgICAgICAgcG9zaXRpb246IG5ld1Bvc2l0aW9uLFxyXG5cdFx0ZG9uZVBhcnRQYXJhbXM6IG5ld0RvbmVQYXJ0UGFyYW1zLFxyXG4gICAgICAgIGNvcHlEYXRhOiBjb3B5RGF0YSxcclxuICAgICAgICBwaXhlbHNXaWR0aDogbmV3UGFydFBhcmFtcy5tYXhYRXhjbHVzaXZlIC0gbmV3UGFydFBhcmFtcy5taW5YLFxyXG4gICAgICAgIHBpeGVsc0hlaWdodDogbmV3UGFydFBhcmFtcy5tYXhZRXhjbHVzaXZlIC0gbmV3UGFydFBhcmFtcy5taW5ZXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tDYWxscy5wdXNoKHJlcG9zaXRpb25BcmdzKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5WaWV3ZXJJbWFnZURlY29kZXIucHJvdG90eXBlLl9ub3RpZnlOZXdQZW5kaW5nQ2FsbHMgPSBmdW5jdGlvbiBub3RpZnlOZXdQZW5kaW5nQ2FsbHMoKSB7XHJcbiAgICBpZiAoIXRoaXMuX2lzTmVhckNhbGxiYWNrQ2FsbGVkKSB7XHJcbiAgICAgICAgdGhpcy5fY2FsbFBlbmRpbmdDYWxsYmFja3MoKTtcclxuICAgIH1cclxufTtcclxuXHJcblZpZXdlckltYWdlRGVjb2Rlci5wcm90b3R5cGUuX2NhbGxQZW5kaW5nQ2FsbGJhY2tzID0gZnVuY3Rpb24gY2FsbFBlbmRpbmdDYWxsYmFja3MoKSB7XHJcbiAgICBpZiAodGhpcy5fcGVuZGluZ0NhbGxiYWNrQ2FsbHMubGVuZ3RoID09PSAwIHx8ICF0aGlzLl9pc1JlYWR5KSB7XHJcbiAgICAgICAgdGhpcy5faXNOZWFyQ2FsbGJhY2tDYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICh0aGlzLl9pc05lYXJDYWxsYmFja0NhbGxlZCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzSW50ZXJ2YWxIYW5kbGUpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAodGhpcy5fbWluRnVuY3Rpb25DYWxsSW50ZXJ2YWxNaWxsaXNlY29uZHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFja3NJbnRlcnZhbEhhbmRsZSA9XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5fY2FsbFBlbmRpbmdDYWxsYmFja3NCb3VuZCxcclxuICAgICAgICAgICAgdGhpcy5fbWluRnVuY3Rpb25DYWxsSW50ZXJ2YWxNaWxsaXNlY29uZHMpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB0aGlzLl9pc05lYXJDYWxsYmFja0NhbGxlZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5ld1Bvc2l0aW9uID0gbnVsbDtcclxuICAgIFxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tDYWxscy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHZhciBjYWxsQXJncyA9IHRoaXMuX3BlbmRpbmdDYWxsYmFja0NhbGxzW2ldO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChjYWxsQXJncy50eXBlID09PSBQRU5ESU5HX0NBTExfVFlQRV9SRVBPU0lUSU9OKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcG9zaXRpb25DYW52YXMoY2FsbEFyZ3MpO1xyXG4gICAgICAgICAgICBuZXdQb3NpdGlvbiA9IGNhbGxBcmdzLnBvc2l0aW9uO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY2FsbEFyZ3MudHlwZSA9PT0gUEVORElOR19DQUxMX1RZUEVfUElYRUxTX1VQREFURUQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGl4ZWxzVXBkYXRlZChjYWxsQXJncyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgJ0ludGVybmFsIFZpZXdlckltYWdlRGVjb2RlciBFcnJvcjogVW5leHBlY3RlZCBjYWxsIHR5cGUgJyArXHJcbiAgICAgICAgICAgICAgICBjYWxsQXJncy50eXBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrQ2FsbHMubGVuZ3RoID0gMDtcclxuICAgIFxyXG4gICAgdGhpcy5fY2FudmFzVXBkYXRlZENhbGxiYWNrKG5ld1Bvc2l0aW9uKTtcclxufTtcclxuXHJcblZpZXdlckltYWdlRGVjb2Rlci5wcm90b3R5cGUuX3BpeGVsc1VwZGF0ZWQgPSBmdW5jdGlvbiBwaXhlbHNVcGRhdGVkKHBpeGVsc1VwZGF0ZWRBcmdzKSB7XHJcbiAgICB2YXIgcmVnaW9uID0gcGl4ZWxzVXBkYXRlZEFyZ3MucmVnaW9uO1xyXG4gICAgdmFyIGRlY29kZWQgPSBwaXhlbHNVcGRhdGVkQXJncy5kZWNvZGVkO1xyXG4gICAgaWYgKGRlY29kZWQuaW1hZ2VEYXRhLndpZHRoID09PSAwIHx8IGRlY29kZWQuaW1hZ2VEYXRhLmhlaWdodCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdmFyIHggPSBkZWNvZGVkLnhJbk9yaWdpbmFsUmVxdWVzdDtcclxuICAgIHZhciB5ID0gZGVjb2RlZC55SW5PcmlnaW5hbFJlcXVlc3Q7XHJcbiAgICBcclxuICAgIHZhciBjb250ZXh0ID0gcmVnaW9uLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgLy92YXIgaW1hZ2VEYXRhID0gY29udGV4dC5jcmVhdGVJbWFnZURhdGEoZGVjb2RlZC53aWR0aCwgZGVjb2RlZC5oZWlnaHQpO1xyXG4gICAgLy9pbWFnZURhdGEuZGF0YS5zZXQoZGVjb2RlZC5waXhlbHMpO1xyXG4gICAgXHJcbiAgICBjb250ZXh0LnB1dEltYWdlRGF0YShkZWNvZGVkLmltYWdlRGF0YSwgeCwgeSk7XHJcbn07XHJcblxyXG5WaWV3ZXJJbWFnZURlY29kZXIucHJvdG90eXBlLl9yZXBvc2l0aW9uQ2FudmFzID0gZnVuY3Rpb24gcmVwb3NpdGlvbkNhbnZhcyhyZXBvc2l0aW9uQXJncykge1xyXG4gICAgdmFyIHJlZ2lvbiA9IHJlcG9zaXRpb25BcmdzLnJlZ2lvbjtcclxuICAgIHZhciBwb3NpdGlvbiA9IHJlcG9zaXRpb25BcmdzLnBvc2l0aW9uO1xyXG5cdHZhciBkb25lUGFydFBhcmFtcyA9IHJlcG9zaXRpb25BcmdzLmRvbmVQYXJ0UGFyYW1zO1xyXG4gICAgdmFyIGNvcHlEYXRhID0gcmVwb3NpdGlvbkFyZ3MuY29weURhdGE7XHJcbiAgICB2YXIgcGl4ZWxzV2lkdGggPSByZXBvc2l0aW9uQXJncy5waXhlbHNXaWR0aDtcclxuICAgIHZhciBwaXhlbHNIZWlnaHQgPSByZXBvc2l0aW9uQXJncy5waXhlbHNIZWlnaHQ7XHJcbiAgICBcclxuICAgIHZhciBpbWFnZURhdGFUb0NvcHk7XHJcbiAgICB2YXIgY29udGV4dCA9IHJlZ2lvbi5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgIFxyXG4gICAgaWYgKGNvcHlEYXRhICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAoY29weURhdGEuZnJvbVdpZHRoID09PSBjb3B5RGF0YS50b1dpZHRoICYmIGNvcHlEYXRhLmZyb21IZWlnaHQgPT09IGNvcHlEYXRhLnRvSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGltYWdlRGF0YVRvQ29weSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKFxyXG4gICAgICAgICAgICAgICAgY29weURhdGEuZnJvbVgsIGNvcHlEYXRhLmZyb21ZLCBjb3B5RGF0YS5mcm9tV2lkdGgsIGNvcHlEYXRhLmZyb21IZWlnaHQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fdG1wQ2FudmFzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90bXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RtcENhbnZhc0NvbnRleHQgPSB0aGlzLl90bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5fdG1wQ2FudmFzLndpZHRoICA9IGNvcHlEYXRhLnRvV2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuX3RtcENhbnZhcy5oZWlnaHQgPSBjb3B5RGF0YS50b0hlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5fdG1wQ2FudmFzQ29udGV4dC5kcmF3SW1hZ2UoXHJcbiAgICAgICAgICAgICAgICByZWdpb24uY2FudmFzLFxyXG4gICAgICAgICAgICAgICAgY29weURhdGEuZnJvbVgsIGNvcHlEYXRhLmZyb21ZLCBjb3B5RGF0YS5mcm9tV2lkdGgsIGNvcHlEYXRhLmZyb21IZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAwLCAwLCBjb3B5RGF0YS50b1dpZHRoLCBjb3B5RGF0YS50b0hlaWdodCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpbWFnZURhdGFUb0NvcHkgPSB0aGlzLl90bXBDYW52YXNDb250ZXh0LmdldEltYWdlRGF0YShcclxuICAgICAgICAgICAgICAgIDAsIDAsIGNvcHlEYXRhLnRvV2lkdGgsIGNvcHlEYXRhLnRvSGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJlZ2lvbi5jYW52YXMud2lkdGggPSBwaXhlbHNXaWR0aDtcclxuICAgIHJlZ2lvbi5jYW52YXMuaGVpZ2h0ID0gcGl4ZWxzSGVpZ2h0O1xyXG4gICAgXHJcbiAgICBpZiAocmVnaW9uICE9PSB0aGlzLl9yZWdpb25zW1JFR0lPTl9PVkVSVklFV10pIHtcclxuICAgICAgICB0aGlzLl9jb3B5T3ZlcnZpZXdUb0NhbnZhcyhcclxuICAgICAgICAgICAgY29udGV4dCwgcG9zaXRpb24sIHBpeGVsc1dpZHRoLCBwaXhlbHNIZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoY29weURhdGEgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YVRvQ29weSwgY29weURhdGEudG9YLCBjb3B5RGF0YS50b1kpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZWdpb24ucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHRyZWdpb24uZG9uZVBhcnRQYXJhbXMgPSBkb25lUGFydFBhcmFtcztcclxufTtcclxuXHJcblZpZXdlckltYWdlRGVjb2Rlci5wcm90b3R5cGUuX2NvcHlPdmVydmlld1RvQ2FudmFzID0gZnVuY3Rpb24gY29weU92ZXJ2aWV3VG9DYW52YXMoXHJcbiAgICBjb250ZXh0LCBjYW52YXNQb3NpdGlvbiwgY2FudmFzUGl4ZWxzV2lkdGgsIGNhbnZhc1BpeGVsc0hlaWdodCkge1xyXG4gICAgXHJcbiAgICB2YXIgc291cmNlUG9zaXRpb24gPSB0aGlzLl9yZWdpb25zW1JFR0lPTl9PVkVSVklFV10ucG9zaXRpb247XHJcbiAgICB2YXIgc291cmNlUGl4ZWxzID1cclxuICAgICAgICB0aGlzLl9yZWdpb25zW1JFR0lPTl9PVkVSVklFV10uaW1hZ2VQYXJ0UGFyYW1zO1xyXG4gICAgXHJcbiAgICB2YXIgc291cmNlUGl4ZWxzV2lkdGggPVxyXG4gICAgICAgIHNvdXJjZVBpeGVscy5tYXhYRXhjbHVzaXZlIC0gc291cmNlUGl4ZWxzLm1pblg7XHJcbiAgICB2YXIgc291cmNlUGl4ZWxzSGVpZ2h0ID1cclxuICAgICAgICBzb3VyY2VQaXhlbHMubWF4WUV4Y2x1c2l2ZSAtIHNvdXJjZVBpeGVscy5taW5ZO1xyXG4gICAgXHJcbiAgICB2YXIgc291cmNlUG9zaXRpb25XaWR0aCA9XHJcbiAgICAgICAgc291cmNlUG9zaXRpb24uZWFzdCAtIHNvdXJjZVBvc2l0aW9uLndlc3Q7XHJcbiAgICB2YXIgc291cmNlUG9zaXRpb25IZWlnaHQgPVxyXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uLm5vcnRoIC0gc291cmNlUG9zaXRpb24uc291dGg7XHJcbiAgICAgICAgXHJcbiAgICB2YXIgc291cmNlUmVzb2x1dGlvblggPVxyXG4gICAgICAgIHNvdXJjZVBpeGVsc1dpZHRoIC8gc291cmNlUG9zaXRpb25XaWR0aDtcclxuICAgIHZhciBzb3VyY2VSZXNvbHV0aW9uWSA9XHJcbiAgICAgICAgc291cmNlUGl4ZWxzSGVpZ2h0IC8gc291cmNlUG9zaXRpb25IZWlnaHQ7XHJcbiAgICBcclxuICAgIHZhciB0YXJnZXRQb3NpdGlvbldpZHRoID1cclxuICAgICAgICBjYW52YXNQb3NpdGlvbi5lYXN0IC0gY2FudmFzUG9zaXRpb24ud2VzdDtcclxuICAgIHZhciB0YXJnZXRQb3NpdGlvbkhlaWdodCA9XHJcbiAgICAgICAgY2FudmFzUG9zaXRpb24ubm9ydGggLSBjYW52YXNQb3NpdGlvbi5zb3V0aDtcclxuICAgICAgICBcclxuICAgIHZhciBjcm9wV2lkdGggPSB0YXJnZXRQb3NpdGlvbldpZHRoICogc291cmNlUmVzb2x1dGlvblg7XHJcbiAgICB2YXIgY3JvcEhlaWdodCA9IHRhcmdldFBvc2l0aW9uSGVpZ2h0ICogc291cmNlUmVzb2x1dGlvblk7XHJcbiAgICBcclxuICAgIHZhciBjcm9wT2Zmc2V0UG9zaXRpb25YID1cclxuICAgICAgICBjYW52YXNQb3NpdGlvbi53ZXN0IC0gc291cmNlUG9zaXRpb24ud2VzdDtcclxuICAgIHZhciBjcm9wT2Zmc2V0UG9zaXRpb25ZID1cclxuICAgICAgICBzb3VyY2VQb3NpdGlvbi5ub3J0aCAtIGNhbnZhc1Bvc2l0aW9uLm5vcnRoO1xyXG4gICAgICAgIFxyXG4gICAgdmFyIGNyb3BQaXhlbE9mZnNldFggPSBjcm9wT2Zmc2V0UG9zaXRpb25YICogc291cmNlUmVzb2x1dGlvblg7XHJcbiAgICB2YXIgY3JvcFBpeGVsT2Zmc2V0WSA9IGNyb3BPZmZzZXRQb3NpdGlvblkgKiBzb3VyY2VSZXNvbHV0aW9uWTtcclxuICAgIFxyXG4gICAgY29udGV4dC5kcmF3SW1hZ2UoXHJcbiAgICAgICAgdGhpcy5fcmVnaW9uc1tSRUdJT05fT1ZFUlZJRVddLmNhbnZhcyxcclxuICAgICAgICBjcm9wUGl4ZWxPZmZzZXRYLCBjcm9wUGl4ZWxPZmZzZXRZLCBjcm9wV2lkdGgsIGNyb3BIZWlnaHQsXHJcbiAgICAgICAgMCwgMCwgY2FudmFzUGl4ZWxzV2lkdGgsIGNhbnZhc1BpeGVsc0hlaWdodCk7XHJcbn07XHJcblxyXG5WaWV3ZXJJbWFnZURlY29kZXIucHJvdG90eXBlLl9vcGVuZWQgPSBmdW5jdGlvbiBvcGVuZWQoKSB7XHJcbiAgICB0aGlzLl9pc1JlYWR5ID0gdHJ1ZTtcclxuICAgIFxyXG4gICAgdmFyIGZpeGVkQm91bmRzID0ge1xyXG4gICAgICAgIHdlc3Q6IHRoaXMuX2NhcnRvZ3JhcGhpY0JvdW5kcy53ZXN0LFxyXG4gICAgICAgIGVhc3Q6IHRoaXMuX2NhcnRvZ3JhcGhpY0JvdW5kcy5lYXN0LFxyXG4gICAgICAgIHNvdXRoOiB0aGlzLl9jYXJ0b2dyYXBoaWNCb3VuZHMuc291dGgsXHJcbiAgICAgICAgbm9ydGg6IHRoaXMuX2NhcnRvZ3JhcGhpY0JvdW5kcy5ub3J0aFxyXG4gICAgfTtcclxuICAgIGltYWdlSGVscGVyRnVuY3Rpb25zLmZpeEJvdW5kcyhcclxuICAgICAgICBmaXhlZEJvdW5kcywgdGhpcy5faW1hZ2UsIHRoaXMuX2FkYXB0UHJvcG9ydGlvbnMpO1xyXG4gICAgdGhpcy5fY2FydG9ncmFwaGljQm91bmRzRml4ZWQgPSBmaXhlZEJvdW5kcztcclxuICAgIFxyXG4gICAgdmFyIGxldmVsID0gdGhpcy5faW1hZ2UuZ2V0SW1hZ2VMZXZlbCgpO1xyXG4gICAgdmFyIGltYWdlV2lkdGggPSB0aGlzLl9pbWFnZS5nZXRMZXZlbFdpZHRoKGxldmVsKTtcclxuICAgIHZhciBpbWFnZUhlaWdodCA9IHRoaXMuX2ltYWdlLmdldExldmVsSGVpZ2h0KGxldmVsKTtcclxuICAgIHRoaXMuX3F1YWxpdHkgPSB0aGlzLl9pbWFnZS5nZXRIaWdoZXN0UXVhbGl0eSgpO1xyXG5cclxuICAgIHZhciByZWN0YW5nbGVXaWR0aCA9IGZpeGVkQm91bmRzLmVhc3QgLSBmaXhlZEJvdW5kcy53ZXN0O1xyXG4gICAgdmFyIHJlY3RhbmdsZUhlaWdodCA9IGZpeGVkQm91bmRzLm5vcnRoIC0gZml4ZWRCb3VuZHMuc291dGg7XHJcbiAgICB0aGlzLl9zY2FsZVggPSBpbWFnZVdpZHRoIC8gcmVjdGFuZ2xlV2lkdGg7XHJcbiAgICB0aGlzLl9zY2FsZVkgPSAtaW1hZ2VIZWlnaHQgLyByZWN0YW5nbGVIZWlnaHQ7XHJcbiAgICBcclxuICAgIHRoaXMuX3RyYW5zbGF0ZVggPSAtZml4ZWRCb3VuZHMud2VzdCAqIHRoaXMuX3NjYWxlWDtcclxuICAgIHRoaXMuX3RyYW5zbGF0ZVkgPSAtZml4ZWRCb3VuZHMubm9ydGggKiB0aGlzLl9zY2FsZVk7XHJcbiAgICBcclxuICAgIHZhciBvdmVydmlld1BhcmFtcyA9IHtcclxuICAgICAgICBtaW5YOiAwLFxyXG4gICAgICAgIG1pblk6IDAsXHJcbiAgICAgICAgbWF4WEV4Y2x1c2l2ZTogaW1hZ2VXaWR0aCxcclxuICAgICAgICBtYXhZRXhjbHVzaXZlOiBpbWFnZUhlaWdodCxcclxuICAgICAgICBzY3JlZW5XaWR0aDogdGhpcy5fb3ZlcnZpZXdSZXNvbHV0aW9uWCxcclxuICAgICAgICBzY3JlZW5IZWlnaHQ6IHRoaXMuX292ZXJ2aWV3UmVzb2x1dGlvbllcclxuICAgIH07XHJcbiAgICBcclxuICAgIHZhciBvdmVydmlld0FsaWduZWRQYXJhbXMgPVxyXG4gICAgICAgIGltYWdlSGVscGVyRnVuY3Rpb25zLmFsaWduUGFyYW1zVG9UaWxlc0FuZExldmVsKFxyXG4gICAgICAgICAgICBvdmVydmlld1BhcmFtcywgdGhpcy5faW1hZ2UpO1xyXG4gICAgICAgICAgICBcclxuICAgIG92ZXJ2aWV3QWxpZ25lZFBhcmFtcy5pbWFnZVBhcnRQYXJhbXMucmVxdWVzdFByaW9yaXR5RGF0YSA9XHJcbiAgICAgICAgb3ZlcnZpZXdBbGlnbmVkUGFyYW1zLmltYWdlUGFydFBhcmFtcy5yZXF1ZXN0UHJpb3JpdHlEYXRhIHx8IHt9O1xyXG4gICAgXHJcbiAgICBvdmVydmlld0FsaWduZWRQYXJhbXMuaW1hZ2VQYXJ0UGFyYW1zLnJlcXVlc3RQcmlvcml0eURhdGEub3ZlcnJpZGVIaWdoZXN0UHJpb3JpdHkgPSB0cnVlO1xyXG4gICAgb3ZlcnZpZXdBbGlnbmVkUGFyYW1zLmltYWdlUGFydFBhcmFtcy5xdWFsaXR5ID0gdGhpcy5faW1hZ2UuZ2V0TG93ZXN0UXVhbGl0eSgpO1xyXG4gICAgXHJcbiAgICB2YXIgc3RhcnREeW5hbWljUmVnaW9uT25UZXJtaW5hdGlvbiA9XHJcbiAgICAgICAgIXRoaXMuX2FsbG93TXVsdGlwbGVDaGFubmVsc0luU2Vzc2lvbjtcclxuICAgICAgICBcclxuICAgIHRoaXMuX2ZldGNoKFxyXG4gICAgICAgIFJFR0lPTl9PVkVSVklFVyxcclxuICAgICAgICBvdmVydmlld0FsaWduZWRQYXJhbXMsXHJcbiAgICAgICAgc3RhcnREeW5hbWljUmVnaW9uT25UZXJtaW5hdGlvbik7XHJcbiAgICBcclxuICAgIGlmICh0aGlzLl9hbGxvd011bHRpcGxlQ2hhbm5lbHNJblNlc3Npb24pIHtcclxuICAgICAgICB0aGlzLl9zdGFydFNob3dpbmdEeW5hbWljUmVnaW9uKCk7XHJcbiAgICB9XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuVmlld2VySW1hZ2VEZWNvZGVyID0gcmVxdWlyZSgndmlld2VyaW1hZ2VkZWNvZGVyLmpzJyk7XHJcbm1vZHVsZS5leHBvcnRzLkltYWdlRGVjb2RlciA9IHJlcXVpcmUoJ2ltYWdlZGVjb2Rlci5qcycpO1xyXG5tb2R1bGUuZXhwb3J0cy5TaW1wbGVGZXRjaGVyID0gcmVxdWlyZSgnc2ltcGxlZmV0Y2hlci5qcycpO1xyXG5tb2R1bGUuZXhwb3J0cy5TaW1wbGVQaXhlbHNEZWNvZGVyQmFzZSA9IHJlcXVpcmUoJ3NpbXBsZXBpeGVsc2RlY29kZXJiYXNlLmpzJyk7XHJcbm1vZHVsZS5leHBvcnRzLkNlc2l1bUltYWdlRGVjb2RlckxheWVyTWFuYWdlciA9IHJlcXVpcmUoJ19jZXNpdW1pbWFnZWRlY29kZXJsYXllcm1hbmFnZXIuanMnKTtcclxubW9kdWxlLmV4cG9ydHMuSW1hZ2VEZWNvZGVySW1hZ2VyeVByb3ZpZGVyID0gcmVxdWlyZSgnaW1hZ2VkZWNvZGVyaW1hZ2VyeXByb3ZpZGVyLmpzJyk7XHJcbm1vZHVsZS5leHBvcnRzLkltYWdlRGVjb2RlclJlZ2lvbkxheWVyID0gcmVxdWlyZSgnaW1hZ2VkZWNvZGVycmVnaW9ubGF5ZXIuanMnKTtcclxubW9kdWxlLmV4cG9ydHMuSW50ZXJuYWxzID0ge1xyXG4gICAgRmV0Y2hNYW5hZ2VyOiByZXF1aXJlKCdmZXRjaG1hbmFnZXIuanMnKVxyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBWaWV3ZXJJbWFnZURlY29kZXIgPSByZXF1aXJlKCd2aWV3ZXJpbWFnZWRlY29kZXIuanMnKTtcclxudmFyIGNhbGN1bGF0ZUxlYWZsZXRGcnVzdHVtID0gcmVxdWlyZSgnbGVhZmxldGZydXN0dW1jYWxjdWxhdG9yLmpzJyk7XHJcblxyXG4vKiBnbG9iYWwgTDogZmFsc2UgKi9cclxuLyogZ2xvYmFsIHNlbGY6IGZhbHNlICovXHJcblxyXG5pZiAoc2VsZi5MKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEwuQ2xhc3MuZXh0ZW5kKGNyZWF0ZUltYWdlRGVjb2RlclJlZ2lvbkxheWVyRnVuY3Rpb25zKCkpO1xyXG59IGVsc2Uge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnN0YW50aWF0ZSBJbWFnZURlY29kZXJSZWdpb25MYXllcjogTm8gTGVhZmxldCBuYW1lc3BhY2UgaW4gc2NvcGUnKTtcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUltYWdlRGVjb2RlclJlZ2lvbkxheWVyRnVuY3Rpb25zKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5sYXRMbmdCb3VuZHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob3B0aW9ucykpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5jYXJ0b2dyYXBoaWNCb3VuZHMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2VzdDogb3B0aW9ucy5sYXRMbmdCb3VuZHMuZ2V0V2VzdCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGVhc3Q6IG9wdGlvbnMubGF0TG5nQm91bmRzLmdldEVhc3QoKSxcclxuICAgICAgICAgICAgICAgICAgICBzb3V0aDogb3B0aW9ucy5sYXRMbmdCb3VuZHMuZ2V0U291dGgoKSxcclxuICAgICAgICAgICAgICAgICAgICBub3J0aDogb3B0aW9ucy5sYXRMbmdCb3VuZHMuZ2V0Tm9ydGgoKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0Q2FudmFzID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fY2FudmFzUG9zaXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9jYW52YXNVcGRhdGVkQ2FsbGJhY2tCb3VuZCA9IHRoaXMuX2NhbnZhc1VwZGF0ZWRDYWxsYmFjay5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9pbWFnZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX2V4Y2VwdGlvbkNhbGxiYWNrID0gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIFxyXG4gICAgICAgIHNldEV4Y2VwdGlvbkNhbGxiYWNrOiBmdW5jdGlvbiBzZXRFeGNlcHRpb25DYWxsYmFjayhleGNlcHRpb25DYWxsYmFjaykge1xyXG4gICAgICAgICAgICB0aGlzLl9leGNlcHRpb25DYWxsYmFjayA9IGV4Y2VwdGlvbkNhbGxiYWNrO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faW1hZ2UgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlLnNldEV4Y2VwdGlvbkNhbGxiYWNrKGV4Y2VwdGlvbkNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXHJcbiAgICAgICAgX2NyZWF0ZUltYWdlOiBmdW5jdGlvbiBjcmVhdGVJbWFnZSgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2ltYWdlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZSA9IG5ldyBWaWV3ZXJJbWFnZURlY29kZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5pbWFnZUltcGxlbWVudGF0aW9uQ2xhc3NOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhc1VwZGF0ZWRDYWxsYmFja0JvdW5kLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZXhjZXB0aW9uQ2FsbGJhY2sgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZS5zZXRFeGNlcHRpb25DYWxsYmFjayh0aGlzLl9leGNlcHRpb25DYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlLm9wZW4odGhpcy5fb3B0aW9ucy51cmwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgb25BZGQ6IGZ1bmN0aW9uIG9uQWRkKG1hcCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbWFwICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93ICdDYW5ub3QgYWRkIHRoaXMgbGF5ZXIgdG8gdHdvIG1hcHMnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XHJcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUltYWdlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBET00gZWxlbWVudCBhbmQgcHV0IGl0IGludG8gb25lIG9mIHRoZSBtYXAgcGFuZXNcclxuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0Q2FudmFzID0gTC5Eb21VdGlsLmNyZWF0ZShcclxuICAgICAgICAgICAgICAgICdjYW52YXMnLCAnaW1hZ2UtZGVjb2Rlci1sYXllci1jYW52YXMgbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLl9pbWFnZS5zZXRUYXJnZXRDYW52YXModGhpcy5fdGFyZ2V0Q2FudmFzKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhc1Bvc2l0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBtYXAuZ2V0UGFuZXMoKS5tYXBQYW5lLmFwcGVuZENoaWxkKHRoaXMuX3RhcmdldENhbnZhcyk7XHJcblxyXG4gICAgICAgICAgICAvLyBhZGQgYSB2aWV3cmVzZXQgZXZlbnQgbGlzdGVuZXIgZm9yIHVwZGF0aW5nIGxheWVyJ3MgcG9zaXRpb24sIGRvIHRoZSBsYXR0ZXJcclxuICAgICAgICAgICAgbWFwLm9uKCd2aWV3cmVzZXQnLCB0aGlzLl9tb3ZlZCwgdGhpcyk7XHJcbiAgICAgICAgICAgIG1hcC5vbignbW92ZScsIHRoaXMuX21vdmVkLCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChMLkJyb3dzZXIuYW55M2QpIHtcclxuICAgICAgICAgICAgICAgIG1hcC5vbignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX21vdmVkKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgb25SZW1vdmU6IGZ1bmN0aW9uIG9uUmVtb3ZlKG1hcCkge1xyXG4gICAgICAgICAgICBpZiAobWFwICE9PSB0aGlzLl9tYXApIHtcclxuICAgICAgICAgICAgICAgIHRocm93ICdSZW1vdmVkIGZyb20gd3JvbmcgbWFwJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbWFwLm9mZigndmlld3Jlc2V0JywgdGhpcy5fbW92ZWQsIHRoaXMpO1xyXG4gICAgICAgICAgICBtYXAub2ZmKCdtb3ZlJywgdGhpcy5fbW92ZWQsIHRoaXMpO1xyXG4gICAgICAgICAgICBtYXAub2ZmKCd6b29tYW5pbScsIHRoaXMuX2FuaW1hdGVab29tLCB0aGlzKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBsYXllcidzIERPTSBlbGVtZW50cyBhbmQgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgIG1hcC5nZXRQYW5lcygpLm1hcFBhbmUucmVtb3ZlQ2hpbGQodGhpcy5fdGFyZ2V0Q2FudmFzKTtcclxuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0Q2FudmFzID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fY2FudmFzUG9zaXRpb24gPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fbWFwID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5faW1hZ2UuY2xvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5faW1hZ2UgPSBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXHJcbiAgICAgICAgX21vdmVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdmVDYW52YXNlcygpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGZydXN0dW1EYXRhID0gY2FsY3VsYXRlTGVhZmxldEZydXN0dW0odGhpcy5fbWFwKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlLnVwZGF0ZVZpZXdBcmVhKGZydXN0dW1EYXRhKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIFxyXG4gICAgICAgIF9jYW52YXNVcGRhdGVkQ2FsbGJhY2s6IGZ1bmN0aW9uIGNhbnZhc1VwZGF0ZWRDYWxsYmFjayhuZXdQb3NpdGlvbikge1xyXG4gICAgICAgICAgICBpZiAobmV3UG9zaXRpb24gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhc1Bvc2l0aW9uID0gbmV3UG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlQ2FudmFzZXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXHJcbiAgICAgICAgX21vdmVDYW52YXNlczogZnVuY3Rpb24gbW92ZUNhbnZhc2VzKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY2FudmFzUG9zaXRpb24gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAvLyB1cGRhdGUgbGF5ZXIncyBwb3NpdGlvblxyXG4gICAgICAgICAgICB2YXIgd2VzdCA9IHRoaXMuX2NhbnZhc1Bvc2l0aW9uLndlc3Q7XHJcbiAgICAgICAgICAgIHZhciBlYXN0ID0gdGhpcy5fY2FudmFzUG9zaXRpb24uZWFzdDtcclxuICAgICAgICAgICAgdmFyIHNvdXRoID0gdGhpcy5fY2FudmFzUG9zaXRpb24uc291dGg7XHJcbiAgICAgICAgICAgIHZhciBub3J0aCA9IHRoaXMuX2NhbnZhc1Bvc2l0aW9uLm5vcnRoO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHRvcExlZnQgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KFtub3J0aCwgd2VzdF0pO1xyXG4gICAgICAgICAgICB2YXIgYm90dG9tUmlnaHQgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KFtzb3V0aCwgZWFzdF0pO1xyXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IGJvdHRvbVJpZ2h0LnN1YnRyYWN0KHRvcExlZnQpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgTC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX3RhcmdldENhbnZhcywgdG9wTGVmdCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldENhbnZhcy5zdHlsZS53aWR0aCA9IHNpemUueCArICdweCc7XHJcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldENhbnZhcy5zdHlsZS5oZWlnaHQgPSBzaXplLnkgKyAncHgnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXHJcbiAgICAgICAgX2FuaW1hdGVab29tOiBmdW5jdGlvbiBhbmltYXRlWm9vbShvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIC8vIE5PVEU6IEFsbCBtZXRob2QgKGluY2x1ZGluZyB1c2luZyBvZiBwcml2YXRlIG1ldGhvZFxyXG4gICAgICAgICAgICAvLyBfbGF0TG5nVG9OZXdMYXllclBvaW50KSB3YXMgY29waWVkIGZyb20gSW1hZ2VPdmVybGF5LFxyXG4gICAgICAgICAgICAvLyBhcyBMZWFmbGV0IGRvY3VtZW50YXRpb24gcmVjb21tZW5kcy5cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciB3ZXN0ID0gIHRoaXMuX2NhbnZhc1Bvc2l0aW9uLndlc3Q7XHJcbiAgICAgICAgICAgIHZhciBlYXN0ID0gIHRoaXMuX2NhbnZhc1Bvc2l0aW9uLmVhc3Q7XHJcbiAgICAgICAgICAgIHZhciBzb3V0aCA9IHRoaXMuX2NhbnZhc1Bvc2l0aW9uLnNvdXRoO1xyXG4gICAgICAgICAgICB2YXIgbm9ydGggPSB0aGlzLl9jYW52YXNQb3NpdGlvbi5ub3J0aDtcclxuXHJcbiAgICAgICAgICAgIHZhciB0b3BMZWZ0ID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQoXHJcbiAgICAgICAgICAgICAgICBbbm9ydGgsIHdlc3RdLCBvcHRpb25zLnpvb20sIG9wdGlvbnMuY2VudGVyKTtcclxuICAgICAgICAgICAgdmFyIGJvdHRvbVJpZ2h0ID0gdGhpcy5fbWFwLl9sYXRMbmdUb05ld0xheWVyUG9pbnQoXHJcbiAgICAgICAgICAgICAgICBbc291dGgsIGVhc3RdLCBvcHRpb25zLnpvb20sIG9wdGlvbnMuY2VudGVyKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuX21hcC5nZXRab29tU2NhbGUob3B0aW9ucy56b29tKTtcclxuICAgICAgICAgICAgdmFyIHNpemUgPSBib3R0b21SaWdodC5zdWJ0cmFjdCh0b3BMZWZ0KTtcclxuICAgICAgICAgICAgdmFyIHNpemVTY2FsZWQgPSBzaXplLm11bHRpcGx5QnkoKDEgLyAyKSAqICgxIC0gMSAvIHNjYWxlKSk7XHJcbiAgICAgICAgICAgIHZhciBvcmlnaW4gPSB0b3BMZWZ0LmFkZChzaXplU2NhbGVkKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldENhbnZhcy5zdHlsZVtMLkRvbVV0aWwuVFJBTlNGT1JNXSA9XHJcbiAgICAgICAgICAgICAgICBMLkRvbVV0aWwuZ2V0VHJhbnNsYXRlU3RyaW5nKG9yaWdpbikgKyAnIHNjYWxlKCcgKyBzY2FsZSArICcpICc7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufSIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBpbWFnZUhlbHBlckZ1bmN0aW9ucyA9IHJlcXVpcmUoJ2ltYWdlaGVscGVyZnVuY3Rpb25zLmpzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUxlYWZsZXRGcnVzdHVtKGxlYWZsZXRNYXApIHtcclxuICAgIHZhciBzY3JlZW5TaXplID0gbGVhZmxldE1hcC5nZXRTaXplKCk7XHJcbiAgICB2YXIgYm91bmRzID0gbGVhZmxldE1hcC5nZXRCb3VuZHMoKTtcclxuXHJcbiAgICB2YXIgY2FydG9ncmFwaGljQm91bmRzID0ge1xyXG4gICAgICAgIHdlc3Q6IGJvdW5kcy5nZXRXZXN0KCksXHJcbiAgICAgICAgZWFzdDogYm91bmRzLmdldEVhc3QoKSxcclxuICAgICAgICBzb3V0aDogYm91bmRzLmdldFNvdXRoKCksXHJcbiAgICAgICAgbm9ydGg6IGJvdW5kcy5nZXROb3J0aCgpXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB2YXIgZnJ1c3R1bURhdGEgPSBpbWFnZUhlbHBlckZ1bmN0aW9ucy5jYWxjdWxhdGVGcnVzdHVtMkRGcm9tQm91bmRzKFxyXG4gICAgICAgIGNhcnRvZ3JhcGhpY0JvdW5kcywgc2NyZWVuU2l6ZSk7XHJcblxyXG4gICAgcmV0dXJuIGZydXN0dW1EYXRhO1xyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGF0YVB1Ymxpc2hlcjtcclxuXHJcbnZhciBMaW5rZWRMaXN0ID0gcmVxdWlyZSgnbGlua2VkbGlzdC5qcycpO1xyXG52YXIgSGFzaE1hcCA9IHJlcXVpcmUoJ2hhc2htYXAuanMnKTtcclxuXHJcbmZ1bmN0aW9uIERhdGFQdWJsaXNoZXIoaGFzaGVyKSB7XHJcbiAgICB0aGlzLl9zdWJzY3JpYmVyc0J5S2V5ID0gbmV3IEhhc2hNYXAoaGFzaGVyKTtcclxufVxyXG5cclxuRGF0YVB1Ymxpc2hlci5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uIHB1Ymxpc2goa2V5LCBkYXRhLCBmZXRjaEVuZGVkKSB7XHJcbiAgICB2YXIgc3Vic2NyaWJlcnMgPSB0aGlzLl9zdWJzY3JpYmVyc0J5S2V5LmdldEZyb21LZXkoa2V5KTtcclxuICAgIGlmICghc3Vic2NyaWJlcnMpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHZhciBpdGVyYXRvciA9IHN1YnNjcmliZXJzLnN1YnNjcmliZXJzTGlzdC5nZXRGaXJzdEl0ZXJhdG9yKCk7XHJcbiAgICB2YXIgbGlzdGVuZXJzID0gW107XHJcbiAgICB3aGlsZSAoaXRlcmF0b3IgIT09IG51bGwpIHtcclxuICAgICAgICB2YXIgc3Vic2NyaWJlciA9IHN1YnNjcmliZXJzLnN1YnNjcmliZXJzTGlzdC5nZXRWYWx1ZShpdGVyYXRvcik7XHJcblx0XHJcblx0XHRpZiAoIXN1YnNjcmliZXIuaXNFbmRlZCkge1xyXG5cdFx0XHRsaXN0ZW5lcnMucHVzaChzdWJzY3JpYmVyLmxpc3RlbmVyKTtcclxuXHRcdFx0aWYgKGZldGNoRW5kZWQpIHtcclxuXHRcdFx0XHQtLXN1YnNjcmliZXJzLnN1YnNjcmliZXJzTm90RW5kZWRDb3VudDtcclxuXHRcdFx0XHRzdWJzY3JpYmVyLmlzRW5kZWQgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaXRlcmF0b3IgPSBzdWJzY3JpYmVycy5zdWJzY3JpYmVyc0xpc3QuZ2V0TmV4dEl0ZXJhdG9yKGl0ZXJhdG9yKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ2FsbCBvbmx5IGFmdGVyIGNvbGxlY3RpbmcgYWxsIGxpc3RlbmVycywgc28gdGhlIGxpc3Qgd2lsbCBub3QgYmUgZGVzdHJveWVkIHdoaWxlIGl0ZXJhdGluZ1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBsaXN0ZW5lcnNbaV0uY2FsbCh0aGlzLCBrZXksIGRhdGEsIGZldGNoRW5kZWQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuRGF0YVB1Ymxpc2hlci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gc3Vic2NyaWJlKGtleSwgc3Vic2NyaWJlcikge1xyXG4gICAgdmFyIHN1YnNjcmliZXJzID0gdGhpcy5fc3Vic2NyaWJlcnNCeUtleS50cnlBZGQoa2V5LCBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdWJzY3JpYmVyc0xpc3Q6IG5ldyBMaW5rZWRMaXN0KCksXHJcbiAgICAgICAgICAgIHN1YnNjcmliZXJzTm90RW5kZWRDb3VudDogMFxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgKytzdWJzY3JpYmVycy52YWx1ZS5zdWJzY3JpYmVyc05vdEVuZGVkQ291bnQ7XHJcbiAgICBcclxuICAgIHZhciBsaXN0SXRlcmF0b3IgPSBzdWJzY3JpYmVycy52YWx1ZS5zdWJzY3JpYmVyc0xpc3QuYWRkKHtcclxuICAgICAgICBsaXN0ZW5lcjogc3Vic2NyaWJlcixcclxuICAgICAgICBpc0VuZGVkOiBmYWxzZVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIHZhciBoYW5kbGUgPSB7XHJcbiAgICAgICAgX2xpc3RJdGVyYXRvcjogbGlzdEl0ZXJhdG9yLFxyXG4gICAgICAgIF9oYXNoSXRlcmF0b3I6IHN1YnNjcmliZXJzLml0ZXJhdG9yXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGhhbmRsZTtcclxufTtcclxuXHJcbkRhdGFQdWJsaXNoZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gdW5zdWJzY3JpYmUoaGFuZGxlKSB7XHJcbiAgICB2YXIgc3Vic2NyaWJlcnMgPSB0aGlzLl9zdWJzY3JpYmVyc0J5S2V5LmdldEZyb21JdGVyYXRvcihoYW5kbGUuX2hhc2hJdGVyYXRvcik7XHJcbiAgICBcclxuICAgIHZhciBzdWJzY3JpYmVyID0gc3Vic2NyaWJlcnMuc3Vic2NyaWJlcnNMaXN0LmdldFZhbHVlKGhhbmRsZS5fbGlzdEl0ZXJhdG9yKTtcclxuICAgIHN1YnNjcmliZXJzLnN1YnNjcmliZXJzTGlzdC5yZW1vdmUoaGFuZGxlLl9saXN0SXRlcmF0b3IpO1xyXG4gICAgaWYgKHN1YnNjcmliZXJzLnN1YnNjcmliZXJzTGlzdC5nZXRDb3VudCgpID09PSAwKSB7XHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlcnNCeUtleS5yZW1vdmUoaGFuZGxlLl9oYXNoSXRlcmF0b3IpO1xyXG4gICAgfSBlbHNlIGlmICghc3Vic2NyaWJlci5pc0VuZGVkKSB7XHJcbiAgICAgICAgLS1zdWJzY3JpYmVycy5zdWJzY3JpYmVyc05vdEVuZGVkQ291bnQ7XHJcbiAgICAgICAgc3Vic2NyaWJlci5pc0VuZGVkID0gdHJ1ZTtcclxuICAgIH1cclxufTtcclxuXHJcbkRhdGFQdWJsaXNoZXIucHJvdG90eXBlLmlzS2V5TmVlZEZldGNoID0gZnVuY3Rpb24gaXNLZXlOZWVkRmV0Y2goa2V5KSB7XHJcbiAgICB2YXIgc3Vic2NyaWJlcnMgPSB0aGlzLl9zdWJzY3JpYmVyc0J5S2V5LmdldEZyb21LZXkoa2V5KTtcclxuICAgIHJldHVybiAoISFzdWJzY3JpYmVycykgJiYgKHN1YnNjcmliZXJzLnN1YnNjcmliZXJzTm90RW5kZWRDb3VudCA+IDApO1xyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2ltcGxlRmV0Y2hlcjtcclxuXHJcbnZhciBTaW1wbGVJbWFnZURhdGFDb250ZXh0ID0gcmVxdWlyZSgnc2ltcGxlaW1hZ2VkYXRhY29udGV4dC5qcycpO1xyXG52YXIgU2ltcGxlTm9uUHJvZ3Jlc3NpdmVGZXRjaEhhbmRsZSA9IHJlcXVpcmUoJ3NpbXBsZW5vbnByb2dyZXNzaXZlZmV0Y2hoYW5kbGUuanMnKTtcclxudmFyIERhdGFQdWJsaXNoZXIgPSByZXF1aXJlKCdkYXRhcHVibGlzaGVyLmpzJyk7XHJcblxyXG4vKiBnbG9iYWwgUHJvbWlzZTogZmFsc2UgKi9cclxuXHJcbmZ1bmN0aW9uIFNpbXBsZUZldGNoZXIoZmV0Y2hlck1ldGhvZHMsIG9wdGlvbnMpIHtcclxuICAgIHRoaXMuX3VybCA9IG51bGw7XHJcbiAgICB0aGlzLl9mZXRjaGVyTWV0aG9kcyA9IGZldGNoZXJNZXRob2RzO1xyXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICB0aGlzLl9pc1JlYWR5ID0gdHJ1ZTtcclxuICAgIFxyXG4gICAgaWYgKCF0aGlzLl9mZXRjaGVyTWV0aG9kcy5nZXREYXRhS2V5cykge1xyXG4gICAgICAgIHRocm93ICdTaW1wbGVGZXRjaGVyIGVycm9yOiBnZXREYXRhS2V5cyBpcyBub3QgaW1wbGVtZW50ZWQnO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0aGlzLl9mZXRjaGVyTWV0aG9kcy5mZXRjaCAmJiAhdGhpcy5fZmV0Y2hlck1ldGhvZHMuZmV0Y2hQcm9ncmVzc2l2ZSkge1xyXG4gICAgICAgIHRocm93ICdTaW1wbGVGZXRjaGVyIGVycm9yOiBOZWl0aGVyIGZldGNoIG5vciBmZXRjaFByb2dyZXNzaXZlIG1ldGhvZHMgYXJlIGltcGxlbWVudGVkJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKCF0aGlzLl9mZXRjaGVyTWV0aG9kcy5nZXRIYXNoQ29kZSkge1xyXG4gICAgICAgIHRocm93ICdTaW1wbGVGZXRjaGVyIGVycm9yOiBnZXRIYXNoQ29kZSBpcyBub3QgaW1wbGVtZW50ZWQnO1xyXG4gICAgfVxyXG4gICAgaWYgKCF0aGlzLl9mZXRjaGVyTWV0aG9kcy5pc0VxdWFsKSB7XHJcbiAgICAgICAgdGhyb3cgJ1NpbXBsZUZldGNoZXIgZXJyb3I6IGlzRXF1YWwgaXMgbm90IGltcGxlbWVudGVkJztcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9oYXNoZXIgPSB7XHJcbiAgICAgICAgX2ZldGNoZXJNZXRob2RzOiB0aGlzLl9mZXRjaGVyTWV0aG9kcyxcclxuICAgICAgICBnZXRIYXNoQ29kZTogZnVuY3Rpb24oZGF0YUtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hlck1ldGhvZHMuZ2V0SGFzaENvZGUoZGF0YUtleSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0VxdWFsOiBmdW5jdGlvbihrZXkxLCBrZXkyKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkxLm1heFF1YWxpdHkgIT09IGtleTIubWF4UXVhbGl0eSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hlck1ldGhvZHMuaXNFcXVhbChrZXkxLmRhdGFLZXksIGtleTIuZGF0YUtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAodGhpcy5fZmV0Y2hlck1ldGhvZHMuY3JlYXRlRGF0YVB1Ymxpc2hlcikge1xyXG4gICAgICAgIHRoaXMuX2RhdGFQdWJsaXNoZXIgPSB0aGlzLmZldGNoZXJNZXRob2RzLmNyZWF0ZURhdGFQdWJsaXNoZXIodGhpcy5faGFzaGVyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fZGF0YVB1Ymxpc2hlciA9IG5ldyBEYXRhUHVibGlzaGVyKHRoaXMuX2hhc2hlcik7XHJcbiAgICB9XHJcbn1cclxuXHJcblNpbXBsZUZldGNoZXIucHJvdG90eXBlLmZldGNoUHJvZ3Jlc3NpdmUgPSBmdW5jdGlvbiBmZXRjaFByb2dyZXNzaXZlKGltYWdlUGFydFBhcmFtcywgZGF0YUtleXMsIGRhdGFDYWxsYmFjaywgcXVlcnlJc0tleU5lZWRGZXRjaCwgbWF4UXVhbGl0eSkge1xyXG4gICAgdGhpcy5fZW5zdXJlUmVhZHkoKTtcclxuICAgIGlmICghdGhpcy5fZmV0Y2hlck1ldGhvZHMuZmV0Y2hQcm9ncmVzc2l2ZSkge1xyXG4gICAgICAgIHZhciBmZXRjaEhhbmRsZSA9IG5ldyBTaW1wbGVOb25Qcm9ncmVzc2l2ZUZldGNoSGFuZGxlKHRoaXMuX2ZldGNoZXJNZXRob2RzLCBkYXRhQ2FsbGJhY2ssIHF1ZXJ5SXNLZXlOZWVkRmV0Y2gsIHRoaXMuX29wdGlvbnMpO1xyXG4gICAgICAgIGZldGNoSGFuZGxlLmZldGNoKGRhdGFLZXlzKTtcclxuICAgICAgICByZXR1cm4gZmV0Y2hIYW5kbGU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiB0aGlzLl9mZXRjaGVyTWV0aG9kcy5mZXRjaFByb2dyZXNzaXZlKGltYWdlUGFydFBhcmFtcywgZGF0YUtleXMsIGRhdGFDYWxsYmFjaywgcXVlcnlJc0tleU5lZWRGZXRjaCwgbWF4UXVhbGl0eSk7XHJcbn07XHJcblxyXG5TaW1wbGVGZXRjaGVyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiByZWNvbm5lY3QoKSB7XHJcbiAgICB0aGlzLl9lbnN1cmVSZWFkeSgpO1xyXG4gICAgaWYgKCF0aGlzLl9mZXRjaGVyTWV0aG9kcy5yZWNvbm5lY3QpIHtcclxuICAgICAgICB0aHJvdyAnU2ltcGxlRmV0Y2hlciBlcnJvcjogcmVjb25uZWN0IGlzIG5vdCBpbXBsZW1lbnRlZCc7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9mZXRjaGVyTWV0aG9kcy5yZWNvbm5lY3QoKTtcclxufTtcclxuXHJcbi8vIEZldGNoZXIgaW1wbGVtZW50YXRpb25cclxuXHJcblNpbXBsZUZldGNoZXIucHJvdG90eXBlLmNyZWF0ZUltYWdlRGF0YUNvbnRleHQgPSBmdW5jdGlvbiBjcmVhdGVJbWFnZURhdGFDb250ZXh0KFxyXG4gICAgaW1hZ2VQYXJ0UGFyYW1zKSB7XHJcbiAgICBcclxuICAgIHRoaXMuX2Vuc3VyZVJlYWR5KCk7XHJcbiAgICB2YXIgZGF0YUtleXMgPSB0aGlzLl9mZXRjaGVyTWV0aG9kcy5nZXREYXRhS2V5cyhpbWFnZVBhcnRQYXJhbXMpO1xyXG4gICAgcmV0dXJuIG5ldyBTaW1wbGVJbWFnZURhdGFDb250ZXh0KGRhdGFLZXlzLCBpbWFnZVBhcnRQYXJhbXMsIHRoaXMuX2RhdGFQdWJsaXNoZXIsIHRoaXMuX2hhc2hlcik7XHJcbn07XHJcblxyXG5TaW1wbGVGZXRjaGVyLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uIGZldGNoKGltYWdlRGF0YUNvbnRleHQpIHtcclxuXHR2YXIgbWF4UXVhbGl0eSA9IGltYWdlRGF0YUNvbnRleHQuZ2V0TWF4UXVhbGl0eSgpO1xyXG5cdHZhciBzZWxmID0gdGhpcztcclxuXHRcclxuXHRmdW5jdGlvbiBkYXRhQ2FsbGJhY2soZGF0YUtleSwgZGF0YSwgaXNGZXRjaEVuZGVkKSB7XHJcblx0XHR2YXIga2V5ID0ge1xyXG5cdFx0XHRkYXRhS2V5OiBkYXRhS2V5LFxyXG5cdFx0XHRtYXhRdWFsaXR5OiBtYXhRdWFsaXR5XHJcblx0XHR9O1xyXG5cdFx0c2VsZi5fZGF0YVB1Ymxpc2hlci5wdWJsaXNoKGtleSwgZGF0YSwgaXNGZXRjaEVuZGVkKTtcclxuXHR9XHJcblx0XHJcblx0ZnVuY3Rpb24gcXVlcnlJc0tleU5lZWRGZXRjaChkYXRhS2V5KSB7XHJcblx0XHR2YXIga2V5ID0ge1xyXG5cdFx0XHRkYXRhS2V5OiBkYXRhS2V5LFxyXG5cdFx0XHRtYXhRdWFsaXR5OiBtYXhRdWFsaXR5XHJcblx0XHR9O1xyXG5cdFx0cmV0dXJuIHNlbGYuX2RhdGFQdWJsaXNoZXIuaXNLZXlOZWVkRmV0Y2goa2V5KTtcclxuXHR9XHJcblx0XHJcblx0cmV0dXJuIHRoaXMuZmV0Y2hQcm9ncmVzc2l2ZShpbWFnZURhdGFDb250ZXh0LmdldEltYWdlUGFydFBhcmFtcygpLCBpbWFnZURhdGFDb250ZXh0LmdldERhdGFLZXlzKCksIGRhdGFDYWxsYmFjaywgcXVlcnlJc0tleU5lZWRGZXRjaCwgbWF4UXVhbGl0eSk7XHJcbn07XHJcblxyXG5TaW1wbGVGZXRjaGVyLnByb3RvdHlwZS5zdGFydE1vdmFibGVGZXRjaCA9IGZ1bmN0aW9uIHN0YXJ0TW92YWJsZUZldGNoKGltYWdlRGF0YUNvbnRleHQsIG1vdmFibGVGZXRjaFN0YXRlKSB7XHJcblx0bW92YWJsZUZldGNoU3RhdGUuZmV0Y2hIYW5kbGUgPSB0aGlzLmZldGNoKGltYWdlRGF0YUNvbnRleHQpO1xyXG59O1xyXG5cclxuU2ltcGxlRmV0Y2hlci5wcm90b3R5cGUubW92ZUZldGNoID0gZnVuY3Rpb24gbW92ZUZldGNoKGltYWdlRGF0YUNvbnRleHQsIG1vdmFibGVGZXRjaFN0YXRlKSB7XHJcblx0bW92YWJsZUZldGNoU3RhdGUuZmV0Y2hIYW5kbGUuYWJvcnRBc3luYygpO1xyXG5cdG1vdmFibGVGZXRjaFN0YXRlLmZldGNoSGFuZGxlID0gdGhpcy5mZXRjaChpbWFnZURhdGFDb250ZXh0KTtcclxufTtcclxuXHJcblNpbXBsZUZldGNoZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gY2xvc2UoY2xvc2VkQ2FsbGJhY2spIHtcclxuICAgIHRoaXMuX2Vuc3VyZVJlYWR5KCk7XHJcbiAgICB0aGlzLl9pc1JlYWR5ID0gZmFsc2U7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgLy8gTk9URTogV2FpdCBmb3IgYWxsIGZldGNoSGFuZGxlcyB0byBmaW5pc2g/XHJcbiAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5TaW1wbGVGZXRjaGVyLnByb3RvdHlwZS5fZW5zdXJlUmVhZHkgPSBmdW5jdGlvbiBlbnN1cmVSZWFkeSgpIHtcclxuICAgIGlmICghdGhpcy5faXNSZWFkeSkge1xyXG4gICAgICAgIHRocm93ICdTaW1wbGVGZXRjaGVyIGVycm9yOiBmZXRjaCBjbGllbnQgaXMgbm90IG9wZW5lZCc7XHJcbiAgICB9XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2ltcGxlSW1hZ2VEYXRhQ29udGV4dDtcclxuXHJcbnZhciBIYXNoTWFwID0gcmVxdWlyZSgnaGFzaG1hcC5qcycpO1xyXG5cclxuZnVuY3Rpb24gU2ltcGxlSW1hZ2VEYXRhQ29udGV4dChkYXRhS2V5cywgaW1hZ2VQYXJ0UGFyYW1zLCBkYXRhUHVibGlzaGVyLCBoYXNoZXIpIHtcclxuICAgIHRoaXMuX2RhdGFCeUtleSA9IG5ldyBIYXNoTWFwKGhhc2hlcik7XHJcbiAgICB0aGlzLl9kYXRhVG9SZXR1cm4gPSB7XHJcbiAgICAgICAgaW1hZ2VQYXJ0UGFyYW1zOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGltYWdlUGFydFBhcmFtcykpLFxyXG4gICAgICAgIGZldGNoZWRJdGVtczogW11cclxuICAgIH07XHJcblx0dGhpcy5fbWF4UXVhbGl0eSA9IGltYWdlUGFydFBhcmFtcy5xdWFsaXR5O1xyXG4gICAgdGhpcy5fZmV0Y2hFbmRlZENvdW50ID0gMDtcclxuXHR0aGlzLl9mZXRjaGVkTG93UXVhbGl0eUNvdW50ID0gMDtcclxuICAgIHRoaXMuX2RhdGFMaXN0ZW5lcnMgPSBbXTtcclxuICAgIHRoaXMuX2RhdGFLZXlzID0gZGF0YUtleXM7XHJcbiAgICB0aGlzLl9pbWFnZVBhcnRQYXJhbXMgPSBpbWFnZVBhcnRQYXJhbXM7XHJcbiAgICB0aGlzLl9kYXRhUHVibGlzaGVyID0gZGF0YVB1Ymxpc2hlcjtcclxuXHR0aGlzLl9pc1Byb2dyZXNzaXZlID0gZmFsc2U7XHJcblx0dGhpcy5faXNEaXNwb3NlZCA9IGZhbHNlO1xyXG4gICAgXHJcbiAgICB0aGlzLl9zdWJzY3JpYmVIYW5kbGVzID0gW107XHJcbiAgICBcclxuICAgIHZhciBkYXRhRmV0Y2hlZEJvdW5kID0gdGhpcy5fZGF0YUZldGNoZWQuYmluZCh0aGlzKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUtleXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICB2YXIgc3Vic2NyaWJlSGFuZGxlID0gdGhpcy5fZGF0YVB1Ymxpc2hlci5zdWJzY3JpYmUoXHJcblx0XHRcdHsgZGF0YUtleTogZGF0YUtleXNbaV0sIG1heFF1YWxpdHk6IHRoaXMuX21heFF1YWxpdHkgfSxcclxuXHRcdFx0ZGF0YUZldGNoZWRCb3VuZCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaWJlSGFuZGxlcy5wdXNoKHN1YnNjcmliZUhhbmRsZSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8vIE5vdCBwYXJ0IG9mIEltYWdlRGF0YUNvbnRleHQgaW50ZXJmYWNlLCBvbmx5IHNlcnZpY2UgZm9yIFNpbXBsZUZldGNoZXJcclxuU2ltcGxlSW1hZ2VEYXRhQ29udGV4dC5wcm90b3R5cGUuZ2V0TWF4UXVhbGl0eSA9IGZ1bmN0aW9uIGdldE1heFF1YWxpdHkoKSB7XHJcblx0cmV0dXJuIHRoaXMuX21heFF1YWxpdHk7XHJcbn07XHJcblxyXG5TaW1wbGVJbWFnZURhdGFDb250ZXh0LnByb3RvdHlwZS5nZXREYXRhS2V5cyA9IGZ1bmN0aW9uIGdldERhdGFLZXlzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RhdGFLZXlzO1xyXG59O1xyXG5cclxuU2ltcGxlSW1hZ2VEYXRhQ29udGV4dC5wcm90b3R5cGUuZ2V0SW1hZ2VQYXJ0UGFyYW1zID0gZnVuY3Rpb24gZ2V0SW1hZ2VQYXJ0UGFyYW1zKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ltYWdlUGFydFBhcmFtcztcclxufTtcclxuXHJcblNpbXBsZUltYWdlRGF0YUNvbnRleHQucHJvdG90eXBlLmhhc0RhdGEgPSBmdW5jdGlvbiBoYXNEYXRhKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2ZldGNoZWRMb3dRdWFsaXR5Q291bnQgPT0gdGhpcy5fZGF0YUtleXMubGVuZ3RoO1xyXG59O1xyXG5cclxuU2ltcGxlSW1hZ2VEYXRhQ29udGV4dC5wcm90b3R5cGUuZ2V0RmV0Y2hlZERhdGEgPSBmdW5jdGlvbiBnZXRGZXRjaGVkRGF0YSgpIHtcclxuICAgIGlmICghdGhpcy5oYXNEYXRhKCkpIHtcclxuICAgICAgICB0aHJvdyAnU2ltcGxlSW1hZ2VEYXRhQ29udGV4dCBlcnJvcjogY2Fubm90IGNhbGwgZ2V0RmV0Y2hlZERhdGEgYmVmb3JlIGhhc0RhdGEgPSB0cnVlJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHRoaXMuX2RhdGFUb1JldHVybjtcclxufTtcclxuXHJcblNpbXBsZUltYWdlRGF0YUNvbnRleHQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGxpc3RlbmVyKSB7XHJcblx0aWYgKHRoaXMuX2lzRGlzcG9zZWQpIHtcclxuXHRcdHRocm93ICdDYW5ub3QgcmVnaXN0ZXIgdG8gZXZlbnQgb24gZGlzcG9zZWQgSW1hZ2VEYXRhQ29udGV4dCc7XHJcblx0fVxyXG4gICAgaWYgKGV2ZW50ICE9PSAnZGF0YScpIHtcclxuICAgICAgICB0aHJvdyAnU2ltcGxlSW1hZ2VEYXRhQ29udGV4dCBlcnJvcjogVW5leHBlY3RlZCBldmVudCAnICsgZXZlbnQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMuX2RhdGFMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XHJcbn07XHJcblxyXG5TaW1wbGVJbWFnZURhdGFDb250ZXh0LnByb3RvdHlwZS5pc0RvbmUgPSBmdW5jdGlvbiBpc0RvbmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2hFbmRlZENvdW50ID09PSB0aGlzLl9kYXRhS2V5cy5sZW5ndGg7XHJcbn07XHJcblxyXG5TaW1wbGVJbWFnZURhdGFDb250ZXh0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcclxuXHR0aGlzLl9pc0Rpc3Bvc2VkID0gdHJ1ZTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc3Vic2NyaWJlSGFuZGxlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIHRoaXMuX2RhdGFQdWJsaXNoZXIudW5zdWJzY3JpYmUodGhpcy5fc3Vic2NyaWJlSGFuZGxlc1tpXSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMuX3N1YnNjcmliZUhhbmRsZXMgPSBbXTtcclxuXHR0aGlzLl9kYXRhTGlzdGVuZXJzID0gW107XHJcbn07XHJcblxyXG5TaW1wbGVJbWFnZURhdGFDb250ZXh0LnByb3RvdHlwZS5zZXRJc1Byb2dyZXNzaXZlID0gZnVuY3Rpb24gc2V0SXNQcm9ncmVzc2l2ZShpc1Byb2dyZXNzaXZlKSB7XHJcblx0dmFyIG9sZElzUHJvZ3Jlc3NpdmUgPSB0aGlzLl9pc1Byb2dyZXNzaXZlO1xyXG4gICAgdGhpcy5faXNQcm9ncmVzc2l2ZSA9IGlzUHJvZ3Jlc3NpdmU7XHJcblx0aWYgKCFvbGRJc1Byb2dyZXNzaXZlICYmIGlzUHJvZ3Jlc3NpdmUgJiYgdGhpcy5oYXNEYXRhKCkpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZGF0YUxpc3RlbmVycy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRhTGlzdGVuZXJzW2ldKHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHR9XHJcbn07XHJcblxyXG5TaW1wbGVJbWFnZURhdGFDb250ZXh0LnByb3RvdHlwZS5fZGF0YUZldGNoZWQgPSBmdW5jdGlvbiBkYXRhRmV0Y2hlZChrZXksIGRhdGEsIGZldGNoRW5kZWQpIHtcclxuXHRpZiAodGhpcy5faXNEaXNwb3NlZCkge1xyXG5cdFx0dGhyb3cgJ1VuZXhwZWN0ZWQgZGF0YUZldGNoZWQgbGlzdGVuZXIgY2FsbCBvbiBkaXNwb3NlZCBJbWFnZURhdGFDb250ZXh0JztcclxuXHR9XHJcblxyXG5cdHZhciBzZWxmID0gdGhpcztcclxuXHR2YXIgYWRkZWQgPSB0aGlzLl9kYXRhQnlLZXkudHJ5QWRkKGtleSwgZnVuY3Rpb24oKSB7XHJcblx0XHQvLyBFeGVjdXRlZCBpZiBuZXcgaXRlbVxyXG4gICAgICAgIHNlbGYuX2RhdGFUb1JldHVybi5mZXRjaGVkSXRlbXMucHVzaCh7XHJcbiAgICAgICAgICAgIGtleToga2V5LmRhdGFLZXksXHJcbiAgICAgICAgICAgIGRhdGE6IGRhdGFcclxuICAgICAgICB9KTtcclxuXHRcdCsrc2VsZi5fZmV0Y2hlZExvd1F1YWxpdHlDb3VudDtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGZldGNoRW5kZWQ6IGZhbHNlLFxyXG5cdFx0XHRmZXRjaGVkSXRlbXNPZmZzZXQ6IHNlbGYuX2RhdGFUb1JldHVybi5mZXRjaGVkSXRlbXMubGVuZ3RoIC0gMVxyXG5cdFx0fTtcclxuXHR9KTtcclxuXHRcclxuICAgIGlmIChhZGRlZC52YWx1ZS5mZXRjaEVuZGVkKSB7XHJcblx0XHQvLyBBbHJlYWR5IGZldGNoZWQgZnVsbCBxdWFsaXR5LCBub3RoaW5nIHRvIHJlZnJlc2hcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblx0XHJcblx0dGhpcy5fZGF0YVRvUmV0dXJuLmZldGNoZWRJdGVtc1thZGRlZC52YWx1ZS5mZXRjaGVkSXRlbXNPZmZzZXRdLmRhdGEgPSBkYXRhO1xyXG5cdGlmIChmZXRjaEVuZGVkKVxyXG5cdHtcclxuXHRcdGFkZGVkLnZhbHVlLmZldGNoRW5kZWQgPSB0cnVlO1xyXG4gICAgICAgICsrdGhpcy5fZmV0Y2hFbmRlZENvdW50O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAodGhpcy5pc0RvbmUoKSB8fCAodGhpcy5oYXNEYXRhKCkgJiYgdGhpcy5faXNQcm9ncmVzc2l2ZSkpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2RhdGFMaXN0ZW5lcnMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGF0YUxpc3RlbmVyc1tpXSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGVOb25Qcm9ncmVzc2l2ZUZldGNoSGFuZGxlO1xyXG5cclxuLyogZ2xvYmFsIFByb21pc2U6IGZhbHNlICovXHJcblxyXG5mdW5jdGlvbiBTaW1wbGVOb25Qcm9ncmVzc2l2ZUZldGNoSGFuZGxlKGZldGNoTWV0aG9kcywgZGF0YUNhbGxiYWNrLCBxdWVyeUlzS2V5TmVlZEZldGNoLCBvcHRpb25zKSB7XHJcbiAgICB0aGlzLl9mZXRjaE1ldGhvZHMgPSBmZXRjaE1ldGhvZHM7XHJcblx0dGhpcy5fZGF0YUNhbGxiYWNrID0gZGF0YUNhbGxiYWNrO1xyXG4gICAgdGhpcy5fcXVlcnlJc0tleU5lZWRGZXRjaCA9IHF1ZXJ5SXNLZXlOZWVkRmV0Y2g7XHJcbiAgICB0aGlzLl9mZXRjaExpbWl0ID0gKG9wdGlvbnMgfHwge30pLmZldGNoTGltaXRQZXJGZXRjaGVyIHx8IDI7XHJcbiAgICB0aGlzLl9rZXlzVG9GZXRjaCA9IG51bGw7XHJcbiAgICB0aGlzLl9uZXh0S2V5VG9GZXRjaCA9IDA7XHJcbiAgICB0aGlzLl9hY3RpdmVGZXRjaGVzID0ge307XHJcbiAgICB0aGlzLl9hY3RpdmVGZXRjaGVzQ291bnQgPSAwO1xyXG4gICAgdGhpcy5faXNBYm9ydGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9pc1N0b3BwZWRDYWxsZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX3Jlc29sdmVBYm9ydCA9IG51bGw7XHJcbn1cclxuXHJcblNpbXBsZU5vblByb2dyZXNzaXZlRmV0Y2hIYW5kbGUucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gZmV0Y2goa2V5cykge1xyXG4gICAgaWYgKHRoaXMuX2tleXNUb0ZldGNoICE9PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgJ1NpbXBsZU5vblByb2dyZXNzaXZlRmV0Y2hIYW5kbGUgZXJyb3I6IFJlcXVlc3QgZmV0Y2hlciBjYW4gZmV0Y2ggb25seSBvbmUgcmVnaW9uJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5fa2V5c1RvRmV0Y2ggPSBrZXlzO1xyXG4gICAgdGhpcy5fbmV4dEtleVRvRmV0Y2ggPSAwO1xyXG4gICAgd2hpbGUgKHRoaXMuX2FjdGl2ZUZldGNoZXNDb3VudCA8IHRoaXMuX2ZldGNoTGltaXQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2ZldGNoU2luZ2xlS2V5KCkpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuU2ltcGxlTm9uUHJvZ3Jlc3NpdmVGZXRjaEhhbmRsZS5wcm90b3R5cGUuYWJvcnRBc3luYyA9IGZ1bmN0aW9uIGFib3J0QXN5bmMoKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgaWYgKHNlbGYuX2FjdGl2ZUZldGNoZXNDb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUFib3J0ID0gcmVzb2x2ZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuXHJcblNpbXBsZU5vblByb2dyZXNzaXZlRmV0Y2hIYW5kbGUucHJvdG90eXBlLl9mZXRjaFNpbmdsZUtleSA9IGZ1bmN0aW9uIGZldGNoU2luZ2xlS2V5KCkge1xyXG4gICAgdmFyIGtleTtcclxuICAgIGRvIHtcclxuICAgICAgICBpZiAodGhpcy5fbmV4dEtleVRvRmV0Y2ggPj0gdGhpcy5fa2V5c1RvRmV0Y2gubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAga2V5ID0gdGhpcy5fa2V5c1RvRmV0Y2hbdGhpcy5fbmV4dEtleVRvRmV0Y2grK107XHJcbiAgICB9IHdoaWxlICghdGhpcy5fcXVlcnlJc0tleU5lZWRGZXRjaChrZXkpKTtcclxuICAgIFxyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdGhpcy5fYWN0aXZlRmV0Y2hlc1trZXldID0gdHJ1ZTtcclxuICAgICsrdGhpcy5fYWN0aXZlRmV0Y2hlc0NvdW50O1xyXG4gICAgXHJcbiAgICB0aGlzLl9mZXRjaE1ldGhvZHMuZmV0Y2goa2V5KVxyXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIHJlc29sdmVkKHJlc3VsdCkge1xyXG4gICAgICAgICAgICBzZWxmLl9kYXRhQ2FsbGJhY2soa2V5LCByZXN1bHQsIC8qZmV0Y2hFbmRlZD0qL3RydWUpO1xyXG4gICAgICAgICAgICBzZWxmLl9mZXRjaEVuZGVkKG51bGwsIGtleSwgcmVzdWx0KTtcclxuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiBmYWlsZWQocmVhc29uKSB7XHJcbiAgICAgICAgICAgIC8vc2VsZi5fZmV0Y2hDbGllbnQuX29uRXJyb3IocmVhc29uKTtcclxuICAgICAgICAgICAgc2VsZi5fZmV0Y2hFbmRlZChyZWFzb24sIGtleSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuU2ltcGxlTm9uUHJvZ3Jlc3NpdmVGZXRjaEhhbmRsZS5wcm90b3R5cGUuX2ZldGNoRW5kZWQgPSBmdW5jdGlvbiBmZXRjaEVuZGVkKGVycm9yLCBrZXksIHJlc3VsdCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2FjdGl2ZUZldGNoZXNba2V5XTtcclxuICAgIC0tdGhpcy5fYWN0aXZlRmV0Y2hlc0NvdW50O1xyXG4gICAgXHJcbiAgICBpZiAoIXRoaXMuX3Jlc29sdmVBYm9ydCkge1xyXG4gICAgICAgIHRoaXMuX2ZldGNoU2luZ2xlS2V5KCk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2FjdGl2ZUZldGNoZXNDb3VudCA9PT0gMCkge1xyXG4gICAgICAgIHRoaXMuX3Jlc29sdmVBYm9ydCgpO1xyXG4gICAgICAgIHRoaXMuX3Jlc29sdmVBYm9ydCA9IG51bGw7XHJcbiAgICB9XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGVQaXhlbHNEZWNvZGVyQmFzZTtcclxuXHJcbi8qIGdsb2JhbCBQcm9taXNlIDogZmFsc2UgKi9cclxuLyogZ2xvYmFsIEltYWdlRGF0YSA6IGZhbHNlICovXHJcblxyXG5mdW5jdGlvbiBTaW1wbGVQaXhlbHNEZWNvZGVyQmFzZSgpIHtcclxuICAgIFNpbXBsZVBpeGVsc0RlY29kZXJCYXNlLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoZmV0Y2hlZERhdGEpIHtcclxuICAgICAgICB2YXIgaW1hZ2VQYXJ0UGFyYW1zID0gZmV0Y2hlZERhdGEuaW1hZ2VQYXJ0UGFyYW1zO1xyXG4gICAgICAgIHZhciB3aWR0aCAgPSBpbWFnZVBhcnRQYXJhbXMubWF4WEV4Y2x1c2l2ZSAtIGltYWdlUGFydFBhcmFtcy5taW5YO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBpbWFnZVBhcnRQYXJhbXMubWF4WUV4Y2x1c2l2ZSAtIGltYWdlUGFydFBhcmFtcy5taW5ZO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmV0Y2hlZERhdGEuZmV0Y2hlZEl0ZW1zLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5kZWNvZGVSZWdpb24ocmVzdWx0LCBpbWFnZVBhcnRQYXJhbXMubWluWCwgaW1hZ2VQYXJ0UGFyYW1zLm1pblksIGZldGNoZWREYXRhLmZldGNoZWRJdGVtc1tpXS5rZXksIGZldGNoZWREYXRhLmZldGNoZWRJdGVtc1tpXS5kYXRhKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIFNpbXBsZVBpeGVsc0RlY29kZXJCYXNlLnByb3RvdHlwZS5kZWNvZGVSZWdpb24gPSBmdW5jdGlvbiBkZWNvZGVSZWdpb24odGFyZ2V0SW1hZ2VEYXRhLCBpbWFnZVBhcnRQYXJhbXMsIGtleSwgZmV0Y2hlZERhdGEpIHtcclxuICAgICAgICB0aHJvdyAnU2ltcGxlUGl4ZWxzRGVjb2RlckJhc2UgZXJyb3I6IGRlY29kZVJlZ2lvbiBpcyBub3QgaW1wbGVtZW50ZWQnO1xyXG4gICAgfTtcclxufSJdfQ==

/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/* Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

/* This class implements the QM Coder decoding as defined in
 *   JPEG 2000 Part I Final Committee Draft Version 1.0
 *   Annex C.3 Arithmetic decoding procedure 
 * available at http://www.jpeg.org/public/fcd15444-1.pdf
 * 
 * The arithmetic decoder is used in conjunction with context models to decode
 * JPEG2000 and JBIG2 streams.
 */
var ArithmeticDecoder = (function ArithmeticDecoderClosure() {
  // Table C-2
  var QeTable = [
    {qe: 0x5601, nmps: 1, nlps: 1, switchFlag: 1},
    {qe: 0x3401, nmps: 2, nlps: 6, switchFlag: 0},
    {qe: 0x1801, nmps: 3, nlps: 9, switchFlag: 0},
    {qe: 0x0AC1, nmps: 4, nlps: 12, switchFlag: 0},
    {qe: 0x0521, nmps: 5, nlps: 29, switchFlag: 0},
    {qe: 0x0221, nmps: 38, nlps: 33, switchFlag: 0},
    {qe: 0x5601, nmps: 7, nlps: 6, switchFlag: 1},
    {qe: 0x5401, nmps: 8, nlps: 14, switchFlag: 0},
    {qe: 0x4801, nmps: 9, nlps: 14, switchFlag: 0},
    {qe: 0x3801, nmps: 10, nlps: 14, switchFlag: 0},
    {qe: 0x3001, nmps: 11, nlps: 17, switchFlag: 0},
    {qe: 0x2401, nmps: 12, nlps: 18, switchFlag: 0},
    {qe: 0x1C01, nmps: 13, nlps: 20, switchFlag: 0},
    {qe: 0x1601, nmps: 29, nlps: 21, switchFlag: 0},
    {qe: 0x5601, nmps: 15, nlps: 14, switchFlag: 1},
    {qe: 0x5401, nmps: 16, nlps: 14, switchFlag: 0},
    {qe: 0x5101, nmps: 17, nlps: 15, switchFlag: 0},
    {qe: 0x4801, nmps: 18, nlps: 16, switchFlag: 0},
    {qe: 0x3801, nmps: 19, nlps: 17, switchFlag: 0},
    {qe: 0x3401, nmps: 20, nlps: 18, switchFlag: 0},
    {qe: 0x3001, nmps: 21, nlps: 19, switchFlag: 0},
    {qe: 0x2801, nmps: 22, nlps: 19, switchFlag: 0},
    {qe: 0x2401, nmps: 23, nlps: 20, switchFlag: 0},
    {qe: 0x2201, nmps: 24, nlps: 21, switchFlag: 0},
    {qe: 0x1C01, nmps: 25, nlps: 22, switchFlag: 0},
    {qe: 0x1801, nmps: 26, nlps: 23, switchFlag: 0},
    {qe: 0x1601, nmps: 27, nlps: 24, switchFlag: 0},
    {qe: 0x1401, nmps: 28, nlps: 25, switchFlag: 0},
    {qe: 0x1201, nmps: 29, nlps: 26, switchFlag: 0},
    {qe: 0x1101, nmps: 30, nlps: 27, switchFlag: 0},
    {qe: 0x0AC1, nmps: 31, nlps: 28, switchFlag: 0},
    {qe: 0x09C1, nmps: 32, nlps: 29, switchFlag: 0},
    {qe: 0x08A1, nmps: 33, nlps: 30, switchFlag: 0},
    {qe: 0x0521, nmps: 34, nlps: 31, switchFlag: 0},
    {qe: 0x0441, nmps: 35, nlps: 32, switchFlag: 0},
    {qe: 0x02A1, nmps: 36, nlps: 33, switchFlag: 0},
    {qe: 0x0221, nmps: 37, nlps: 34, switchFlag: 0},
    {qe: 0x0141, nmps: 38, nlps: 35, switchFlag: 0},
    {qe: 0x0111, nmps: 39, nlps: 36, switchFlag: 0},
    {qe: 0x0085, nmps: 40, nlps: 37, switchFlag: 0},
    {qe: 0x0049, nmps: 41, nlps: 38, switchFlag: 0},
    {qe: 0x0025, nmps: 42, nlps: 39, switchFlag: 0},
    {qe: 0x0015, nmps: 43, nlps: 40, switchFlag: 0},
    {qe: 0x0009, nmps: 44, nlps: 41, switchFlag: 0},
    {qe: 0x0005, nmps: 45, nlps: 42, switchFlag: 0},
    {qe: 0x0001, nmps: 45, nlps: 43, switchFlag: 0},
    {qe: 0x5601, nmps: 46, nlps: 46, switchFlag: 0}
  ];

  // C.3.5 Initialisation of the decoder (INITDEC)
  function ArithmeticDecoder(data, start, end) {
    this.data = data;
    this.bp = start;
    this.dataEnd = end;

    this.chigh = data[start];
    this.clow = 0;

    this.byteIn();

    this.chigh = ((this.chigh << 7) & 0xFFFF) | ((this.clow >> 9) & 0x7F);
    this.clow = (this.clow << 7) & 0xFFFF;
    this.ct -= 7;
    this.a = 0x8000;
  }

  ArithmeticDecoder.prototype = {
    // C.3.4 Compressed data input (BYTEIN)
    byteIn: function ArithmeticDecoder_byteIn() {
      var data = this.data;
      var bp = this.bp;
      if (data[bp] === 0xFF) {
        var b1 = data[bp + 1];
        if (b1 > 0x8F) {
          this.clow += 0xFF00;
          this.ct = 8;
        } else {
          bp++;
          this.clow += (data[bp] << 9);
          this.ct = 7;
          this.bp = bp;
        }
      } else {
        bp++;
        this.clow += bp < this.dataEnd ? (data[bp] << 8) : 0xFF00;
        this.ct = 8;
        this.bp = bp;
      }
      if (this.clow > 0xFFFF) {
        this.chigh += (this.clow >> 16);
        this.clow &= 0xFFFF;
      }
    },
    // C.3.2 Decoding a decision (DECODE)
    readBit: function ArithmeticDecoder_readBit(contexts, pos) {
      // contexts are packed into 1 byte:
      // highest 7 bits carry cx.index, lowest bit carries cx.mps
      var cx_index = contexts[pos] >> 1, cx_mps = contexts[pos] & 1;
      var qeTableIcx = QeTable[cx_index];
      var qeIcx = qeTableIcx.qe;
      var d;
      var a = this.a - qeIcx;

      if (this.chigh < qeIcx) {
        // exchangeLps
        if (a < qeIcx) {
          a = qeIcx;
          d = cx_mps;
          cx_index = qeTableIcx.nmps;
        } else {
          a = qeIcx;
          d = 1 ^ cx_mps;
          if (qeTableIcx.switchFlag === 1) {
            cx_mps = d;
          }
          cx_index = qeTableIcx.nlps;
        }
      } else {
        this.chigh -= qeIcx;
        if ((a & 0x8000) !== 0) {
          this.a = a;
          return cx_mps;
        }
        // exchangeMps
        if (a < qeIcx) {
          d = 1 ^ cx_mps;
          if (qeTableIcx.switchFlag === 1) {
            cx_mps = d;
          }
          cx_index = qeTableIcx.nlps;
        } else {
          d = cx_mps;
          cx_index = qeTableIcx.nmps;
        }
      }
      // C.3.3 renormD;
      do {
        if (this.ct === 0) {
          this.byteIn();
        }

        a <<= 1;
        this.chigh = ((this.chigh << 1) & 0xFFFF) | ((this.clow >> 15) & 1);
        this.clow = (this.clow << 1) & 0xFFFF;
        this.ct--;
      } while ((a & 0x8000) === 0);
      this.a = a;

      contexts[pos] = cx_index << 1 | cx_mps;
      return d;
    }
  };

  return ArithmeticDecoder;
})();

'use strict';

function AsyncJpxImage() {
}

AsyncJpxImage.prototype = Object.create(JpxImage.prototype);

AsyncJpxImage.prototype.parseCodestreamAsync = function parseCodestreamAsync(
	callback, data, start, end, options) {
	
	this._currentContext = this.parseCodestream(data, start, end, options);
	
	if (options !== undefined && options.isOnlyParseHeaders) {
		callback(null);
		return;
	}
	
	this._getPixels(callback, options);
};

AsyncJpxImage.prototype.addPacketsDataToCurrentContext =
	function addPacketsDataToCurrentContext(packetsData) {
	
	this.addPacketsData(this._currentContext, packetsData);
};

AsyncJpxImage.prototype.decodeCurrentContextAsync =
	function decodeCurrentContextAsync(callback, options) {
	
	this.decode(this._currentContext, options);
	this._getPixels(callback, options);
};

AsyncJpxImage.prototype._getPixels = function getPixels(callback, options) {
	var region;
	if (options !== undefined && options.regionToParse !== undefined) {
		region = options.regionToParse;
	} else {
		region = {
			left : 0,
			top : 0,
			right : this.width,
			bottom : this.height
		};
	}
	
	var result = copyTilesPixelsToOnePixelsArray(this.tiles, region, this.componentsCount);
	callback(result);
};
/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/* Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* globals ArithmeticDecoder, globalScope, log2, readUint16, readUint32,
           info, warn */

'use strict';

var JpxImage = (function JpxImageClosure() {
  // Table E.1
  var SubbandsGainLog2 = {
    'LL': 0,
    'LH': 1,
    'HL': 1,
    'HH': 2
  };
  function JpxImage() {
    this.failOnCorruptedImage = false;
  }
  JpxImage.prototype = {
    parse: function JpxImage_parse(data) {

      var head = readUint16(data, 0);
      // No box header, immediate start of codestream (SOC)
      if (head === 0xFF4F) {
        this.parseCodestream(data, 0, data.length);
        return;
      }

      var position = 0, length = data.length;
      while (position < length) {
        var headerSize = 8;
        var lbox = readUint32(data, position);
        var tbox = readUint32(data, position + 4);
        position += headerSize;
        if (lbox === 1) {
          // XLBox: read UInt64 according to spec.
          // JavaScript's int precision of 53 bit should be sufficient here.
          lbox = readUint32(data, position) * 4294967296 +
                 readUint32(data, position + 4);
          position += 8;
          headerSize += 8;
        }
        if (lbox === 0) {
          lbox = length - position + headerSize;
        }
        if (lbox < headerSize) {
          throw new Error('JPX Error: Invalid box field size');
        }
        var dataLength = lbox - headerSize;
        var jumpDataLength = true;
        switch (tbox) {
          case 0x6A703268: // 'jp2h'
            jumpDataLength = false; // parsing child boxes
            break;
          case 0x636F6C72: // 'colr'
            // Colorspaces are not used, the CS from the PDF is used.
            var method = data[position];
            var precedence = data[position + 1];
            var approximation = data[position + 2];
            if (method === 1) {
              // enumerated colorspace
              var colorspace = readUint32(data, position + 3);
              switch (colorspace) {
                case 16: // this indicates a sRGB colorspace
                case 17: // this indicates a grayscale colorspace
                case 18: // this indicates a YUV colorspace
                  break;
                default:
                  warn('Unknown colorspace ' + colorspace);
                  break;
              }
            } else if (method === 2) {
              info('ICC profile not supported');
            }
            break;
          case 0x6A703263: // 'jp2c'
            this.parseCodestream(data, position, position + dataLength);
            break;
          case 0x6A502020: // 'jP\024\024'
            if (0x0d0a870a !== readUint32(data, position)) {
              warn('Invalid JP2 signature');
            }
            break;
          // The following header types are valid but currently not used:
          case 0x6A501A1A: // 'jP\032\032'
          case 0x66747970: // 'ftyp'
          case 0x72726571: // 'rreq'
          case 0x72657320: // 'res '
          case 0x69686472: // 'ihdr'
            break;
          default:
            var headerType = String.fromCharCode((tbox >> 24) & 0xFF,
                                                 (tbox >> 16) & 0xFF,
                                                 (tbox >> 8) & 0xFF,
                                                 tbox & 0xFF);
            warn('Unsupported header type ' + tbox + ' (' + headerType + ')');
            break;
        }
        if (jumpDataLength) {
          position += dataLength;
        }
      }
    },
    parseImageProperties: function JpxImage_parseImageProperties(stream) {
      var newByte = stream.getByte();
      while (newByte >= 0) {
        var oldByte = newByte;
        newByte = stream.getByte();
        var code = (oldByte << 8) | newByte;
        // Image and tile size (SIZ)
        if (code === 0xFF51) {
          stream.skip(4);
          var Xsiz = stream.getInt32() >>> 0; // Byte 4
          var Ysiz = stream.getInt32() >>> 0; // Byte 8
          var XOsiz = stream.getInt32() >>> 0; // Byte 12
          var YOsiz = stream.getInt32() >>> 0; // Byte 16
          stream.skip(16);
          var Csiz = stream.getUint16(); // Byte 36
          this.width = Xsiz - XOsiz;
          this.height = Ysiz - YOsiz;
          this.componentsCount = Csiz;
          // Results are always returned as Uint8Arrays
          this.bitsPerComponent = 8;
          return;
        }
      }
      throw new Error('JPX Error: No size marker found in JPX stream');
    },
    parseCodestream: function JpxImage_parseCodestream(
      data, start, end, options) {
      var context = {};
      options = options || {};
      var isOnlyParseHeaders = !!options.isOnlyParseHeaders;
      var regionToParse = options.regionToParse;
      if (regionToParse !== undefined && isOnlyParseHeaders) {
        throw 'JPX Error: options.regionToParse is uneffective if ' +
          'options.isOnlyParseHeaders = true';
      }
      
      try {
        var doNotRecover = false;
        var position = start;
        while (position + 1 < end) {
          var code = readUint16(data, position);
          position += 2;

          var length = 0, j, sqcd, spqcds, spqcdSize, scalarExpounded, tile;
          switch (code) {
            case 0xFF4F: // Start of codestream (SOC)
              context.mainHeader = true;
              break;
            case 0xFFD9: // End of codestream (EOC)
              break;
            case 0xFF51: // Image and tile size (SIZ)
              length = readUint16(data, position);
              var siz = {};
              siz.Xsiz = readUint32(data, position + 4);
              siz.Ysiz = readUint32(data, position + 8);
              siz.XOsiz = readUint32(data, position + 12);
              siz.YOsiz = readUint32(data, position + 16);
              siz.XTsiz = readUint32(data, position + 20);
              siz.YTsiz = readUint32(data, position + 24);
              siz.XTOsiz = readUint32(data, position + 28);
              siz.YTOsiz = readUint32(data, position + 32);
              var componentsCount = readUint16(data, position + 36);
              siz.Csiz = componentsCount;
              var components = [];
              var isComponentSizesSupported = true;
              j = position + 38;
              for (var i = 0; i < componentsCount; i++) {
                var component = {
                  precision: (data[j] & 0x7F) + 1,
                  isSigned: !!(data[j] & 0x80),
                  XRsiz: data[j + 1],
                  YRsiz: data[j + 1]
                };
                calculateComponentDimensions(component, siz);
                components.push(component);
                
                if (regionToParse !== undefined) {
                  isComponentSizesSupported &=
                    component.XRsiz === 1 && component.YRsiz === 1;
                }
              }
              context.SIZ = siz;
              context.components = components;
              calculateTileGrids(context, components);
              context.QCC = [];
              context.COC = [];
              
              if (!isComponentSizesSupported) {
                throw new Error('JPX Error: When regionToParse is used, ' +
                  'component size other than 1 is not supported');
              }
              break;
            case 0xFF55: // Tile-part lengths, main header (TLM)
              var Ltlm = readUint16(data, position); // Marker segment length
              // Skip tile length markers
              position += Ltlm;
              break;
            case 0xFF58: // Packet lengths, tile header (PLT): MAMAZAV
              var Lplt = readUint16(data, position); // Marker segment length
              // Skip tile length markers
              position += Lplt;
              break;
            case 0xFF5C: // Quantization default (QCD)
              length = readUint16(data, position);
              var qcd = {};
              j = position + 2;
              sqcd = data[j++];
              switch (sqcd & 0x1F) {
                case 0:
                  spqcdSize = 8;
                  scalarExpounded = true;
                  break;
                case 1:
                  spqcdSize = 16;
                  scalarExpounded = false;
                  break;
                case 2:
                  spqcdSize = 16;
                  scalarExpounded = true;
                  break;
                default:
                  throw new Error('JPX Error: Invalid SQcd value ' + sqcd);
              }
              qcd.noQuantization = (spqcdSize === 8);
              qcd.scalarExpounded = scalarExpounded;
              qcd.guardBits = sqcd >> 5;
              spqcds = [];
              while (j < length + position) {
                var spqcd = {};
                if (spqcdSize === 8) {
                  spqcd.epsilon = data[j++] >> 3;
                  spqcd.mu = 0;
                } else {
                  spqcd.epsilon = data[j] >> 3;
                  spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];
                  j += 2;
                }
                spqcds.push(spqcd);
              }
              qcd.SPqcds = spqcds;
              if (context.mainHeader) {
                context.QCD = qcd;
              } else {
                context.currentTile.QCD = qcd;
                context.currentTile.QCC = [];
              }
              break;
            case 0xFF5D: // Quantization component (QCC)
              length = readUint16(data, position);
              var qcc = {};
              j = position + 2;
              var cqcc;
              if (context.SIZ.Csiz < 257) {
                cqcc = data[j++];
              } else {
                cqcc = readUint16(data, j);
                j += 2;
              }
              sqcd = data[j++];
              switch (sqcd & 0x1F) {
                case 0:
                  spqcdSize = 8;
                  scalarExpounded = true;
                  break;
                case 1:
                  spqcdSize = 16;
                  scalarExpounded = false;
                  break;
                case 2:
                  spqcdSize = 16;
                  scalarExpounded = true;
                  break;
                default:
                  throw new Error('JPX Error: Invalid SQcd value ' + sqcd);
              }
              qcc.noQuantization = (spqcdSize === 8);
              qcc.scalarExpounded = scalarExpounded;
              qcc.guardBits = sqcd >> 5;
              spqcds = [];
              while (j < (length + position)) {
                spqcd = {};
                if (spqcdSize === 8) {
                  spqcd.epsilon = data[j++] >> 3;
                  spqcd.mu = 0;
                } else {
                  spqcd.epsilon = data[j] >> 3;
                  spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];
                  j += 2;
                }
                spqcds.push(spqcd);
              }
              qcc.SPqcds = spqcds;
              if (context.mainHeader) {
                context.QCC[cqcc] = qcc;
              } else {
                context.currentTile.QCC[cqcc] = qcc;
              }
              break;
            case 0xFF52: // Coding style default (COD)
              length = readUint16(data, position);
              var cod = {};
              j = position + 2;
              var scod = data[j++];
              cod.entropyCoderWithCustomPrecincts = !!(scod & 1);
              cod.sopMarkerUsed = !!(scod & 2);
              cod.ephMarkerUsed = !!(scod & 4);
              cod.progressionOrder = data[j++];
              cod.layersCount = readUint16(data, j);
              j += 2;
              cod.multipleComponentTransform = data[j++];

              cod.decompositionLevelsCount = data[j++];
              cod.xcb = (data[j++] & 0xF) + 2;
              cod.ycb = (data[j++] & 0xF) + 2;
              var blockStyle = data[j++];
              cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);
              cod.resetContextProbabilities = !!(blockStyle & 2);
              cod.terminationOnEachCodingPass = !!(blockStyle & 4);
              cod.verticalyStripe = !!(blockStyle & 8);
              cod.predictableTermination = !!(blockStyle & 16);
              cod.segmentationSymbolUsed = !!(blockStyle & 32);
              cod.reversibleTransformation = data[j++];
              if (cod.entropyCoderWithCustomPrecincts) {
                var precinctsSizes = [];
                while (j < length + position) {
                  var precinctsSize = data[j++];
                  precinctsSizes.push({
                    PPx: precinctsSize & 0xF,
                    PPy: precinctsSize >> 4
                  });
                }
                cod.precinctsSizes = precinctsSizes;
              }
              var unsupported = [];
              if (cod.selectiveArithmeticCodingBypass) {
                unsupported.push('selectiveArithmeticCodingBypass');
              }
              if (cod.resetContextProbabilities) {
                unsupported.push('resetContextProbabilities');
              }
              if (cod.terminationOnEachCodingPass) {
                unsupported.push('terminationOnEachCodingPass');
              }
              if (cod.verticalyStripe) {
                unsupported.push('verticalyStripe');
              }
              if (cod.predictableTermination) {
                unsupported.push('predictableTermination');
              }
              if (unsupported.length > 0) {
                doNotRecover = true;
                throw new Error('JPX Error: Unsupported COD options (' +
                                unsupported.join(', ') + ')');
              }
              if (context.mainHeader) {
                context.COD = cod;
              } else {
                context.currentTile.COD = cod;
                context.currentTile.COC = [];
              }
              break;
            case 0xFF90: // Start of tile-part (SOT)
              length = readUint16(data, position);
              tile = {};
              tile.index = readUint16(data, position + 2);
              tile.length = readUint32(data, position + 4);
              tile.dataEnd = tile.length + position - 2;
              tile.partIndex = data[position + 8];
              tile.partsCount = data[position + 9];

              context.mainHeader = false;
              if (tile.partIndex === 0) {
                // reset component specific settings
                tile.COD = context.COD;
                tile.COC = context.COC.slice(0); // clone of the global COC
                tile.QCD = context.QCD;
                tile.QCC = context.QCC.slice(0); // clone of the global COC
              }
              context.currentTile = tile;
              break;
            case 0xFF93: // Start of data (SOD)
              tile = context.currentTile;
              if (tile.partIndex === 0) {
                initializeTile(context, tile.index);
                buildPackets(context);
              }

              // moving to the end of the data
              length = tile.dataEnd - position;
              if (!isOnlyParseHeaders) {
                parseTilePackets(context, data, position, length);
              }
              
              break;
            case 0xFF64: // Comment (COM)
              length = readUint16(data, position);
              // skipping content
              break;
            case 0xFF53: // Coding style component (COC)
              throw new Error('JPX Error: Codestream code 0xFF53 (COC) is ' +
                              'not implemented');
            default:
              throw new Error('JPX Error: Unknown codestream code: ' +
                              code.toString(16));
          }
          position += length;
        }
      } catch (e) {
        if (doNotRecover || this.failOnCorruptedImage) {
          throw e;
        } else {
          warn('Trying to recover from ' + e.message);
        }
      }
      if (!isOnlyParseHeaders) {
        this.decode(context, options);
      }
      this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;
      this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;
      this.componentsCount = context.SIZ.Csiz;
      return context;
    },
    addPacketsData: function JpxImage_addPacketData(context, packetsData) {
      for (var j = 0; j < packetsData.packetDataOffsets.length; ++j) {
        var packetOffsets = packetsData.packetDataOffsets[j];
        var tile = context.tiles[packetOffsets.tileIndex];
        var component = tile.components[packetOffsets.c];
        var resolution = component.resolutions[packetOffsets.r];
        var p = packetOffsets.p;
        var l = packetOffsets.l;
        var packet = createPacket(resolution, p, l);
        for (var i = 0; i < packetOffsets.codeblockOffsets.length; ++i) {
          var codeblockOffsets = packetOffsets.codeblockOffsets[i];
          var isNoData = codeblockOffsets.start === codeblockOffsets.end;
          if (isNoData) {
            continue;
          }
          var codeblock = packet.codeblocks[i];
          if (codeblock['data'] === undefined) {
            codeblock.data = [];
          }
          if (codeblockOffsets.zeroBitPlanes !== undefined) {
            if (codeblock.zeroBitPlanes === undefined) {
              codeblock.zeroBitPlanes = codeblockOffsets.zeroBitPlanes;
            }
            if (codeblock.zeroBitPlanes !== codeblockOffsets.zeroBitPlanes) {
              throw 'JPX Error: Unmatched zero bit planes';
            }
          } else if (codeblock.zeroBitPlanes === undefined) {
            throw 'JPX Error: zeroBitPlanes is unknown';
          }
          codeblock.included = true;
          codeblock.data.push({
            data: packetsData.data,
            start: codeblockOffsets.start,
            end: codeblockOffsets.end,
            codingpasses: codeblockOffsets.codingpasses
          });
        }
      }
    },
    decode: function JpxImage_decode(context, options) {
      if (options !== undefined && options.regionToParse !== undefined) {
        var region = options.regionToParse;
        if (region.top === undefined ||
            region.left === undefined ||
            region.right === undefined ||
            region.bottom === undefined) {
          throw new Error('JPX Error: Either left, top, right or ' +
            'bottom are undefined in regionToParse');
        }
        context.regionToParse = region;
      }
      this.tiles = transformComponents(context);
      context.regionToParse = undefined;
    }
  };
  function calculateComponentDimensions(component, siz) {
    // Section B.2 Component mapping
    component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);
    component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);
    component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);
    component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);
    component.width = component.x1 - component.x0;
    component.height = component.y1 - component.y0;
  }
  function calculateTileGrids(context, components) {
    var siz = context.SIZ;
    // Section B.3 Division into tile and tile-components
    var tile, tiles = [];
    var numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);
    var numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);
    for (var q = 0; q < numYtiles; q++) {
      for (var p = 0; p < numXtiles; p++) {
        tile = {};
        tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);
        tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);
        tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);
        tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);
        tile.width = tile.tx1 - tile.tx0;
        tile.height = tile.ty1 - tile.ty0;
        tile.components = [];
        tiles.push(tile);
      }
    }
    context.tiles = tiles;

    var componentsCount = siz.Csiz;
    for (var i = 0, ii = componentsCount; i < ii; i++) {
      var component = components[i];
      for (var j = 0, jj = tiles.length; j < jj; j++) {
        var tileComponent = {};
        tile = tiles[j];
        tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);
        tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);
        tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);
        tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);
        tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;
        tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;
        tile.components[i] = tileComponent;
      }
    }
  }
  function getBlocksDimensions(context, component, r) {
    var codOrCoc = component.codingStyleParameters;
    var result = {};
    if (!codOrCoc.entropyCoderWithCustomPrecincts) {
      result.PPx = 15;
      result.PPy = 15;
    } else {
      result.PPx = codOrCoc.precinctsSizes[r].PPx;
      result.PPy = codOrCoc.precinctsSizes[r].PPy;
    }
    // calculate codeblock size as described in section B.7
    result.xcb_ = (r > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) :
                   Math.min(codOrCoc.xcb, result.PPx));
    result.ycb_ = (r > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) :
                   Math.min(codOrCoc.ycb, result.PPy));
    return result;
  }
  function buildPrecincts(context, resolution, dimensions) {
    // Section B.6 Division resolution to precincts
    var precinctWidth = 1 << dimensions.PPx;
    var precinctHeight = 1 << dimensions.PPy;
    // Jasper introduces codeblock groups for mapping each subband codeblocks
    // to precincts. Precinct partition divides a resolution according to width
    // and height parameters. The subband that belongs to the resolution level
    // has a different size than the level, unless it is the zero resolution.

    // From Jasper documentation: jpeg2000.pdf, section K: Tier-2 coding:
    // The precinct partitioning for a particular subband is derived from a
    // partitioning of its parent LL band (i.e., the LL band at the next higher
    // resolution level)... The LL band associated with each resolution level is
    // divided into precincts... Each of the resulting precinct regions is then
    // mapped into its child subbands (if any) at the next lower resolution
    // level. This is accomplished by using the coordinate transformation
    // (u, v) = (ceil(x/2), ceil(y/2)) where (x, y) and (u, v) are the
    // coordinates of a point in the LL band and child subband, respectively.
    var isZeroRes = resolution.resLevel === 0;
    var precinctWidthInSubband = 1 << (dimensions.PPx + (isZeroRes ? 0 : -1));
    var precinctHeightInSubband = 1 << (dimensions.PPy + (isZeroRes ? 0 : -1));
    var numprecinctswide = (resolution.trx1 > resolution.trx0 ?
      Math.ceil(resolution.trx1 / precinctWidth) -
      Math.floor(resolution.trx0 / precinctWidth) : 0);
    var numprecinctshigh = (resolution.try1 > resolution.try0 ?
      Math.ceil(resolution.try1 / precinctHeight) -
      Math.floor(resolution.try0 / precinctHeight) : 0);
    var numprecincts = numprecinctswide * numprecinctshigh;

    resolution.precinctParameters = {
      precinctWidth: precinctWidth,
      precinctHeight: precinctHeight,
      numprecinctswide: numprecinctswide,
      numprecinctshigh: numprecinctshigh,
      numprecincts: numprecincts,
      precinctWidthInSubband: precinctWidthInSubband,
      precinctHeightInSubband: precinctHeightInSubband
    };
  }
  function buildCodeblocks(context, subband, dimensions) {
    // Section B.7 Division sub-band into code-blocks
    var xcb_ = dimensions.xcb_;
    var ycb_ = dimensions.ycb_;
    var codeblockWidth = 1 << xcb_;
    var codeblockHeight = 1 << ycb_;
    var cbx0 = subband.tbx0 >> xcb_;
    var cby0 = subband.tby0 >> ycb_;
    var cbx1 = (subband.tbx1 + codeblockWidth - 1) >> xcb_;
    var cby1 = (subband.tby1 + codeblockHeight - 1) >> ycb_;
    var precinctParameters = subband.resolution.precinctParameters;
    var codeblocks = [];
    var precincts = [];
    var i, j, codeblock, precinctNumber;
    for (j = cby0; j < cby1; j++) {
      for (i = cbx0; i < cbx1; i++) {
        codeblock = {
          cbx: i,
          cby: j,
          tbx0: codeblockWidth * i,
          tby0: codeblockHeight * j,
          tbx1: codeblockWidth * (i + 1),
          tby1: codeblockHeight * (j + 1)
        };

        codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);
        codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);
        codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);
        codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);

        // Calculate precinct number for this codeblock, codeblock position
        // should be relative to its subband, use actual dimension and position
        // See comment about codeblock group width and height
        var pi = Math.floor((codeblock.tbx0_ - subband.tbx0) /
          precinctParameters.precinctWidthInSubband);
        var pj = Math.floor((codeblock.tby0_ - subband.tby0) /
          precinctParameters.precinctHeightInSubband);
        precinctNumber = pi + (pj * precinctParameters.numprecinctswide);

        codeblock.precinctNumber = precinctNumber;
        codeblock.subbandType = subband.type;
        codeblock.Lblock = 3;

        if (codeblock.tbx1_ <= codeblock.tbx0_ ||
            codeblock.tby1_ <= codeblock.tby0_) {
          continue;
        }
        codeblocks.push(codeblock);
        // building precinct for the sub-band
        var precinct = precincts[precinctNumber];
        if (precinct !== undefined) {
          if (i < precinct.cbxMin) {
            precinct.cbxMin = i;
          } else if (i > precinct.cbxMax) {
            precinct.cbxMax = i;
          }
          if (j < precinct.cbyMin) {
            precinct.cbxMin = j;
          } else if (j > precinct.cbyMax) {
            precinct.cbyMax = j;
          }
        } else {
          precincts[precinctNumber] = precinct = {
            cbxMin: i,
            cbyMin: j,
            cbxMax: i,
            cbyMax: j
          };
        }
        codeblock.precinct = precinct;
      }
    }
    subband.codeblockParameters = {
      codeblockWidth: xcb_,
      codeblockHeight: ycb_,
      numcodeblockwide: cbx1 - cbx0 + 1,
      numcodeblockhigh: cby1 - cby0 + 1
    };
    subband.codeblocks = codeblocks;
    subband.precincts = precincts;
  }
  function createPacket(resolution, precinctNumber, layerNumber) {
    var precinctCodeblocks = [];
    // Section B.10.8 Order of info in packet
    var subbands = resolution.subbands;
    // sub-bands already ordered in 'LL', 'HL', 'LH', and 'HH' sequence
    for (var i = 0, ii = subbands.length; i < ii; i++) {
      var subband = subbands[i];
      var codeblocks = subband.codeblocks;
      for (var j = 0, jj = codeblocks.length; j < jj; j++) {
        var codeblock = codeblocks[j];
        if (codeblock.precinctNumber !== precinctNumber) {
          continue;
        }
        precinctCodeblocks.push(codeblock);
      }
    }
    return {
      layerNumber: layerNumber,
      codeblocks: precinctCodeblocks
    };
  }
  function LayerResolutionComponentPositionIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var maxDecompositionLevelsCount = 0;
    for (var q = 0; q < componentsCount; q++) {
      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,
        tile.components[q].codingStyleParameters.decompositionLevelsCount);
    }

    var l = 0, r = 0, i = 0, k = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.1 Layer-resolution-component-position
      for (; l < layersCount; l++) {
        for (; r <= maxDecompositionLevelsCount; r++) {
          for (; i < componentsCount; i++) {
            var component = tile.components[i];
            if (r > component.codingStyleParameters.decompositionLevelsCount) {
              continue;
            }

            var resolution = component.resolutions[r];
            var numprecincts = resolution.precinctParameters.numprecincts;
            for (; k < numprecincts;) {
              var packet = createPacket(resolution, k, l);
              k++;
              return packet;
            }
            k = 0;
          }
          i = 0;
        }
        r = 0;
      }
      throw new Error('JPX Error: Out of packets');
    };
  }
  function ResolutionLayerComponentPositionIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var maxDecompositionLevelsCount = 0;
    for (var q = 0; q < componentsCount; q++) {
      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,
        tile.components[q].codingStyleParameters.decompositionLevelsCount);
    }

    var r = 0, l = 0, i = 0, k = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.2 Resolution-layer-component-position
      for (; r <= maxDecompositionLevelsCount; r++) {
        for (; l < layersCount; l++) {
          for (; i < componentsCount; i++) {
            var component = tile.components[i];
            if (r > component.codingStyleParameters.decompositionLevelsCount) {
              continue;
            }

            var resolution = component.resolutions[r];
            var numprecincts = resolution.precinctParameters.numprecincts;
            for (; k < numprecincts;) {
              var packet = createPacket(resolution, k, l);
              k++;
              return packet;
            }
            k = 0;
          }
          i = 0;
        }
        l = 0;
      }
      throw new Error('JPX Error: Out of packets');
    };
  }
  function ResolutionPositionComponentLayerIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var l, r, c, p;
    var maxDecompositionLevelsCount = 0;
    for (c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,
        component.codingStyleParameters.decompositionLevelsCount);
    }
    var maxNumPrecinctsInLevel = new Int32Array(
      maxDecompositionLevelsCount + 1);
    for (r = 0; r <= maxDecompositionLevelsCount; ++r) {
      var maxNumPrecincts = 0;
      for (c = 0; c < componentsCount; ++c) {
        var resolutions = tile.components[c].resolutions;
        if (r < resolutions.length) {
          maxNumPrecincts = Math.max(maxNumPrecincts,
            resolutions[r].precinctParameters.numprecincts);
        }
      }
      maxNumPrecinctsInLevel[r] = maxNumPrecincts;
    }
    l = 0;
    r = 0;
    c = 0;
    p = 0;
    
    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.3 Resolution-position-component-layer
      for (; r <= maxDecompositionLevelsCount; r++) {
        for (; p < maxNumPrecinctsInLevel[r]; p++) {
          for (; c < componentsCount; c++) {
            var component = tile.components[c];
            if (r > component.codingStyleParameters.decompositionLevelsCount) {
              continue;
            }
            var resolution = component.resolutions[r];
            var numprecincts = resolution.precinctParameters.numprecincts;
            if (p >= numprecincts) {
              continue;
            }
            for (; l < layersCount;) {
              var packet = createPacket(resolution, p, l);
              l++;
              return packet;
            }
            l = 0;
          }
          c = 0;
        }
        p = 0;
      }
      throw new Error('JPX Error: Out of packets');
    };
  }
  function PositionComponentResolutionLayerIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var precinctsSizes = getPrecinctSizesInImageScale(tile);
    var precinctsIterationSizes = precinctsSizes;
    var l = 0, r = 0, c = 0, px = 0, py = 0;

    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.4 Position-component-resolution-layer
      for (; py < precinctsIterationSizes.maxNumHigh; py++) {
        for (; px < precinctsIterationSizes.maxNumWide; px++) {
          for (; c < componentsCount; c++) {
            var component = tile.components[c];
            var decompositionLevelsCount =
              component.codingStyleParameters.decompositionLevelsCount;
            for (; r <= decompositionLevelsCount; r++) {
              var resolution = component.resolutions[r];
              var sizeInImageScale =
                precinctsSizes.components[c].resolutions[r];
              var k = getPrecinctIndexIfExist(
                px,
                py,
                sizeInImageScale,
                precinctsIterationSizes,
                resolution);
              if (k === null) {
                continue;
              }
              for (; l < layersCount;) {
                var packet = createPacket(resolution, k, l);
                l++;
                return packet;
              }
              l = 0;
            }
            r = 0;
          }
          c = 0;
        }
        px = 0;
      }
      throw new Error('JPX Error: Out of packets');
    };
  }
  function ComponentPositionResolutionLayerIterator(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var layersCount = tile.codingStyleDefaultParameters.layersCount;
    var componentsCount = siz.Csiz;
    var precinctsSizes = getPrecinctSizesInImageScale(tile);
    var l = 0, r = 0, c = 0, px = 0, py = 0;
    
    this.nextPacket = function JpxImage_nextPacket() {
      // Section B.12.1.5 Component-position-resolution-layer
      for (; c < componentsCount; ++c) {
        var component = tile.components[c];
        var precinctsIterationSizes = precinctsSizes.components[c];
        var decompositionLevelsCount =
          component.codingStyleParameters.decompositionLevelsCount;
        for (; py < precinctsIterationSizes.maxNumHigh; py++) {
          for (; px < precinctsIterationSizes.maxNumWide; px++) {
            for (; r <= decompositionLevelsCount; r++) {
              var resolution = component.resolutions[r];
              var sizeInImageScale = precinctsIterationSizes.resolutions[r];
              var k = getPrecinctIndexIfExist(
                px,
                py,
                sizeInImageScale,
                precinctsIterationSizes,
                resolution);
              if (k === null) {
                continue;
              }
              for (; l < layersCount;) {
                var packet = createPacket(resolution, k, l);
                l++;
                return packet;
              }
              l = 0;
            }
            r = 0;
          }
          px = 0;
        }
        py = 0;
      }
      throw new Error('JPX Error: Out of packets');
    };
  }
  function getPrecinctIndexIfExist(
    pxIndex, pyIndex, sizeInImageScale, precinctIterationSizes, resolution) {
    var posX = pxIndex * precinctIterationSizes.minWidth;
    var posY = pyIndex * precinctIterationSizes.minHeight;
    if (posX % sizeInImageScale.width !== 0 ||
        posY % sizeInImageScale.height !== 0) {
      return null;
    }
    var startPrecinctRowIndex =
      (posY / sizeInImageScale.width) *
      resolution.precinctParameters.numprecinctswide;
    return (posX / sizeInImageScale.height) + startPrecinctRowIndex;
  }
  function getPrecinctSizesInImageScale(tile) {
    var componentsCount = tile.components.length;
    var minWidth = Number.MAX_VALUE;
    var minHeight = Number.MAX_VALUE;
    var maxNumWide = 0;
    var maxNumHigh = 0;
    var sizePerComponent = new Array(componentsCount);
    for (var c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      var decompositionLevelsCount =
        component.codingStyleParameters.decompositionLevelsCount;
      var sizePerResolution = new Array(decompositionLevelsCount + 1);
      var minWidthCurrentComponent = Number.MAX_VALUE;
      var minHeightCurrentComponent = Number.MAX_VALUE;
      var maxNumWideCurrentComponent = 0;
      var maxNumHighCurrentComponent = 0;
      var scale = 1;
      for (var r = decompositionLevelsCount; r >= 0; --r) {
        var resolution = component.resolutions[r];
        var widthCurrentResolution =
          scale * resolution.precinctParameters.precinctWidth;
        var heightCurrentResolution =
          scale * resolution.precinctParameters.precinctHeight;
        minWidthCurrentComponent = Math.min(
          minWidthCurrentComponent,
          widthCurrentResolution);
        minHeightCurrentComponent = Math.min(
          minHeightCurrentComponent,
          heightCurrentResolution);
        maxNumWideCurrentComponent = Math.max(maxNumWideCurrentComponent,
          resolution.precinctParameters.numprecinctswide);
        maxNumHighCurrentComponent = Math.max(maxNumHighCurrentComponent,
          resolution.precinctParameters.numprecinctshigh);
        sizePerResolution[r] = {
          width: widthCurrentResolution,
          height: heightCurrentResolution
        };
        scale <<= 1;
      }
      minWidth = Math.min(minWidth, minWidthCurrentComponent);
      minHeight = Math.min(minHeight, minHeightCurrentComponent);
      maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);
      maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);
      sizePerComponent[c] = {
        resolutions: sizePerResolution,
        minWidth: minWidthCurrentComponent,
        minHeight: minHeightCurrentComponent,
        maxNumWide: maxNumWideCurrentComponent,
        maxNumHigh: maxNumHighCurrentComponent
      };
    }
    return {
      components: sizePerComponent,
      minWidth: minWidth,
      minHeight: minHeight,
      maxNumWide: maxNumWide,
      maxNumHigh: maxNumHigh
    };
  }
  function buildPackets(context) {
    var siz = context.SIZ;
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var componentsCount = siz.Csiz;
    // Creating resolutions and sub-bands for each component
    for (var c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      var decompositionLevelsCount =
        component.codingStyleParameters.decompositionLevelsCount;
      // Section B.5 Resolution levels and sub-bands
      var resolutions = [];
      var subbands = [];
      for (var r = 0; r <= decompositionLevelsCount; r++) {
        var blocksDimensions = getBlocksDimensions(context, component, r);
        var resolution = {};
        var scale = 1 << (decompositionLevelsCount - r);
        resolution.trx0 = Math.ceil(component.tcx0 / scale);
        resolution.try0 = Math.ceil(component.tcy0 / scale);
        resolution.trx1 = Math.ceil(component.tcx1 / scale);
        resolution.try1 = Math.ceil(component.tcy1 / scale);
        resolution.resLevel = r;
        buildPrecincts(context, resolution, blocksDimensions);
        resolutions.push(resolution);

        var subband;
        if (r === 0) {
          // one sub-band (LL) with last decomposition
          subband = {};
          subband.type = 'LL';
          subband.tbx0 = Math.ceil(component.tcx0 / scale);
          subband.tby0 = Math.ceil(component.tcy0 / scale);
          subband.tbx1 = Math.ceil(component.tcx1 / scale);
          subband.tby1 = Math.ceil(component.tcy1 / scale);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolution.subbands = [subband];
        } else {
          var bscale = 1 << (decompositionLevelsCount - r + 1);
          var resolutionSubbands = [];
          // three sub-bands (HL, LH and HH) with rest of decompositions
          subband = {};
          subband.type = 'HL';
          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
          subband.tby0 = Math.ceil(component.tcy0 / bscale);
          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
          subband.tby1 = Math.ceil(component.tcy1 / bscale);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolutionSubbands.push(subband);

          subband = {};
          subband.type = 'LH';
          subband.tbx0 = Math.ceil(component.tcx0 / bscale);
          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
          subband.tbx1 = Math.ceil(component.tcx1 / bscale);
          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolutionSubbands.push(subband);

          subband = {};
          subband.type = 'HH';
          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);
          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);
          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);
          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);
          subband.resolution = resolution;
          buildCodeblocks(context, subband, blocksDimensions);
          subbands.push(subband);
          resolutionSubbands.push(subband);

          resolution.subbands = resolutionSubbands;
        }
      }
      component.resolutions = resolutions;
      component.subbands = subbands;
    }
    // Generate the packets sequence
    var progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;
    switch (progressionOrder) {
      case 0:
        tile.packetsIterator =
          new LayerResolutionComponentPositionIterator(context);
        break;
      case 1:
        tile.packetsIterator =
          new ResolutionLayerComponentPositionIterator(context);
        break;
      case 2:
        tile.packetsIterator =
          new ResolutionPositionComponentLayerIterator(context);
        break;
      case 3:
        tile.packetsIterator =
          new PositionComponentResolutionLayerIterator(context);
        break;
      case 4:
        tile.packetsIterator =
          new ComponentPositionResolutionLayerIterator(context);
        break;
      default:
        throw new Error('JPX Error: Unsupported progression order ' +
                        progressionOrder);
    }
  }
  function parseTilePackets(context, data, offset, dataLength) {
    var position = 0;
    var buffer, bufferSize = 0, skipNextBit = false;
    function readBits(count) {
      while (bufferSize < count) {
        var b = data[offset + position];
        position++;
        if (skipNextBit) {
          buffer = (buffer << 7) | b;
          bufferSize += 7;
          skipNextBit = false;
        } else {
          buffer = (buffer << 8) | b;
          bufferSize += 8;
        }
        if (b === 0xFF) {
          skipNextBit = true;
        }
      }
      bufferSize -= count;
      return (buffer >>> bufferSize) & ((1 << count) - 1);
    }
    function skipMarkerIfEqual(value) {
      if (data[offset + position - 1] === 0xFF &&
          data[offset + position] === value) {
        skipBytes(1);
        return true;
      } else if (data[offset + position] === 0xFF &&
                 data[offset + position + 1] === value) {
        skipBytes(2);
        return true;
      }
      return false;
    }
    function skipBytes(count) {
      position += count;
    }
    function alignToByte() {
      bufferSize = 0;
      if (skipNextBit) {
        position++;
        skipNextBit = false;
      }
    }
    function readCodingpasses() {
      if (readBits(1) === 0) {
        return 1;
      }
      if (readBits(1) === 0) {
        return 2;
      }
      var value = readBits(2);
      if (value < 3) {
        return value + 3;
      }
      value = readBits(5);
      if (value < 31) {
        return value + 6;
      }
      value = readBits(7);
      return value + 37;
    }
    var tileIndex = context.currentTile.index;
    var tile = context.tiles[tileIndex];
    var sopMarkerUsed = context.COD.sopMarkerUsed;
    var ephMarkerUsed = context.COD.ephMarkerUsed;
    var packetsIterator = tile.packetsIterator;
    while (position < dataLength) {
      alignToByte();
      if (sopMarkerUsed && skipMarkerIfEqual(0x91)) {
        // Skip also marker segment length and packet sequence ID
        skipBytes(4);
      }
      var packet = packetsIterator.nextPacket();
      if (!readBits(1)) {
        continue;
      }
      var layerNumber = packet.layerNumber;
      var queue = [], codeblock;
      for (var i = 0, ii = packet.codeblocks.length; i < ii; i++) {
        codeblock = packet.codeblocks[i];
        var precinct = codeblock.precinct;
        var codeblockColumn = codeblock.cbx - precinct.cbxMin;
        var codeblockRow = codeblock.cby - precinct.cbyMin;
        var codeblockIncluded = false;
        var firstTimeInclusion = false;
        var valueReady;
        if (codeblock['included'] !== undefined) {
          codeblockIncluded = !!readBits(1);
        } else {
          // reading inclusion tree
          precinct = codeblock.precinct;
          var inclusionTree, zeroBitPlanesTree;
          if (precinct['inclusionTree'] !== undefined) {
            inclusionTree = precinct.inclusionTree;
          } else {
            // building inclusion and zero bit-planes trees
            var width = precinct.cbxMax - precinct.cbxMin + 1;
            var height = precinct.cbyMax - precinct.cbyMin + 1;
            inclusionTree = new InclusionTree(width, height, layerNumber);
            zeroBitPlanesTree = new TagTree(width, height);
            precinct.inclusionTree = inclusionTree;
            precinct.zeroBitPlanesTree = zeroBitPlanesTree;
          }

          if (inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber)) {
            while (true) {
              if (readBits(1)) {
                valueReady = !inclusionTree.nextLevel();
                if (valueReady) {
                  codeblock.included = true;
                  codeblockIncluded = firstTimeInclusion = true;
                  break;
                }
              } else {
                inclusionTree.incrementValue(layerNumber);
                break;
              }
            }
          }
        }
        if (!codeblockIncluded) {
          continue;
        }
        if (firstTimeInclusion) {
          zeroBitPlanesTree = precinct.zeroBitPlanesTree;
          zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);
          while (true) {
            if (readBits(1)) {
              valueReady = !zeroBitPlanesTree.nextLevel();
              if (valueReady) {
                break;
              }
            } else {
              zeroBitPlanesTree.incrementValue();
            }
          }
          codeblock.zeroBitPlanes = zeroBitPlanesTree.value;
        }
        var codingpasses = readCodingpasses();
        while (readBits(1)) {
          codeblock.Lblock++;
        }
        var codingpassesLog2 = log2(codingpasses);
        // rounding down log2
        var bits = ((codingpasses < (1 << codingpassesLog2)) ?
          codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;
        var codedDataLength = readBits(bits);
        queue.push({
          codeblock: codeblock,
          codingpasses: codingpasses,
          dataLength: codedDataLength
        });
      }
      alignToByte();
      if (ephMarkerUsed) {
        skipMarkerIfEqual(0x92);
      }
      while (queue.length > 0) {
        var packetItem = queue.shift();
        codeblock = packetItem.codeblock;
        if (codeblock['data'] === undefined) {
          codeblock.data = [];
        }
        codeblock.data.push({
          data: data,
          start: offset + position,
          end: offset + position + packetItem.dataLength,
          codingpasses: packetItem.codingpasses
        });
        position += packetItem.dataLength;
      }
    }
    return position;
  }
  function copyCoefficients(coefficients, targetArrayWidth, targetArrayHeight,
                            subband,delta, mb, reversible,
                            segmentationSymbolUsed, regionInLevel) {
    var x0 = subband.tbx0;
    var y0 = subband.tby0;
    var codeblocks = subband.codeblocks;
    var right = subband.type.charAt(0) === 'H' ? 1 : 0;
    var bottom = subband.type.charAt(1) === 'H' ? targetArrayWidth : 0;
    var resolution = subband.resolution;
    var interleave = (subband.type !== 'LL');
    var regionInSubband;
    if (!interleave) {
      regionInSubband = regionInLevel;
    } else {
      regionInSubband = {
        x0: (regionInLevel.x0 - resolution.trx0) / 2 + subband.tbx0,
        y0: (regionInLevel.y0 - resolution.try0) / 2 + subband.tby0,
        x1: (regionInLevel.x1 - resolution.trx0) / 2 + subband.tbx0,
        y1: (regionInLevel.y1 - resolution.try0) / 2 + subband.tby0
      };
    }
    var targetArrayStep = interleave ? 2 : 1;

    for (var i = 0, ii = codeblocks.length; i < ii; ++i) {
      var codeblock = codeblocks[i];
      var blockWidth = codeblock.tbx1_ - codeblock.tbx0_;
      var blockHeight = codeblock.tby1_ - codeblock.tby0_;
      if (blockWidth === 0 || blockHeight === 0) {
        continue;
      }
      if (codeblock['data'] === undefined) {
        continue;
      }
      
      var regionInCodeblock = {
        x0: Math.max(codeblock.tbx0_, regionInSubband.x0),
        y0: Math.max(codeblock.tby0_, regionInSubband.y0),
        x1: Math.min(codeblock.tbx1_, regionInSubband.x1),
        y1: Math.min(codeblock.tby1_, regionInSubband.y1)
      };
      if (regionInCodeblock.x0 >= regionInCodeblock.x1 ||
          regionInCodeblock.y0 >= regionInCodeblock.y1) {
        continue;
      }

      var bitModel, currentCodingpassType;
      bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType,
                              codeblock.zeroBitPlanes, mb);
      currentCodingpassType = 2; // first bit plane starts from cleanup

      // collect data
      var data = codeblock.data, totalLength = 0, codingpasses = 0;
      var j, jj, dataItem;
      for (j = 0, jj = data.length; j < jj; j++) {
        dataItem = data[j];
        totalLength += dataItem.end - dataItem.start;
        codingpasses += dataItem.codingpasses;
      }
      var encodedData = new Uint8Array(totalLength);
      var position = 0;
      for (j = 0, jj = data.length; j < jj; j++) {
        dataItem = data[j];
        var chunk = dataItem.data.subarray(dataItem.start, dataItem.end);
        encodedData.set(chunk, position);
        position += chunk.length;
      }
      // decoding the item
      var decoder = new ArithmeticDecoder(encodedData, 0, totalLength);
      bitModel.setDecoder(decoder);

      for (j = 0; j < codingpasses; j++) {
        switch (currentCodingpassType) {
          case 0:
            bitModel.runSignificancePropogationPass();
            break;
          case 1:
            bitModel.runMagnitudeRefinementPass();
            break;
          case 2:
            bitModel.runCleanupPass();
            if (segmentationSymbolUsed) {
              bitModel.checkSegmentationSymbol();
            }
            break;
        }
        currentCodingpassType = (currentCodingpassType + 1) % 3;
      }

      var sign = bitModel.coefficentsSign;
      var magnitude = bitModel.coefficentsMagnitude;
      var bitsDecoded = bitModel.bitsDecoded;
      var magnitudeCorrection = reversible ? 0 : 0.5;
      var k, n, nb;
      var regionInCodeblockWidth = regionInCodeblock.x1 - regionInCodeblock.x0;
      // Do the interleaving of Section F.3.3 here, so we do not need
      // to copy later. LL level is not interleaved, just copied.
      for (var row = regionInCodeblock.y0; row < regionInCodeblock.y1; ++row) {
        var codeblockOffset =
          (regionInCodeblock.x0 - codeblock.tbx0_) +
          (row - codeblock.tby0_) * blockWidth;
        var targetOffset =
          (regionInCodeblock.x0 - regionInSubband.x0) * targetArrayStep +
          (row - regionInSubband.y0) * targetArrayWidth * targetArrayStep +
          right + bottom;
          
        for (k = regionInCodeblock.x0; k < regionInCodeblock.x1; k++) {
          n = magnitude[codeblockOffset];
          if (n !== 0) {
            n = (n + magnitudeCorrection) * delta;
            if (sign[codeblockOffset] !== 0) {
              n = -n;
            }
            nb = bitsDecoded[codeblockOffset];
            if (reversible && (nb >= mb)) {
              coefficients[targetOffset] = n;
            } else {
              coefficients[targetOffset] = n * (1 << (mb - nb));
            }
          }
          targetOffset += targetArrayStep;
          ++codeblockOffset;
        }
      }
    }
  }
  function transformTile(context, tile, c) {
    var component = tile.components[c];
    var codingStyleParameters = component.codingStyleParameters;
    var quantizationParameters = component.quantizationParameters;
    var decompositionLevelsCount =
      codingStyleParameters.decompositionLevelsCount;
    var spqcds = quantizationParameters.SPqcds;
    var scalarExpounded = quantizationParameters.scalarExpounded;
    var guardBits = quantizationParameters.guardBits;
    var segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;
    var precision = context.components[c].precision;
    var relativeRegionInTile;
    if (context.regionToParse !== undefined) {
      var x1 = Math.min(component.tcx1, context.regionToParse.right);
      var y1 = Math.min(component.tcy1, context.regionToParse.bottom);
      relativeRegionInTile = {
        x0: Math.max(0, context.regionToParse.left - component.tcx0),
        y0: Math.max(0, context.regionToParse.top - component.tcy0),
        x1: x1 - component.tcx0,
        y1: y1 - component.tcy0
      };
    }

    var reversible = codingStyleParameters.reversibleTransformation;
    var transform = (reversible ? new ReversibleTransform() :
                                  new IrreversibleTransform());

    var subbandCoefficients = [];
    var b = 0;
    for (var i = 0; i <= decompositionLevelsCount; i++) {
      var resolution = component.resolutions[i];

      var width = resolution.trx1 - resolution.trx0;
      var height = resolution.try1 - resolution.try0;
      
      var regionInLevel, arrayWidth, arrayHeight;
      if (relativeRegionInTile === undefined) {
        arrayWidth = width;
        arrayHeight = height;
        regionInLevel = {
          x0: resolution.trx0,
          y0: resolution.try0,
          x1: resolution.trx1,
          y1: resolution.try1
        };
      } else {
        var scale = 1 << (decompositionLevelsCount - i);
        var redundantCoeffs = 4;
        regionInLevel = {
          x0: Math.ceil(relativeRegionInTile.x0 / scale) - redundantCoeffs,
          y0: Math.ceil(relativeRegionInTile.y0 / scale) - redundantCoeffs,
          x1: Math.ceil(relativeRegionInTile.x1 / scale) + redundantCoeffs,
          y1: Math.ceil(relativeRegionInTile.y1 / scale) + redundantCoeffs
        };
        regionInLevel.x0 = 2 * Math.floor(regionInLevel.x0 / 2) +
          resolution.trx0;
        regionInLevel.y0 = 2 * Math.floor(regionInLevel.y0 / 2) +
          resolution.try0;
        regionInLevel.x1 = 2 * Math.floor(regionInLevel.x1 / 2) +
          resolution.trx0;
        regionInLevel.y1 = 2 * Math.floor(regionInLevel.y1 / 2) +
          resolution.try0;
        
        regionInLevel.x0 = Math.max(regionInLevel.x0, resolution.trx0);
        regionInLevel.y0 = Math.max(regionInLevel.y0, resolution.try0);
        regionInLevel.x1 = Math.min(regionInLevel.x1, resolution.trx1);
        regionInLevel.y1 = Math.min(regionInLevel.y1, resolution.try1);
        
        arrayWidth = regionInLevel.x1 - regionInLevel.x0;
        arrayHeight = regionInLevel.y1 - regionInLevel.y0;
      }
      
      // Allocate space for the whole sublevel.
      var coefficients = new Float32Array(arrayWidth * arrayHeight);

      for (var j = 0, jj = resolution.subbands.length; j < jj; j++) {
        var mu, epsilon;
        if (!scalarExpounded) {
          // formula E-5
          mu = spqcds[0].mu;
          epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);
        } else {
          mu = spqcds[b].mu;
          epsilon = spqcds[b].epsilon;
          b++;
        }

        var subband = resolution.subbands[j];
        var gainLog2 = SubbandsGainLog2[subband.type];

        // calulate quantization coefficient (Section E.1.1.1)
        var delta = (reversible ? 1 :
          Math.pow(2, precision + gainLog2 - epsilon) * (1 + mu / 2048));
        var mb = (guardBits + epsilon - 1);

        // In the first resolution level, copyCoefficients will fill the
        // whole array with coefficients. In the succeding passes,
        // copyCoefficients will consecutively fill in the values that belong
        // to the interleaved positions of the HL, LH, and HH coefficients.
        // The LL coefficients will then be interleaved in Transform.iterate().
        copyCoefficients(coefficients, arrayWidth, arrayHeight, subband, delta,
                         mb, reversible, segmentationSymbolUsed,
                         regionInLevel);
      }
      
      var relativeRegionInLevel = {
        x0: regionInLevel.x0 - resolution.trx0,
        y0: regionInLevel.y0 - resolution.try0,
        x1: regionInLevel.x1 - resolution.trx0,
        y1: regionInLevel.y1 - resolution.try0
      };
      subbandCoefficients.push({
        items: coefficients,
        relativeRegionInLevel: relativeRegionInLevel
      });
    }

    var result = transform.calculate(subbandCoefficients,
                                     component.tcx0, component.tcy0);
    var transformedRegion = result.relativeRegionInLevel;
    var transformedWidth = transformedRegion.x1 - transformedRegion.x0;
    
    var needCropTile = false;
    if (context.regionToParse !== undefined) {
      needCropTile =
        relativeRegionInTile.x0 !== transformedRegion.x0 ||
        relativeRegionInTile.y0 !== transformedRegion.y0 ||
        relativeRegionInTile.x1 !== transformedRegion.x1 ||
        relativeRegionInTile.y1 !== transformedRegion.y1;
    }
    if (!needCropTile) {
      var transformedHeight = transformedRegion.y1 - transformedRegion.y0;
      return {
        left: component.tcx0,
        top: component.tcy0,
        width: transformedWidth,
        height: transformedHeight,
        items: result.items
      };
    }
    
    // Crop the 4 redundant pixels used for the DWT
    
    var width = relativeRegionInTile.x1 - relativeRegionInTile.x0;
    var height = relativeRegionInTile.y1 - relativeRegionInTile.y0;
    
    var itemsWithRedundantPixels = result.items;
    var items = new Float32Array(width * height);
    
    var redundantRowsTop =
      relativeRegionInTile.y0 - transformedRegion.y0;
    var redundantColumnsLeft =
      relativeRegionInTile.x0 - transformedRegion.x0;
      
    var targetOffset = 0;
    var sourceOffset =
      redundantColumnsLeft + transformedWidth * redundantRowsTop;
    for (var i = 0; i < height; ++i) {
      var sourceEnd = sourceOffset + width;
      
      items.set(
        itemsWithRedundantPixels.subarray(sourceOffset, sourceEnd),
        targetOffset);
      
      sourceOffset += transformedWidth;
      targetOffset += width;
    }
    
    return {
      left: component.tcx0 + relativeRegionInTile.x0,
      top: component.tcy0 + relativeRegionInTile.y0,
      width: width,
      height: height,
      items: items
    };
  }
  function transformComponents(context) {
    var siz = context.SIZ;
    var components = context.components;
    var componentsCount = siz.Csiz;
    var resultImages = [];
    for (var i = 0, ii = context.tiles.length; i < ii; i++) {
      var tile = context.tiles[i];
      
      if (context.regionToParse !== undefined) {
        if (context.regionToParse.left >= tile.tx1 ||
            context.regionToParse.top >= tile.ty1 ||
            context.regionToParse.right <= tile.tx0 ||
            context.regionToParse.bottom <= tile.ty0) {
          continue;
        }
      }
      
      var transformedTiles = [];
      var c;
      for (c = 0; c < componentsCount; c++) {
        transformedTiles[c] = transformTile(context, tile, c);
      }
      var tile0 = transformedTiles[0];
      var out = new Uint8Array(tile0.items.length * componentsCount);
      var result = {
        left: tile0.left,
        top: tile0.top,
        width: tile0.width,
        height: tile0.height,
        items: out
      };

      // Section G.2.2 Inverse multi component transform
      var shift, offset, max, min, maxK;
      var pos = 0, j, jj, y0, y1, y2, r, g, b, k, val;
      if (tile.codingStyleDefaultParameters.multipleComponentTransform) {
        var fourComponents = componentsCount === 4;
        var y0items = transformedTiles[0].items;
        var y1items = transformedTiles[1].items;
        var y2items = transformedTiles[2].items;
        var y3items = fourComponents ? transformedTiles[3].items : null;

        // HACK: The multiple component transform formulas below assume that
        // all components have the same precision. With this in mind, we
        // compute shift and offset only once.
        shift = components[0].precision - 8;
        offset = (128 << shift) + 0.5;
        max = 255 * (1 << shift);
        maxK = max * 0.5;
        min = -maxK;

        var component0 = tile.components[0];
        var alpha01 = componentsCount - 3;
        jj = y0items.length;
        if (!component0.codingStyleParameters.reversibleTransformation) {
          // inverse irreversible multiple component transform
          for (j = 0; j < jj; j++, pos += alpha01) {
            y0 = y0items[j] + offset;
            y1 = y1items[j];
            y2 = y2items[j];
            r = y0 + 1.402 * y2;
            g = y0 - 0.34413 * y1 - 0.71414 * y2;
            b = y0 + 1.772 * y1;
            out[pos++] = r <= 0 ? 0 : r >= max ? 255 : r >> shift;
            out[pos++] = g <= 0 ? 0 : g >= max ? 255 : g >> shift;
            out[pos++] = b <= 0 ? 0 : b >= max ? 255 : b >> shift;
          }
        } else {
          // inverse reversible multiple component transform
          for (j = 0; j < jj; j++, pos += alpha01) {
            y0 = y0items[j] + offset;
            y1 = y1items[j];
            y2 = y2items[j];
            g = y0 - ((y2 + y1) >> 2);
            r = g + y2;
            b = g + y1;
            out[pos++] = r <= 0 ? 0 : r >= max ? 255 : r >> shift;
            out[pos++] = g <= 0 ? 0 : g >= max ? 255 : g >> shift;
            out[pos++] = b <= 0 ? 0 : b >= max ? 255 : b >> shift;
          }
        }
        if (fourComponents) {
          for (j = 0, pos = 3; j < jj; j++, pos += 4) {
            k = y3items[j];
            out[pos] = k <= min ? 0 : k >= maxK ? 255 : (k + offset) >> shift;
          }
        }
      } else { // no multi-component transform
        for (c = 0; c < componentsCount; c++) {
          var items = transformedTiles[c].items;
          shift = components[c].precision - 8;
          offset = (128 << shift) + 0.5;
          max = (127.5 * (1 << shift));
          min = -max;
          for (pos = c, j = 0, jj = items.length; j < jj; j++) {
            val = items[j];
            out[pos] = val <= min ? 0 :
                       val >= max ? 255 : (val + offset) >> shift;
            pos += componentsCount;
          }
        }
      }
      resultImages.push(result);
    }
    return resultImages;
  }
  function initializeTile(context, tileIndex) {
    var siz = context.SIZ;
    var componentsCount = siz.Csiz;
    var tile = context.tiles[tileIndex];
    for (var c = 0; c < componentsCount; c++) {
      var component = tile.components[c];
      var qcdOrQcc = (context.currentTile.QCC[c] !== undefined ?
        context.currentTile.QCC[c] : context.currentTile.QCD);
      component.quantizationParameters = qcdOrQcc;
      var codOrCoc = (context.currentTile.COC[c] !== undefined  ?
        context.currentTile.COC[c] : context.currentTile.COD);
      component.codingStyleParameters = codOrCoc;
    }
    tile.codingStyleDefaultParameters = context.currentTile.COD;
  }

  // Section B.10.2 Tag trees
  var TagTree = (function TagTreeClosure() {
    function TagTree(width, height) {
      var levelsLength = log2(Math.max(width, height)) + 1;
      this.levels = [];
      for (var i = 0; i < levelsLength; i++) {
        var level = {
          width: width,
          height: height,
          items: []
        };
        this.levels.push(level);
        width = Math.ceil(width / 2);
        height = Math.ceil(height / 2);
      }
    }
    TagTree.prototype = {
      reset: function TagTree_reset(i, j) {
        var currentLevel = 0, value = 0, level;
        while (currentLevel < this.levels.length) {
          level = this.levels[currentLevel];
          var index = i + j * level.width;
          if (level.items[index] !== undefined) {
            value = level.items[index];
            break;
          }
          level.index = index;
          i >>= 1;
          j >>= 1;
          currentLevel++;
        }
        currentLevel--;
        level = this.levels[currentLevel];
        level.items[level.index] = value;
        this.currentLevel = currentLevel;
        delete this.value;
      },
      incrementValue: function TagTree_incrementValue() {
        var level = this.levels[this.currentLevel];
        level.items[level.index]++;
      },
      nextLevel: function TagTree_nextLevel() {
        var currentLevel = this.currentLevel;
        var level = this.levels[currentLevel];
        var value = level.items[level.index];
        currentLevel--;
        if (currentLevel < 0) {
          this.value = value;
          return false;
        }

        this.currentLevel = currentLevel;
        level = this.levels[currentLevel];
        level.items[level.index] = value;
        return true;
      }
    };
    return TagTree;
  })();

  var InclusionTree = (function InclusionTreeClosure() {
    function InclusionTree(width, height,  defaultValue) {
      var levelsLength = log2(Math.max(width, height)) + 1;
      this.levels = [];
      for (var i = 0; i < levelsLength; i++) {
        var items = new Uint8Array(width * height);
        for (var j = 0, jj = items.length; j < jj; j++) {
          items[j] = defaultValue;
        }

        var level = {
          width: width,
          height: height,
          items: items
        };
        this.levels.push(level);

        width = Math.ceil(width / 2);
        height = Math.ceil(height / 2);
      }
    }
    InclusionTree.prototype = {
      reset: function InclusionTree_reset(i, j, stopValue) {
        var currentLevel = 0;
        while (currentLevel < this.levels.length) {
          var level = this.levels[currentLevel];
          var index = i + j * level.width;
          level.index = index;
          var value = level.items[index];

          if (value === 0xFF) {
            break;
          }

          if (value > stopValue) {
            this.currentLevel = currentLevel;
            // already know about this one, propagating the value to top levels
            this.propagateValues();
            return false;
          }

          i >>= 1;
          j >>= 1;
          currentLevel++;
        }
        this.currentLevel = currentLevel - 1;
        return true;
      },
      incrementValue: function InclusionTree_incrementValue(stopValue) {
        var level = this.levels[this.currentLevel];
        level.items[level.index] = stopValue + 1;
        this.propagateValues();
      },
      propagateValues: function InclusionTree_propagateValues() {
        var levelIndex = this.currentLevel;
        var level = this.levels[levelIndex];
        var currentValue = level.items[level.index];
        while (--levelIndex >= 0) {
          level = this.levels[levelIndex];
          level.items[level.index] = currentValue;
        }
      },
      nextLevel: function InclusionTree_nextLevel() {
        var currentLevel = this.currentLevel;
        var level = this.levels[currentLevel];
        var value = level.items[level.index];
        level.items[level.index] = 0xFF;
        currentLevel--;
        if (currentLevel < 0) {
          return false;
        }

        this.currentLevel = currentLevel;
        level = this.levels[currentLevel];
        level.items[level.index] = value;
        return true;
      }
    };
    return InclusionTree;
  })();

  // Section D. Coefficient bit modeling
  var BitModel = (function BitModelClosure() {
    var UNIFORM_CONTEXT = 17;
    var RUNLENGTH_CONTEXT = 18;
    // Table D-1
    // The index is binary presentation: 0dddvvhh, ddd - sum of Di (0..4),
    // vv - sum of Vi (0..2), and hh - sum of Hi (0..2)
    var LLAndLHContextsLabel = new Uint8Array([
      0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4,
      7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6,
      8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8
    ]);
    var HLContextLabel = new Uint8Array([
      0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8,
      8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3,
      4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8
    ]);
    var HHContextLabel = new Uint8Array([
      0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5,
      5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8,
      8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8
    ]);

    function BitModel(width, height, subband, zeroBitPlanes, mb) {
      this.width = width;
      this.height = height;

      this.contextLabelTable = (subband === 'HH' ? HHContextLabel :
        (subband === 'HL' ? HLContextLabel : LLAndLHContextsLabel));

      var coefficientCount = width * height;

      // coefficients outside the encoding region treated as insignificant
      // add border state cells for significanceState
      this.neighborsSignificance = new Uint8Array(coefficientCount);
      this.coefficentsSign = new Uint8Array(coefficientCount);
      this.coefficentsMagnitude = mb > 14 ? new Uint32Array(coefficientCount) :
                                  mb > 6 ? new Uint16Array(coefficientCount) :
                                  new Uint8Array(coefficientCount);
      this.processingFlags = new Uint8Array(coefficientCount);

      var bitsDecoded = new Uint8Array(coefficientCount);
      if (zeroBitPlanes !== 0) {
        for (var i = 0; i < coefficientCount; i++) {
          bitsDecoded[i] = zeroBitPlanes;
        }
      }
      this.bitsDecoded = bitsDecoded;

      this.reset();
    }

    BitModel.prototype = {
      setDecoder: function BitModel_setDecoder(decoder) {
        this.decoder = decoder;
      },
      reset: function BitModel_reset() {
        // We have 17 contexts that are accessed via context labels,
        // plus the uniform and runlength context.
        this.contexts = new Int8Array(19);

        // Contexts are packed into 1 byte:
        // highest 7 bits carry the index, lowest bit carries mps
        this.contexts[0] = (4 << 1) | 0;
        this.contexts[UNIFORM_CONTEXT] = (46 << 1) | 0;
        this.contexts[RUNLENGTH_CONTEXT] = (3 << 1) | 0;
      },
      setNeighborsSignificance:
        function BitModel_setNeighborsSignificance(row, column, index) {
        var neighborsSignificance = this.neighborsSignificance;
        var width = this.width, height = this.height;
        var left = (column > 0);
        var right = (column + 1 < width);
        var i;

        if (row > 0) {
          i = index - width;
          if (left) {
            neighborsSignificance[i - 1] += 0x10;
          }
          if (right) {
            neighborsSignificance[i + 1] += 0x10;
          }
          neighborsSignificance[i] += 0x04;
        }

        if (row + 1 < height) {
          i = index + width;
          if (left) {
            neighborsSignificance[i - 1] += 0x10;
          }
          if (right) {
            neighborsSignificance[i + 1] += 0x10;
          }
          neighborsSignificance[i] += 0x04;
        }

        if (left) {
          neighborsSignificance[index - 1] += 0x01;
        }
        if (right) {
          neighborsSignificance[index + 1] += 0x01;
        }
        neighborsSignificance[index] |= 0x80;
      },
      runSignificancePropogationPass:
        function BitModel_runSignificancePropogationPass() {
        var decoder = this.decoder;
        var width = this.width, height = this.height;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var coefficentsSign = this.coefficentsSign;
        var neighborsSignificance = this.neighborsSignificance;
        var processingFlags = this.processingFlags;
        var contexts = this.contexts;
        var labels = this.contextLabelTable;
        var bitsDecoded = this.bitsDecoded;
        var processedInverseMask = ~1;
        var processedMask = 1;
        var firstMagnitudeBitMask = 2;

        for (var i0 = 0; i0 < height; i0 += 4) {
          for (var j = 0; j < width; j++) {
            var index = i0 * width + j;
            for (var i1 = 0; i1 < 4; i1++, index += width) {
              var i = i0 + i1;
              if (i >= height) {
                break;
              }
              // clear processed flag first
              processingFlags[index] &= processedInverseMask;

              if (coefficentsMagnitude[index] ||
                  !neighborsSignificance[index]) {
                continue;
              }

              var contextLabel = labels[neighborsSignificance[index]];
              var decision = decoder.readBit(contexts, contextLabel);
              if (decision) {
                var sign = this.decodeSignBit(i, j, index);
                coefficentsSign[index] = sign;
                coefficentsMagnitude[index] = 1;
                this.setNeighborsSignificance(i, j, index);
                processingFlags[index] |= firstMagnitudeBitMask;
              }
              bitsDecoded[index]++;
              processingFlags[index] |= processedMask;
            }
          }
        }
      },
      decodeSignBit: function BitModel_decodeSignBit(row, column, index) {
        var width = this.width, height = this.height;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var coefficentsSign = this.coefficentsSign;
        var contribution, sign0, sign1, significance1;
        var contextLabel, decoded;

        // calculate horizontal contribution
        significance1 = (column > 0 && coefficentsMagnitude[index - 1] !== 0);
        if (column + 1 < width && coefficentsMagnitude[index + 1] !== 0) {
          sign1 = coefficentsSign[index + 1];
          if (significance1) {
            sign0 = coefficentsSign[index - 1];
            contribution = 1 - sign1 - sign0;
          } else {
            contribution = 1 - sign1 - sign1;
          }
        } else if (significance1) {
          sign0 = coefficentsSign[index - 1];
          contribution = 1 - sign0 - sign0;
        } else {
          contribution = 0;
        }
        var horizontalContribution = 3 * contribution;

        // calculate vertical contribution and combine with the horizontal
        significance1 = (row > 0 && coefficentsMagnitude[index - width] !== 0);
        if (row + 1 < height && coefficentsMagnitude[index + width] !== 0) {
          sign1 = coefficentsSign[index + width];
          if (significance1) {
            sign0 = coefficentsSign[index - width];
            contribution = 1 - sign1 - sign0 + horizontalContribution;
          } else {
            contribution = 1 - sign1 - sign1 + horizontalContribution;
          }
        } else if (significance1) {
          sign0 = coefficentsSign[index - width];
          contribution = 1 - sign0 - sign0 + horizontalContribution;
        } else {
          contribution = horizontalContribution;
        }

        if (contribution >= 0) {
          contextLabel = 9 + contribution;
          decoded = this.decoder.readBit(this.contexts, contextLabel);
        } else {
          contextLabel = 9 - contribution;
          decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1;
        }
        return decoded;
      },
      runMagnitudeRefinementPass:
        function BitModel_runMagnitudeRefinementPass() {
        var decoder = this.decoder;
        var width = this.width, height = this.height;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var neighborsSignificance = this.neighborsSignificance;
        var contexts = this.contexts;
        var bitsDecoded = this.bitsDecoded;
        var processingFlags = this.processingFlags;
        var processedMask = 1;
        var firstMagnitudeBitMask = 2;
        var length = width * height;
        var width4 = width * 4;

        for (var index0 = 0, indexNext; index0 < length; index0 = indexNext) {
          indexNext = Math.min(length, index0 + width4);
          for (var j = 0; j < width; j++) {
            for (var index = index0 + j; index < indexNext; index += width) {

              // significant but not those that have just become
              if (!coefficentsMagnitude[index] ||
                (processingFlags[index] & processedMask) !== 0) {
                continue;
              }

              var contextLabel = 16;
              if ((processingFlags[index] & firstMagnitudeBitMask) !== 0) {
                processingFlags[index] ^= firstMagnitudeBitMask;
                // first refinement
               var significance = neighborsSignificance[index] & 127;
               contextLabel = significance === 0 ? 15 : 14;
              }

              var bit = decoder.readBit(contexts, contextLabel);
              coefficentsMagnitude[index] =
                (coefficentsMagnitude[index] << 1) | bit;
              bitsDecoded[index]++;
              processingFlags[index] |= processedMask;
            }
          }
        }
      },
      runCleanupPass: function BitModel_runCleanupPass() {
        var decoder = this.decoder;
        var width = this.width, height = this.height;
        var neighborsSignificance = this.neighborsSignificance;
        var coefficentsMagnitude = this.coefficentsMagnitude;
        var coefficentsSign = this.coefficentsSign;
        var contexts = this.contexts;
        var labels = this.contextLabelTable;
        var bitsDecoded = this.bitsDecoded;
        var processingFlags = this.processingFlags;
        var processedMask = 1;
        var firstMagnitudeBitMask = 2;
        var oneRowDown = width;
        var twoRowsDown = width * 2;
        var threeRowsDown = width * 3;
        var iNext;
        for (var i0 = 0; i0 < height; i0 = iNext) {
          iNext = Math.min(i0 + 4, height);
          var indexBase = i0 * width;
          var checkAllEmpty = i0 + 3 < height;
          for (var j = 0; j < width; j++) {
            var index0 = indexBase + j;
            // using the property: labels[neighborsSignificance[index]] === 0
            // when neighborsSignificance[index] === 0
            var allEmpty = (checkAllEmpty &&
              processingFlags[index0] === 0 &&
              processingFlags[index0 + oneRowDown] === 0 &&
              processingFlags[index0 + twoRowsDown] === 0 &&
              processingFlags[index0 + threeRowsDown] === 0 &&
              neighborsSignificance[index0] === 0 &&
              neighborsSignificance[index0 + oneRowDown] === 0 &&
              neighborsSignificance[index0 + twoRowsDown] === 0 &&
              neighborsSignificance[index0 + threeRowsDown] === 0);
            var i1 = 0, index = index0;
            var i = i0, sign;
            if (allEmpty) {
              var hasSignificantCoefficent =
                decoder.readBit(contexts, RUNLENGTH_CONTEXT);
              if (!hasSignificantCoefficent) {
                bitsDecoded[index0]++;
                bitsDecoded[index0 + oneRowDown]++;
                bitsDecoded[index0 + twoRowsDown]++;
                bitsDecoded[index0 + threeRowsDown]++;
                continue; // next column
              }
              i1 = (decoder.readBit(contexts, UNIFORM_CONTEXT) << 1) |
                    decoder.readBit(contexts, UNIFORM_CONTEXT);
              if (i1 !== 0) {
                i = i0 + i1;
                index += i1 * width;
              }

              sign = this.decodeSignBit(i, j, index);
              coefficentsSign[index] = sign;
              coefficentsMagnitude[index] = 1;
              this.setNeighborsSignificance(i, j, index);
              processingFlags[index] |= firstMagnitudeBitMask;

              index = index0;
              for (var i2 = i0; i2 <= i; i2++, index += width) {
                bitsDecoded[index]++;
              }

              i1++;
            }
            for (i = i0 + i1; i < iNext; i++, index += width) {
              if (coefficentsMagnitude[index] ||
                (processingFlags[index] & processedMask) !== 0) {
                continue;
              }

              var contextLabel = labels[neighborsSignificance[index]];
              var decision = decoder.readBit(contexts, contextLabel);
              if (decision === 1) {
                sign = this.decodeSignBit(i, j, index);
                coefficentsSign[index] = sign;
                coefficentsMagnitude[index] = 1;
                this.setNeighborsSignificance(i, j, index);
                processingFlags[index] |= firstMagnitudeBitMask;
              }
              bitsDecoded[index]++;
            }
          }
        }
      },
      checkSegmentationSymbol: function BitModel_checkSegmentationSymbol() {
        var decoder = this.decoder;
        var contexts = this.contexts;
        var symbol = (decoder.readBit(contexts, UNIFORM_CONTEXT) << 3) |
                     (decoder.readBit(contexts, UNIFORM_CONTEXT) << 2) |
                     (decoder.readBit(contexts, UNIFORM_CONTEXT) << 1) |
                      decoder.readBit(contexts, UNIFORM_CONTEXT);
        if (symbol !== 0xA) {
          throw new Error('JPX Error: Invalid segmentation symbol');
        }
      }
    };

    return BitModel;
  })();

  // Section F, Discrete wavelet transformation
  var Transform = (function TransformClosure() {
    function Transform() {}

    Transform.prototype.calculate =
      function transformCalculate(subbands, u0, v0) {
      var ll = subbands[0];
      for (var i = 1, ii = subbands.length; i < ii; i++) {
        ll = this.iterate(ll, subbands[i], u0, v0);
      }
      return ll;
    };
    Transform.prototype.extend = function extend(buffer, offset, size) {
      // Section F.3.7 extending... using max extension of 4
      var i1 = offset - 1, j1 = offset + 1;
      var i2 = offset + size - 2, j2 = offset + size;
      buffer[i1--] = buffer[j1++];
      buffer[j2++] = buffer[i2--];
      buffer[i1--] = buffer[j1++];
      buffer[j2++] = buffer[i2--];
      buffer[i1--] = buffer[j1++];
      buffer[j2++] = buffer[i2--];
      buffer[i1] = buffer[j1];
      buffer[j2] = buffer[i2];
    };
    Transform.prototype.iterate = function Transform_iterate(ll, hl_lh_hh,
                                                             u0, v0) {
      var levelRegion = hl_lh_hh.relativeRegionInLevel;
      if (ll.relativeRegionInLevel.x0 * 2 > levelRegion.x0 ||
          ll.relativeRegionInLevel.y0 * 2 > levelRegion.y0 ||
          ll.relativeRegionInLevel.x1 * 2 < levelRegion.x1 ||
          ll.relativeRegionInLevel.y1 * 2 < levelRegion.y1) {
        throw new Error('JPX Error: region in LL is smaller than region in ' +
          'higher resolution level');
      }
      if (levelRegion.x0 % 2 !== 0 || levelRegion.y0 % 2 !== 0) {
        throw new Error('JPX Error: region in HL/LH/HH subbands begins in ' +
          'odd coefficients');
      }
      var llItems = ll.items;
      var width = levelRegion.x1 - levelRegion.x0;
      var height = levelRegion.y1 - levelRegion.y0;
      var llWidth = ll.relativeRegionInLevel.x1 - ll.relativeRegionInLevel.x0;
      var llOffsetX = levelRegion.x0 / 2 - ll.relativeRegionInLevel.x0;
      var llOffsetY = levelRegion.y0 / 2 - ll.relativeRegionInLevel.y0;
      var llOffset = llOffsetX + llOffsetY * llWidth;
      var items = hl_lh_hh.items;
      var i, j, k, l, u, v;

      // Interleave LL according to Section F.3.3
      for (i = 0; i < height; i += 2) {
        l = i * width;
        k = llOffset + (llWidth * i / 2);
        for (j = 0; j < width; j += 2, k++, l += 2) {
          items[l] = llItems[k];
        }
      }
      // The LL band is not needed anymore.
      llItems = ll.items = null;

      var bufferPadding = 4;
      var rowBuffer = new Float32Array(width + 2 * bufferPadding);

      // Section F.3.4 HOR_SR
      if (width === 1) {
        // if width = 1, when u0 even keep items as is, when odd divide by 2
        if ((u0 & 1) !== 0) {
          for (v = 0, k = 0; v < height; v++, k += width) {
            items[k] *= 0.5;
          }
        }
      } else {
        for (v = 0, k = 0; v < height; v++, k += width) {
          rowBuffer.set(items.subarray(k, k + width), bufferPadding);

          this.extend(rowBuffer, bufferPadding, width);
          this.filter(rowBuffer, bufferPadding, width);

          items.set(
            rowBuffer.subarray(bufferPadding, bufferPadding + width),
            k);
        }
      }

      // Accesses to the items array can take long, because it may not fit into
      // CPU cache and has to be fetched from main memory. Since subsequent
      // accesses to the items array are not local when reading columns, we
      // have a cache miss every time. To reduce cache misses, get up to
      // 'numBuffers' items at a time and store them into the individual
      // buffers. The colBuffers should be small enough to fit into CPU cache.
      var numBuffers = 16;
      var colBuffers = [];
      for (i = 0; i < numBuffers; i++) {
        colBuffers.push(new Float32Array(height + 2 * bufferPadding));
      }
      var b, currentBuffer = 0;
      ll = bufferPadding + height;

      // Section F.3.5 VER_SR
      if (height === 1) {
          // if height = 1, when v0 even keep items as is, when odd divide by 2
        if ((v0 & 1) !== 0) {
          for (u = 0; u < width; u++) {
            items[u] *= 0.5;
          }
        }
      } else {
        for (u = 0; u < width; u++) {
          // if we ran out of buffers, copy several image columns at once
          if (currentBuffer === 0) {
            numBuffers = Math.min(width - u, numBuffers);
            for (k = u, l = bufferPadding; l < ll; k += width, l++) {
              for (b = 0; b < numBuffers; b++) {
                colBuffers[b][l] = items[k + b];
              }
            }
            currentBuffer = numBuffers;
          }

          currentBuffer--;
          var buffer = colBuffers[currentBuffer];
          this.extend(buffer, bufferPadding, height);
          this.filter(buffer, bufferPadding, height);

          // If this is last buffer in this group of buffers, flush all buffers.
          if (currentBuffer === 0) {
            k = u - numBuffers + 1;
            for (l = bufferPadding; l < ll; k += width, l++) {
              for (b = 0; b < numBuffers; b++) {
                items[k + b] = colBuffers[b][l];
              }
            }
          }
        }
      }

      return {
        relativeRegionInLevel: levelRegion,
        items: items
      };
    };
    return Transform;
  })();

  // Section 3.8.2 Irreversible 9-7 filter
  var IrreversibleTransform = (function IrreversibleTransformClosure() {
    function IrreversibleTransform() {
      Transform.call(this);
    }

    IrreversibleTransform.prototype = Object.create(Transform.prototype);
    IrreversibleTransform.prototype.filter =
      function irreversibleTransformFilter(x, offset, length) {
      var len = length >> 1;
      offset = offset | 0;
      var j, n, current, next;

      var alpha = -1.586134342059924;
      var beta = -0.052980118572961;
      var gamma = 0.882911075530934;
      var delta = 0.443506852043971;
      var K = 1.230174104914001;
      var K_ = 1 / K;

      // step 1 is combined with step 3

      // step 2
      j = offset - 3;
      for (n = len + 4; n--; j += 2) {
        x[j] *= K_;
      }

      // step 1 & 3
      j = offset - 2;
      current = delta * x[j -1];
      for (n = len + 3; n--; j += 2) {
        next = delta * x[j + 1];
        x[j] = K * x[j] - current - next;
        if (n--) {
          j += 2;
          current = delta * x[j + 1];
          x[j] = K * x[j] - current - next;
        } else {
          break;
        }
      }

      // step 4
      j = offset - 1;
      current = gamma * x[j - 1];
      for (n = len + 2; n--; j += 2) {
        next = gamma * x[j + 1];
        x[j] -= current + next;
        if (n--) {
          j += 2;
          current = gamma * x[j + 1];
          x[j] -= current + next;
        } else {
          break;
        }
      }

      // step 5
      j = offset;
      current = beta * x[j - 1];
      for (n = len + 1; n--; j += 2) {
        next = beta * x[j + 1];
        x[j] -= current + next;
        if (n--) {
          j += 2;
          current = beta * x[j + 1];
          x[j] -= current + next;
        } else {
          break;
        }
      }

      // step 6
      if (len !== 0) {
        j = offset + 1;
        current = alpha * x[j - 1];
        for (n = len; n--; j += 2) {
          next = alpha * x[j + 1];
          x[j] -= current + next;
          if (n--) {
            j += 2;
            current = alpha * x[j + 1];
            x[j] -= current + next;
          } else {
            break;
          }
        }
      }
    };

    return IrreversibleTransform;
  })();

  // Section 3.8.1 Reversible 5-3 filter
  var ReversibleTransform = (function ReversibleTransformClosure() {
    function ReversibleTransform() {
      Transform.call(this);
    }

    ReversibleTransform.prototype = Object.create(Transform.prototype);
    ReversibleTransform.prototype.filter =
      function reversibleTransformFilter(x, offset, length) {
      var len = length >> 1;
      offset = offset | 0;
      var j, n;

      for (j = offset, n = len + 1; n--; j += 2) {
        x[j] -= (x[j - 1] + x[j + 1] + 2) >> 2;
      }

      for (j = offset + 1, n = len; n--; j += 2) {
        x[j] += (x[j - 1] + x[j + 1]) >> 1;
      }
    };

    return ReversibleTransform;
  })();

  return JpxImage;
})();


/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/* Copyright 2012 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* globals Cmd, ColorSpace, Dict, MozBlobBuilder, Name, PDFJS, Ref, URL,
           Promise */

'use strict';

var globalScope = (typeof window === 'undefined') ? this : window;

var isWorker = (typeof window === 'undefined');

var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];

var TextRenderingMode = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
};

var ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};

var AnnotationType = {
  WIDGET: 1,
  TEXT: 2,
  LINK: 3
};

var StreamType = {
  UNKNOWN: 0,
  FLATE: 1,
  LZW: 2,
  DCT: 3,
  JPX: 4,
  JBIG: 5,
  A85: 6,
  AHX: 7,
  CCF: 8,
  RL: 9
};

var FontType = {
  UNKNOWN: 0,
  TYPE1: 1,
  TYPE1C: 2,
  CIDFONTTYPE0: 3,
  CIDFONTTYPE0C: 4,
  TRUETYPE: 5,
  CIDFONTTYPE2: 6,
  TYPE3: 7,
  OPENTYPE: 8,
  TYPE0: 9,
  MMTYPE1: 10
};

// The global PDFJS object exposes the API
// In production, it will be declared outside a global wrapper
// In development, it will be declared here
if (!globalScope.PDFJS) {
  globalScope.PDFJS = {};
}

globalScope.PDFJS.pdfBug = false;

PDFJS.VERBOSITY_LEVELS = {
  errors: 0,
  warnings: 1,
  infos: 5
};

// All the possible operations for an operator list.
var OPS = PDFJS.OPS = {
  // Intentionally start from 1 so it is easy to spot bad operators that will be
  // 0's.
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotations: 78,
  endAnnotations: 79,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintJpegXObject: 82,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91
};

// A notice for devs. These are good for things that are helpful to devs, such
// as warning that Workers were disabled, which is important to devs but not
// end users.
function info(msg) {
  if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.infos) {
    console.log('Info: ' + msg);
  }
}

// Non-fatal warnings.
function warn(msg) {
  if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.warnings) {
    console.log('Warning: ' + msg);
  }
}

// Fatal errors that should trigger the fallback UI and halt execution by
// throwing an exception.
function error(msg) {
  // If multiple arguments were passed, pass them all to the log function.
  if (arguments.length > 1) {
    var logArguments = ['Error:'];
    logArguments.push.apply(logArguments, arguments);
    console.log.apply(console, logArguments);
    // Join the arguments into a single string for the lines below.
    msg = [].join.call(arguments, ' ');
  } else {
    console.log('Error: ' + msg);
  }
  console.log(backtrace());
  UnsupportedManager.notify(UNSUPPORTED_FEATURES.unknown);
  throw new Error(msg);
}

function backtrace() {
  try {
    throw new Error();
  } catch (e) {
    return e.stack ? e.stack.split('\n').slice(2).join('\n') : '';
  }
}

function assert(cond, msg) {
  if (!cond) {
    error(msg);
  }
}

var UNSUPPORTED_FEATURES = PDFJS.UNSUPPORTED_FEATURES = {
  unknown: 'unknown',
  forms: 'forms',
  javaScript: 'javaScript',
  smask: 'smask',
  shadingPattern: 'shadingPattern',
  font: 'font'
};

var UnsupportedManager = PDFJS.UnsupportedManager =
  (function UnsupportedManagerClosure() {
  var listeners = [];
  return {
    listen: function (cb) {
      listeners.push(cb);
    },
    notify: function (featureId) {
      warn('Unsupported feature "' + featureId + '"');
      for (var i = 0, ii = listeners.length; i < ii; i++) {
        listeners[i](featureId);
      }
    }
  };
})();

// Combines two URLs. The baseUrl shall be absolute URL. If the url is an
// absolute URL, it will be returned as is.
function combineUrl(baseUrl, url) {
  if (!url) {
    return baseUrl;
  }
  if (/^[a-z][a-z0-9+\-.]*:/i.test(url)) {
    return url;
  }
  var i;
  if (url.charAt(0) === '/') {
    // absolute path
    i = baseUrl.indexOf('://');
    if (url.charAt(1) === '/') {
      ++i;
    } else {
      i = baseUrl.indexOf('/', i + 3);
    }
    return baseUrl.substring(0, i) + url;
  } else {
    // relative path
    var pathLength = baseUrl.length;
    i = baseUrl.lastIndexOf('#');
    pathLength = i >= 0 ? i : pathLength;
    i = baseUrl.lastIndexOf('?', pathLength);
    pathLength = i >= 0 ? i : pathLength;
    var prefixLength = baseUrl.lastIndexOf('/', pathLength);
    return baseUrl.substring(0, prefixLength + 1) + url;
  }
}

// Validates if URL is safe and allowed, e.g. to avoid XSS.
function isValidUrl(url, allowRelative) {
  if (!url) {
    return false;
  }
  // RFC 3986 (http://tools.ietf.org/html/rfc3986#section-3.1)
  // scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
  var protocol = /^[a-z][a-z0-9+\-.]*(?=:)/i.exec(url);
  if (!protocol) {
    return allowRelative;
  }
  protocol = protocol[0].toLowerCase();
  switch (protocol) {
    case 'http':
    case 'https':
    case 'ftp':
    case 'mailto':
      return true;
    default:
      return false;
  }
}
PDFJS.isValidUrl = isValidUrl;

function shadow(obj, prop, value) {
  Object.defineProperty(obj, prop, { value: value,
                                     enumerable: true,
                                     configurable: true,
                                     writable: false });
  return value;
}

var PasswordResponses = PDFJS.PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};

var PasswordException = (function PasswordExceptionClosure() {
  function PasswordException(msg, code) {
    this.name = 'PasswordException';
    this.message = msg;
    this.code = code;
  }

  PasswordException.prototype = new Error();
  PasswordException.constructor = PasswordException;

  return PasswordException;
})();
PDFJS.PasswordException = PasswordException;

var UnknownErrorException = (function UnknownErrorExceptionClosure() {
  function UnknownErrorException(msg, details) {
    this.name = 'UnknownErrorException';
    this.message = msg;
    this.details = details;
  }

  UnknownErrorException.prototype = new Error();
  UnknownErrorException.constructor = UnknownErrorException;

  return UnknownErrorException;
})();
PDFJS.UnknownErrorException = UnknownErrorException;

var InvalidPDFException = (function InvalidPDFExceptionClosure() {
  function InvalidPDFException(msg) {
    this.name = 'InvalidPDFException';
    this.message = msg;
  }

  InvalidPDFException.prototype = new Error();
  InvalidPDFException.constructor = InvalidPDFException;

  return InvalidPDFException;
})();
PDFJS.InvalidPDFException = InvalidPDFException;

var MissingPDFException = (function MissingPDFExceptionClosure() {
  function MissingPDFException(msg) {
    this.name = 'MissingPDFException';
    this.message = msg;
  }

  MissingPDFException.prototype = new Error();
  MissingPDFException.constructor = MissingPDFException;

  return MissingPDFException;
})();
PDFJS.MissingPDFException = MissingPDFException;

var UnexpectedResponseException =
    (function UnexpectedResponseExceptionClosure() {
  function UnexpectedResponseException(msg, status) {
    this.name = 'UnexpectedResponseException';
    this.message = msg;
    this.status = status;
  }

  UnexpectedResponseException.prototype = new Error();
  UnexpectedResponseException.constructor = UnexpectedResponseException;

  return UnexpectedResponseException;
})();
PDFJS.UnexpectedResponseException = UnexpectedResponseException;

var NotImplementedException = (function NotImplementedExceptionClosure() {
  function NotImplementedException(msg) {
    this.message = msg;
  }

  NotImplementedException.prototype = new Error();
  NotImplementedException.prototype.name = 'NotImplementedException';
  NotImplementedException.constructor = NotImplementedException;

  return NotImplementedException;
})();

var MissingDataException = (function MissingDataExceptionClosure() {
  function MissingDataException(begin, end) {
    this.begin = begin;
    this.end = end;
    this.message = 'Missing data [' + begin + ', ' + end + ')';
  }

  MissingDataException.prototype = new Error();
  MissingDataException.prototype.name = 'MissingDataException';
  MissingDataException.constructor = MissingDataException;

  return MissingDataException;
})();

var XRefParseException = (function XRefParseExceptionClosure() {
  function XRefParseException(msg) {
    this.message = msg;
  }

  XRefParseException.prototype = new Error();
  XRefParseException.prototype.name = 'XRefParseException';
  XRefParseException.constructor = XRefParseException;

  return XRefParseException;
})();


function bytesToString(bytes) {
  var length = bytes.length;
  var MAX_ARGUMENT_COUNT = 8192;
  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }
  var strBuf = [];
  for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
    var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
    var chunk = bytes.subarray(i, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }
  return strBuf.join('');
}

function stringToBytes(str) {
  var length = str.length;
  var bytes = new Uint8Array(length);
  for (var i = 0; i < length; ++i) {
    bytes[i] = str.charCodeAt(i) & 0xFF;
  }
  return bytes;
}

function string32(value) {
  return String.fromCharCode((value >> 24) & 0xff, (value >> 16) & 0xff,
                             (value >> 8) & 0xff, value & 0xff);
}

function log2(x) {
  var n = 1, i = 0;
  while (x > n) {
    n <<= 1;
    i++;
  }
  return i;
}

function readInt8(data, start) {
  return (data[start] << 24) >> 24;
}

function readUint16(data, offset) {
  return (data[offset] << 8) | data[offset + 1];
}

function readUint32(data, offset) {
  return ((data[offset] << 24) | (data[offset + 1] << 16) |
         (data[offset + 2] << 8) | data[offset + 3]) >>> 0;
}

// Lazy test the endianness of the platform
// NOTE: This will be 'true' for simulated TypedArrays
function isLittleEndian() {
  var buffer8 = new Uint8Array(2);
  buffer8[0] = 1;
  var buffer16 = new Uint16Array(buffer8.buffer);
  return (buffer16[0] === 1);
}

Object.defineProperty(PDFJS, 'isLittleEndian', {
  configurable: true,
  get: function PDFJS_isLittleEndian() {
    return shadow(PDFJS, 'isLittleEndian', isLittleEndian());
  }
});

//#if !(FIREFOX || MOZCENTRAL || B2G || CHROME)
//// Lazy test if the userAgant support CanvasTypedArrays
function hasCanvasTypedArrays() {
  var canvas = document.createElement('canvas');
  canvas.width = canvas.height = 1;
  var ctx = canvas.getContext('2d');
  var imageData = ctx.createImageData(1, 1);
  return (typeof imageData.data.buffer !== 'undefined');
}

Object.defineProperty(PDFJS, 'hasCanvasTypedArrays', {
  configurable: true,
  get: function PDFJS_hasCanvasTypedArrays() {
    return shadow(PDFJS, 'hasCanvasTypedArrays', hasCanvasTypedArrays());
  }
});

var Uint32ArrayView = (function Uint32ArrayViewClosure() {

  function Uint32ArrayView(buffer, length) {
    this.buffer = buffer;
    this.byteLength = buffer.length;
    this.length = length === undefined ? (this.byteLength >> 2) : length;
    ensureUint32ArrayViewProps(this.length);
  }
  Uint32ArrayView.prototype = Object.create(null);

  var uint32ArrayViewSetters = 0;
  function createUint32ArrayProp(index) {
    return {
      get: function () {
        var buffer = this.buffer, offset = index << 2;
        return (buffer[offset] | (buffer[offset + 1] << 8) |
          (buffer[offset + 2] << 16) | (buffer[offset + 3] << 24)) >>> 0;
      },
      set: function (value) {
        var buffer = this.buffer, offset = index << 2;
        buffer[offset] = value & 255;
        buffer[offset + 1] = (value >> 8) & 255;
        buffer[offset + 2] = (value >> 16) & 255;
        buffer[offset + 3] = (value >>> 24) & 255;
      }
    };
  }

  function ensureUint32ArrayViewProps(length) {
    while (uint32ArrayViewSetters < length) {
      Object.defineProperty(Uint32ArrayView.prototype,
        uint32ArrayViewSetters,
        createUint32ArrayProp(uint32ArrayViewSetters));
      uint32ArrayViewSetters++;
    }
  }

  return Uint32ArrayView;
})();
//#else
//PDFJS.hasCanvasTypedArrays = true;
//#endif

var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];

var Util = PDFJS.Util = (function UtilClosure() {
  function Util() {}

  var rgbBuf = ['rgb(', 0, ',', 0, ',', 0, ')'];

  // makeCssRgb() can be called thousands of times. Using |rgbBuf| avoids
  // creating many intermediate strings.
  Util.makeCssRgb = function Util_makeCssRgb(rgb) {
    rgbBuf[1] = rgb[0];
    rgbBuf[3] = rgb[1];
    rgbBuf[5] = rgb[2];
    return rgbBuf.join('');
  };

  // Concatenates two transformation matrices together and returns the result.
  Util.transform = function Util_transform(m1, m2) {
    return [
      m1[0] * m2[0] + m1[2] * m2[1],
      m1[1] * m2[0] + m1[3] * m2[1],
      m1[0] * m2[2] + m1[2] * m2[3],
      m1[1] * m2[2] + m1[3] * m2[3],
      m1[0] * m2[4] + m1[2] * m2[5] + m1[4],
      m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
    ];
  };

  // For 2d affine transforms
  Util.applyTransform = function Util_applyTransform(p, m) {
    var xt = p[0] * m[0] + p[1] * m[2] + m[4];
    var yt = p[0] * m[1] + p[1] * m[3] + m[5];
    return [xt, yt];
  };

  Util.applyInverseTransform = function Util_applyInverseTransform(p, m) {
    var d = m[0] * m[3] - m[1] * m[2];
    var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
    var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
    return [xt, yt];
  };

  // Applies the transform to the rectangle and finds the minimum axially
  // aligned bounding box.
  Util.getAxialAlignedBoundingBox =
    function Util_getAxialAlignedBoundingBox(r, m) {

    var p1 = Util.applyTransform(r, m);
    var p2 = Util.applyTransform(r.slice(2, 4), m);
    var p3 = Util.applyTransform([r[0], r[3]], m);
    var p4 = Util.applyTransform([r[2], r[1]], m);
    return [
      Math.min(p1[0], p2[0], p3[0], p4[0]),
      Math.min(p1[1], p2[1], p3[1], p4[1]),
      Math.max(p1[0], p2[0], p3[0], p4[0]),
      Math.max(p1[1], p2[1], p3[1], p4[1])
    ];
  };

  Util.inverseTransform = function Util_inverseTransform(m) {
    var d = m[0] * m[3] - m[1] * m[2];
    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d,
      (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
  };

  // Apply a generic 3d matrix M on a 3-vector v:
  //   | a b c |   | X |
  //   | d e f | x | Y |
  //   | g h i |   | Z |
  // M is assumed to be serialized as [a,b,c,d,e,f,g,h,i],
  // with v as [X,Y,Z]
  Util.apply3dTransform = function Util_apply3dTransform(m, v) {
    return [
      m[0] * v[0] + m[1] * v[1] + m[2] * v[2],
      m[3] * v[0] + m[4] * v[1] + m[5] * v[2],
      m[6] * v[0] + m[7] * v[1] + m[8] * v[2]
    ];
  };

  // This calculation uses Singular Value Decomposition.
  // The SVD can be represented with formula A = USV. We are interested in the
  // matrix S here because it represents the scale values.
  Util.singularValueDecompose2dScale =
    function Util_singularValueDecompose2dScale(m) {

    var transpose = [m[0], m[2], m[1], m[3]];

    // Multiply matrix m with its transpose.
    var a = m[0] * transpose[0] + m[1] * transpose[2];
    var b = m[0] * transpose[1] + m[1] * transpose[3];
    var c = m[2] * transpose[0] + m[3] * transpose[2];
    var d = m[2] * transpose[1] + m[3] * transpose[3];

    // Solve the second degree polynomial to get roots.
    var first = (a + d) / 2;
    var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
    var sx = first + second || 1;
    var sy = first - second || 1;

    // Scale values are the square roots of the eigenvalues.
    return [Math.sqrt(sx), Math.sqrt(sy)];
  };

  // Normalize rectangle rect=[x1, y1, x2, y2] so that (x1,y1) < (x2,y2)
  // For coordinate systems whose origin lies in the bottom-left, this
  // means normalization to (BL,TR) ordering. For systems with origin in the
  // top-left, this means (TL,BR) ordering.
  Util.normalizeRect = function Util_normalizeRect(rect) {
    var r = rect.slice(0); // clone rect
    if (rect[0] > rect[2]) {
      r[0] = rect[2];
      r[2] = rect[0];
    }
    if (rect[1] > rect[3]) {
      r[1] = rect[3];
      r[3] = rect[1];
    }
    return r;
  };

  // Returns a rectangle [x1, y1, x2, y2] corresponding to the
  // intersection of rect1 and rect2. If no intersection, returns 'false'
  // The rectangle coordinates of rect1, rect2 should be [x1, y1, x2, y2]
  Util.intersect = function Util_intersect(rect1, rect2) {
    function compare(a, b) {
      return a - b;
    }

    // Order points along the axes
    var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare),
        orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare),
        result = [];

    rect1 = Util.normalizeRect(rect1);
    rect2 = Util.normalizeRect(rect2);

    // X: first and second points belong to different rectangles?
    if ((orderedX[0] === rect1[0] && orderedX[1] === rect2[0]) ||
        (orderedX[0] === rect2[0] && orderedX[1] === rect1[0])) {
      // Intersection must be between second and third points
      result[0] = orderedX[1];
      result[2] = orderedX[2];
    } else {
      return false;
    }

    // Y: first and second points belong to different rectangles?
    if ((orderedY[0] === rect1[1] && orderedY[1] === rect2[1]) ||
        (orderedY[0] === rect2[1] && orderedY[1] === rect1[1])) {
      // Intersection must be between second and third points
      result[1] = orderedY[1];
      result[3] = orderedY[2];
    } else {
      return false;
    }

    return result;
  };

  Util.sign = function Util_sign(num) {
    return num < 0 ? -1 : 1;
  };

  Util.appendToArray = function Util_appendToArray(arr1, arr2) {
    Array.prototype.push.apply(arr1, arr2);
  };

  Util.prependToArray = function Util_prependToArray(arr1, arr2) {
    Array.prototype.unshift.apply(arr1, arr2);
  };

  Util.extendObj = function extendObj(obj1, obj2) {
    for (var key in obj2) {
      obj1[key] = obj2[key];
    }
  };

  Util.getInheritableProperty = function Util_getInheritableProperty(dict,
                                                                     name) {
    while (dict && !dict.has(name)) {
      dict = dict.get('Parent');
    }
    if (!dict) {
      return null;
    }
    return dict.get(name);
  };

  Util.inherit = function Util_inherit(sub, base, prototype) {
    sub.prototype = Object.create(base.prototype);
    sub.prototype.constructor = sub;
    for (var prop in prototype) {
      sub.prototype[prop] = prototype[prop];
    }
  };

  Util.loadScript = function Util_loadScript(src, callback) {
    var script = document.createElement('script');
    var loaded = false;
    script.setAttribute('src', src);
    if (callback) {
      script.onload = function() {
        if (!loaded) {
          callback();
        }
        loaded = true;
      };
    }
    document.getElementsByTagName('head')[0].appendChild(script);
  };

  return Util;
})();

/**
 * PDF page viewport created based on scale, rotation and offset.
 * @class
 * @alias PDFJS.PageViewport
 */
var PageViewport = PDFJS.PageViewport = (function PageViewportClosure() {
  /**
   * @constructor
   * @private
   * @param viewBox {Array} xMin, yMin, xMax and yMax coordinates.
   * @param scale {number} scale of the viewport.
   * @param rotation {number} rotations of the viewport in degrees.
   * @param offsetX {number} offset X
   * @param offsetY {number} offset Y
   * @param dontFlip {boolean} if true, axis Y will not be flipped.
   */
  function PageViewport(viewBox, scale, rotation, offsetX, offsetY, dontFlip) {
    this.viewBox = viewBox;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;

    // creating transform to convert pdf coordinate system to the normal
    // canvas like coordinates taking in account scale and rotation
    var centerX = (viewBox[2] + viewBox[0]) / 2;
    var centerY = (viewBox[3] + viewBox[1]) / 2;
    var rotateA, rotateB, rotateC, rotateD;
    rotation = rotation % 360;
    rotation = rotation < 0 ? rotation + 360 : rotation;
    switch (rotation) {
      case 180:
        rotateA = -1; rotateB = 0; rotateC = 0; rotateD = 1;
        break;
      case 90:
        rotateA = 0; rotateB = 1; rotateC = 1; rotateD = 0;
        break;
      case 270:
        rotateA = 0; rotateB = -1; rotateC = -1; rotateD = 0;
        break;
      //case 0:
      default:
        rotateA = 1; rotateB = 0; rotateC = 0; rotateD = -1;
        break;
    }

    if (dontFlip) {
      rotateC = -rotateC; rotateD = -rotateD;
    }

    var offsetCanvasX, offsetCanvasY;
    var width, height;
    if (rotateA === 0) {
      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
      width = Math.abs(viewBox[3] - viewBox[1]) * scale;
      height = Math.abs(viewBox[2] - viewBox[0]) * scale;
    } else {
      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
      width = Math.abs(viewBox[2] - viewBox[0]) * scale;
      height = Math.abs(viewBox[3] - viewBox[1]) * scale;
    }
    // creating transform for the following operations:
    // translate(-centerX, -centerY), rotate and flip vertically,
    // scale, and translate(offsetCanvasX, offsetCanvasY)
    this.transform = [
      rotateA * scale,
      rotateB * scale,
      rotateC * scale,
      rotateD * scale,
      offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY,
      offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY
    ];

    this.width = width;
    this.height = height;
    this.fontScale = scale;
  }
  PageViewport.prototype = /** @lends PDFJS.PageViewport.prototype */ {
    /**
     * Clones viewport with additional properties.
     * @param args {Object} (optional) If specified, may contain the 'scale' or
     * 'rotation' properties to override the corresponding properties in
     * the cloned viewport.
     * @returns {PDFJS.PageViewport} Cloned viewport.
     */
    clone: function PageViewPort_clone(args) {
      args = args || {};
      var scale = 'scale' in args ? args.scale : this.scale;
      var rotation = 'rotation' in args ? args.rotation : this.rotation;
      return new PageViewport(this.viewBox.slice(), scale, rotation,
                              this.offsetX, this.offsetY, args.dontFlip);
    },
    /**
     * Converts PDF point to the viewport coordinates. For examples, useful for
     * converting PDF location into canvas pixel coordinates.
     * @param x {number} X coordinate.
     * @param y {number} Y coordinate.
     * @returns {Object} Object that contains 'x' and 'y' properties of the
     * point in the viewport coordinate space.
     * @see {@link convertToPdfPoint}
     * @see {@link convertToViewportRectangle}
     */
    convertToViewportPoint: function PageViewport_convertToViewportPoint(x, y) {
      return Util.applyTransform([x, y], this.transform);
    },
    /**
     * Converts PDF rectangle to the viewport coordinates.
     * @param rect {Array} xMin, yMin, xMax and yMax coordinates.
     * @returns {Array} Contains corresponding coordinates of the rectangle
     * in the viewport coordinate space.
     * @see {@link convertToViewportPoint}
     */
    convertToViewportRectangle:
      function PageViewport_convertToViewportRectangle(rect) {
      var tl = Util.applyTransform([rect[0], rect[1]], this.transform);
      var br = Util.applyTransform([rect[2], rect[3]], this.transform);
      return [tl[0], tl[1], br[0], br[1]];
    },
    /**
     * Converts viewport coordinates to the PDF location. For examples, useful
     * for converting canvas pixel location into PDF one.
     * @param x {number} X coordinate.
     * @param y {number} Y coordinate.
     * @returns {Object} Object that contains 'x' and 'y' properties of the
     * point in the PDF coordinate space.
     * @see {@link convertToViewportPoint}
     */
    convertToPdfPoint: function PageViewport_convertToPdfPoint(x, y) {
      return Util.applyInverseTransform([x, y], this.transform);
    }
  };
  return PageViewport;
})();

var PDFStringTranslateTable = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014,
  0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C,
  0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160,
  0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC
];

function stringToPDFString(str) {
  var i, n = str.length, strBuf = [];
  if (str[0] === '\xFE' && str[1] === '\xFF') {
    // UTF16BE BOM
    for (i = 2; i < n; i += 2) {
      strBuf.push(String.fromCharCode(
        (str.charCodeAt(i) << 8) | str.charCodeAt(i + 1)));
    }
  } else {
    for (i = 0; i < n; ++i) {
      var code = PDFStringTranslateTable[str.charCodeAt(i)];
      strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
    }
  }
  return strBuf.join('');
}

function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}

function isEmptyObj(obj) {
  for (var key in obj) {
    return false;
  }
  return true;
}

function isBool(v) {
  return typeof v === 'boolean';
}

function isInt(v) {
  return typeof v === 'number' && ((v | 0) === v);
}

function isNum(v) {
  return typeof v === 'number';
}

function isString(v) {
  return typeof v === 'string';
}

function isNull(v) {
  return v === null;
}

function isName(v) {
  return v instanceof Name;
}

function isCmd(v, cmd) {
  return v instanceof Cmd && (cmd === undefined || v.cmd === cmd);
}

function isDict(v, type) {
  if (!(v instanceof Dict)) {
    return false;
  }
  if (!type) {
    return true;
  }
  var dictType = v.get('Type');
  return isName(dictType) && dictType.name === type;
}

function isArray(v) {
  return v instanceof Array;
}

function isStream(v) {
  return typeof v === 'object' && v !== null && v.getBytes !== undefined;
}

function isArrayBuffer(v) {
  return typeof v === 'object' && v !== null && v.byteLength !== undefined;
}

function isRef(v) {
  return v instanceof Ref;
}

/**
 * Promise Capability object.
 *
 * @typedef {Object} PromiseCapability
 * @property {Promise} promise - A promise object.
 * @property {function} resolve - Fullfills the promise.
 * @property {function} reject - Rejects the promise.
 */

/**
 * Creates a promise capability object.
 * @alias PDFJS.createPromiseCapability
 *
 * @return {PromiseCapability} A capability object contains:
 * - a Promise, resolve and reject methods.
 */
function createPromiseCapability() {
  var capability = {};
  capability.promise = new Promise(function (resolve, reject) {
    capability.resolve = resolve;
    capability.reject = reject;
  });
  return capability;
}

PDFJS.createPromiseCapability = createPromiseCapability;

/**
 * Polyfill for Promises:
 * The following promise implementation tries to generally implement the
 * Promise/A+ spec. Some notable differences from other promise libaries are:
 * - There currently isn't a seperate deferred and promise object.
 * - Unhandled rejections eventually show an error if they aren't handled.
 *
 * Based off of the work in:
 * https://bugzilla.mozilla.org/show_bug.cgi?id=810490
 */
(function PromiseClosure() {
  if (globalScope.Promise) {
    // Promises existing in the DOM/Worker, checking presence of all/resolve
    if (typeof globalScope.Promise.all !== 'function') {
      globalScope.Promise.all = function (iterable) {
        var count = 0, results = [], resolve, reject;
        var promise = new globalScope.Promise(function (resolve_, reject_) {
          resolve = resolve_;
          reject = reject_;
        });
        iterable.forEach(function (p, i) {
          count++;
          p.then(function (result) {
            results[i] = result;
            count--;
            if (count === 0) {
              resolve(results);
            }
          }, reject);
        });
        if (count === 0) {
          resolve(results);
        }
        return promise;
      };
    }
    if (typeof globalScope.Promise.resolve !== 'function') {
      globalScope.Promise.resolve = function (value) {
        return new globalScope.Promise(function (resolve) { resolve(value); });
      };
    }
    if (typeof globalScope.Promise.reject !== 'function') {
      globalScope.Promise.reject = function (reason) {
        return new globalScope.Promise(function (resolve, reject) {
          reject(reason);
        });
      };
    }
    if (typeof globalScope.Promise.prototype.catch !== 'function') {
      globalScope.Promise.prototype.catch = function (onReject) {
        return globalScope.Promise.prototype.then(undefined, onReject);
      };
    }
    return;
  }
//#if !MOZCENTRAL
  var STATUS_PENDING = 0;
  var STATUS_RESOLVED = 1;
  var STATUS_REJECTED = 2;

  // In an attempt to avoid silent exceptions, unhandled rejections are
  // tracked and if they aren't handled in a certain amount of time an
  // error is logged.
  var REJECTION_TIMEOUT = 500;

  var HandlerManager = {
    handlers: [],
    running: false,
    unhandledRejections: [],
    pendingRejectionCheck: false,

    scheduleHandlers: function scheduleHandlers(promise) {
      if (promise._status === STATUS_PENDING) {
        return;
      }

      this.handlers = this.handlers.concat(promise._handlers);
      promise._handlers = [];

      if (this.running) {
        return;
      }
      this.running = true;

      setTimeout(this.runHandlers.bind(this), 0);
    },

    runHandlers: function runHandlers() {
      var RUN_TIMEOUT = 1; // ms
      var timeoutAt = Date.now() + RUN_TIMEOUT;
      while (this.handlers.length > 0) {
        var handler = this.handlers.shift();

        var nextStatus = handler.thisPromise._status;
        var nextValue = handler.thisPromise._value;

        try {
          if (nextStatus === STATUS_RESOLVED) {
            if (typeof handler.onResolve === 'function') {
              nextValue = handler.onResolve(nextValue);
            }
          } else if (typeof handler.onReject === 'function') {
              nextValue = handler.onReject(nextValue);
              nextStatus = STATUS_RESOLVED;

              if (handler.thisPromise._unhandledRejection) {
                this.removeUnhandeledRejection(handler.thisPromise);
              }
          }
        } catch (ex) {
          nextStatus = STATUS_REJECTED;
          nextValue = ex;
        }

        handler.nextPromise._updateStatus(nextStatus, nextValue);
        if (Date.now() >= timeoutAt) {
          break;
        }
      }

      if (this.handlers.length > 0) {
        setTimeout(this.runHandlers.bind(this), 0);
        return;
      }

      this.running = false;
    },

    addUnhandledRejection: function addUnhandledRejection(promise) {
      this.unhandledRejections.push({
        promise: promise,
        time: Date.now()
      });
      this.scheduleRejectionCheck();
    },

    removeUnhandeledRejection: function removeUnhandeledRejection(promise) {
      promise._unhandledRejection = false;
      for (var i = 0; i < this.unhandledRejections.length; i++) {
        if (this.unhandledRejections[i].promise === promise) {
          this.unhandledRejections.splice(i);
          i--;
        }
      }
    },

    scheduleRejectionCheck: function scheduleRejectionCheck() {
      if (this.pendingRejectionCheck) {
        return;
      }
      this.pendingRejectionCheck = true;
      setTimeout(function rejectionCheck() {
        this.pendingRejectionCheck = false;
        var now = Date.now();
        for (var i = 0; i < this.unhandledRejections.length; i++) {
          if (now - this.unhandledRejections[i].time > REJECTION_TIMEOUT) {
            var unhandled = this.unhandledRejections[i].promise._value;
            var msg = 'Unhandled rejection: ' + unhandled;
            if (unhandled.stack) {
              msg += '\n' + unhandled.stack;
            }
            warn(msg);
            this.unhandledRejections.splice(i);
            i--;
          }
        }
        if (this.unhandledRejections.length) {
          this.scheduleRejectionCheck();
        }
      }.bind(this), REJECTION_TIMEOUT);
    }
  };

  function Promise(resolver) {
    this._status = STATUS_PENDING;
    this._handlers = [];
    try {
      resolver.call(this, this._resolve.bind(this), this._reject.bind(this));
    } catch (e) {
      this._reject(e);
    }
  }
  /**
   * Builds a promise that is resolved when all the passed in promises are
   * resolved.
   * @param {array} array of data and/or promises to wait for.
   * @return {Promise} New dependant promise.
   */
  Promise.all = function Promise_all(promises) {
    var resolveAll, rejectAll;
    var deferred = new Promise(function (resolve, reject) {
      resolveAll = resolve;
      rejectAll = reject;
    });
    var unresolved = promises.length;
    var results = [];
    if (unresolved === 0) {
      resolveAll(results);
      return deferred;
    }
    function reject(reason) {
      if (deferred._status === STATUS_REJECTED) {
        return;
      }
      results = [];
      rejectAll(reason);
    }
    for (var i = 0, ii = promises.length; i < ii; ++i) {
      var promise = promises[i];
      var resolve = (function(i) {
        return function(value) {
          if (deferred._status === STATUS_REJECTED) {
            return;
          }
          results[i] = value;
          unresolved--;
          if (unresolved === 0) {
            resolveAll(results);
          }
        };
      })(i);
      if (Promise.isPromise(promise)) {
        promise.then(resolve, reject);
      } else {
        resolve(promise);
      }
    }
    return deferred;
  };

  /**
   * Checks if the value is likely a promise (has a 'then' function).
   * @return {boolean} true if value is thenable
   */
  Promise.isPromise = function Promise_isPromise(value) {
    return value && typeof value.then === 'function';
  };

  /**
   * Creates resolved promise
   * @param value resolve value
   * @returns {Promise}
   */
  Promise.resolve = function Promise_resolve(value) {
    return new Promise(function (resolve) { resolve(value); });
  };

  /**
   * Creates rejected promise
   * @param reason rejection value
   * @returns {Promise}
   */
  Promise.reject = function Promise_reject(reason) {
    return new Promise(function (resolve, reject) { reject(reason); });
  };

  Promise.prototype = {
    _status: null,
    _value: null,
    _handlers: null,
    _unhandledRejection: null,

    _updateStatus: function Promise__updateStatus(status, value) {
      if (this._status === STATUS_RESOLVED ||
          this._status === STATUS_REJECTED) {
        return;
      }

      if (status === STATUS_RESOLVED &&
          Promise.isPromise(value)) {
        value.then(this._updateStatus.bind(this, STATUS_RESOLVED),
                   this._updateStatus.bind(this, STATUS_REJECTED));
        return;
      }

      this._status = status;
      this._value = value;

      if (status === STATUS_REJECTED && this._handlers.length === 0) {
        this._unhandledRejection = true;
        HandlerManager.addUnhandledRejection(this);
      }

      HandlerManager.scheduleHandlers(this);
    },

    _resolve: function Promise_resolve(value) {
      this._updateStatus(STATUS_RESOLVED, value);
    },

    _reject: function Promise_reject(reason) {
      this._updateStatus(STATUS_REJECTED, reason);
    },

    then: function Promise_then(onResolve, onReject) {
      var nextPromise = new Promise(function (resolve, reject) {
        this.resolve = resolve;
        this.reject = reject;
      });
      this._handlers.push({
        thisPromise: this,
        onResolve: onResolve,
        onReject: onReject,
        nextPromise: nextPromise
      });
      HandlerManager.scheduleHandlers(this);
      return nextPromise;
    },

    catch: function Promise_catch(onReject) {
      return this.then(undefined, onReject);
    }
  };

  globalScope.Promise = Promise;
//#else
//throw new Error('DOM Promise is not present');
//#endif
})();

var StatTimer = (function StatTimerClosure() {
  function rpad(str, pad, length) {
    while (str.length < length) {
      str += pad;
    }
    return str;
  }
  function StatTimer() {
    this.started = {};
    this.times = [];
    this.enabled = true;
  }
  StatTimer.prototype = {
    time: function StatTimer_time(name) {
      if (!this.enabled) {
        return;
      }
      if (name in this.started) {
        warn('Timer is already running for ' + name);
      }
      this.started[name] = Date.now();
    },
    timeEnd: function StatTimer_timeEnd(name) {
      if (!this.enabled) {
        return;
      }
      if (!(name in this.started)) {
        warn('Timer has not been started for ' + name);
      }
      this.times.push({
        'name': name,
        'start': this.started[name],
        'end': Date.now()
      });
      // Remove timer from started so it can be called again.
      delete this.started[name];
    },
    toString: function StatTimer_toString() {
      var i, ii;
      var times = this.times;
      var out = '';
      // Find the longest name for padding purposes.
      var longest = 0;
      for (i = 0, ii = times.length; i < ii; ++i) {
        var name = times[i]['name'];
        if (name.length > longest) {
          longest = name.length;
        }
      }
      for (i = 0, ii = times.length; i < ii; ++i) {
        var span = times[i];
        var duration = span.end - span.start;
        out += rpad(span['name'], ' ', longest) + ' ' + duration + 'ms\n';
      }
      return out;
    }
  };
  return StatTimer;
})();

PDFJS.createBlob = function createBlob(data, contentType) {
  if (typeof Blob !== 'undefined') {
    return new Blob([data], { type: contentType });
  }
  // Blob builder is deprecated in FF14 and removed in FF18.
  var bb = new MozBlobBuilder();
  bb.append(data);
  return bb.getBlob(contentType);
};

PDFJS.createObjectURL = (function createObjectURLClosure() {
  // Blob/createObjectURL is not available, falling back to data schema.
  var digits =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  return function createObjectURL(data, contentType) {
    if (!PDFJS.disableCreateObjectURL &&
        typeof URL !== 'undefined' && URL.createObjectURL) {
      var blob = PDFJS.createBlob(data, contentType);
      return URL.createObjectURL(blob);
    }

    var buffer = 'data:' + contentType + ';base64,';
    for (var i = 0, ii = data.length; i < ii; i += 3) {
      var b1 = data[i] & 0xFF;
      var b2 = data[i + 1] & 0xFF;
      var b3 = data[i + 2] & 0xFF;
      var d1 = b1 >> 2, d2 = ((b1 & 3) << 4) | (b2 >> 4);
      var d3 = i + 1 < ii ? ((b2 & 0xF) << 2) | (b3 >> 6) : 64;
      var d4 = i + 2 < ii ? (b3 & 0x3F) : 64;
      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
    }
    return buffer;
  };
})();

function MessageHandler(name, comObj) {
  this.name = name;
  this.comObj = comObj;
  this.callbackIndex = 1;
  this.postMessageTransfers = true;
  var callbacksCapabilities = this.callbacksCapabilities = {};
  var ah = this.actionHandler = {};

  ah['console_log'] = [function ahConsoleLog(data) {
    console.log.apply(console, data);
  }];
  ah['console_error'] = [function ahConsoleError(data) {
    console.error.apply(console, data);
  }];
  ah['_unsupported_feature'] = [function ah_unsupportedFeature(data) {
    UnsupportedManager.notify(data);
  }];

  comObj.onmessage = function messageHandlerComObjOnMessage(event) {
    var data = event.data;
    if (data.isReply) {
      var callbackId = data.callbackId;
      if (data.callbackId in callbacksCapabilities) {
        var callback = callbacksCapabilities[callbackId];
        delete callbacksCapabilities[callbackId];
        if ('error' in data) {
          callback.reject(data.error);
        } else {
          callback.resolve(data.data);
        }
      } else {
        error('Cannot resolve callback ' + callbackId);
      }
    } else if (data.action in ah) {
      var action = ah[data.action];
      if (data.callbackId) {
        Promise.resolve().then(function () {
          return action[0].call(action[1], data.data);
        }).then(function (result) {
          comObj.postMessage({
            isReply: true,
            callbackId: data.callbackId,
            data: result
          });
        }, function (reason) {
          comObj.postMessage({
            isReply: true,
            callbackId: data.callbackId,
            error: reason
          });
        });
      } else {
        action[0].call(action[1], data.data);
      }
    } else {
      error('Unknown action from worker: ' + data.action);
    }
  };
}

MessageHandler.prototype = {
  on: function messageHandlerOn(actionName, handler, scope) {
    var ah = this.actionHandler;
    if (ah[actionName]) {
      error('There is already an actionName called "' + actionName + '"');
    }
    ah[actionName] = [handler, scope];
  },
  /**
   * Sends a message to the comObj to invoke the action with the supplied data.
   * @param {String} actionName Action to call.
   * @param {JSON} data JSON data to send.
   * @param {Array} [transfers] Optional list of transfers/ArrayBuffers
   */
  send: function messageHandlerSend(actionName, data, transfers) {
    var message = {
      action: actionName,
      data: data
    };
    this.postMessage(message, transfers);
  },
  /**
   * Sends a message to the comObj to invoke the action with the supplied data.
   * Expects that other side will callback with the response.
   * @param {String} actionName Action to call.
   * @param {JSON} data JSON data to send.
   * @param {Array} [transfers] Optional list of transfers/ArrayBuffers.
   * @returns {Promise} Promise to be resolved with response data.
   */
  sendWithPromise:
    function messageHandlerSendWithPromise(actionName, data, transfers) {
    var callbackId = this.callbackIndex++;
    var message = {
      action: actionName,
      data: data,
      callbackId: callbackId
    };
    var capability = createPromiseCapability();
    this.callbacksCapabilities[callbackId] = capability;
    try {
      this.postMessage(message, transfers);
    } catch (e) {
      capability.reject(e);
    }
    return capability.promise;
  },
  /**
   * Sends raw message to the comObj.
   * @private
   * @param message {Object} Raw message.
   * @param transfers List of transfers/ArrayBuffers, or undefined.
   */
  postMessage: function (message, transfers) {
    if (transfers && this.postMessageTransfers) {
      this.comObj.postMessage(message, transfers);
    } else {
      this.comObj.postMessage(message);
    }
  }
};

function loadJpegStream(id, imageUrl, objs) {
  var img = new Image();
  img.onload = (function loadJpegStream_onloadClosure() {
    objs.resolve(id, img);
  });
  img.onerror = (function loadJpegStream_onerrorClosure() {
    objs.resolve(id, null);
    warn('Error during JPEG image loading');
  });
  img.src = imageUrl;
}

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.webjpip = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');
var jpipRuntimeFactory = require('jpip-runtime-factory.js'); 

module.exports.JpipCodestreamClient = function JpipCodestreamClient(options) {
    options = options || {};
    var jpipFactory = jpipRuntimeFactory;

    var databinsSaver = jpipFactory.createDatabinsSaver(/*isJpipTilepartStream=*/false);
    var mainHeaderDatabin = databinsSaver.getMainHeaderDatabin();

    var markersParser = jpipFactory.createMarkersParser(mainHeaderDatabin);
    var offsetsCalculator = jpipFactory.createOffsetsCalculator(
        mainHeaderDatabin, markersParser);
    var structureParser = jpipFactory.createStructureParser(
        databinsSaver, markersParser, offsetsCalculator);
    
    var progressionOrder = 'RPCL';
    var codestreamStructure = jpipFactory.createCodestreamStructure(
        structureParser, progressionOrder);
    
    var qualityLayersCache = jpipFactory.createQualityLayersCache(
        codestreamStructure);
        
    var headerModifier = jpipFactory.createHeaderModifier(
        codestreamStructure, offsetsCalculator, progressionOrder);
    var reconstructor = jpipFactory.createCodestreamReconstructor(
        codestreamStructure, databinsSaver, headerModifier, qualityLayersCache);
    var packetsDataCollector = jpipFactory.createPacketsDataCollector(
        codestreamStructure, databinsSaver, qualityLayersCache);
    
    var maxChannelsInSession = options.maxChannelsInSession || 1;
    var maxRequestsWaitingForResponseInChannel =
        options.maxRequestsWaitingForResponseInChannel || 1;
        
    var requester = jpipFactory.createReconnectableRequester(
        maxChannelsInSession,
        maxRequestsWaitingForResponseInChannel,
        codestreamStructure,
        databinsSaver);
    
    var jpipObjectsForRequestContext = {
        requester: requester,
        reconstructor: reconstructor,
        packetsDataCollector: packetsDataCollector,
        qualityLayersCache: qualityLayersCache,
        codestreamStructure: codestreamStructure,
        databinsSaver: databinsSaver,
        jpipFactory: jpipFactory
        };
    
    var statusCallback = null;
    
    this.setStatusCallback = function setStatusCallbackClosure(callback) {
        statusCallback = callback;
        
        if (callback !== null) {
            requester.setStatusCallback(requesterStatusCallback);
        } else {
            requester.setStatusCallback(null);
        }
    };
    
    this.open = function open(baseUrl) {
        requester.open(baseUrl);
    };
    
    this.close = function close(closedCallback) {
        requester.close(closedCallback);
    };
    
    this.getSizesParams = function getSizesParams() {
        if (!requester.getIsReady()) {
            throw new jGlobals.jpipExceptions.IllegalOperationException(
                'Cannot get codestream structure before image is ready');
        }
        
        var params = codestreamStructure.getSizesParams();
        var clonedParams = JSON.parse(JSON.stringify(params));
        
        var tile = codestreamStructure.getDefaultTileStructure();
        var component = tile.getDefaultComponentStructure();

        clonedParams.defaultNumQualityLayers =
            tile.getNumQualityLayers();
        clonedParams.defaultNumResolutionLevels =
            component.getNumResolutionLevels();
        
        return clonedParams;
    };
    
    this.createDataRequest = function createDataRequest(
        codestreamPartParams, callback, userContextVars, options) {
        
        options = options || {};
        if (options.isOnlyWaitForData !== undefined) {
            throw new jGlobals.jpipExceptions.ArgumentException(
                'options.isOnlyWaitForData',
                options.isOnlyWaitForData,
                'isOnlyWaitForData is supported only for progressive request');
        }
        
        var codestreamPartParamsModified = castCodestreamPartParams(
            codestreamPartParams);
        
        var progressiveness;
        if (options.useCachedDataOnly) {
            progressiveness = [ { minNumQualityLayers: 0 } ];
        } else {
            var maxNumQualityLayers = codestreamPartParams.maxNumQualityLayers;
            var minNumQualityLayers =
                maxNumQualityLayers === undefined ? 'max' : maxNumQualityLayers;
            
            progressiveness = [ { minNumQualityLayers: minNumQualityLayers } ];
        }
        
        var requestContext = jpipFactory.createRequestContext(
            jpipObjectsForRequestContext,
            codestreamPartParamsModified,
            callback,
            progressiveness,
            {
                disableServerRequests: !!options.useCachedDataOnly,
                isMovable: false,
                userContextVars: userContextVars,
                failureCallback: options.failureCallback
            });
        
        return requestContext;
    };
    
    this.createProgressiveDataRequest = function createProgressiveDataRequest(
        codestreamPartParams,
        callback,
        userContextVars,
        options,
        progressiveness) {
        
        options = options || {};
        if (options.useCachedDataOnly !== undefined) {
            throw new jGlobals.jpipExceptions.ArgumentException(
                'options.useCachedDataOnly',
                options.useCachedDataOnly,
                'useCachedDataOnly is not supported for progressive request');
        }
        
        var codestreamPartParamsModified = castCodestreamPartParams(
            codestreamPartParams);
        
        var progressivenessModified;
        if (progressiveness === undefined) {
            progressivenessModified = getAutomaticProgressivenessStages(
                codestreamPartParamsModified.maxNumQualityLayers);
        } else {
            progressivenessModified = castProgressivenessParams(
                progressiveness, codestreamPartParamsModified.maxNumQualityLayers, 'maxNumQualityLayers');
        }
        
        var requestContext = jpipFactory.createRequestContext(
            jpipObjectsForRequestContext,
            codestreamPartParamsModified,
            callback,
            progressivenessModified,
            {
                disableServerRequests: !!options.isOnlyWaitForData,
                isMovable: false,
                userContextVars: userContextVars,
                failureCallback: options.failureCallback
            });
        
        return requestContext;
    };
    
    this.createMovableRequest = function createMovableRequest(
        callback, userContextVars) {
        
        // NOTE: Think of the correct API of progressiveness in movable requests
        
        var zombieCodestreamPartParams = null;
        var progressiveness = getAutomaticProgressivenessStages();
        
        var requestContext = jpipFactory.createRequestContext(
            jpipObjectsForRequestContext,
            zombieCodestreamPartParams,
            callback,
            progressiveness,
            {
                disableServerRequests: false,
                isMovable: true,
                userContextVars: userContextVars
            });
            
        return requestContext;
    };
    
    this.reconnect = function reconnect() {
        requester.reconnect();
    };
    
    function requesterStatusCallback(requesterStatus) {
        var serializableException = null;
        if (requesterStatus.exception !== null) {
            serializableException = requesterStatus.exception.toString();
        }
        
        var status = {
            isReady: requesterStatus.isReady,
            exception: serializableException
            };
        
        statusCallback(status);
    }
    
    function castProgressivenessParams(progressiveness, maxNumQualityLayers, propertyName) {
        // Ensure than minNumQualityLayers is given for all items
        
        var result = new Array(progressiveness.length);

        for (var i = 0; i < progressiveness.length; ++i) {
            var minNumQualityLayers = progressiveness[i].minNumQualityLayers;
            
            if (minNumQualityLayers !== 'max') {
                if (maxNumQualityLayers !== undefined &&
                    minNumQualityLayers > maxNumQualityLayers) {
                    
                    throw new jGlobals.jpipExceptions.ArgumentException(
                        'progressiveness[' + i + '].minNumQualityLayers',
                        minNumQualityLayers,
                        'minNumQualityLayers is bigger than ' +
                            'fetchParams.maxNumQualityLayers');
                }
                
                minNumQualityLayers = validateNumericParam(
                    minNumQualityLayers,
                    propertyName,
                    'progressiveness[' + i + '].minNumQualityLayers');
            }
            
            result[i] = { minNumQualityLayers: minNumQualityLayers };
        }
        
        return result;
    }
    
    function getAutomaticProgressivenessStages(maxNumQualityLayers) {
        // Create progressiveness of (1, 2, 3, (#max-quality/2), (#max-quality))

        var progressiveness = [];

        // No progressiveness, wait for all quality layers to be fetched
        var tileStructure = codestreamStructure.getDefaultTileStructure();
        var numQualityLayersNumeric = tileStructure.getNumQualityLayers();
        var maxNumQualityLayersNumericOrMax = 'max';
        
        if (maxNumQualityLayers !== undefined) {
            numQualityLayersNumeric = Math.min(
                numQualityLayersNumeric, maxNumQualityLayers);
            maxNumQualityLayersNumericOrMax = numQualityLayersNumeric;
        }
        
        var firstQualityLayersCount = numQualityLayersNumeric < 4 ?
            numQualityLayersNumeric - 1: 3;
        
        for (var i = 1; i < firstQualityLayersCount; ++i) {
            progressiveness.push({ minNumQualityLayers: i });
        }
        
        var middleQuality = Math.round(numQualityLayersNumeric / 2);
        if (middleQuality > firstQualityLayersCount) {
            progressiveness.push({ minNumQualityLayers: middleQuality });
        }
        
        progressiveness.push({
            minNumQualityLayers: maxNumQualityLayersNumericOrMax
            });
        
        return progressiveness;
    }
    
    function castCodestreamPartParams(codestreamPartParams) {
        var numResolutionLevelsToCut = validateNumericParam(
            codestreamPartParams.numResolutionLevelsToCut,
            'numResolutionLevelsToCut',
            /*defaultValue=*/undefined,
            /*allowUndefiend=*/true);

        var maxNumQualityLayers = validateNumericParam(
            codestreamPartParams.maxNumQualityLayers,
            'maxNumQualityLayers',
            /*defaultValue=*/undefined,
            /*allowUndefiend=*/true);
        
        var minX = validateNumericParam(codestreamPartParams.minX, 'minX');
        var minY = validateNumericParam(codestreamPartParams.minY, 'minY');
        
        var maxX = validateNumericParam(
            codestreamPartParams.maxXExclusive, 'maxXExclusive');
        
        var maxY = validateNumericParam(
            codestreamPartParams.maxYExclusive, 'maxYExclusive');
        
        var levelWidth = codestreamStructure.getLevelWidth(numResolutionLevelsToCut);
        var levelHeight = codestreamStructure.getLevelHeight(numResolutionLevelsToCut);
        
        if (minX < 0 || maxX > levelWidth ||
            minY < 0 || maxY > levelHeight ||
            minX >= maxX || minY >= maxY) {
            
            throw new jGlobals.jpipExceptions.ArgumentException(
                'codestreamPartParams', codestreamPartParams);
        }
        
        var result = {
            minX: minX,
            minY: minY,
            maxXExclusive: maxX,
            maxYExclusive: maxY,
            
            numResolutionLevelsToCut: numResolutionLevelsToCut,
            maxNumQualityLayers: maxNumQualityLayers
            };
        
        return result;
    }
    
    function validateNumericParam(
        inputValue, propertyName, defaultValue, allowUndefined) {
        
        if (inputValue === undefined &&
            (defaultValue !== undefined || allowUndefined)) {
            
            return defaultValue;
        }
        
        var result = +inputValue;
        if (isNaN(result) || result !== Math.floor(result)) {
            throw new jGlobals.jpipExceptions.ArgumentException(
                propertyName, inputValue);
        }
        
        return result;
    }
    
    return this;
};
},{"j2k-jpip-globals.js":12,"jpip-runtime-factory.js":13}],2:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipCodestreamSizesCalculator = function JpipCodestreamSizesCalculator(
    params) {
    
    var EDGE_TYPE_NO_EDGE = 0;
    var EDGE_TYPE_FIRST = 1;
    var EDGE_TYPE_LAST = 2;

    this.EDGE_TYPE_NO_EDGE = EDGE_TYPE_NO_EDGE;
    this.EDGE_TYPE_FIRST = EDGE_TYPE_FIRST;
    this.EDGE_TYPE_LAST = EDGE_TYPE_LAST;
    
    this.getSizeOfPart = getSizeOfPart;
    
    this.getTilesFromPixels = getTilesFromPixels;
    
    this.getNumTilesX = getNumTilesX;
    
    this.getNumTilesY = getNumTilesY;
    
    this.getLevelWidth = getLevelWidth;
    
    this.getLevelHeight = getLevelHeight;
    
    this.getTileWidth = getTileWidth;
    
    this.getTileHeight = getTileHeight;
    
    this.getFirstTileOffsetX = getFirstTileOffsetX;
    
    this.getFirstTileOffsetY = getFirstTileOffsetY;
    
    this.getFirstTileWidth = getFirstTileWidth;
    
    this.getFirstTileHeight = getFirstTileHeight;
    
    this.isEdgeTileId = isEdgeTileId;
    
    this.getTileSize = getTileSize;
    
    this.getDefaultNumResolutionLevels =
        function getDefaultNumResolutionLevels() {
        
        if (params.defaultNumResolutionLevels === undefined) {
            throw 'This method is available only when jpipSizesCalculator ' +
                'is created from params returned by jpipCodestreamClient. ' +
                'It shall be used for JPIP API purposes only';
        }
        
        return params.defaultNumResolutionLevels;
    };
    
    this.getDefaultNumQualityLayers =
        function getDefaultNumQualityLayers() {
        
        if (params.defaultNumQualityLayers === undefined) {
            throw 'This method is available only when jpipSizesCalculator ' +
                'is created from params returned by jpipCodestreamClient. ' +
                'It shall be used for JPIP API purposes only';
        }
        
        return params.defaultNumQualityLayers;
    };
    
    function getSizeOfPart(codestreamPartParams) {
        var numResolutionLevelsToCut =
            codestreamPartParams.numResolutionLevelsToCut;
        var tileWidth = getTileWidth(numResolutionLevelsToCut);
        var tileHeight = getTileHeight(numResolutionLevelsToCut);
        
        var tileBounds = getTilesFromPixels(codestreamPartParams);
        
        var firstTileIndex =
            tileBounds.minTileX + tileBounds.minTileY * getNumTilesX();
            
        var lastTileIndex =
            (tileBounds.maxTileXExclusive - 1) +
            (tileBounds.maxTileYExclusive - 1) * getNumTilesX();
        
        var firstEdgeType = isEdgeTileId(firstTileIndex);
        var lastEdgeType = isEdgeTileId(lastTileIndex);
        var firstSize = getTileSize(firstEdgeType, numResolutionLevelsToCut);
        var lastSize = getTileSize(lastEdgeType, numResolutionLevelsToCut);
        
        var width = firstSize[0];
        var height = firstSize[1];

        var tilesX = tileBounds.maxTileXExclusive - tileBounds.minTileX;
        var tilesY = tileBounds.maxTileYExclusive - tileBounds.minTileY;
        
        if (tilesX > 1) {
            width += lastSize[0];
            width += tileWidth * (tilesX - 2);
        }
        
        if (tilesY > 1) {
            height += lastSize[1];
            height += tileHeight * (tilesY - 2);
        }
        
        return {
            width: width,
            height: height
            };
    }
    
    function getTilesFromPixels(partParams) {
        var numResolutionLevelsToCut =
            partParams.numResolutionLevelsToCut;

        var tileWidth = getTileWidth(numResolutionLevelsToCut);
        var tileHeight = getTileHeight(numResolutionLevelsToCut);
        
        var firstTileWidth = getFirstTileWidth(numResolutionLevelsToCut);
        var firstTileHeight = getFirstTileHeight(numResolutionLevelsToCut);
        
        var startXNoFirst = (partParams.minX - firstTileWidth) / tileWidth;
        var startYNoFirst = (partParams.minY - firstTileHeight) / tileHeight;
        var endXNoFirst = (partParams.maxXExclusive - firstTileWidth) / tileWidth;
        var endYNoFirst = (partParams.maxYExclusive - firstTileHeight) / tileHeight;
        
        var minTileX = Math.max(0, 1 + startXNoFirst);
        var minTileY = Math.max(0, 1 + startYNoFirst);
        var maxTileX = Math.min(getNumTilesX(), 1 + endXNoFirst);
        var maxTileY = Math.min(getNumTilesY(), 1 + endYNoFirst);

        var bounds = {
            minTileX: Math.floor(minTileX),
            minTileY: Math.floor(minTileY),
            maxTileXExclusive: Math.ceil(maxTileX),
            maxTileYExclusive: Math.ceil(maxTileY)
            };
        
        return bounds;
    }

    function getTileSize(edgeType, numResolutionLevelsToCut) {
        var tileWidth = getTileDimensionSize(
            edgeType.horizontalEdgeType,
            getFirstTileWidth,
            getLevelWidth,
            getTileWidth);
        
        var tileHeight = getTileDimensionSize(
            edgeType.verticalEdgeType,
            getFirstTileHeight,
            getLevelHeight,
            getTileHeight);
        
        if (numResolutionLevelsToCut !== undefined) {
            var scale = 1 << numResolutionLevelsToCut;
            tileWidth = Math.ceil(tileWidth / scale);
            tileHeight = Math.ceil(tileHeight / scale);
        }
        
        return [tileWidth, tileHeight];
    }

    function getTileDimensionSize(
        edgeType, getFirstTileSize, getLevelSize, getNonEdgeTileSize) {
        
        var result;
        
        switch (edgeType) {
            case EDGE_TYPE_FIRST:
                result = getFirstTileSize();
                break;
            
            case EDGE_TYPE_LAST:
                var nonEdgeTileSize = getNonEdgeTileSize();
                var widthWithoutFirst = getLevelSize() - getFirstTileSize();
                result = widthWithoutFirst % nonEdgeTileSize;
                
                if (result === 0) {
                    result = nonEdgeTileSize;
                }
                
                break;
            
            case EDGE_TYPE_NO_EDGE:
                result = getNonEdgeTileSize();
                break;
            
            default:
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'Unexpected edge type: ' + edgeType);
        }
        
        return result;
    }
    function isEdgeTileId(tileId) {
        var numTilesX = getNumTilesX();
        var numTilesY = getNumTilesY();
        
        var tileX = tileId % numTilesX;
        var tileY = Math.floor(tileId / numTilesX);
        
        if (tileY > numTilesY || tileX < 0 || tileY < 0) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'Tile index ' + tileId + ' is not in range');
        }
        
        var horizontalEdge =
            tileX === 0 ? EDGE_TYPE_FIRST :
            tileX === (numTilesX - 1) ? EDGE_TYPE_LAST :
            EDGE_TYPE_NO_EDGE;
        
        var verticalEdge =
            tileY === 0 ? EDGE_TYPE_FIRST :
            tileY === (numTilesY - 1) ? EDGE_TYPE_LAST :
            EDGE_TYPE_NO_EDGE;
        
        var result = {
            horizontalEdgeType: horizontalEdge,
            verticalEdgeType: verticalEdge
            };
        
        return result;
    }

    function getNumTilesX() {
        var numTilesX = Math.ceil(params.imageWidth / params.tileWidth);
        return numTilesX;
    }
    
    function getNumTilesY() {
        var numTilesY = Math.ceil(params.imageHeight / params.tileHeight);
        return numTilesY;
    }
    
    function getLevelWidth(numResolutionLevelsToCut) {
        if (numResolutionLevelsToCut === undefined) {
            return params.imageWidth;
        }
        
        var size = getSizeOfPart({
            minX: 0,
            maxXExclusive: params.imageWidth,
            minY: 0,
            maxYExclusive: params.imageHeight,
            numResolutionLevelsToCut: numResolutionLevelsToCut
            });
        
        return size.width;
    }
    
    function getLevelHeight(numResolutionLevelsToCut) {
        if (numResolutionLevelsToCut === undefined) {
            return params.imageHeight;
        }
        
        var size = getSizeOfPart({
            minX: 0,
            maxXExclusive: params.imageWidth,
            minY: 0,
            maxYExclusive: params.imageHeight,
            numResolutionLevelsToCut: numResolutionLevelsToCut
            });
        
        return size.height;
    }

    function getTileWidth(numResolutionLevelsToCut) {
        if (numResolutionLevelsToCut === undefined) {
            return params.tileWidth;
        }
    
        var scale = 1 << numResolutionLevelsToCut;
        var width = Math.ceil(params.tileWidth / scale);
        return width;
    }
    
    function getTileHeight(numResolutionLevelsToCut) {
        if (numResolutionLevelsToCut === undefined) {
            return params.tileHeight;
        }
    
        var scale = 1 << numResolutionLevelsToCut;
        var height = Math.ceil(params.tileHeight / scale);
        return height;
    }
    
    function getFirstTileOffsetX() {
        return params.firstTileOffsetX;
    }
    
    function getFirstTileOffsetY() {
        return params.firstTileOffsetY;
    }

    function getFirstTileWidth(numResolutionLevelsToCut) {
        var firstTileWidthBestLevel =
            getTileWidth() - getFirstTileOffsetX();
        
        var imageWidth = getLevelWidth();
        if (firstTileWidthBestLevel > imageWidth) {
            firstTileWidthBestLevel = imageWidth;
        }
        
        var scale = 1 << numResolutionLevelsToCut;
        var firstTileWidth = Math.ceil(firstTileWidthBestLevel / scale);
        
        return firstTileWidth;
    }
    
    function getFirstTileHeight(numResolutionLevelsToCut) {
        var firstTileHeightBestLevel =
            getTileHeight() - getFirstTileOffsetY();
        
        var imageHeight = getLevelHeight();
        if (firstTileHeightBestLevel > imageHeight) {
            firstTileHeightBestLevel = imageHeight;
        }
        
        var scale = 1 << numResolutionLevelsToCut;
        var firstTileHeight = Math.ceil(firstTileHeightBestLevel / scale);

        return firstTileHeight;
    }

    return this;
};
},{"j2k-jpip-globals.js":12}],3:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipRequestContext = (function JpipRequestContext() {
    var STATUS_ACTIVE = 1;
    var STATUS_WAITING_FOR_USER_INPUT = 2;
    var STATUS_PAUSED = 3;
    var STATUS_ENDED = 4;
    
    var STATUS_ZOMBIE_OF_MOVABLE_REQUEST = 5;
    
    var requestIdCounter = 0;
    var showLogs = false;
    
    function JpipRequestContext(
        jpipObjects, codestreamPartParams, callback, progressiveness, options) {
        
        var disableServerRequests = options.disableServerRequests;
        var isMovable = options.isMovable;
        var userContextVars = options.userContextVars;
        var failureCallback = options.failureCallback;
        var lastServerRequest = null;
        var statusWhenFinished = isMovable ?
            STATUS_ZOMBIE_OF_MOVABLE_REQUEST: STATUS_WAITING_FOR_USER_INPUT;
        
        var requester = jpipObjects.requester;
        var reconstructor = jpipObjects.reconstructor;
        var packetsDataCollector = jpipObjects.packetsDataCollector;
        var qualityLayersCache = jpipObjects.qualityLayersCache;
        var codestreamStructure = jpipObjects.codestreamStructure;
        var databinsSaver = jpipObjects.databinsSaver;
        var jpipFactory = jpipObjects.jpipFactory;
        
        var listener = null;
        
        var self = this;
        var progressiveStagesFinished = 0;
        var alreadyReturnedCodeblocks = null;
        var qualityLayersReached = 0;

        var status = getInitialStatus(codestreamPartParams, isMovable);
        
        var isFailure = false;
        var isWaitingForQualityLayer = false;
        var isWaitingForServer = false;
        var isRequestDone = false;
        
        var dedicatedChannelHandle = options.dedicatedChannelHandle;
        
        var requestId = ++requestIdCounter;
        
        this.getRequestId = function getRequestId() {
            return requestId;
        };
        
        this.createMovedRequest = function move(
            newCodestreamPartParams, newProgressiveness) {
            
            // TODO: Move logic of casting progressiveness from the
            // codestreamClient to here
            
            if (!isMovable) {
                throw new jGlobals.jpipExceptions.InvalidOperationException(
                    'createMovedRequest() is supported only for movable ' +
                    'requests. Create the request with options.isMovable = true');
            }
            
            ensureNoFailure();

            updateStatus(STATUS_ENDED, 'createMovedRequest()');
            
            var modifiedOptions = options;
            if (options.dedicatedChannelHandle === undefined &&
                dedicatedChannelHandle !== undefined) {
                
                modifiedOptions = Object.create(options);
                modifiedOptions.dedicatedChannelHandle = dedicatedChannelHandle;
            }
            
            var requestContext = new JpipRequestContext(
                jpipObjects,
                newCodestreamPartParams || codestreamPartParams,
                callback,
                newProgressiveness || progressiveness,
                modifiedOptions);
            
            return requestContext;
        };
        
        this.ignorePreviousFailure = function ignorePreviousFailure() {
            isFailure = false;
        };
        
        this.createCodestream = function createCodestream(
            isOnlyHeadersWithoutBitstream, maxNumQualityLayers) {
            
            ensureNoFailure();
            
            var params = getParamsForDataWriter(maxNumQualityLayers);
            
            var codestream = reconstructor.createCodestreamForRegion(
                params.codestreamPartParams,
                params.minNumQualityLayers,
                isOnlyHeadersWithoutBitstream);
            
            if (codestream === null) {
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'Could not reconstruct codestream although ' +
                    'progressiveness stage has been reached');
            }
            
            return codestream;
        };
        
        this.getNewCodeblocksData = function getNewCodeblocksData(
            maxNumQualityLayers) {
            
            ensureNoFailure();

            if (alreadyReturnedCodeblocks === null) {
                var result = getAllCodeblocksData();
                return result;
            }
            
            var params = getParamsForDataWriter(maxNumQualityLayers);
            var codeblocksData = packetsDataCollector
                .getNewCodeblocksDataAndUpdateReturnedCodeblocks(
                    params.codestreamPartParams,
                    params.minNumQualityLayers,
                    alreadyReturnedCodeblocks);
            
            if (codeblocksData === null) {
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'Could not collect codeblocks although progressiveness ' +
                    'stage has been reached');
            }
            
            return codeblocksData;
        };
        
        this.endAsync = function endAsync() {
            if (isMovable) {
                throw new jGlobals.jpipExceptions.InvalidOperationException(
                    'endAsync() is not supported for movable requests');
            }

            ensureNoFailure();
            ensureNotEnded(status);
            updateStatus(STATUS_ENDED, 'endAsync()');
            
            // NOTE: This will be used when reconnect is implemented, to note
            // that the data related to this request that had been already
            // recieved is not needed to be copied to the new client
        };
        
        this.pauseAsync = function pauseAsync() {
            ensureNoFailure();
            ensureNotEnded(status);
            updateStatus(STATUS_PAUSED, 'pauseAsync()');
        };
        
        this.hasData = function hasData() {
            ensureNoFailure();
            return progressiveStagesFinished > 0;
        };
        
        this.getAllCodeblocksData = getAllCodeblocksData;
        
        this.tryContinueRequest = tryContinueRequest;
        
        function getAllCodeblocksData(maxNumQualityLayers) {
            ensureNoFailure();
            var params = getParamsForDataWriter(maxNumQualityLayers);
            var codeblocks = packetsDataCollector.getAllCodeblocksData(
                params.codestreamPartParams,
                params.minNumQualityLayers);
            
            if (codeblocks.codeblocksData === null) {
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'Could not collect codeblocks although progressiveness ' +
                    'stage has been reached');
            }
            
            alreadyReturnedCodeblocks = codeblocks.alreadyReturnedCodeblocks;
            return codeblocks.codeblocksData;
        }
        
        function tryContinueRequest() {
            ensureNoFailure();
            ensureNotEnded(status);
            
            if (listener === null) {
                listener = jpipFactory.createRequestDatabinsListener(
                    codestreamPartParams,
                    qualityLayerReachedCallback,
                    codestreamStructure,
                    databinsSaver,
                    qualityLayersCache);
                
                tryAdvanceProgressiveStage();
                isRequestDone = progressiveStagesFinished === progressiveness.length;
            }
            
            if (isWaitingForServer) {
                updateStatus(
                    STATUS_ACTIVE, 'tryContinueRequest(): isWaitingForServer');
                
                if (isRequestDone) {
                    throw new jGlobals.jpipExceptions.InternalErrorException(
                        'Inconsistent state: isWaitingForServer=true, ' +
                        'needMoreRequests=false');
                }
                
                return !isRequestDone;
            }
            
            if (isRequestDone) {
                updateStatus(
                    statusWhenFinished,
                    'tryContinueRequest(): !needMoreRequests');

                return !isRequestDone;
            }
            
            isWaitingForQualityLayer = true;
            
            var newStatus = isRequestDone ? statusWhenFinished : STATUS_ACTIVE;
            
            updateStatus(newStatus, 'tryContinueRequest(): end function');
            
            if (isWaitingForServer || disableServerRequests) {
                return !isRequestDone;
            }

            // If still waiting for quality layer but no request to server
            // has been done, then request data from server
            
            if (lastServerRequest !== null) {
                requester.stopRequestAsync(lastServerRequest);
            }
                
            isWaitingForServer = true;
            var numQualityLayersToWait =
                progressiveness[progressiveStagesFinished].minNumQualityLayers;
            
            if (isMovable && dedicatedChannelHandle === undefined) {
                dedicatedChannelHandle =
                    requester.dedicateChannelForMovableRequest();
            }
            
            lastServerRequest = requester.requestData(
                codestreamPartParams,
                requesterCallbackOnAllDataRecieved,
                requesterCallbackOnFailure,
                numQualityLayersToWait,
                dedicatedChannelHandle);

            return !isRequestDone;
        }
        
        function requesterCallbackOnAllDataRecieved(request, isResponseDone) {
            if (isResponseDone && request === lastServerRequest) {
                throw new jGlobals.jpipExceptions.IllegalDataException(
                    'JPIP server not returned all data', 'D.3');
            }
        }
        
        function requesterCallbackOnFailure() {
            updateStatus(STATUS_ENDED, 'endAsync()');
            
            if (failureCallback !== undefined) {
                failureCallback(self, userContextVars);
            } else {
                isFailure = true;
            }
        }
        
        function qualityLayerReachedCallback(qualityLayersReached_) {
            qualityLayersReached = qualityLayersReached_;
            
            if (status === STATUS_ENDED) {
                throw new jGlobals.jpipExcpetions.InternalErrorException(
                    'Callback from requestDatabinsListener after request ended');
            }
            
            if (!isWaitingForQualityLayer /* && !disableServerRequests */) {
                return;
            }
            
            if (tryAdvanceProgressiveStage()) {
                isWaitingForQualityLayer = false;
                isWaitingForServer = false;
            }
            
            updateStatus(
                STATUS_WAITING_FOR_USER_INPUT, 'qualityLayerReachedCallback');

            // Do not call callback from within tryContinueRequest() called
            // by the user: avoid recursive calls, he can perform his operations
            // after tryContinueRequest() returns
            
            if (isRequestDone) {
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'Request already done but callback is called');
            }
            
            isRequestDone = progressiveStagesFinished === progressiveness.length;
            callback(self, userContextVars, isRequestDone);

            ensureNotWaitingForUserInput(status);
        }
        
        function tryAdvanceProgressiveStage() {
            var numQualityLayersToWait =
                progressiveness[progressiveStagesFinished].minNumQualityLayers;

            if (qualityLayersReached < numQualityLayersToWait) {
                return false;
            }
            
            if (qualityLayersReached === 'max') {
                progressiveStagesFinished = progressiveness.length;
            }
            
            while (progressiveStagesFinished < progressiveness.length) {
                var qualityLayersRequired =
                    progressiveness[progressiveStagesFinished].minNumQualityLayers;
                
                if (qualityLayersRequired === 'max' ||
                    qualityLayersRequired > qualityLayersReached) {
                    
                    break;
                }
                
                ++progressiveStagesFinished;
            }
            
            return true;
        }
        
        function getParamsForDataWriter(maxNumQualityLayers) {
            ensureNotEnded(status, /*allowZombie=*/true);
            
            if (codestreamPartParams === null) {
                throw new jGlobals.jpipExceptions.InvalidOperationException('Cannot ' +
                    'get data of zombie request with no codestreamPartParams');
            }
            
            var isRequestDone = progressiveStagesFinished === progressiveness.length;
            if (!isRequestDone) {
                ensureNotWaitingForUserInput(status);
            }
            
            if (progressiveStagesFinished === 0) {
                throw new jGlobals.jpipExceptions.IllegalOperationException(
                    'Cannot create codestream before first progressiveness ' +
                    'stage has been reached');
            }
            
            var minNumQualityLayers =
                progressiveness[progressiveStagesFinished - 1].minNumQualityLayers;
            
            var newParams = codestreamPartParams;
            if (maxNumQualityLayers !== undefined) {
                newParams = Object.create(codestreamPartParams);
                newParams.maxNumQualityLayers = maxNumQualityLayers;
                
                if (minNumQualityLayers !== 'max') {
                    minNumQualityLayers = Math.min(
                        minNumQualityLayers, maxNumQualityLayers);
                }
            }
            
            return {
                codestreamPartParams: newParams,
                minNumQualityLayers: minNumQualityLayers
                };
        }
        
        function updateStatus(newStatus, location) {
            if (showLogs) {
                /* global console: false */
                console.log('Request ' + requestId + ' status changed: ' +
                    status + ' -> ' + newStatus + ' (' + location + ')');
            }
            
            if (listener !== null && newStatus === STATUS_ENDED) {
                listener.unregister();
                listener = null;
            }

            status = newStatus;
            
            if (newStatus !== STATUS_PAUSED && newStatus !== STATUS_ENDED) {
                return;
            }
            
            if (lastServerRequest !== null) {
                requester.stopRequestAsync(lastServerRequest);
                lastServerRequest = null;
            }
        }

        function ensureNoFailure() {
            if (isFailure) {
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'An error occurred while previous request from server. ' +
                    'Use ignorePreviousFailure() to ignore and continue');
            }
        }
    }
    
    function ensureNotEnded(status, allowZombie) {
        var notEndedDescription =
            'Cannot perform this operation after request ended';
        
        ensureNoStatus(status, STATUS_ENDED, notEndedDescription);
        
        if (allowZombie) {
            return;
        }
        
        var noZombieDescription =
            'Cannot perform this operation on zombie request (= request with ' +
            'codestreamPartParams = null, used as the first request of ' +
            'movable request';
        
        ensureNoStatus(
            status,
            STATUS_ZOMBIE_OF_MOVABLE_REQUEST,
            noZombieDescription);
    }
    
    function ensureNotWaitingForUserInput(status) {
        var description =
            'Call for endAsync(), pauseAsync() or tryContinueRequest() has ' +
                'not been performed';
                
        ensureNoStatus(status, STATUS_WAITING_FOR_USER_INPUT, description);
    }
    
    function ensureNoStatus(status, unexpectedStatus, exceptionDescription) {
        if (status === unexpectedStatus) {
            throw new jGlobals.jpipExceptions.IllegalOperationException(
                exceptionDescription);
        }
    }
    
    function getInitialStatus(codestreamPartParams, isMovable) {
        if (codestreamPartParams !== null) {
            return STATUS_PAUSED;
        } else if (isMovable) {
            return STATUS_ZOMBIE_OF_MOVABLE_REQUEST;
        }
        
        throw new jGlobals.jpipExceptions.ArgumentException(
            'codestreamPartParams',
            codestreamPartParams,
            'Non movable request must  have codestreamPartParams !== null');
    }
    
    return JpipRequestContext;
})();
},{"j2k-jpip-globals.js":12}],4:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.CompositeArray = function CompositeArray(offset) {
    var length = 0;
    var internalParts = [];
    
    this.getLength = function getLength() {
        return length;
    };

    this.getOffset = function getOffset() {
        return offset;
    };
        
    this.pushSubArray = function pushSubArray(subArray) {
        internalParts.push(subArray);
        length += subArray.length;
    };
    
    this.copyToOtherAtTheEnd = function copyToOtherAtTheEnd(result, minOffset, maxOffset) {
        checkOffsetsToCopy(minOffset, maxOffset);
        
        var iterator = getInternalPartsIterator(minOffset, maxOffset);
        
        // NOTE: What if data not in first part?
        
        while (tryAdvanceIterator(iterator)) {
            result.pushSubArray(iterator.subArray);
        }
    };

    this.copyToTypedArray = function copyToTypedArray(
        resultArray, resultArrayOffset, minOffset, maxOffset) {
        
        checkOffsetsToCopy(minOffset, maxOffset);
        
        var iterator = getInternalPartsIterator(minOffset, maxOffset);
        
        // NOTE: What if data not in first part?
        
        while (tryAdvanceIterator(iterator)) {
            var offsetInResult =
                iterator.offset - resultArrayOffset;
            
            resultArray.set(iterator.subArray, offsetInResult);
        }
    };

    this.copyToArray = function copyToArray(
        resultArray, resultArrayOffset, minOffset, maxOffset) {
        
        checkOffsetsToCopy(minOffset, maxOffset);
        
        var iterator = getInternalPartsIterator(minOffset, maxOffset);
        
        // NOTE: What if data not in first part?
        
        while (tryAdvanceIterator(iterator)) {
            var offsetInResult =
                iterator.offset - resultArrayOffset;
            
            for (var j = 0; j < iterator.subArray.length; ++j) {
                resultArray[offsetInResult++] = iterator.subArray[j];
            }
        }
    };
    
    this.copyToOther = function copyToOther(other) {
        if (other.getOffset() > offset) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'CompositeArray: Trying to copy part into a latter part');
        }
        
        var otherEndOffset = other.getOffset() + other.getLength();
        var isOtherContainsThis = offset + length <= otherEndOffset;
        if (isOtherContainsThis) {
            return;
        }
    
        // Do not override already exist data (for efficiency)
        var minOffset = otherEndOffset;
        
        var iterator = getInternalPartsIterator(minOffset);
        
        if (!tryAdvanceIterator(iterator)) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'CompositeArray: Could not merge parts');
        }
        
        var expectedOffsetValue = minOffset;

        do {
            if (iterator.offset !== expectedOffsetValue) {
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'CompositeArray: Non-continuous value of ' +
                    'rangeToCopy.offset. Expected: ' + expectedOffsetValue +
                     ', Actual: ' + iterator.offset);
            }
            
            other.pushSubArray(iterator.subArray);
            expectedOffsetValue += iterator.subArray.length;
        } while (tryAdvanceIterator(iterator));
    };
    
    function checkOffsetsToCopy(minOffset, maxOffset) {
        if (minOffset === undefined || maxOffset === undefined) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'minOffset or maxOffset is undefined for CompositeArray.copyToArray');
        }
        
        if (minOffset < offset) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'minOffset (' + minOffset + ') must be smaller than ' +
                'CompositeArray offset (' + offset + ')');
        }
        
        if (maxOffset > offset + length) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'maxOffset (' + maxOffset + ') must be larger than ' +
                'CompositeArray end offset (' + offset + length + ')');
        }
    }
    
    function getInternalPartsIterator(minOffset, maxOffset) {
        var start = Math.max(offset, minOffset);

        var end = offset + length;
        if (maxOffset !== undefined) {
            end = Math.min(end, maxOffset);
        }
        
        if (start >= end) {
            var emptyIterator = {
                internalIteratorData: { isEndOfRange: true }
            };
            
            return emptyIterator;
        }
        
        var iterator = {
            subArray: null,
            offset: -1,
            
            internalIteratorData: {
                end: end,
                currentSubArray: null,
                currentInternalPartOffset: null,
                nextInternalPartOffset: offset,
                currentInternalPartIndex: -1,
                isEndOfRange: false
            }
        };
        
        var alreadyReachedToTheEnd = false;
        do {
            if (alreadyReachedToTheEnd) {
                throw new jGlobals.jpipExceptions.InternalErrorException('Iterator reached ' +
                    'to the end although no data has been iterated');
            }
            
            alreadyReachedToTheEnd = !tryAdvanceIterator(iterator);
        } while (start >= iterator.internalIteratorData.nextInternalPartOffset);
        
        var cutFirstSubArray =
            start - iterator.internalIteratorData.currentInternalPartOffset;
        iterator.internalIteratorData.currentSubArray =
            iterator.internalIteratorData.currentSubArray.subarray(cutFirstSubArray);
        iterator.internalIteratorData.currentInternalPartOffset = start;
        
        return iterator;
    }
    
    function tryAdvanceIterator(iterator) {
        var internalIteratorData = iterator.internalIteratorData;
        
        if (internalIteratorData.isEndOfRange) {
            return false;
        }
        
        iterator.subArray = internalIteratorData.currentSubArray;
        iterator.offset = internalIteratorData.currentInternalPartOffset;
        
        ++internalIteratorData.currentInternalPartIndex;
        
        if (internalIteratorData.nextInternalPartOffset >= internalIteratorData.end) {
            internalIteratorData.isEndOfRange = true;

            return true;
        }
        
        ensureNoEndOfArrayReached(internalIteratorData.currentInternalPartIndex);
        
        internalIteratorData.currentSubArray = internalParts[
            internalIteratorData.currentInternalPartIndex];
        internalIteratorData.currentInternalPartOffset =
            internalIteratorData.nextInternalPartOffset;
        var currentInternalPartLength =
            internalParts[internalIteratorData.currentInternalPartIndex].length;
        
        internalIteratorData.nextInternalPartOffset =
            internalIteratorData.currentInternalPartOffset + currentInternalPartLength;

        var cutLastSubArray =
            internalIteratorData.end - internalIteratorData.currentInternalPartOffset;
        var isLastSubArray =
            cutLastSubArray < internalIteratorData.currentSubArray.length;
        
        if (isLastSubArray) {
            internalIteratorData.currentSubArray = internalIteratorData
                .currentSubArray.subarray(0, cutLastSubArray);
        }
        
        return true;
    }
    
    function ensureNoEndOfArrayReached(currentInternalPartIndex) {
        if (currentInternalPartIndex >= internalParts.length) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'CompositeArray: end of part has reached. Check end calculation');
        }
    }
};
},{"j2k-jpip-globals.js":12}],5:[function(require,module,exports){
'use strict';

// A.2.1.

module.exports.JpipDatabinParts = function JpipDatabinParts(
    classId, inClassId, jpipFactory) {

    var self = this;

    var parts = [];
    var databinLengthIfKnown = null;
    var loadedBytes = 0;
    
    var cachedData = [];
    
    this.getDatabinLengthIfKnown = function() {
        return databinLengthIfKnown;
    };
    
    this.getLoadedBytes = function getLoadedBytes() {
        return loadedBytes;
    };
    
    this.isAllDatabinLoaded = function isAllDatabinLoaded() {
        var result;
        
        switch (parts.length) {
            case 0:
                result = databinLengthIfKnown === 0;
                break;
                
            case 1:
                result =
                    parts[0].getOffset() === 0 &&
                    parts[0].getLength() === databinLengthIfKnown;
                break;
            
            default:
                result = false;
                break;
        }
        
        return result;
    };
    
    this.getCachedData = function getCachedData(key) {
        var obj = cachedData[key];
        if (obj === undefined) {
            obj = {};
            cachedData[key] = obj;
        }
        
        return obj;
    };
    
    this.getClassId = function getClassId() {
        return classId;
    };
    
    this.getInClassId = function getInClassId() {
        return inClassId;
    };
    
    this.copyToCompositeArray = function copyToCompositeArray(result, rangeOptions) {
        var dummyResultStartOffset = 0;
        var params = getParamsForCopyBytes(dummyResultStartOffset, rangeOptions);
        
        if (params.resultWithoutCopy !== undefined) {
            return params.resultWithoutCopy;
        }
        
        var maxLengthCopied = iterateRange(
            params.databinStartOffset,
            params.maxLengthToCopy,
            function addPartToResultInCopyToCompositeArray(part, minOffsetInPart, maxOffsetInPart) {
                part.copyToOtherAtTheEnd(
                    result,
                    minOffsetInPart,
                    maxOffsetInPart);
            });
        
        return maxLengthCopied;
    };
    
    this.copyBytes = function(resultArray, resultStartOffset, rangeOptions) {
        var params = getParamsForCopyBytes(resultStartOffset, rangeOptions);
        
        if (params.resultWithoutCopy !== undefined) {
            return params.resultWithoutCopy;
        }
        
        var resultArrayOffsetInDatabin = params.databinStartOffset - params.resultStartOffset;
        
        var maxLengthCopied = iterateRange(
            params.databinStartOffset,
            params.maxLengthToCopy,
            function addPartToResultInCopyBytes(part, minOffsetInPart, maxOffsetInPart) {
                part.copyToArray(
                    resultArray,
                    resultArrayOffsetInDatabin,
                    minOffsetInPart,
                    maxOffsetInPart);
            });
        
        return maxLengthCopied;
    };
    
    this.getExistingRanges = function() {
        var result = new Array(parts.length);
        
        for (var i = 0; i < parts.length; ++i) {
            result[i] = {
                start: parts[i].getOffset(),
                length: parts[i].getLength()
                };
        }
        
        return result;
    };
    
    this.addData = function(header, message) {
        if (header.isLastByteInDatabin) {
            databinLengthIfKnown = header.messageOffsetFromDatabinStart + header.messageBodyLength;
        }
        
        if (header.messageBodyLength === 0) {
            return;
        }

        var newPart = jpipFactory.createCompositeArray(
            header.messageOffsetFromDatabinStart);

        var endOffsetInMessage = header.bodyStart + header.messageBodyLength;
        newPart.pushSubArray(message.subarray(header.bodyStart, endOffsetInMessage));

        // Find where to push the new message
        
        var indexFirstPartAfter = findFirstPartAfterOffset(header.messageOffsetFromDatabinStart);
        var indexFirstPartNearOrAfter = indexFirstPartAfter;

        if (indexFirstPartAfter > 0) {
            var previousPart = parts[indexFirstPartAfter - 1];
            var previousPartEndOffset =
                previousPart.getOffset() + previousPart.getLength();
            
            if (previousPartEndOffset === header.messageOffsetFromDatabinStart) {
                // Can merge also previous part
                --indexFirstPartNearOrAfter;
            }
        }

        if (indexFirstPartNearOrAfter >= parts.length) {
            parts.push(newPart);
            loadedBytes += header.messageBodyLength;
            
            return;
        }
        
        var firstPartNearOrAfter = parts[indexFirstPartNearOrAfter];
        var endOffsetInDatabin =
            header.messageOffsetFromDatabinStart + header.messageBodyLength;
        if (firstPartNearOrAfter.getOffset() > endOffsetInDatabin) {
            // Not found an overlapping part, push a new
            // part in the middle of the parts array
                
            for (var i = parts.length; i > indexFirstPartNearOrAfter; --i) {
                parts[i] = parts[i - 1];
            }
            
            parts[indexFirstPartNearOrAfter] = newPart;
            loadedBytes += header.messageBodyLength;

            return;
        }
        
        // Merge first and last overlapping parts - all the rest (if any) are in the middle of the new part
        
        var bytesAlreadySaved = firstPartNearOrAfter.getLength();

        var shouldSwap =
            firstPartNearOrAfter.getOffset() > header.messageOffsetFromDatabinStart;
        if (shouldSwap) {
            parts[indexFirstPartNearOrAfter] = newPart;
            newPart = firstPartNearOrAfter;
            
            firstPartNearOrAfter = parts[indexFirstPartNearOrAfter];
        }

        newPart.copyToOther(firstPartNearOrAfter);
        
        var endOffset =
            firstPartNearOrAfter.getOffset() + firstPartNearOrAfter.getLength();
        
        var partToMergeIndex;
        for (partToMergeIndex = indexFirstPartNearOrAfter;
            partToMergeIndex < parts.length - 1;
            ++partToMergeIndex) {
            
            if (endOffset < parts[partToMergeIndex + 1].getOffset()) {
                break;
            }
            
            bytesAlreadySaved += parts[partToMergeIndex + 1].getLength();
        }
        
        var partsToDelete = partToMergeIndex - indexFirstPartNearOrAfter;
        if (partsToDelete > 0) {
            parts[partToMergeIndex].copyToOther(firstPartNearOrAfter);
            
            // Delete all middle and merged parts except 1
            
            for (var j = indexFirstPartNearOrAfter + 1; j < parts.length - partsToDelete; ++j) {
                parts[j] = parts[j + partsToDelete];
            }
            
            parts.length -= partsToDelete;
        }
        
        loadedBytes += firstPartNearOrAfter.getLength() - bytesAlreadySaved;
    };
    
    function getParamsForCopyBytes(resultStartOffset, rangeOptions) {
        var forceCopyAllRange = false;
        var databinStartOffset = 0;
        var maxLengthToCopy;
        
        if (rangeOptions !== undefined) {
            forceCopyAllRange = !!rangeOptions.forceCopyAllRange;
            databinStartOffset = rangeOptions.databinStartOffset;
            maxLengthToCopy = rangeOptions.maxLengthToCopy;
            
            if (databinStartOffset === undefined) {
                databinStartOffset = 0;
            }
        }
        
        if (resultStartOffset === undefined) {
            resultStartOffset = 0;
        }
        
        if (maxLengthToCopy === 0) {
            return { resultWithoutCopy: 0 };
        }
        
        if ((databinLengthIfKnown !== null) && (databinStartOffset >= databinLengthIfKnown)) {
            return { resultWithoutCopy: (!!maxLengthToCopy && forceCopyAllRange ? null : 0) };
        }
        
        var firstRelevantPartIndex = findFirstPartAfterOffset(databinStartOffset);
        
        if (firstRelevantPartIndex === parts.length) {
            return { resultWithoutCopy: (forceCopyAllRange ? null : 0) };
        }
        
        if (forceCopyAllRange) {
            var isAllRequestedRangeExist =
                isAllRangeExist(databinStartOffset, maxLengthToCopy, firstRelevantPartIndex);
            
            if (!isAllRequestedRangeExist) {
                return { resultWithoutCopy: null };
            }
        }
        
        var params = {
            databinStartOffset: databinStartOffset,
            maxLengthToCopy: maxLengthToCopy,
            resultStartOffset: resultStartOffset
            };
        
        return params;
    }
    
    function isAllRangeExist(
        databinStartOffset, maxLengthToCopy, firstRelevantPartIndex) {
        
        if (parts[firstRelevantPartIndex].getOffset() > databinStartOffset) {
            return false;
        }
        
        if (maxLengthToCopy) {
            var unusedElements =
                databinStartOffset - parts[firstRelevantPartIndex].getOffset();
            var availableLength =
                parts[firstRelevantPartIndex].getLength() - unusedElements;
            
            var isUntilMaxLengthExist = availableLength >= maxLengthToCopy;
            return isUntilMaxLengthExist;
        }
        
        if (databinLengthIfKnown === null ||
            firstRelevantPartIndex < parts.length - 1) {
            
            return false;
        }
        
        var lastPart = parts[parts.length - 1];
        var endOffsetRecieved = lastPart.getOffset() + lastPart.getLength();
        
        var isUntilEndOfDatabinExist = endOffsetRecieved === databinLengthIfKnown;
        return isUntilEndOfDatabinExist;
    }
    
    function iterateRange(
            databinStartOffset,
            maxLengthToCopy,
        addSubPartToResult) {
        
        var minOffsetInDatabinToCopy = databinStartOffset;
        
        var maxOffsetInDatabinToCopy;
        if (maxLengthToCopy !== undefined) {
            maxOffsetInDatabinToCopy = databinStartOffset + maxLengthToCopy;
        } else {
            var lastPart = parts[parts.length - 1];
            maxOffsetInDatabinToCopy = lastPart.getOffset() + lastPart.getLength();
        }
                
        var lastCopiedPart = null;
        
        for (var i = 0; i < parts.length; ++i) {
            if (parts[i].getOffset() >= maxOffsetInDatabinToCopy) {
                break;
            }
            
            var currentMinOffsetInDatabinToCopy = Math.max(
                minOffsetInDatabinToCopy, parts[i].getOffset());
            var currentMaxOffsetInDatabinToCopy = Math.min(
                maxOffsetInDatabinToCopy, parts[i].getOffset() + parts[i].getLength());
        
            addSubPartToResult(
                parts[i],
                currentMinOffsetInDatabinToCopy,
                currentMaxOffsetInDatabinToCopy);
            
            lastCopiedPart = parts[i];
        }
        
        if (lastCopiedPart === null) {
            return 0;
        }
        
        var lastOffsetCopied = Math.min(
            lastCopiedPart.getOffset() + lastCopiedPart.getLength(),
            maxOffsetInDatabinToCopy);
        
        var maxLengthCopied = lastOffsetCopied - databinStartOffset;
        return maxLengthCopied;
    }

    function findFirstPartAfterOffset(offset) {
        var index;
        for (index = 0; index < parts.length; ++index) {
            if (parts[index].getOffset() + parts[index].getLength() > offset) {
                break;
            }
        }
        
        return index;
    }
    
    return this;
};
},{}],6:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipDatabinsSaver = function JpipDatabinsSaver(isJpipTilePartStream, jpipFactory) {
    var PRECINCT_NO_AUX_CLASS = 0;
    var PRECINCT_WITH_AUX_CLASS = 1;
    var TILE_HEADER_CLASS = 2;
    var TILE_NO_AUX_CLASS = 4;
    var TILE_WITH_AUX_CLASS = 5;

    var databinsByClass = [];
    var forbiddenInJpp = [];
    var forbiddenInJpt = [];
    
    var loadedBytes = 0;
    var loadedBytesInRegisteredDatabins = 0;

    // Valid only if isJpipTilePartStream = false
    
    databinsByClass[TILE_HEADER_CLASS] = createDatabinsArray();
    databinsByClass[PRECINCT_NO_AUX_CLASS] = createDatabinsArray();
    databinsByClass[PRECINCT_WITH_AUX_CLASS] = databinsByClass[
        PRECINCT_NO_AUX_CLASS];
    
    forbiddenInJpt[TILE_HEADER_CLASS] = true;
    forbiddenInJpt[PRECINCT_NO_AUX_CLASS] = true;
    forbiddenInJpt[PRECINCT_WITH_AUX_CLASS] = true;
    
    // Valid only if isJpipTilePartStream = true

    databinsByClass[TILE_NO_AUX_CLASS] = createDatabinsArray();
    databinsByClass[TILE_WITH_AUX_CLASS] = databinsByClass[
        TILE_NO_AUX_CLASS];
    
    forbiddenInJpp[TILE_NO_AUX_CLASS] = true;
    forbiddenInJpp[TILE_WITH_AUX_CLASS] = true;
    
    var mainHeaderDatabin = jpipFactory.createDatabinParts(6, 0);
    
    this.getIsJpipTilePartStream = function() {
        return isJpipTilePartStream;
    };
    
    this.getLoadedBytes = function getLoadedBytes() {
        return loadedBytes;
    };

    this.getMainHeaderDatabin = function () {
        return mainHeaderDatabin;
    };
    
    this.getTileHeaderDatabin = function(inClassIndex) {
        var databin = getDatabinFromArray(
            databinsByClass[TILE_HEADER_CLASS],
            TILE_HEADER_CLASS,
            inClassIndex,
            /*isJpipTilePartStreamExpected=*/false,
            'tileHeader');
        
        return databin;
    };
    
    this.getPrecinctDatabin = function(inClassIndex) {
        var databin = getDatabinFromArray(
            databinsByClass[PRECINCT_NO_AUX_CLASS],
            PRECINCT_NO_AUX_CLASS,
            inClassIndex,
            /*isJpipTilePartStreamExpected=*/false,
            'precinct');
        
        return databin;
    };
    
    this.getTileDatabin = function(inClassIndex) {
        var databin = getDatabinFromArray(
            databinsByClass[TILE_NO_AUX_CLASS],
            TILE_NO_AUX_CLASS,
            inClassIndex,
            /*isJpipTilePartStreamExpected=*/true,
            'tilePart');
        
        return databin;
    };
    
    this.addEventListener = function addEventListener(
        databin, event, listener, listenerThis) {
        
        if (event !== 'dataArrived') {
            throw new jGlobals.jpipExceptions.InternalErrorException('Unsupported event: ' +
                event);
        }
        
        var classId = databin.getClassId();
        var inClassId = databin.getInClassId();
        var databinsArray = databinsByClass[classId];
        
        if (databin !== databinsArray.databins[inClassId]) {
            throw new jGlobals.jpipExceptions.InternalErrorException('Unmatched databin ' +
                'with class-ID=' + classId + ' and in-class-ID=' + inClassId);
        }
        
        if (databinsArray.listeners[inClassId] === undefined) {
            databinsArray.listeners[inClassId] = [];
        }
        
        if (databinsArray.listeners[inClassId].length === 0) {
            loadedBytesInRegisteredDatabins += databin.getLoadedBytes();
        }
        
        databinsArray.listeners[inClassId].push({
            listener: listener,
            listenerThis: listenerThis
            });
        
        databinsArray.databinsWithListeners[inClassId] = databin;
    };
    
    this.removeEventListener = function removeEventListener(
        databin, event, listener) {
        
        if (event !== 'dataArrived') {
            throw new jGlobals.jpipExceptions.InternalErrorException('Unsupported event: ' +
                event);
        }

        var classId = databin.getClassId();
        var inClassId = databin.getInClassId();
        var databinsArray = databinsByClass[classId];
        var listeners = databinsArray.listeners[inClassId];
        
        if (databin !== databinsArray.databins[inClassId] ||
            databin !== databinsArray.databinsWithListeners[inClassId]) {
            
            throw new jGlobals.jpipExceptions.InternalErrorException('Unmatched databin ' +
                'with class-ID=' + classId + ' and in-class-ID=' + inClassId);
        }
        
        for (var i = 0; i < listeners.length; ++i) {
            if (listeners[i].listener === listener) {
                listeners[i] = listeners[listeners.length - 1];
                listeners.length -= 1;
                
                if (listeners.length === 0) {
                    delete databinsArray.databinsWithListeners[inClassId];
                    loadedBytesInRegisteredDatabins -= databin.getLoadedBytes();
                }
                
                return;
            }
        }
        
        throw new jGlobals.jpipExceptions.InternalErrorException(
            'Could not unregister listener from databin');
    };
    
    this.cleanupUnregisteredDatabins = function cleanupUnregisteredDatabins() {
        for (var i = 0; i < databinsByClass.length; ++i) {
            if (databinsByClass[i] === undefined) {
                continue;
            }
            
            var databins = databinsByClass[i].databinsWithListeners;
            databinsByClass[i].databins = databins.slice();
        }
        
        loadedBytes = loadedBytesInRegisteredDatabins;
    };

    this.saveData = function (header, message) {
        // A.2.2
        
        if (header.codestreamIndex !== 0) {
            throw new jGlobals.jpipExceptions.UnsupportedFeatureException(
                'Non zero Csn (Code Stream Index)', 'A.2.2');
        }
        
        switch (header.classId) {
            case 6:
                saveMainHeader(header, message);
                break;
                
            case 8:
                saveMetadata(header, message);
                break;
            
            default:
                // A.3.2, A.3.3, A.3.4
                
                var databinsArray = databinsByClass[header.classId];
                if (databinsArray === undefined) {
                    break; // A.2.2
                }
                
                var isJptExpected = !!forbiddenInJpp[header.classId];
                var databin = getDatabinFromArray(
                    databinsArray,
                    header.classId,
                    header.inClassId,
                    isJptExpected,
                    '<class ID ' + header.classId + '>');
                
                var bytesBefore = databin.getLoadedBytes();
                databin.addData(header, message);
                var bytesDifference = databin.getLoadedBytes() - bytesBefore;
                loadedBytes += bytesDifference;
                
                var listeners = databinsArray.listeners;
                var databinListeners = listeners[header.inClassId];
                
                if (databinListeners !== undefined && databinListeners.length > 0) {
                    loadedBytesInRegisteredDatabins += bytesDifference;
                    
                    var localListeners = databinListeners.slice();
                    
                    for (var i = 0; i < localListeners.length; ++i) {
                        var listener = localListeners[i];
                        listener.listener.call(listener.listenerThis, databin);
                    }
                }
                
                break;
        }
    };
    
    function saveMainHeader(header, message) {
        // A.3.5
        
        if (header.inClassId !== 0) {
            throw new jGlobals.jpipExceptions.IllegalDataException('Main header data-bin with ' +
                'in-class index other than zero is not valid', 'A.3.5');
        }
        
        var bytesBefore = mainHeaderDatabin.getLoadedBytes();
        mainHeaderDatabin.addData(header, message);
        var bytesDifference = mainHeaderDatabin.getLoadedBytes() - bytesBefore;
        
        loadedBytes += bytesDifference;
        loadedBytesInRegisteredDatabins += bytesDifference;
    }
    
    function saveMetadata(header, message) {
        // A.3.6
        
        // throw new jGlobals.jpipExceptions.UnsupportedFeatureException('recieve metadata-bin', 'A.3.6');
        
        // ignore unused metadata (legal according to A.2.2).
    }
    
    function getDatabinFromArray(
        databinsArray,
        classId,
        inClassId,
        isJpipTilePartStreamExpected,
        databinTypeDescription) {
        
        if (isJpipTilePartStreamExpected !== isJpipTilePartStream) {
            throw new jGlobals.jpipExceptions.WrongStreamException('databin of type ' +
                databinTypeDescription, isJpipTilePartStream);
        }
        
        var databin = databinsArray.databins[inClassId];
        if (!databin) {
            databin = jpipFactory.createDatabinParts(classId, inClassId);
            databinsArray.databins[inClassId] = databin;
        }
        
        return databin;
    }
    
    function createDatabinsArray() {
        return {
            databins: [],
            listeners: [],
            databinsWithListeners: []
            };
    }
    
    return this;
};
},{"j2k-jpip-globals.js":12}],7:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipObjectPoolByDatabin = function JpipObjectPoolByDatabin() {
    var databinIdToObject = [];
    
    this.getObject = function getObject(databin) {
        var classId = databin.getClassId();
        var inClassIdToObject = databinIdToObject[classId];
        
        if (inClassIdToObject === undefined) {
            inClassIdToObject = [];
            databinIdToObject[classId] = inClassIdToObject;
        }
        
        var inClassId = databin.getInClassId();
        var obj = inClassIdToObject[inClassId];
        
        if (obj === undefined) {
            obj = {};
            obj.databin = databin;
            
            inClassIdToObject[inClassId] = obj;
        } else if (obj.databin !== databin) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'Databin IDs are not unique');
        }
        
        return obj;
    };
};
},{"j2k-jpip-globals.js":12}],8:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipRequestDatabinsListener = function JpipRequestDatabinsListener(
    codestreamPartParams,
    qualityLayerReachedCallback,
    codestreamStructure,
    databinsSaver,
    qualityLayersCache,
    jpipFactory) {
    
    var numQualityLayersToWaitFor;
    var tileHeadersNotLoaded = 0;
    var minNumQualityLayersReached = 0;
    var unregistered = false;
    
    var registeredTileHeaderDatabins = [];
    var registeredPrecinctDatabins = [];
    var accumulatedDataPerDatabin = jpipFactory.createObjectPoolByDatabin();
    var precinctCountByReachedQualityLayer = [];
    
    register();
    
    this.unregister = function unregister() {
        if (unregistered) {
            return;
        }
    
        for (var i = 0; i < registeredTileHeaderDatabins.length; ++i) {
            databinsSaver.removeEventListener(
                registeredTileHeaderDatabins[i],
                'dataArrived',
                tileHeaderDataArrived);
        }
        
        for (var j = 0; j < registeredPrecinctDatabins.length; ++j) {
            databinsSaver.removeEventListener(
                registeredPrecinctDatabins[j],
                'dataArrived',
                precinctDataArrived);
        }
        
        unregistered = true;
    };
    
    function register() {
        ++tileHeadersNotLoaded;
        
        var tileIterator = codestreamStructure.getTilesIterator(codestreamPartParams);
        do {
            var tileIndex = tileIterator.tileIndex;
            var databin = databinsSaver.getTileHeaderDatabin(tileIndex);
            registeredTileHeaderDatabins.push(databin);
            
            databinsSaver.addEventListener(
                databin, 'dataArrived', tileHeaderDataArrived);
                
            ++tileHeadersNotLoaded;
            tileHeaderDataArrived(databin);
        } while (tileIterator.tryAdvance());
        
        --tileHeadersNotLoaded;
        tryAdvanceQualityLayersReached();
    }
    
    function tileHeaderDataArrived(tileHeaderDatabin) {
        if (!tileHeaderDatabin.isAllDatabinLoaded()) {
            return;
        }
        
        var tileAccumulatedData = accumulatedDataPerDatabin.getObject(
            tileHeaderDatabin);
        
        if (tileAccumulatedData.isAlreadyLoaded) {
            return;
        }
        
        tileAccumulatedData.isAlreadyLoaded = true;
        --tileHeadersNotLoaded;
        
        var tileIndex = tileHeaderDatabin.getInClassId();
        var tileStructure = codestreamStructure.getTileStructure(tileIndex);
        var maxNumQualityLayersInTile = tileStructure.getNumQualityLayers();
        
        var precinctIterator = tileStructure.getPrecinctIterator(
            tileIndex, codestreamPartParams);

        do {
            if (!precinctIterator.isInCodestreamPart) {
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'Unexpected precinct not in codestream part');
            }
            
            var inClassId = tileStructure.precinctPositionToInClassIndex(
                precinctIterator);
                
            var precinctDatabin = databinsSaver.getPrecinctDatabin(inClassId);
            registeredPrecinctDatabins.push(precinctDatabin);
            var accumulatedData = accumulatedDataPerDatabin.getObject(
                precinctDatabin);
            
            if (accumulatedData.maxNumQualityLayersInTile !== undefined) {
                throw new jGlobals.jpipExceptions.InternalErrorException('Tile was ' +
                    'iterated twice in codestream part');
            }
            
            accumulatedData.maxNumQualityLayersInTile = maxNumQualityLayersInTile;
            incrementPrecinctQualityLayers(
                precinctDatabin, accumulatedData, precinctIterator);
            
            databinsSaver.addEventListener(
                precinctDatabin, 'dataArrived', precinctDataArrived);
        } while (precinctIterator.tryAdvance());
        
        tryAdvanceQualityLayersReached();
    }
    
    function precinctDataArrived(precinctDatabin) {
        var accumulatedData = accumulatedDataPerDatabin.getObject(
            precinctDatabin);

        var oldQualityLayersReached = accumulatedData.numQualityLayersReached;
        var maxNumQualityLayersInTile =
            accumulatedData.maxNumQualityLayersInTile;

        if (oldQualityLayersReached === maxNumQualityLayersInTile) {
            return;
        }
        
        --precinctCountByReachedQualityLayer[oldQualityLayersReached];
        incrementPrecinctQualityLayers(precinctDatabin, accumulatedData);
        
        tryAdvanceQualityLayersReached();
    }
    
    function incrementPrecinctQualityLayers(
        precinctDatabin, accumulatedData, precinctIteratorOptional) {
        
        var qualityLayers = qualityLayersCache.getQualityLayerOffset(
            precinctDatabin,
            codestreamPartParams.maxNumQualityLayers,
            precinctIteratorOptional);

        var numQualityLayersReached = qualityLayers.numQualityLayers;
        accumulatedData.numQualityLayersReached = numQualityLayersReached;

        var maxNumQualityLayersInTile =
            accumulatedData.maxNumQualityLayersInTile;

        if (numQualityLayersReached === maxNumQualityLayersInTile) {
            return;
        }
        
        var prevCount =
            precinctCountByReachedQualityLayer[numQualityLayersReached] || 0;
        
        precinctCountByReachedQualityLayer[numQualityLayersReached] =
            prevCount + 1;
    }
    
    function tryAdvanceQualityLayersReached() {
        if (precinctCountByReachedQualityLayer[minNumQualityLayersReached] > 0 ||
            minNumQualityLayersReached === 'max' ||
            minNumQualityLayersReached >= numQualityLayersToWaitFor ||
            tileHeadersNotLoaded > 0) {
            
            return;
        }
        
        var hasPrecinctsInQualityLayer;
        var maxQualityLayers = precinctCountByReachedQualityLayer.length;
        
        do {
            ++minNumQualityLayersReached;
            
            if (minNumQualityLayersReached >= maxQualityLayers) {
                minNumQualityLayersReached = 'max';
                break;
            }
            
            hasPrecinctsInQualityLayer =
                precinctCountByReachedQualityLayer[minNumQualityLayersReached] > 0;
        } while (!hasPrecinctsInQualityLayer);
        
        qualityLayerReachedCallback(minNumQualityLayersReached);
    }
    
    function ensureQualityLayersStatisticsForDebug() {
        var precinctCountByReachedQualityLayerExpected = [];
        
        for (var i = 0; i < registeredPrecinctDatabins.length; ++i) {
            var accumulatedData = accumulatedDataPerDatabin.getObject(
                registeredPrecinctDatabins[i]);
            
            var maxNumQualityLayersInTile =
                accumulatedData.maxNumQualityLayersInTile;
                
            if (maxNumQualityLayersInTile === undefined) {
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'No information of maxNumQualityLayersInTile in ' +
                    'JpipRequestDatabinsListener');
            }
            
            var qualityLayers = qualityLayersCache.getQualityLayerOffset(
                registeredPrecinctDatabins[i],
                codestreamPartParams.maxNumQualityLayers);
            
            if (qualityLayers.numQualityLayers === maxNumQualityLayersInTile) {
                continue;
            }
            
            var oldValue = precinctCountByReachedQualityLayerExpected[
                qualityLayers.numQualityLayers];
            
            precinctCountByReachedQualityLayerExpected[
                qualityLayers.numQualityLayers] = (oldValue || 0) + 1;
        }
        
        var length = Math.max(
            precinctCountByReachedQualityLayerExpected.length,
            precinctCountByReachedQualityLayer.length);
            
        var minNumQualityLayersReachedExpected = 'max';
        
        for (var j = 0; j < length; ++j) {
            var isExpectedZero = (precinctCountByReachedQualityLayerExpected[j] || 0) === 0;
            var isActualZero = (precinctCountByReachedQualityLayer[j] || 0) === 0;
            
            if (isExpectedZero !== isActualZero) {
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'Wrong accumulated statistics in JpipRequestDatabinsListener');
            }
            
            if (isExpectedZero) {
                continue;
            }
            
            if (precinctCountByReachedQualityLayer[j] !==
                precinctCountByReachedQualityLayerExpected[j]) {
                
                throw new jGlobals.jpipExceptions.InternalErrorException('Wrong ' +
                    'accumulated statistics in JpipRequestDatabinsListener');
            }
            
            if (minNumQualityLayersReachedExpected === 'max') {
                minNumQualityLayersReachedExpected = j;
            }
        }
        
        if (minNumQualityLayersReached !== minNumQualityLayersReachedExpected) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'Wrong minNumQualityLayersReached in JpipRequestDatabinsListener');
        }
    }
};
},{"j2k-jpip-globals.js":12}],9:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipCodestreamStructure = function JpipCodestreamStructure(
    jpipStructureParser,
    jpipFactory,
    progressionOrder) {

    var self = this;
    var params;
    var sizesCalculator;
    
    var defaultTileStructureByEdgeType;

    var cachedTileStructures = [];
    
    this.getSizesParams = function getSizesParams() {
        validateParams();
        return params;
    };
    
    this.getNumTilesX = function getNumTilesX() {
        validateParams();
        
        var numTiles = sizesCalculator.getNumTilesX();
        return numTiles;
    };
    
    this.getNumTilesY = function getNumTilesY() {
        validateParams();
        
        var numTiles = sizesCalculator.getNumTilesY();
        return numTiles;
    };

    this.getNumComponents = function() {
        validateParams();
        return params.numComponents;
    };
    
    this.getImageWidth = function() {
        validateParams();

        var size = sizesCalculator.getLevelWidth();
        return size;
    };
    
    this.getImageHeight = function() {
        validateParams();

        var size = sizesCalculator.getLevelHeight();
        return size;
    };
    
    this.getLevelWidth = function(numResolutionLevelsToCut) {
        validateParams();

        var size = sizesCalculator.getLevelWidth(numResolutionLevelsToCut);
        return size;
    };
    
    this.getLevelHeight = function(numResolutionLevelsToCut) {
        validateParams();

        var size = sizesCalculator.getLevelHeight(numResolutionLevelsToCut);
        return size;
    };
    
    this.getTileWidth = function(numResolutionLevelsToCut) {
        validateParams();

        var size = sizesCalculator.getTileWidth(numResolutionLevelsToCut);
        return size;
    };
    
    this.getTileHeight = function(numResolutionLevelsToCut) {
        validateParams();

        var size = sizesCalculator.getTileHeight(numResolutionLevelsToCut);
        return size;
    };
    
    this.getFirstTileOffsetX = function() {
        validateParams();

        var offset = sizesCalculator.getFirstTileOffsetX();
        return offset;
    };
    
    this.getFirstTileOffsetY = function() {
        validateParams();

        var offset = sizesCalculator.getFirstTileOffsetY();
        return offset;
    };
    
    this.getTileLeft = function getTileLeft(
        tileIndex, numResolutionLevelsToCut) {
        
        validateParams();
        
        var tileX = tileIndex % sizesCalculator.getNumTilesX();
        if (tileX === 0) {
            return 0;
        }
        
        var tileLeft =
            (tileX - 1) * sizesCalculator.getTileWidth(numResolutionLevelsToCut) +
            sizesCalculator.getFirstTileWidth(numResolutionLevelsToCut);
        
        return tileLeft;
    };
    
    this.getTileTop = function getTileTop(tileIndex, numResolutionLevelsToCut) {
        validateParams();
        
        var tileY = Math.floor(tileIndex / sizesCalculator.getNumTilesX());
        if (tileY === 0) {
            return 0;
        }
        
        var tileTop =
            (tileY - 1) * sizesCalculator.getTileHeight(numResolutionLevelsToCut) +
            sizesCalculator.getFirstTileHeight(numResolutionLevelsToCut);
        
        return tileTop;
    };
    
    this.getDefaultTileStructure = function getDefaultTileStructure() {
        validateParams();
        var result = getDefaultTileStructureInternal({
            horizontalEdgeType: sizesCalculator.EDGE_TYPE_NO_EDGE,
            verticalEdgeType: sizesCalculator.EDGE_TYPE_NO_EDGE
            });
            
        return result;
    };
    
    this.getTileStructure = getTileStructure;

    this.tilePositionToInClassIndex = function(tilePosition) {
        validateParams();
        var tilesX = sizesCalculator.getNumTilesX();
        var tilesY = sizesCalculator.getNumTilesY();
        
        validateArgumentInRange('tilePosition.tileX', tilePosition.tileX, tilesX);
        validateArgumentInRange('tilePosition.tileY', tilePosition.tileY, tilesY);

        var inClassIndex = tilePosition.tileX + tilePosition.tileY * tilesX;
        
        return inClassIndex;
    };

    this.tileInClassIndexToPosition = function(inClassIndex) {
        validateParams();
        var tilesX = sizesCalculator.getNumTilesX();
        var tilesY = sizesCalculator.getNumTilesY();
        var numTiles = tilesX * tilesY;

        validateArgumentInRange('inClassIndex', inClassIndex, tilesX * tilesY);
        
        var tileX = inClassIndex % tilesX;
        var tileY = (inClassIndex - tileX) / tilesX;
        
        var result = {
            tileX: tileX,
            tileY: tileY
            };
        
        return result;
    };
    
    this.getTilesIterator = function getTilesIterator(codestreamPartParams) {
        validateParams();
        var bounds = sizesCalculator.getTilesFromPixels(codestreamPartParams);
        
        var setableIterator = {
            currentX: bounds.minTileX,
            currentY: bounds.minTileY
        };
        
        var iterator = {
            get tileIndex() {
                var firstInRow =
                    setableIterator.currentY * sizesCalculator.getNumTilesX();
                var index = firstInRow + setableIterator.currentX;
                
                return index;
            },
            
            tryAdvance: function tryAdvance() {
                var result = tryAdvanceTileIterator(setableIterator, bounds);
                return result;
            }
        };
        
        return iterator;
    };
    
    this.getSizeOfPart = function getSizeOfPart(codestreamPartParams) {
        validateParams();
        
        var size = sizesCalculator.getSizeOfPart(codestreamPartParams);
        return size;
    };
    
    function tryAdvanceTileIterator(setableIterator, bounds) {
        if (setableIterator.currentY >= bounds.maxTileYExclusive) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'Cannot advance tile iterator after end');
        }
        
        ++setableIterator.currentX;
        if (setableIterator.currentX < bounds.maxTileXExclusive) {
            return true;
        }
        
        setableIterator.currentX = bounds.minTileX;
        ++setableIterator.currentY;
        
        var isMoreTilesAvailable =
            setableIterator.currentY < bounds.maxTileYExclusive;
        
        return isMoreTilesAvailable;
    }
    
    function getTileStructure(tileId) {
        validateParams();
        
        var maxTileId =
            sizesCalculator.getNumTilesX() * sizesCalculator.getNumTilesY()- 1;
        
        if (tileId < 0 || tileId > maxTileId) {
            throw new jGlobals.jpipExceptions.ArgumentException(
                'tileId',
                tileId,
                'Expected value between 0 and ' + maxTileId);
        }
        
        var isEdge = sizesCalculator.isEdgeTileId(tileId);
        
        if (cachedTileStructures[tileId] === undefined) {
            var tileParams = jpipStructureParser.parseOverridenTileParams(tileId);
            
            if (!!tileParams) {
                cachedTileStructures[tileId] = createTileStructure(tileParams, isEdge);
            }
            else {
                cachedTileStructures[tileId] = null;
            }
        }
        
        if (cachedTileStructures[tileId]) {
            return cachedTileStructures[tileId];
        }
        
        var result = getDefaultTileStructureInternal(isEdge);
        return result;
    }

    function validateArgumentInRange(paramName, paramValue, suprimumParamValue) {
        if (paramValue < 0 || paramValue >= suprimumParamValue) {
            throw new jGlobals.jpipExceptions.ArgumentException(
                paramName,
                paramValue,
                paramName + ' is expected to be between 0 and ' + suprimumParamValue - 1);
        }
    }
    
    function getDefaultTileStructureInternal(edgeType) {
        if (!defaultTileStructureByEdgeType) {
            var defaultTileParams = jpipStructureParser.parseDefaultTileParams();
            
            defaultTileStructureByEdgeType = new Array(3);
            
            for (var horizontalEdge = 0; horizontalEdge < 3; ++horizontalEdge) {
                defaultTileStructureByEdgeType[horizontalEdge] = new Array(3);
                
                for (var verticalEdge = 0; verticalEdge < 3; ++verticalEdge) {
                    var edge = {
                        horizontalEdgeType: horizontalEdge,
                        verticalEdgeType: verticalEdge
                        };
                    
                    defaultTileStructureByEdgeType[horizontalEdge][verticalEdge] =
                        createTileStructure(defaultTileParams, edge);
                }
            }
        }
        
        var structureByVerticalType =
            defaultTileStructureByEdgeType[edgeType.horizontalEdgeType];
        
        var tileStructure = structureByVerticalType[edgeType.verticalEdgeType];
        
        return tileStructure;
    }
    
    function createTileStructure(tileParams, edgeType) {
        validateParams();
        
        var sizeParams = JSON.parse(JSON.stringify(tileParams));
        
        sizeParams.tileSize = sizesCalculator.getTileSize(edgeType);
        
        sizeParams.defaultComponentParams.scaleX = 1;
        sizeParams.defaultComponentParams.scaleY = 1;
        
        for (var i = 0; i < sizeParams.paramsPerComponent.length; ++i) {
            sizeParams.paramsPerComponent[i].scaleX = params.componentsScaleX[i];
            sizeParams.paramsPerComponent[i].scaleY = params.componentsScaleY[i];
        }
        
        var tileStructure = jpipFactory.createTileStructure(sizeParams, self, progressionOrder);
        
        return tileStructure;
    }
    
    function validateParams(self) {
        if (!params) {
            params = jpipStructureParser.parseCodestreamStructure();
            sizesCalculator = jpipFactory.createCodestreamSizesCalculator(
                params);
        }
    }
    
    return this;
};
},{"j2k-jpip-globals.js":12}],10:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipComponentStructure = function JpipComponentStructure(
    params, tileStructure) {
    
    var tileWidthLevel0;
    var tileHeightLevel0;
    
    initialize();
    
    this.getComponentScaleX = function getComponentScaleX() {
        return params.scaleX;
    };
    
    this.getComponentScaleY = function getComponentScaleY() {
        return params.scaleY;
    };
    
    this.getNumResolutionLevels = function() {
        return params.numResolutionLevels;
    };
    
    this.getPrecinctWidth = function(resolutionLevel) {
        var width = params.precinctWidthPerLevel[resolutionLevel];
        
        return width;
    };
    
    this.getPrecinctHeight = function(resolutionLevel) {
        var height = params.precinctHeightPerLevel[resolutionLevel];
        
        return height;
    };
    
    this.getMaxCodeblockWidth = function getMaxCodeblockWidth() {
        var width = params.maxCodeblockWidth;
        
        return width;
    };
    
    this.getMaxCodeblockHeight = function getMaxCodeblockHeight() {
        var height = params.maxCodeblockHeight;
        
        return height;
    };
    
    this.getNumCodeblocksXInPrecinct =
        function getNumCodeblocksX(precinct) {
        
        var numCodeblocksX = calculateNumCodeblocks(
            precinct,
            precinct.precinctX,
            params.maxCodeblockWidth,
            params.precinctWidthPerLevel,
            tileWidthLevel0);
        
        return numCodeblocksX;
    };
    
    this.getNumCodeblocksYInPrecinct =
        function getNumCodeblocksY(precinct) {
        
        var numCodeblocksY = calculateNumCodeblocks(
            precinct,
            precinct.precinctY,
            params.maxCodeblockHeight,
            params.precinctHeightPerLevel,
            tileHeightLevel0);
        
        return numCodeblocksY;
    };

    this.getNumPrecinctsX = function(resolutionLevel) {
        var precinctsX = calculateNumPrecincts(
            tileWidthLevel0, params.precinctWidthPerLevel, resolutionLevel);
            
        return precinctsX;
    };
    
    this.getNumPrecinctsY = function(resolutionLevel) {
        var precinctsY = calculateNumPrecincts(
            tileHeightLevel0, params.precinctHeightPerLevel, resolutionLevel);
            
        return precinctsY;
    };
    
    function calculateNumPrecincts(
        tileSizeLevel0, precinctSizePerLevel, resolutionLevel) {
    
        var resolutionFactor = getResolutionFactor(resolutionLevel);
        var tileSizeInLevel = tileSizeLevel0 / resolutionFactor;
        
        var precinctSizeInLevel = precinctSizePerLevel[resolutionLevel];
        
        var numPrecincts = Math.ceil(tileSizeInLevel / precinctSizeInLevel);
        return numPrecincts;
    }
    
    function calculateNumCodeblocks(
        precinct,
        precinctIndex,
        maxCodeblockSize,
        precinctSizePerLevel,
        tileSizeLevel0) {
        
        var resolutionFactor = getResolutionFactor(precinct.resolutionLevel);
        var tileSizeInLevel = Math.ceil(tileSizeLevel0 / resolutionFactor);
        
        var precinctBeginPixel =
            precinctIndex * precinctSizePerLevel[precinct.resolutionLevel];
        
        var precinctSize = Math.min(
            precinctSizePerLevel[precinct.resolutionLevel],
            tileSizeInLevel - precinctBeginPixel);
        
        var subbandTypeFactor = precinct.resolutionLevel === 0 ? 1 : 2;
        var subbandOfPrecinctSize = Math.ceil(precinctSize / subbandTypeFactor);
        
        var numCodeblocks = subbandTypeFactor * Math.ceil(
            subbandOfPrecinctSize / maxCodeblockSize);
        
        if (precinctSize % maxCodeblockSize === 1 &&
            precinct.resolutionLevel > 0) {
            
            --numCodeblocks;
        }
        
        return numCodeblocks;
    }
    
    function getResolutionFactor(resolutionLevel) {
        var differenceFromBestLevel = params.numResolutionLevels - resolutionLevel - 1;
        
        var factor = 1 << differenceFromBestLevel;
        
        return factor;
    }
    
    function initialize() {
        if (params.scaleX !== 1 || params.scaleY !== 1) {
            throw new jGlobals.j2kExceptions.UnsupportedFeatureException(
                'Non 1 component scale', 'A.5.1');
        }
        
        tileWidthLevel0 = Math.floor(
            tileStructure.getTileWidth() / params.scaleX);
        tileHeightLevel0 = Math.floor(
            tileStructure.getTileHeight() / params.scaleY);
    }
};
},{"j2k-jpip-globals.js":12}],11:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipTileStructure = function JpipTileStructure(
    sizeParams,
    codestreamStructure,
    jpipFactory,
    progressionOrder
    ) {
    
    var defaultComponentStructure;
    var componentStructures;
    var componentToInClassLevelStartIndex;
    var minNumResolutionLevels;

    this.getProgressionOrder = function() {
        return progressionOrder;
    };
    
    this.getDefaultComponentStructure = function getDefaultComponentStructure(component) {
        return defaultComponentStructure;
    };
    
    this.getComponentStructure = function getComponentStructure(component) {
        return componentStructures[component];
    };
    
    this.getTileWidth = function getTileWidthClosure() {
        return sizeParams.tileSize[0];
    };
    
    this.getTileHeight = function getTileHeightClosure() {
        return sizeParams.tileSize[1];
    };
    
    this.getNumQualityLayers = function getNumQualityLayers() {
        return sizeParams.numQualityLayers;
    };
    
    this.getIsPacketHeaderNearData = function getIsPacketHeaderNearData() {
        return sizeParams.isPacketHeadersNearData;
    };
    
    this.getIsStartOfPacketMarkerAllowed = function getIsStartOfPacketMarkerAllowed() {
        return sizeParams.isStartOfPacketMarkerAllowed;
    };
    
    this.getIsEndPacketHeaderMarkerAllowed =
        function getIsEndPacketHeaderMarkerAllowed() {
        
        return sizeParams.isEndPacketHeaderMarkerAllowed;
    };
    
    this.precinctInClassIndexToPosition = function(inClassIndex) {
        // A.3.2
        
        if (inClassIndex < 0) {
            throw new jGlobals.jpipExceptions.ArgumentException(
                'inClassIndex',
                inClassIndex,
                'Invalid negative in-class index of precinct');
        }
        
        var numTiles = codestreamStructure.getNumTilesX() * codestreamStructure.getNumTilesY();
        var numComponents = codestreamStructure.getNumComponents();

        var tileIndex = inClassIndex % numTiles;
        var inClassIndexWithoutTile = (inClassIndex - tileIndex) / numTiles;
        
        var component = inClassIndexWithoutTile % numComponents;
        var componentStructure = componentStructures[component];
        
        var numResolutionLevels = componentStructure.getNumResolutionLevels();
        var precinctIndex = (inClassIndexWithoutTile - component) / numComponents;
        
        var resolutionLevel;
        var levelStartIndex = 0;
        for (resolutionLevel = 1; resolutionLevel < numResolutionLevels; ++resolutionLevel) {
            var nextLevelStartIndex =
                componentToInClassLevelStartIndex[component][resolutionLevel];
            
            if (nextLevelStartIndex > precinctIndex) {
                break;
            }
            
            levelStartIndex = nextLevelStartIndex;
        }
        
        --resolutionLevel;
        var precinctIndexInLevel = precinctIndex - levelStartIndex;
        
        var precinctsX = componentStructure.getNumPrecinctsX(resolutionLevel);
        var precinctsY = componentStructure.getNumPrecinctsY(resolutionLevel);

        var precinctX = precinctIndexInLevel % precinctsX;
        var precinctY = (precinctIndexInLevel - precinctX) / precinctsX;
        
        if (precinctY >= precinctsY) {
            throw new jGlobals.jpipExceptions.ArgumentException(
                'inClassIndex',
                inClassIndex,
                'Invalid in-class index of precinct');
        }
        
        var result = {
            tileIndex: tileIndex,
            component: component,
            
            precinctX: precinctX,
            precinctY: precinctY,
            resolutionLevel: resolutionLevel
            };
        
        return result;
    };
    
    this.precinctPositionToInClassIndex = function(precinctPosition) {
        // A.3.2

        var numComponents = codestreamStructure.getNumComponents();
        validateArgumentInRange(
            'precinctPosition.component', precinctPosition.component, numComponents);
        
        var componentStructure = componentStructures[precinctPosition.component];

        var numResolutionLevels = componentStructure.getNumResolutionLevels();
        validateArgumentInRange(
            'precinctPosition.resolutionLevel', precinctPosition.resolutionLevel, numResolutionLevels);

        var numTiles = codestreamStructure.getNumTilesX() * codestreamStructure.getNumTilesY();
        var precinctsX = componentStructure.getNumPrecinctsX(precinctPosition.resolutionLevel);
        var precinctsY = componentStructure.getNumPrecinctsY(precinctPosition.resolutionLevel);
        
        validateArgumentInRange(
            'precinctPosition.precinctX', precinctPosition.precinctX, precinctsX);
        validateArgumentInRange(
            'precinctPosition.precinctY', precinctPosition.precinctY, precinctsY);
        validateArgumentInRange(
            'precinctPosition.tileIndex', precinctPosition.tileIndex, numTiles);

        var precinctIndexInLevel = precinctPosition.precinctX + 
            precinctPosition.precinctY * precinctsX;
        
        var levelStartIndex = componentToInClassLevelStartIndex[precinctPosition.component][precinctPosition.resolutionLevel];
        
        var precinctIndex = precinctIndexInLevel + levelStartIndex;

        var inClassIndexWithoutTile =
            precinctPosition.component + precinctIndex * codestreamStructure.getNumComponents();

        var inClassIndex = precinctPosition.tileIndex + 
            inClassIndexWithoutTile * codestreamStructure.getNumTilesX() * codestreamStructure.getNumTilesY();
        
        return inClassIndex;
    };
    
    this.getPrecinctIterator = function getPrecinctIterator(
        tileIndex, codestreamPartParams, isIteratePrecinctsNotInCodestreamPart) {
        
        var numResolutionLevelsToCut = 0;
        if (codestreamPartParams !== undefined &&
            codestreamPartParams.numResolutionLevelsToCut !== undefined) {
            
            numResolutionLevelsToCut = codestreamPartParams.numResolutionLevelsToCut;
            
            if (minNumResolutionLevels <= numResolutionLevelsToCut) {
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'Cannot advance resolution: numResolutionLevelsToCut=' +
                    codestreamPartParams.numResolutionLevelsToCut + ' but should ' +
                    'be smaller than ' + minNumResolutionLevels);
            }
        }

        var precinctsInCodestreamPartPerLevelPerComponent =
            getPrecinctsInCodestreamPartPerLevelPerComponent(
                tileIndex, codestreamPartParams);
                
        var precinctX = 0;
        var precinctY = 0;
        if (isIteratePrecinctsNotInCodestreamPart &&
            precinctsInCodestreamPartPerLevelPerComponent !== null) {
            
            var firstPrecinctsRange =
                precinctsInCodestreamPartPerLevelPerComponent[0][0];
            precinctX = firstPrecinctsRange.minPrecinctX;
            precinctY = firstPrecinctsRange.minPrecinctY;
        }
        
        // A.6.1 in part 1: Core Coding System
        
        var setableIterator = {
            precinctIndexInComponentResolution: 0,
            component: 0,
            precinctX: precinctX,
            precinctY: precinctY,
            resolutionLevel: 0,
            isInCodestreamPart: true
            };

        var iterator = {
            get tileIndex() { return tileIndex; },
                get component() { return setableIterator.component; },
            get precinctIndexInComponentResolution() {
                return setableIterator.precinctIndexInComponentResolution;
            },
                
                get precinctX() { return setableIterator.precinctX; },
                get precinctY() { return setableIterator.precinctY; },
                get resolutionLevel() { return setableIterator.resolutionLevel; },
            get isInCodestreamPart() { return setableIterator.isInCodestreamPart; }
            };
        
        iterator.tryAdvance = function tryAdvance() {
            var isSucceeded = tryAdvancePrecinctIterator(
                setableIterator,
                numResolutionLevelsToCut,
                precinctsInCodestreamPartPerLevelPerComponent,
                isIteratePrecinctsNotInCodestreamPart);
            
            return isSucceeded;
        };
        
        return iterator;
    };
    
    function validateArgumentInRange(paramName, paramValue, suprimumParamValue) {
        if (paramValue < 0 || paramValue >= suprimumParamValue) {
            throw new jGlobals.jpipExceptions.ArgumentException(
                paramName,
                paramValue,
                paramName + ' is expected to be between 0 and ' + suprimumParamValue - 1);
        }
    }
    
    function validateTargetProgressionOrder(progressionOrder) {
        if (progressionOrder.length !== 4) {
            throw new jGlobals.j2kExceptions.IllegalDataException('Illegal progression order ' + progressionOrder + ': unexpected length');
        }
        
        if (progressionOrder[3] !== 'L') {
            throw new jGlobals.jpipExceptions.IllegalDataException('Illegal target progression order of ' + progressionOrder, 'A.3.2.1');
        }
        
        var hasP = progressionOrder.indexOf('P') >= 0;
        var hasC = progressionOrder.indexOf('C') >= 0;
        var hasR = progressionOrder.indexOf('R') >= 0;
        if (!hasP || !hasC || !hasR) {
            throw new jGlobals.j2kExceptions.IllegalDataException('Illegal progression order ' + progressionOrder + ': missing letter');
        }
        
        if (progressionOrder !== 'RPCL') {
            throw new jGlobals.j2kExceptions.UnsupportedFeatureException('Progression order of ' + progressionOrder, 'A.6.1');
        }
    }
    
    function preprocessParams() {
        componentToInClassLevelStartIndex = new Array(components);

        var components = codestreamStructure.getNumComponents();
        
        var defaultComponent = sizeParams.defaultComponentParams;
        minNumResolutionLevels = defaultComponent.numResolutionLevels;
        var isComponentsIdenticalSize = true;
        var isPrecinctPartitionFitsToTilePartition = true;

        for (var c = 0; c < components; ++c) {
            var size = sizeParams.paramsPerComponent[c];
            minNumResolutionLevels = Math.min(
                minNumResolutionLevels, size.numResolutionLevels);
                
            componentToInClassLevelStartIndex[c] = new Array(size.numResolutionLevels);
            var componentStructure = componentStructures[c];
            
            var accumulatedOffset = 0;
            var firstLevelPrecinctsX = componentStructure.getNumPrecinctsX(c);
            var firstLevelPrecinctsY = componentStructure.getNumPrecinctsY(c);
            
            for (var r = 0; r < size.numResolutionLevels; ++r) {
                componentToInClassLevelStartIndex[c][r] = accumulatedOffset;
                var precinctsXInLevel = componentStructure.getNumPrecinctsX(r);
                var precinctsYInLevel = componentStructure.getNumPrecinctsY(r);
                accumulatedOffset += precinctsXInLevel * precinctsYInLevel;
            
                if (defaultComponent.precinctWidthPerLevel[r] !==
                        size.precinctWidthPerLevel[r] ||
                    defaultComponent.precinctHeightPerLevel[r] !==
                        size.precinctHeightPerLevel[r]) {
                    
                    isComponentsIdenticalSize = false;
                }
                
                var isHorizontalPartitionSupported =
                    checkIfPrecinctPartitionStartsInTileTopLeft(
                        r,
                        size.numResolutionLevels,
                        componentStructure.getPrecinctWidth,
                        codestreamStructure.getLevelWidth,
                        codestreamStructure.getTileWidth);
                        
                var isVerticalPartitionSupported =
                    checkIfPrecinctPartitionStartsInTileTopLeft(
                        r,
                        size.numResolutionLevels,
                        componentStructure.getPrecinctWidth,
                        codestreamStructure.getLevelWidth,
                        codestreamStructure.getTileWidth);
                        
                isPrecinctPartitionFitsToTilePartition &=
                    isHorizontalPartitionSupported &&
                    isVerticalPartitionSupported;
            }
        }

        if (!isComponentsIdenticalSize) {
            throw new jGlobals.j2kExceptions.UnsupportedFeatureException(
                'Special Coding Style for Component (COC)', 'A.6.2');
        }
        
        if (!isPrecinctPartitionFitsToTilePartition) {
            throw new jGlobals.j2kExceptions.UnsupportedFeatureException(
                'Precinct TopLeft which is not matched to tile TopLeft', 'B.6');
        }
    }
    
    function checkIfPrecinctPartitionStartsInTileTopLeft(
        resolutionLevel,
        numResolutionLevels,
        getPrecinctSizeFunction,
        getLevelSizeFunction,
        getTileSizeFunction) {
        
        // Jpeg2000 standard allows partition of tiles which does not fit
        // exactly the precincts partition (i.e. the first precincts "virtually"
        // starts before the tile, thus is smaller than other).
        // This is not supported now in the code, this function should check
        // that this is not the situation.
        
        // The function assumes that firstTileOffset is zero and componentScale
        // is one (UnsupportedExceptions are thrown in ComponentStructure and
        // CodestreamStructure classes).
        
        var precinctSize = getPrecinctSizeFunction(resolutionLevel);
        var levelSize = getLevelSizeFunction(resolutionLevel);
        
        if (precinctSize > levelSize) {
            // Precinct is larger than image thus anyway tile has a single
            // precinct
            
            return true;
        }
        
        var tileSize = getTileSizeFunction(resolutionLevel);
        
        var isPrecinctPartitionFitsToTilePartition =
            precinctSize % tileSize === 0 ||
            tileSize % precinctSize === 0;
        
        return isPrecinctPartitionFitsToTilePartition;
    }
    
    function getPrecinctsInCodestreamPartPerLevelPerComponent(
        tileIndex, codestreamPartParams) {
        
        if (codestreamPartParams === undefined) {
            return null;
        }
        
        var components = codestreamStructure.getNumComponents();
        var perComponentResult = new Array(components);
        var numResolutionLevelsToCut =
            codestreamPartParams.numResolutionLevelsToCut || 0;
        
        var tileLeftInLevel = codestreamStructure.getTileLeft(
            tileIndex, numResolutionLevelsToCut);
        var tileTopInLevel = codestreamStructure.getTileTop(
            tileIndex, numResolutionLevelsToCut);
        
        var minXInTile =
            codestreamPartParams.minX - tileLeftInLevel;
        var minYInTile =
            codestreamPartParams.minY - tileTopInLevel;
        var maxXInTile =
            codestreamPartParams.maxXExclusive - tileLeftInLevel;
        var maxYInTile =
            codestreamPartParams.maxYExclusive - tileTopInLevel;
        
        var codestreamPartLevelWidth = codestreamStructure.getLevelWidth(
            numResolutionLevelsToCut);
        var codestreamPartLevelHeight = codestreamStructure.getLevelHeight(
            numResolutionLevelsToCut);

        for (var component = 0; component < components; ++component) {
            var componentStructure = componentStructures[component];
            var levels = componentStructure.getNumResolutionLevels();
            var levelsInCodestreamPart = levels - numResolutionLevelsToCut;
            var numResolutionLevels = componentStructure.getNumResolutionLevels();
            var perLevelResult = new Array(levels);
        
            for (var level = 0; level < levelsInCodestreamPart; ++level) {
                var componentScaleX = componentStructure.getComponentScaleX();
                var componentScaleY = componentStructure.getComponentScaleY();
                var levelInCodestreamPart = levelsInCodestreamPart - level - 1;
                var levelScaleX = componentScaleX << levelInCodestreamPart;
                var levelScaleY = componentScaleY << levelInCodestreamPart;
                
                var redundant = 4; // Redundant pixels for wavelet 9-7 convolution
                var minXInLevel = Math.floor(minXInTile / levelScaleX) - redundant;
                var minYInLevel = Math.floor(minYInTile / levelScaleY) - redundant;
                var maxXInLevel = Math.ceil(maxXInTile / levelScaleX) + redundant;
                var maxYInLevel = Math.ceil(maxYInTile / levelScaleY) + redundant;
                
                var precinctWidth =
                    componentStructure.getPrecinctWidth(level) * componentScaleX;
                var precinctHeight =
                    componentStructure.getPrecinctHeight(level) * componentScaleY;
                
                var minPrecinctX = Math.floor(minXInLevel / precinctWidth);
                var minPrecinctY = Math.floor(minYInLevel / precinctHeight);
                var maxPrecinctX = Math.ceil(maxXInLevel / precinctWidth);
                var maxPrecinctY = Math.ceil(maxYInLevel / precinctHeight);
                
                var precinctsX = componentStructure.getNumPrecinctsX(level);
                var precinctsY = componentStructure.getNumPrecinctsY(level);
                
                perLevelResult[level] = {
                    minPrecinctX: Math.max(0, minPrecinctX),
                    minPrecinctY: Math.max(0, minPrecinctY),
                    maxPrecinctXExclusive: Math.min(maxPrecinctX, precinctsX),
                    maxPrecinctYExclusive: Math.min(maxPrecinctY, precinctsY)
                    };
            }
            
            perComponentResult[component] = perLevelResult;
        }
        
        return perComponentResult;
    }
    
    function tryAdvancePrecinctIterator(
        setableIterator,
        numResolutionLevelsToCut,
        precinctsInCodestreamPartPerLevelPerComponent,
        isIteratePrecinctsNotInCodestreamPart) {
        
        var needAdvanceNextMember = true;
        var precinctsRangeHash = isIteratePrecinctsNotInCodestreamPart ?
            null: precinctsInCodestreamPartPerLevelPerComponent;
        
        var needResetPrecinctToMinimalInCodestreamPart = false;
        
        for (var i = 2; i >= 0; --i) {
            var newValue = advanceProgressionOrderMember(
                setableIterator, i, numResolutionLevelsToCut, precinctsRangeHash);
            
            needAdvanceNextMember = newValue === 0;
            if (!needAdvanceNextMember) {
                break;
            }
            
            if (progressionOrder[i] === 'P' &&
                !isIteratePrecinctsNotInCodestreamPart) {
                
                needResetPrecinctToMinimalInCodestreamPart = true;
            }
        }
        
        if (needAdvanceNextMember) {
            // If we are here, the last precinct has been reached
            return false;
        }
        
        var componentStructure = componentStructures[setableIterator.component];
        var precinctsX = componentStructure.getNumPrecinctsX(
            setableIterator.resolutionLevel);
        setableIterator.precinctIndexInComponentResolution =
            setableIterator.precinctX + setableIterator.precinctY * precinctsX;
        
        if (precinctsInCodestreamPartPerLevelPerComponent === null) {
            setableIterator.isInCodestreamPart = true;
            return true;
        }
        
        var rangePerLevel =
            precinctsInCodestreamPartPerLevelPerComponent[setableIterator.component];
        var precinctsRange = rangePerLevel[setableIterator.resolutionLevel];
        
        if (needResetPrecinctToMinimalInCodestreamPart) {
            setableIterator.precinctX = precinctsRange.minPrecinctX;
                setableIterator.precinctY = precinctsRange.minPrecinctY;
            setableIterator.precinctIndexInComponentResolution =
                setableIterator.precinctX + setableIterator.precinctY * precinctsX;
        }
        
        setableIterator.isInCodestreamPart =
            setableIterator.precinctX >= precinctsRange.minPrecinctX &&
            setableIterator.precinctY >= precinctsRange.minPrecinctY &&
            setableIterator.precinctX < precinctsRange.maxPrecinctXExclusive &&
            setableIterator.precinctY < precinctsRange.maxPrecinctYExclusive;
        
        return true;
    }
    
    function advanceProgressionOrderMember(
        precinctPosition,
        memberIndex,
        numResolutionLevelsToCut,
        precinctsRange) {
        
        var componentStructure = componentStructures[precinctPosition.component];
        
        switch (progressionOrder[memberIndex]) {
            case 'R':
                var numResolutionLevels =
                    componentStructure.getNumResolutionLevels() -
                    numResolutionLevelsToCut;
                
                ++precinctPosition.resolutionLevel;
                precinctPosition.resolutionLevel %= numResolutionLevels;
                return precinctPosition.resolutionLevel;
            
            case 'C':
                ++precinctPosition.component;
                precinctPosition.component %= codestreamStructure.getNumComponents();
                return precinctPosition.component;
            
            case 'P':
                var minX, minY, maxX, maxY;
                if (precinctsRange !== null) {
                    var precinctsRangePerLevel = precinctsRange[
                        precinctPosition.component];
                    var precinctsRangeInLevelComponent = precinctsRangePerLevel[
                        precinctPosition.resolutionLevel];
                    
                    minX = precinctsRangeInLevelComponent.minPrecinctX;
                    minY = precinctsRangeInLevelComponent.minPrecinctY;
                    maxX = precinctsRangeInLevelComponent.maxPrecinctXExclusive;
                    maxY = precinctsRangeInLevelComponent.maxPrecinctYExclusive;
                } else {
                    minX = 0;
                    minY = 0;
                    maxX = componentStructure.getNumPrecinctsX(
                        precinctPosition.resolutionLevel);
                    maxY = componentStructure.getNumPrecinctsY(
                        precinctPosition.resolutionLevel);
                }
                
                precinctPosition.precinctX -= (minX - 1);
                precinctPosition.precinctX %= (maxX - minX);
                precinctPosition.precinctX += minX;
                
                if (precinctPosition.precinctX != minX) {
                    return precinctPosition.precinctX - minX;
                }
                
                precinctPosition.precinctY -= (minY - 1);
                precinctPosition.precinctY %= (maxY - minY);
                precinctPosition.precinctY += minY;

                return precinctPosition.precinctY - minY;
            
            case 'L' :
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'Advancing L is not supported in JPIP');
            
            default:
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'Unexpected letter in progression order: ' +
                    progressionOrder[memberIndex]);
        }
    }
    
    defaultComponentStructure = jpipFactory.createComponentStructure(
        sizeParams.defaultComponentParams, this);
        
    componentStructures = new Array(codestreamStructure.getNumComponents());
    for (var i = 0; i < codestreamStructure.getNumComponents(); ++i) {
        componentStructures[i] = jpipFactory.createComponentStructure(
            sizeParams.paramsPerComponent[i], this);
    }
    
    preprocessParams();
    
    validateTargetProgressionOrder(progressionOrder);

    return this;
};
},{"j2k-jpip-globals.js":12}],12:[function(require,module,exports){
'use strict';

module.exports.j2kMarkers = {
    StartOfCodestream: [0xFF, 0x4F], // SOC
    ImageAndTileSize: [0xFF, 0x51], // SIZ
    CodingStyleDefault: [0xFF, 0x52], // COD
    CodingStyleComponent: [0xFF, 0x53], // COC
    QuantizationDefault: [0xFF, 0x5C], // QCD
    ProgressionOrderChange: [0xFF, 0x5F], // POC
    PackedPacketHeadersInMainHeader: [0xFF, 0x60], // PPM
    PackedPacketHeadersInTileHeader: [0xFF, 0x61], // PPT
    StartOfTile: [0xFF, 0x90], // SOT
    StartOfData: [0xFF, 0x93], // SOD
    EndOfCodestream: [0xFF, 0xD9], // EOC
    Comment: [0xFF, 0x64] // COM
};

module.exports.j2kOffsets = {
    MARKER_SIZE: 2,
    LENGTH_FIELD_SIZE: 2,
    
    NUM_COMPONENTS_OFFSET_AFTER_SIZ_MARKER: 38,
    REFERENCE_GRID_SIZE_OFFSET_AFTER_SIZ_MARKER: 6

};

module.exports.jpipEndOfResponseReasons = {
    IMAGE_DONE : 1,
    WINDOW_DONE : 2,
    WINDOW_CHANGE : 3,
    BYTE_LIMIT : 4,
    QUALITY_LIMIT : 5,
    SESSION_LIMIT : 6,
    RESPONSE_LIMIT : 7,
    NON_SPECIFIED : 8
};

module.exports.j2kExceptions = {
    UnsupportedFeatureException: function(feature, standardSection) {
        this.description = feature + ' (specified in section ' + standardSection + ' of part 1: Core Coding System standard) is not supported yet';
        
        this.toString = function() {
            return 'J2k UnsupportedFeatureException: ' + this.description;
        };
        
        return this;
    },

    ParseException: function(description) {
        this.description = description;
        
        this.toString = function() {
            return 'J2k ParseException: ' + this.description;
        };
        
        return this;
    },

    IllegalDataException: function(illegalDataDescription, standardSection) {
        this.description = illegalDataDescription + ' (see section ' + standardSection + ' of part 9: Interactivity tools, APIs and Protocols)';
        
        this.toString = function() {
            return 'J2k IllegalDataException: ' + this.description;
        };
        
        return this;
    }
};

module.exports.jpipExceptions = {
    UnsupportedFeatureException: function(feature, standardSection) {
        this.description = feature + ' (specified in section ' + standardSection + ' of part 9: Interactivity tools, APIs and Protocols) is not supported yet';
        
        this.toString = function() {
            return 'Jpip UnsupportedFeatureException: ' + this.description;
        };
        
        return this;
    },

    ParseException: function(description) {
        this.description = description;
        
        this.toString = function() {
            return 'Jpip ParseException: ' + this.description;
        };
        
        return this;
    },

    IllegalDataException: function(illegalDataDescription, standardSection) {
        this.description = illegalDataDescription + ' (see section ' + standardSection + ' of part 9: Interactivity tools, APIs and Protocols)';
        
        this.toString = function() {
            return 'Jpip IllegalDataException: ' + this.description;
        };
        
        return this;
    },
    
    IllegalOperationException: function(description) {
        this.description = description;
        
        this.toString = function() {
            return 'Jpip IllegalOperationException: ' + this.description;
        };
        
        return this;
    },
    
    ArgumentException: function(argumentName, argumentValue, description) {
        this.description = 'Argument ' + argumentName + ' has invalid value ' +
            argumentValue + (description !== undefined ? ' :' + description : '');
        
        this.toString = function() {
            return 'Jpip ArgumentException: ' + this.description;
        };
        
        return this;
    },

    WrongStreamException: function(requestedOperation, isJPT) {
        var correctStream = 'JPP (JPIP Precinct)';
        var wrongStream = 'JPT (JPIP Tile-part)';
        
        if (isJPT) {
            var swap = correctStream;
            correctStream = wrongStream;
            wrongStream = swap;
        }
        
        this.description =    'Stream type is ' + wrongStream + ', but ' + requestedOperation +
                            ' is allowed only in ' + correctStream + ' stream';
                            
        this.toString = function() {
            return 'Jpip WrongStreamException: ' + this.description;
        };
        
        return this;
    },

    InternalErrorException: function(description) {
        this.description = description;
        
        this.toString = function() {
            return 'Jpip InternalErrorException: ' + this.description;
        };
        
        return this;
    }
};

module.exports.j2kExceptions.UnsupportedFeatureException.Name =
    'j2kExceptions.UnsupportedFeatureException';
module.exports.j2kExceptions.ParseException.Name =
    'j2kExceptions.ParseException';
module.exports.j2kExceptions.IllegalDataException.Name =
    'j2kExceptions.IllegalDataException';

module.exports.jpipExceptions.UnsupportedFeatureException.Name =
    'jpipExceptions.UnsupportedFeatureException';
module.exports.jpipExceptions.ParseException.Name =
    'jpipExceptions.ParseException';
module.exports.jpipExceptions.IllegalDataException.Name =
    'jpipExceptions.IllegalDataException';
module.exports.jpipExceptions.IllegalOperationException.Name =
    'jpipExceptions.IllegalOperationException';
module.exports.jpipExceptions.ArgumentException.Name =
    'jpipExceptions.ArgumentException';
module.exports.jpipExceptions.WrongStreamException.Name =
    'jpipExceptions.WrongStreamException';
module.exports.jpipExceptions.InternalErrorException.Name =
    'jpipExceptions.InternalErrorException';
},{}],13:[function(require,module,exports){
'use strict';

var simpleAjaxHelper                 = require('simple-ajax-helper.js'                 ).simpleAjaxHelper;
var mutualExclusiveTransactionHelper = require('mutual-exclusive-transaction-helper.js').mutualExclusiveTransactionHelper;

var jpipCodingPassesNumberParser = require('jpip-coding-passes-number-parser.js').jpipCodingPassesNumberParser;
var jpipMessageHeaderParser      = require('jpip-message-header-parser.js'      ).jpipMessageHeaderParser;

var JpipChannel                               = require('jpip-channel.js'                                   ).JpipChannel;
var JpipCodestreamReconstructor               = require('jpip-codestream-reconstructor.js'                  ).JpipCodestreamReconstructor;
var JpipCodestreamSizesCalculator             = require('jpip-codestream-sizes-calculator.js'               ).JpipCodestreamSizesCalculator;
var JpipCodestreamStructure                   = require('jpip-codestream-structure.js'                      ).JpipCodestreamStructure;
var JpipComponentStructure                    = require('jpip-component-structure.js'                       ).JpipComponentStructure;
var CompositeArray                            = require('composite-array.js'                                ).CompositeArray;
var JpipDatabinParts                          = require('jpip-databin-parts.js'                             ).JpipDatabinParts;
var JpipDatabinsSaver                         = require('jpip-databins-saver.js'                            ).JpipDatabinsSaver;
var JpipHeaderModifier                        = require('jpip-header-modifier.js'                           ).JpipHeaderModifier;
var JpipMarkersParser                         = require('jpip-markers-parser.js'                            ).JpipMarkersParser;
var JpipObjectPoolByDatabin                   = require('jpip-object-pool-by-databin.js'                    ).JpipObjectPoolByDatabin;
var JpipOffsetsCalculator                     = require('jpip-offsets-calculator.js'                        ).JpipOffsetsCalculator;
var JpipPacketsDataCollector                  = require('jpip-packets-data-collector.js'                    ).JpipPacketsDataCollector;
var JpipRequestContext                        = require('jpip-request-context.js'                           ).JpipRequestContext;
var JpipRequestDatabinsListener               = require('jpip-request-databins-listener.js'                 ).JpipRequestDatabinsListener;
var JpipRequest                               = require('jpip-request.js'                                   ).JpipRequest;
var JpipSessionHelper                         = require('jpip-session-helper.js'                            ).JpipSessionHelper;
var JpipSession                               = require('jpip-session.js'                                   ).JpipSession;
var JpipReconnectableRequester                = require('jpip-reconnectable-requester.js'                   ).JpipReconnectableRequester;
var JpipStructureParser                       = require('jpip-structure-parser.js'                          ).JpipStructureParser;
var JpipTileStructure                         = require('jpip-tile-structure.js'                            ).JpipTileStructure;
var JpipBitstreamReader                       = require('jpip-bitstream-reader.js'                          ).JpipBitstreamReader;
var JpipTagTree                               = require('jpip-tag-tree.js'                                  ).JpipTagTree;
var JpipCodeblockLengthParser                 = require('jpip-codeblock-length-parser.js'                   ).JpipCodeblockLengthParser;
var JpipSubbandLengthInPacketHeaderCalculator = require('jpip-subband-length-in-packet-header-calculator.js').JpipSubbandLengthInPacketHeaderCalculator;
var JpipPacketLengthCalculator                = require('jpip-packet-length-calculator.js'                  ).JpipPacketLengthCalculator;
var JpipQualityLayersCache                    = require('jpip-quality-layers-cache.js'                      ).JpipQualityLayersCache;

var jpipRuntimeFactory = {
    createChannel: function createChannel(
        maxRequestsWaitingForResponseInChannel, sessionHelper) {
        
        return new JpipChannel(
            maxRequestsWaitingForResponseInChannel,
            sessionHelper,
            jpipRuntimeFactory);
    },
    
    createCodestreamReconstructor: function(
        codestreamStructure, databinsSaver, headerModifier, qualityLayersCache) {
        
        return new JpipCodestreamReconstructor(
            codestreamStructure,
            databinsSaver,
            headerModifier,
            qualityLayersCache);
    },
    
    createCodestreamSizesCalculator: function(params) {
        return new JpipCodestreamSizesCalculator(params);
    },
    
    createCodestreamStructure: function(structureParser, progressionOrder) {
        return new JpipCodestreamStructure(
            structureParser, jpipRuntimeFactory, progressionOrder);
    },
    
    createComponentStructure: function(params, tileStructure) {
        return new JpipComponentStructure(params, tileStructure);
    },
    
    createCompositeArray: function(offset) {
        return new CompositeArray(offset);
    },
    
    createDatabinParts: function(classId, inClassId) {
        return new JpipDatabinParts(classId, inClassId, jpipRuntimeFactory);
    },
    
    createDatabinsSaver: function(isJpipTilepartStream) {
        return new JpipDatabinsSaver(isJpipTilepartStream, jpipRuntimeFactory);
    },
    
    createHeaderModifier: function(
        codestreamStructure, offsetsCalculator, progressionOrder) {
        
        return new JpipHeaderModifier(
            codestreamStructure, offsetsCalculator, progressionOrder);
    },
    
    createMarkersParser: function(mainHeaderDatabin) {
        return new JpipMarkersParser(
            mainHeaderDatabin, jpipMessageHeaderParser, jpipRuntimeFactory);
    },
    
    createObjectPoolByDatabin: function() {
        return new JpipObjectPoolByDatabin();
    },
    
    createOffsetsCalculator: function(mainHeaderDatabin, markersParser) {
        return new JpipOffsetsCalculator(mainHeaderDatabin, markersParser);
    },
    
    createPacketsDataCollector: function(
        codestreamStructure, databinsSaver, qualityLayersCache) {
        
        return new JpipPacketsDataCollector(
            codestreamStructure,
            databinsSaver,
            qualityLayersCache,
            jpipRuntimeFactory);
    },
    
    createRequestContext: function(
        jpipObjects,
        codestreamPartParams,
        callback,
        progressiveness,
        options) {
        
        return new JpipRequestContext(
            jpipObjects,
            codestreamPartParams,
            callback,
            progressiveness,
            options);
    },
    
    createRequestDatabinsListener: function createRequestDatabinsListener(
        codestreamPartParams,
        qualityLayerReachedCallback,
        codestreamStructure,
        databinsSaver,
        qualityLayersCache) {
        
        return new JpipRequestDatabinsListener(
            codestreamPartParams,
            qualityLayerReachedCallback,
            codestreamStructure,
            databinsSaver,
            qualityLayersCache,
            jpipRuntimeFactory);
    },
    
    createRequest: function createRequest(
        sessionHelper, channel, requestUrl, callback, failureCallback) {
        
        return new JpipRequest(
            sessionHelper,
            jpipMessageHeaderParser,
            channel,
            requestUrl,
            callback,
            failureCallback);
    },
    
    createSessionHelper: function createSessionHelper(
        dataRequestUrl,
        knownTargetId,
        codestreamStructure,
        databinsSaver) {
        
        return new JpipSessionHelper(
            dataRequestUrl,
            knownTargetId,
            codestreamStructure,
            databinsSaver,
            simpleAjaxHelper);
    },
    
    createSession: function createSession(
        maxChannelsInSession,
        maxRequestsWaitingForResponseInChannel,
        targetId,
        codestreamStructure,
        databinsSaver) {
        
        return new JpipSession(
            maxChannelsInSession,
            maxRequestsWaitingForResponseInChannel,
            targetId,
            codestreamStructure,
            databinsSaver,
            setInterval,
            clearInterval,
            jpipRuntimeFactory);
    },
    
    createReconnectableRequester: function(
        maxChannelsInSession,
        maxRequestsWaitingForResponseInChannel,
        codestreamStructure,
        databinsSaver) {
        
        return new JpipReconnectableRequester(
            maxChannelsInSession,
            maxRequestsWaitingForResponseInChannel,
            codestreamStructure,
            databinsSaver,
            jpipRuntimeFactory);
    },
    
    createStructureParser: function(databinsSaver, markersParser, offsetsCalculator) {
        return new JpipStructureParser(
            databinsSaver, markersParser, jpipMessageHeaderParser, offsetsCalculator);
    },
    
    createTileStructure: function(
        sizeParams, codestreamStructure, progressionOrder) {
        return new JpipTileStructure(
            sizeParams, codestreamStructure, jpipRuntimeFactory, progressionOrder);
    },
    
    createBitstreamReader: function createBitstreamReader(databin) {
        return new JpipBitstreamReader(
            databin, mutualExclusiveTransactionHelper);
    },
    
    createTagTree: function createTagTree(bitstreamReader, width, height) {
        return new JpipTagTree(
            bitstreamReader, width, height, mutualExclusiveTransactionHelper);
    },
    
    createCodeblockLengthParser: function createCodeblockLengthParser(
        bitstreamReader, transactionHelper) {
        
        return new JpipCodeblockLengthParser(
            bitstreamReader, mutualExclusiveTransactionHelper);
    },
    
    createSubbandLengthInPacketHeaderCalculator :
        function createSubbandLengthInPacketHeaderCalculator(
            bitstreamReader, numCodeblocksXInSubband, numCodeblocksYInSubband) {
        
        return new JpipSubbandLengthInPacketHeaderCalculator(
            bitstreamReader,
            numCodeblocksXInSubband,
            numCodeblocksYInSubband,
            jpipCodingPassesNumberParser,
            mutualExclusiveTransactionHelper,
            jpipRuntimeFactory);
    },
    
    createPacketLengthCalculator: function createPacketLengthCalculator(
        tileStructure,
        componentStructure,
        databin,
        startOffsetInDatabin,
        precinct) {
        
        return new JpipPacketLengthCalculator(
            tileStructure,
            componentStructure,
            databin,
            startOffsetInDatabin,
            precinct,
            jpipRuntimeFactory);
    },
    
    createQualityLayersCache: function createQualityLayersCache(
        codestreamStructure) {
        
        return new JpipQualityLayersCache(
            codestreamStructure,
            jpipRuntimeFactory);
    }
};

module.exports.jpipRuntimeFactory = jpipRuntimeFactory;
},{"composite-array.js":4,"jpip-bitstream-reader.js":24,"jpip-channel.js":18,"jpip-codeblock-length-parser.js":25,"jpip-codestream-reconstructor.js":33,"jpip-codestream-sizes-calculator.js":2,"jpip-codestream-structure.js":9,"jpip-coding-passes-number-parser.js":26,"jpip-component-structure.js":10,"jpip-databin-parts.js":5,"jpip-databins-saver.js":6,"jpip-header-modifier.js":34,"jpip-markers-parser.js":15,"jpip-message-header-parser.js":19,"jpip-object-pool-by-databin.js":7,"jpip-offsets-calculator.js":16,"jpip-packet-length-calculator.js":27,"jpip-packets-data-collector.js":35,"jpip-quality-layers-cache.js":28,"jpip-reconnectable-requester.js":20,"jpip-request-context.js":3,"jpip-request-databins-listener.js":8,"jpip-request.js":21,"jpip-session-helper.js":22,"jpip-session.js":23,"jpip-structure-parser.js":17,"jpip-subband-length-in-packet-header-calculator.js":29,"jpip-tag-tree.js":30,"jpip-tile-structure.js":11,"mutual-exclusive-transaction-helper.js":31,"simple-ajax-helper.js":14}],14:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.simpleAjaxHelper = {
    request: function request(
        url,
        callbackForAsynchronousRequest,
        failureCallbackForAsynchronousRequest,
        progressiveRequestQuantBytes) {
        
        var ajaxResponse = new XMLHttpRequest();
        var isSynchronous = callbackForAsynchronousRequest === undefined;

        var isFinishedRequest = false;
        var bytesRecievedOnLastQuant = 0;
        
        function internalAjaxCallback(e) {
            if (isFinishedRequest) {
                return;
            }
            
            if (ajaxResponse.readyState !== 4) {
                if (progressiveRequestQuantBytes === undefined ||
                    ajaxResponse.response === null ||
                    ajaxResponse.readyState < 3) {
                    
                    return;
                }
                
                var bytesRecieved = ajaxResponse.response.byteLength;
                var bytesTillLastQuant = bytesRecieved - bytesRecievedOnLastQuant;
                
                if (bytesTillLastQuant < progressiveRequestQuantBytes) {
                    return;
                }
                
                bytesRecievedOnLastQuant = bytesRecieved;
            } else {
                isFinishedRequest = true;
                
                if (ajaxResponse.status !== 200 ||
                    ajaxResponse.response === null) {
                    
                    failureCallbackForAsynchronousRequest(ajaxResponse);
                    return;
                }
            }
            
            if (!isSynchronous) {
                callbackForAsynchronousRequest(ajaxResponse, isFinishedRequest);
            }
        }
        
        ajaxResponse.open('GET', url, !isSynchronous);
        ajaxResponse.onreadystatechange = internalAjaxCallback;
        
        if (!isSynchronous) {
            // Not supported for synchronous requests
            ajaxResponse.mozResponseType = ajaxResponse.responseType = 'arraybuffer';
        }

        if (progressiveRequestQuantBytes !== undefined) {
            ajaxResponse.setRequestHeader('X-Content-Type-Options', 'nosniff');
            ajaxResponse.onprogress = internalAjaxCallback;
        }
        
        ajaxResponse.send(null);

        if (isSynchronous && !isFinishedRequest) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'synchronous ajax call was not finished synchronously');
        }
        
        return ajaxResponse;
    }
};
},{"j2k-jpip-globals.js":12}],15:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipMarkersParser = function JpipMarkersParser(
    mainHeaderDatabin, messageHeaderParser, jpipFactory) {
    
    var CACHE_KEY = 'markers';
    
    this.getMandatoryMarkerOffsetInDatabin =
        function getMandatoryMarkerOffsetInDatabinClosure(
            databin, marker, markerName, standardSection) {
        
        var offset = getMarkerOffsetInDatabin(databin, marker);
        
        if (offset === null) {
            throw new jGlobals.j2kExceptions.IllegalDataException(
                markerName + ' is not found where expected to be',
                standardSection);
        }
        
        return offset;
    };
    
    this.checkSupportedMarkers = function checkSupportedMarkersClosure(
        databin, markers, isMarkersSupported) {
        
        isMarkersSupported = !!isMarkersSupported;
        
        var databinMarkers = getDatabinMarkers(
            databin, /*forceAllMarkersParsed=*/true);
        
        var markersAsProperties = {};
        for (var i = 0; i < markers.length; ++i) {
            var marker = getMarkerAsPropertyName(
                markers[i], 'jpipMarkersParser.supportedMarkers[' + i + ']');
            markersAsProperties[marker] = true;
        }
        
        for (var existingMarker in databinMarkers.markerToOffset) {
            var isMarkerInList = !!markersAsProperties[existingMarker];
            if (isMarkerInList !== isMarkersSupported) {
                throw new jGlobals.j2kExceptions.UnsupportedFeatureException(
                    'Unsupported marker found: ' + existingMarker, 'unknown');
            }
        }
    };
    
    this.getMarkerOffsetInDatabin = getMarkerOffsetInDatabin;
    
    this.isMarker = isMarker;
    
    function isMarker(data, marker, offset) {
        var result = (data[offset] === marker[0]) && (data[offset + 1] === marker[1]);
        
        return result;
    }

    function getMarkerOffsetInDatabin(databin, marker) {
        var databinMarkers = getDatabinMarkers(
            databin, /*forceAllMarkersParsed=*/true);
        
        var strMarker = getMarkerAsPropertyName(
            marker, 'Predefined marker in jGlobals.j2kMarkers');
        var offset = databinMarkers.markerToOffset[strMarker];
        
        if (offset === undefined) {
            return null;
        }
        
        return offset;
    }

    function getDatabinMarkers(databin, forceAllMarkersParsed) {
        var databinMarkers = databin.getCachedData(CACHE_KEY);
        
        if (databinMarkers.markerToOffset === undefined) {
            databinMarkers.isParsedAllMarkers = false;
            databinMarkers.lastOffsetParsed = 0;
            databinMarkers.markerToOffset = {};
            databinMarkers.databin = databin;
        }
        
        if (databinMarkers.isParsedAllMarkers) {
            return databinMarkers;
        }
        
        var startOffset = 0;
        var bytes = [];
        var canParse = true;

        if (databin === mainHeaderDatabin && databinMarkers.lastOffsetParsed === 0) {
            var bytesCopied = databin.copyBytes(bytes, /*startOffset=*/0, {
                forceCopyAllRange: true,
                maxLengthToCopy: jGlobals.j2kOffsets.MARKER_SIZE
                });
            
            if (bytesCopied === null) {
                canParse = false;
            } else if (!isMarker(bytes, jGlobals.j2kMarkers.StartOfCodestream, /*offset=*/0)) {
                throw new jGlobals.j2kExceptions.IllegalDataException(
                    'SOC (Start Of Codestream) ' +
                    'is not found where expected to be',
                    'A.4.1');
            }
            
            databinMarkers.lastOffsetParsed = 2;
        }

        if (canParse) {
            actualParseMarkers(databinMarkers);
        }
        
        afterParseMarkers(databinMarkers, forceAllMarkersParsed);
        
        return databinMarkers;
    }
    
    function actualParseMarkers(databinMarkers) {
        var offset = databinMarkers.lastOffsetParsed;
        
        var bytes = [];
        var bytesCopied = databinMarkers.databin.copyBytes(bytes, /*startOffset=*/0, {
                forceCopyAllRange: true,
                maxLengthToCopy: jGlobals.j2kOffsets.MARKER_SIZE + jGlobals.j2kOffsets.LENGTH_FIELD_SIZE,
                databinStartOffset: offset
                });
        
        while (bytesCopied !== null) {
            var marker = getMarkerAsPropertyName(
                bytes,
                'offset ' + offset + ' of databin with class ID = ' +
                    databinMarkers.databin.getClassId() + ' and in class ID = ' +
                    databinMarkers.databin.getInClassId());
            databinMarkers.markerToOffset[marker.toString()] = offset;
                
            var length = messageHeaderParser.getInt16(bytes, jGlobals.j2kOffsets.MARKER_SIZE);
            offset += length + jGlobals.j2kOffsets.MARKER_SIZE;
            
            bytesCopied = databinMarkers.databin.copyBytes(bytes, /*startOffset=*/0, {
                forceCopyAllRange: true,
                maxLengthToCopy: jGlobals.j2kOffsets.MARKER_SIZE + jGlobals.j2kOffsets.LENGTH_FIELD_SIZE,
                databinStartOffset: offset
                });
        }

        databinMarkers.lastOffsetParsed = offset;
    }
    
    function afterParseMarkers(databinMarkers, forceAllMarkersParsed) {
        var databinLength = databinMarkers.databin.getDatabinLengthIfKnown();
        databinMarkers.isParsedAllMarkers = databinMarkers.lastOffsetParsed === databinLength;
        
        if (!databinMarkers.isParsedAllMarkers && databinMarkers.databin !== mainHeaderDatabin) {
            var bytes = [];
            var bytesCopied = databinMarkers.databin.copyBytes(bytes, /*startOffset=*/0, {
                forceCopyAllRange: true,
                maxLengthToCopy: jGlobals.j2kOffsets.MARKER_SIZE,
                databinStartOffset: databinMarkers.lastOffsetParsed
                });
            
            if (bytesCopied !== null &&
                isMarker(bytes, 0, jGlobals.j2kMarkers.StartOfData)) {
                
                databinMarkers.lastOffsetParsed += jGlobals.j2kOffsets.MARKER_SIZE;
                databinMarkers.isParsedAllMarkers = true;
            }
        }
        
        if (forceAllMarkersParsed && !databinMarkers.isParsedAllMarkers) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'data-bin with class ID = ' +
                databinMarkers.databin.getClassId() + ' and in class ID = ' +
                databinMarkers.databin.getInClassId() +
                ' was not recieved yet');
        }
    }
    
    function getMarkerAsPropertyName(bytes, markerPositionDescription) {
        if (bytes[0] !== 0xFF) {
            throw new jGlobals.j2kExceptions.IllegalDataException(
                'Expected marker in ' + markerPositionDescription, 'A');
        }
        
        var marker = bytes[1].toString(16);
        return marker;
    }
};
},{"j2k-jpip-globals.js":12}],16:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipOffsetsCalculator = function JpipOffsetsCalculator(
    mainHeaderDatabin, markersParser) {
    
    var supportedMarkers = [
        jGlobals.j2kMarkers.ImageAndTileSize,
        jGlobals.j2kMarkers.CodingStyleDefault,
        jGlobals.j2kMarkers.QuantizationDefault,
        jGlobals.j2kMarkers.Comment
        ];
    
    this.getCodingStyleOffset = getCodingStyleOffset;
    
    this.getCodingStyleBaseParams = getCodingStyleBaseParams;
    
    this.getImageAndTileSizeOffset = function getImageAndTileSizeOffset() {
        // A.5.1 (Image and tile size marker segment)
        
        var sizMarkerOffset = markersParser.getMandatoryMarkerOffsetInDatabin(
            mainHeaderDatabin,
            jGlobals.j2kMarkers.ImageAndTileSize,
            'Image and Tile Size (SIZ)',
            'A.5.1');
        
        return sizMarkerOffset;
    };
    
    this.getRangesOfBestResolutionLevelsData =
        function getRangesWithDataOfResolutionLevelsClosure(
            databin, numResolutionLevels) {
        
        markersParser.checkSupportedMarkers(
            databin, supportedMarkers, /*isMarkersSupported=*/true);
        
        var numDecompositionLevelsOffset = null;
        
        var databinCodingStyleDefaultBaseParams = getCodingStyleBaseParams(
            databin, /*isMandatory=*/false);
        
        var databinOrMainHeaderCodingStyleBaseParams = databinCodingStyleDefaultBaseParams;
        if (databinCodingStyleDefaultBaseParams === null) {
            databinOrMainHeaderCodingStyleBaseParams = getCodingStyleBaseParams(
                mainHeaderDatabin, /*isMandatory=*/true);
        } else {
            numDecompositionLevelsOffset =
                databinCodingStyleDefaultBaseParams.numDecompositionLevelsOffset;
        }
        
        var codingStyleNumResolutionLevels = 
            databinOrMainHeaderCodingStyleBaseParams.numResolutionLevels;
            
        if (codingStyleNumResolutionLevels <= numResolutionLevels) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'numResolutionLevels (' + numResolutionLevels + ') <= COD.' +
                'numResolutionLevels (' + codingStyleNumResolutionLevels + ')');
        }

        var ranges = [];

        addRangeOfBestResolutionLevelsInCodingStyle(
            ranges, databinCodingStyleDefaultBaseParams, numResolutionLevels);

        addRangeOfBestResolutionLevelsInQuantization(
            ranges,
            databin,
            databinOrMainHeaderCodingStyleBaseParams,
            numResolutionLevels);

        var result = {
            ranges: ranges,
            numDecompositionLevelsOffset: numDecompositionLevelsOffset
            };
        
        return result;
    };
    
    function getCodingStyleBaseParams(
        databin, isMandatory) {
        
        var codingStyleDefaultOffset = getCodingStyleOffset(
            databin, isMandatory);
        
        if (codingStyleDefaultOffset === null) {
            return null;
        }
        
        var numBytes = 8;
        var bytesOffset = codingStyleDefaultOffset + jGlobals.j2kOffsets.MARKER_SIZE;
        var bytes = getBytes(databin, numBytes, bytesOffset);

        var codingStyleFlagsForAllComponentsOffset = 2; // Scod
        var codingStyleFlagsForAllComponents =
            bytes[codingStyleFlagsForAllComponentsOffset];
            
        var isDefaultPrecinctSize = !(codingStyleFlagsForAllComponents & 0x1);
        var isStartOfPacketMarkerAllowed = !!(codingStyleFlagsForAllComponents & 0x2);
        var isEndPacketHeaderMarkerAllowed = !!(codingStyleFlagsForAllComponents & 0x4);
        
        var numDecompositionLevelsOffsetInBytes = 7; // SPcod, 1st byte
        var numDecompositionLevels = bytes[numDecompositionLevelsOffsetInBytes];
        var numResolutionLevels = numDecompositionLevels + 1;
        
        var numDecompositionLevelsOffset = bytesOffset + numDecompositionLevelsOffsetInBytes;
        
        var precinctSizesOffset = isDefaultPrecinctSize ? null : codingStyleDefaultOffset + 14;
        
        var result = {
            codingStyleDefaultOffset: codingStyleDefaultOffset,
            
            isDefaultPrecinctSize: isDefaultPrecinctSize,
            isStartOfPacketMarkerAllowed: isStartOfPacketMarkerAllowed,
            isEndPacketHeaderMarkerAllowed: isEndPacketHeaderMarkerAllowed,
            
            numResolutionLevels: numResolutionLevels,
            precinctSizesOffset: precinctSizesOffset,
            numDecompositionLevelsOffset: numDecompositionLevelsOffset
            };
        
        return result;
    }
    
    function addRangeOfBestResolutionLevelsInCodingStyle(
        ranges, codingStyleDefaultBaseParams, numResolutionLevels) {
        
        if (codingStyleDefaultBaseParams === null ||
            codingStyleDefaultBaseParams.isDefaultPrecinctSize) {
            
            return;
        }
        
        var levelsNotInRange =
            codingStyleDefaultBaseParams.numResolutionLevels - numResolutionLevels;
        
        var firstOffsetInRange =
            codingStyleDefaultBaseParams.precinctSizesOffset + levelsNotInRange;
        
        var markerLengthOffset = 
            codingStyleDefaultBaseParams.codingStyleDefaultOffset + jGlobals.j2kOffsets.MARKER_SIZE;
        
        var precinctSizesRange = {
            markerSegmentLengthOffset: markerLengthOffset,
            start: firstOffsetInRange,
            length: numResolutionLevels
            };
        

        ranges.push(precinctSizesRange);
    }

    function getQuantizationDataBytesPerSubband(databin, quantizationStyleOffset) {
        var sqcdOffset = quantizationStyleOffset + 4; // Sqcd
        var bytes = getBytes(databin, /*numBytes=*/1, sqcdOffset);
        var quantizationStyle = bytes[0] & 0x1F;
        
        var bytesPerSubband;
        switch (quantizationStyle) {
            case 0:
                bytesPerSubband = 1;
                break;
            case 1:
                bytesPerSubband = 0;
                break;
            case 2:
                bytesPerSubband = 2;
                break;
            default:
                throw new jGlobals.j2kExceptions.IllegalDataException(
                    'Quantization style of ' + quantizationStyle, 'A.6.4');
        }
        
        return bytesPerSubband;
    }
    
    function addRangeOfBestResolutionLevelsInQuantization(
        ranges,
        databin,
        codingStyleDefaultBaseParams,
        numResolutionLevels) {
        
        var qcdMarkerOffset = markersParser.getMarkerOffsetInDatabin(
            databin, jGlobals.j2kMarkers.QuantizationDefault);
        
        if (qcdMarkerOffset === null) {
            return;
        }
        
        var bytesPerSubband = getQuantizationDataBytesPerSubband(
            databin, qcdMarkerOffset);
            
        if (bytesPerSubband === 0) {
            return;
        }
        
        var levelsNotInRange =
            codingStyleDefaultBaseParams.numResolutionLevels - numResolutionLevels;
        
        var subbandsNotInRange = 1 + 3 * (levelsNotInRange - 1);
        var subbandsInRange = 3 * numResolutionLevels;
        
        var firstOffsetInRange =
            qcdMarkerOffset + 5 + subbandsNotInRange * bytesPerSubband;
        
        var rangeLength = subbandsInRange * bytesPerSubband;
        
        var markerLengthOffset = qcdMarkerOffset + jGlobals.j2kOffsets.MARKER_SIZE;
        
        var quantizationsRange = {
            markerSegmentLengthOffset: markerLengthOffset,
            start: firstOffsetInRange,
            length: rangeLength
            };
        
        ranges.push(quantizationsRange);
    }
    
    function expectNoCodingStyleComponent(databin) {
        var cocOffset = markersParser.getMarkerOffsetInDatabin(
            databin, jGlobals.j2kMarkers.CodingStyleComponent);
        
        if (cocOffset !== null) {
            // A.6.2
            throw new jGlobals.j2kExceptions.UnsupportedFeatureException(
                'COC Marker (Coding Style Component)', 'A.6.2');
        }
    }
    
    function getCodingStyleOffset(databin, isMandatory) {
        expectNoCodingStyleComponent(databin);

        var offset;
        if (isMandatory) {
            offset = markersParser.getMandatoryMarkerOffsetInDatabin(
                databin,
                jGlobals.j2kMarkers.CodingStyleDefault,
                'COD (Coding style Default)',
                'A.6.1');
        } else {
            offset = markersParser.getMarkerOffsetInDatabin(
                databin, jGlobals.j2kMarkers.CodingStyleDefault);
        }
        
        return offset;
    }
    
    function getBytes(databin, numBytes, databinStartOffset, allowEndOfRange) {
        var bytes = [];

        var rangeOptions = {
            forceCopyAllRange: true,
            maxLengthToCopy: numBytes,
            databinStartOffset: databinStartOffset
            };
        
        var bytesCopied = databin.copyBytes(bytes, /*startOffset=*/0, rangeOptions);
        if (bytesCopied === null) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'Header data-bin has not yet recieved ' + numBytes +
                ' bytes starting from offset ' + databinStartOffset);
        }
        
        return bytes;
    }
};
},{"j2k-jpip-globals.js":12}],17:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipStructureParser = function JpipStructureParser(
    databinsSaver, markersParser, messageHeaderParser, offsetsCalculator) {
    
    this.parseCodestreamStructure = function parseCodestreamStructure() {
        // A.5.1 (Image and Tile Size)
        
        var mainHeaderDatabin = databinsSaver.getMainHeaderDatabin();
        
        var sizMarkerOffset = offsetsCalculator.getImageAndTileSizeOffset();
        
        var bytes = getBytes(
            mainHeaderDatabin,
            /*numBytes=*/38,
            sizMarkerOffset + jGlobals.j2kOffsets.MARKER_SIZE + jGlobals.j2kOffsets.LENGTH_FIELD_SIZE);
        
        var referenceGridSizeOffset =
            jGlobals.j2kOffsets.REFERENCE_GRID_SIZE_OFFSET_AFTER_SIZ_MARKER -
            (jGlobals.j2kOffsets.MARKER_SIZE + jGlobals.j2kOffsets.LENGTH_FIELD_SIZE);
        var numComponentsOffset =
            jGlobals.j2kOffsets.NUM_COMPONENTS_OFFSET_AFTER_SIZ_MARKER -
            (jGlobals.j2kOffsets.MARKER_SIZE + jGlobals.j2kOffsets.LENGTH_FIELD_SIZE);
            
        var referenceGridSizeX = messageHeaderParser.getInt32(
            bytes, referenceGridSizeOffset); // XSiz
        var referenceGridSizeY = messageHeaderParser.getInt32(
            bytes, referenceGridSizeOffset + 4); // YSiz
            
        var imageOffsetX = messageHeaderParser.getInt32(bytes, 10); // XOSiz
        var imageOffsetY = messageHeaderParser.getInt32(bytes, 14); // YOSiz
        var tileSizeX = messageHeaderParser.getInt32(bytes, 18); // XTSiz
        var tileSizeY = messageHeaderParser.getInt32(bytes, 22); // YTSiz
        var firstTileOffsetX = messageHeaderParser.getInt32(bytes, 26); // XTOSiz
        var firstTileOffsetY = messageHeaderParser.getInt32(bytes, 30); // YTOSiz
        
        var numComponents = messageHeaderParser.getInt16(bytes, numComponentsOffset); // CSiz
        
        var componentsDataOffset =
            sizMarkerOffset + jGlobals.j2kOffsets.NUM_COMPONENTS_OFFSET_AFTER_SIZ_MARKER + 2;
        var componentsDataLength = numComponents * 3;
        
        var componentsDataBytes = getBytes(
            mainHeaderDatabin, componentsDataLength, componentsDataOffset);
        
        var componentsScaleX = new Array(numComponents);
        var componentsScaleY = new Array(numComponents);
        for (var i = 0; i < numComponents; ++i) {
            componentsScaleX[i] = componentsDataBytes[i * 3 + 1];
            componentsScaleY[i] = componentsDataBytes[i * 3 + 2];
        }
        
        var result = {
            numComponents: numComponents,
            componentsScaleX: componentsScaleX,
            componentsScaleY: componentsScaleY,
            imageWidth: referenceGridSizeX - firstTileOffsetX,
            imageHeight: referenceGridSizeY - firstTileOffsetY,
            tileWidth: tileSizeX,
            tileHeight: tileSizeY,
            firstTileOffsetX: firstTileOffsetX,
            firstTileOffsetY: firstTileOffsetY
        };
        return result;
    };
    
    this.parseDefaultTileParams = function() {
        var mainHeaderDatabin = databinsSaver.getMainHeaderDatabin();

        var tileParams = parseCodingStyle(mainHeaderDatabin, /*isMandatory=*/true);
        return tileParams;
    };
    
    this.parseOverridenTileParams = function(tileIndex) {
        var tileHeaderDatabin = databinsSaver.getTileHeaderDatabin(tileIndex);
        
        // A.4.2 (Start Of Tile-part)
        
        var tileParams = parseCodingStyle(tileHeaderDatabin, /*isMandatory=*/false);
        return tileParams;
    };

    function parseCodingStyle(databin, isMandatory) {
        // A.5.1 (Image and Tile Size)

        var baseParams = offsetsCalculator.getCodingStyleBaseParams(
            databin, isMandatory);
        
        if (baseParams === null) {
            return null;
        }

        var mainHeaderDatabin = databinsSaver.getMainHeaderDatabin();

        var sizMarkerOffset = offsetsCalculator.getImageAndTileSizeOffset();
        
        var numComponentsOffset =
            sizMarkerOffset + jGlobals.j2kOffsets.NUM_COMPONENTS_OFFSET_AFTER_SIZ_MARKER;

        var numComponentsBytes = getBytes(
            mainHeaderDatabin,
            /*numBytes=*/2,
            /*startOffset=*/numComponentsOffset);
        var numComponents = messageHeaderParser.getInt16(numComponentsBytes, 0);
        
        var packedPacketHeadersMarkerInTileHeader =
            markersParser.getMarkerOffsetInDatabin(
                databin, jGlobals.j2kMarkers.PackedPacketHeadersInTileHeader);
        
        var packedPacketHeadersMarkerInMainHeader =
            markersParser.getMarkerOffsetInDatabin(
                mainHeaderDatabin, jGlobals.j2kMarkers.PackedPacketHeadersInMainHeader);
        
        var isPacketHeadersNearData =
            packedPacketHeadersMarkerInTileHeader === null &&
            packedPacketHeadersMarkerInMainHeader === null;
        
        var codingStyleMoreDataOffset = baseParams.codingStyleDefaultOffset + 6;
        var codingStyleMoreDataBytes = getBytes(
            databin,
            /*numBytes=*/6,
            /*startOffset=*/codingStyleMoreDataOffset);
        var numQualityLayers = messageHeaderParser.getInt16(
            codingStyleMoreDataBytes, 0);

        var codeblockWidth = parseCodeblockSize(
            codingStyleMoreDataBytes, 4);
        var codeblockHeight = parseCodeblockSize(
            codingStyleMoreDataBytes, 5);
        
        var precinctWidths = new Array(baseParams.numResolutionLevels);
        var precinctHeights = new Array(baseParams.numResolutionLevels);
        
        var precinctSizesBytes = null;
        if (!baseParams.isDefaultPrecinctSize) {
            var precinctSizesBytesNeeded = baseParams.numResolutionLevels;
            
            precinctSizesBytes = getBytes(
                databin,
                precinctSizesBytesNeeded,
                baseParams.precinctSizesOffset);
        }

        var defaultSize = 1 << 15;
        for (var i = 0; i < baseParams.numResolutionLevels; ++i) {
            if (baseParams.isDefaultPrecinctSize) {
                precinctWidths[i] = defaultSize;
                precinctHeights[i] = defaultSize;
                continue;
            }
            
            var precinctSizeOffset = i;
            var sizeExponents = precinctSizesBytes[precinctSizeOffset];
            var ppx = sizeExponents & 0x0F;
            var ppy = sizeExponents >>> 4;
            
            precinctWidths[i] = 1 * Math.pow(2, ppx); // Avoid negative result due to signed calculation
            precinctHeights[i] = 1 * Math.pow(2, ppy); // Avoid negative result due to signed calculation
        }
        
        var paramsPerComponent = new Array(numComponents);
        for (var j = 0; j < numComponents; ++j) {
            paramsPerComponent[j] = {
                maxCodeblockWidth: codeblockWidth,
                maxCodeblockHeight: codeblockHeight,
                
                numResolutionLevels: baseParams.numResolutionLevels,
                
                precinctWidthPerLevel: precinctWidths,
                precinctHeightPerLevel: precinctHeights
            };
        }
        
        var defaultComponentParams = {
            maxCodeblockWidth: codeblockWidth,
            maxCodeblockHeight: codeblockHeight,
            
            numResolutionLevels: baseParams.numResolutionLevels,
            
            precinctWidthPerLevel: precinctWidths,
            precinctHeightPerLevel: precinctHeights
            };
        
        var tileParams = {
            numQualityLayers: numQualityLayers,
            
            isPacketHeadersNearData: isPacketHeadersNearData,
            isStartOfPacketMarkerAllowed: baseParams.isStartOfPacketMarkerAllowed,
            isEndPacketHeaderMarkerAllowed: baseParams.isEndPacketHeaderMarkerAllowed,

            paramsPerComponent: paramsPerComponent,
            defaultComponentParams: defaultComponentParams
            };
        
        return tileParams;
    }
    
    function parseCodeblockSize(bytes, offset) {
        var codeblockSizeExponentMinus2 = bytes[offset];
        var codeblockSizeExponent = 2 + (codeblockSizeExponentMinus2 & 0x0F);
        
        if (codeblockSizeExponent > 10) {
            throw new jGlobals.j2kExceptions.IllegalDataException(
                'Illegal codeblock width exponent ' + codeblockSizeExponent,
                'A.6.1, Table A.18');
        }
        
        var size = 1 << codeblockSizeExponent;
        return size;
    }
    
    function getBytes(databin, numBytes, databinStartOffset, allowEndOfRange) {
        var bytes = [];

        var rangeOptions = {
            forceCopyAllRange: true,
            maxLengthToCopy: numBytes,
            databinStartOffset: databinStartOffset
            };
        
        var bytesCopied = databin.copyBytes(bytes, /*startOffset=*/0, rangeOptions);
        if (bytesCopied === null) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'Header data-bin has not yet recieved ' + numBytes +
                ' bytes starting from offset ' + databinStartOffset);
        }
        
        return bytes;
    }
};
},{"j2k-jpip-globals.js":12}],18:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipChannel = function JpipChannel(
    maxRequestsWaitingForResponseInChannel, sessionHelper, jpipFactory) {
    
    var self = this;
    var channelId = null;
    var requestId = 0;
    var requestsWaitingForChannelCreation = [];
    var requestsWaitingForResponse = [];
    var isDedicatedForMovableRequest = false;
    
    this.requestData = function requestData(
        codestreamPartParams,
        callback,
        failureCallback,
        numQualityLayers) {
        
        if (!isDedicatedForMovableRequest) {
            // No need to check if there are too many concurrent requests
            // if channel was dedicated for movable request. The reason is
            // that any request in dedicated channel cancel the previous one.
            
            var allWaitingRequests = getAllQueuedRequestCount();
            
            if (allWaitingRequests >= maxRequestsWaitingForResponseInChannel) {
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'Channel has too many requests not responded yet');
            }
        }

        var url = createRequestUrl(codestreamPartParams, numQualityLayers);
        var request = jpipFactory.createRequest(
            sessionHelper,
            self,
            url,
            callback,
            failureCallback);
        
        if (channelId !== null || requestsWaitingForResponse.length === 0) {
            requestsWaitingForResponse.push(request);
            request.startRequest();
        } else if (isDedicatedForMovableRequest) {
            // Those requests cancel all previous requests in channel, so no
            // need to log old requests
            requestsWaitingForChannelCreation = [request];
        } else {
            requestsWaitingForChannelCreation.push(request);
        }
        
        return request;
    };
    
    this.sendMinimalRequest = function sendMinimalRequest(callback) {
        if (channelId === null && requestsWaitingForResponse.length > 0) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'Minimal requests should be used for first request or keep ' +
                'alive message. Keep alive requires an already initialized ' +
                'channel, and first request requires to not have any ' +
                'previous request');
        }
        
        var url = createMinimalRequestUrl();
        var request = jpipFactory.createRequest(
            sessionHelper, self, url, callback);
        
        requestsWaitingForResponse.push(request);
        request.startRequest();
    };
    
    this.getIsDedicatedForMovableRequest =
        function getIsDedicatedForMovableRequest() {
        
        return isDedicatedForMovableRequest;
    };
    
    this.dedicateForMovableRequest = function dedicateForMovableRequest() {
        if (isDedicatedForMovableRequest) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'Channel already dedicated for movable request');
        }
        
        isDedicatedForMovableRequest = true;
    };
    
    this.getChannelId = function getChannelId() {
        return channelId;
    };
    
    this.setChannelId = function setChannelId(newChannelId) {
        if (newChannelId === null) {
            return;
        }
        
        channelId = newChannelId;
        
        var requestsToSend = requestsWaitingForChannelCreation;
        requestsWaitingForChannelCreation = [];
        
        for (var i = 0; i < requestsToSend.length; ++i) {
            requestsWaitingForResponse.push(requestsToSend[i]);
            requestsToSend[i].startRequest();
        }
    };
    
    this.nextRequestId = function nextRequestId() {
        return ++requestId;
    };
    
    this.getRequestsWaitingForResponse =
        function getRequestsWaitingForResponse() {
        
        return requestsWaitingForResponse;
    };
    
    this.getAllQueuedRequestCount = getAllQueuedRequestCount;
    
    this.requestEnded = function requestEnded(ajaxResponse, request) {
        var requests = requestsWaitingForResponse;
        var isFound = false;
        for (var i = 0; i < requests.length; ++i) {
            if (requests[i] === request) {
                requests[i] = requests[requests.length - 1];
                requests.length -= 1;
                isFound = true;
                break;
            }
        }
        
        if (!isFound) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'channel.requestsWaitingForResponse inconsistency');
        }
        
        sessionHelper.requestEnded(ajaxResponse, self);
        
        if (channelId === null && requestsWaitingForChannelCreation.length > 0) {
            // If not succeeded to create a channel ID yet,
            // perform an additional request
            
            var nextRequest = requestsWaitingForChannelCreation.shift();
            
            requestsWaitingForResponse.push(nextRequest);
            nextRequest.startRequest();
        }
    };
    
    this.isAllOldRequestsEnded = function isAllOldRequestsEnded(priorToId) {
        for (var i = 0; i < requestsWaitingForResponse.length; ++i) {
            if (requestsWaitingForResponse[i].lastRequestId <= priorToId) {
                return false;
            }
        }
        
        return true;
    };
    
    function getAllQueuedRequestCount() {
        var allWaitingRequests =
            requestsWaitingForResponse.length +
            requestsWaitingForChannelCreation.length;
        
        return allWaitingRequests;
    }
    
    function createMinimalRequestUrl(allowStopPreviousRequestsInChannel) {
        var requestUrl = sessionHelper.getDataRequestUrl();
        var targetId = sessionHelper.getTargetId();
        
        if (targetId !== '0') {
            requestUrl += '&tid=' + targetId;
        }
        
        var alreadySentMessagesOnChannel = channelId !== null;
        
        if (alreadySentMessagesOnChannel) {
            var isStopPrevious =
                isDedicatedForMovableRequest &&
                allowStopPreviousRequestsInChannel;
            
            if (isStopPrevious) {
                requestUrl += '&wait=no';
            } else {
                requestUrl += '&wait=yes';
            }
        }
        
        return requestUrl;
    }
        
    function createRequestUrl(codestreamPartParams, numQualityLayers) {
        var requestUrl = createMinimalRequestUrl(
            /*allowStopPreviousRequestsInChannel=*/true);
        
        var codestreamStructure = sessionHelper.getCodestreamStructure();
        
        var frameWidth = codestreamStructure.getLevelWidth(
            codestreamPartParams.numResolutionLevelsToCut);
        var frameHeight = codestreamStructure.getLevelHeight(
            codestreamPartParams.numResolutionLevelsToCut);
        
        var regionWidth =
            codestreamPartParams.maxXExclusive - codestreamPartParams.minX;
        var regionHeight =
            codestreamPartParams.maxYExclusive - codestreamPartParams.minY;
        
        requestUrl +=
            '&fsiz=' + frameWidth + ',' + frameHeight + ',closest' +
            '&rsiz=' + regionWidth + ',' + regionHeight +
            '&roff=' + codestreamPartParams.minX + ',' + codestreamPartParams.minY;
            
        if (numQualityLayers !== 'max') {
            requestUrl += '&layers=' + numQualityLayers;
        }
        
        return requestUrl;
    }
};
},{"j2k-jpip-globals.js":12}],19:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

var jpipMessageHeaderParser = {
        
    LSB_MASK: 0x1,
    BIT_4_MASK: 0x10,
    BITS_56_MASK: 0x60,
    MSB_MASK: 0x80,

    LSB_7_MASK: 0x7F,

    // A.2.1
    parseNumberInVbas: function parseNumberInVbasClosure(
        message, startOffset, bitsToTakeInFirstByte) {
        
        var self = jpipMessageHeaderParser;
        var currentOffset = startOffset;
        
        var result;
        if (bitsToTakeInFirstByte) {
            var maskFirstByte = (1 << bitsToTakeInFirstByte) - 1;
            result = message[currentOffset] & maskFirstByte;
        }
        else {
            result = message[currentOffset] & self.LSB_7_MASK;
        }
        
        while ( !!(message[currentOffset] & self.MSB_MASK) ) {
            ++currentOffset;

            result <<= 7;
            result |= message[currentOffset] & self.LSB_7_MASK;
        }
        
        return {
            endOffset: currentOffset + 1,
            number: result
        };
    },
    
    // A.2
    parseMessageHeader: function parseMessageHeaderClosure(
        message, startOffset, previousMessageHeader) {
        
        var self = jpipMessageHeaderParser;
        
        // A.2.1
        
        // First Vbas: Bin-ID
        
        var classAndCsnPrecense = (message[startOffset] & self.BITS_56_MASK) >>> 5;
        
        if (classAndCsnPrecense === 0) {
            throw new jGlobals.jpipExceptions.ParseException('Failed parsing message header ' +
                '(A.2.1): prohibited existance class and csn bits 00');
        }
        
        var hasClassVbas = !!(classAndCsnPrecense & 0x2);
        var hasCodeStreamIndexVbas = classAndCsnPrecense === 3;
        
        var isLastByteInDatabin = !!(message[startOffset] & self.BIT_4_MASK);
        
        // A.2.3
        var parsedInClassId = self.parseNumberInVbas(
            message, startOffset, /*bitsToTakeInFirstByte=*/4);
        var inClassId = parsedInClassId.number;
        var currentOffset = parsedInClassId.endOffset;
        
        // Second optional Vbas: Class ID
        
        var classId = 0;
        if (hasClassVbas) {
            var parsedClassId = self.parseNumberInVbas(message, currentOffset);
            classId = parsedClassId.number;
            currentOffset = parsedClassId.endOffset;
        }
        else if (previousMessageHeader) {
            classId = previousMessageHeader.classId;
        }
        
        // Third optional Vbas: Code Stream Index (Csn)
        
        var codestreamIndex = 0;
        if (hasCodeStreamIndexVbas) {
            var parsedCsn = self.parseNumberInVbas(message, currentOffset);
            codestreamIndex = parsedCsn.number;
            currentOffset = parsedCsn.endOffset;
        }
        else if (previousMessageHeader) {
            codestreamIndex = previousMessageHeader.codestreamIndex;
        }
        
        // 4th Vbas: Message offset
        
        var parsedOffset = self.parseNumberInVbas(message, currentOffset);
        var messageOffsetFromDatabinStart = parsedOffset.number;
        currentOffset = parsedOffset.endOffset;
        
        // 5th Vbas: Message length

        var parsedLength = self.parseNumberInVbas(message, currentOffset);
        var messageBodyLength = parsedLength.number;
        currentOffset = parsedLength.endOffset;
        
        // 6th optional Vbas: Aux
        
        // A.2.2
        var hasAuxVbas = !!(classId & self.LSB_MASK);
        
        var aux;
        if (hasAuxVbas) {
            var parsedAux = self.parseNumberInVbas(message, currentOffset);
            aux = parsedAux.number;
            currentOffset = parsedAux.endOffset;
        }
        
        // Return
        
        var result = {
            isLastByteInDatabin: isLastByteInDatabin,
            inClassId: inClassId,
            bodyStart: currentOffset,
            classId: classId,
            codestreamIndex: codestreamIndex,
            messageOffsetFromDatabinStart: messageOffsetFromDatabinStart,
            messageBodyLength: messageBodyLength
        };
        
        if (hasAuxVbas) {
            result.aux = aux;
        }
        
        return result;
    },
    
    getInt32: function getInt32Closure(data, offset) {
        var msb = data[offset] * Math.pow(2, 24); // Avoid negative result due to signed calculation
        var byte2 = data[offset + 1] << 16;
        var byte1 = data[offset + 2] << 8;
        var lsb = data[offset + 3];
        
        var result = msb + byte2 + byte1 + lsb;
        return result;
    },
    
    getInt16: function getInt16Closure(data, offset) {
        var msb = data[offset] << 8;
        var lsb = data[offset + 1];
        
        var result = msb + lsb;
        return result;
    }
};

module.exports.jpipMessageHeaderParser = jpipMessageHeaderParser;
},{"j2k-jpip-globals.js":12}],20:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipReconnectableRequester = function JpipReconnectableRequester(
    maxChannelsInSession,
    maxRequestsWaitingForResponseInChannel, 
    codestreamStructure,
    databinsSaver,
    jpipFactory,
    // NOTE: Move parameter to beginning and expose in CodestreamClient
    maxJpipCacheSizeConfig) {
    
    var MB = 1048576;
    var maxJpipCacheSize = maxJpipCacheSizeConfig || (10 * MB);
    
    var sessionWaitingForReady;
    var activeSession = null;
    var sessionWaitingForDisconnect = null;
    
    var url = null;
    var waitingForCloseSessions = 0;
    
    var nonDedicatedRequestsWaitingForSend = [];
    var dedicatedChannels = [];
    
    var statusCallback = null;
    var lastClosedCallback = null;
    
    this.getIsReady = function getIsReady() {
        return activeSession !== null && activeSession.getIsReady();
    };
    
    this.open = function open(baseUrl) {
        if (baseUrl === undefined || baseUrl === null) {
            throw new jGlobals.jpipExceptions.ArgumentException('baseUrl', baseUrl);
        }
        
        if (url !== null) {
            throw new jGlobals.jpipExceptions.IllegalOperationException(
                'Image was already opened');
        }
        
        url = baseUrl;
        createInternalSession();
    };
    
    this.close = function close(closedCallback) {
        if (lastClosedCallback !== null) {
            throw new jGlobals.jpipExceptions.IllegalOperationException('closed twice');
        }
        
        lastClosedCallback = closedCallback;
        waitingForCloseSessions = 1;
        
        closeInternalSession(activeSession);
        closeInternalSession(sessionWaitingForReady);
        closeInternalSession(sessionWaitingForDisconnect);
        
        checkIfAllSessionsClosedAfterSessionClosed();
    };

    this.setStatusCallback = function setStatusCallback(newStatusCallback) {
        statusCallback = newStatusCallback;
        
        if (activeSession !== null) {
            activeSession.setStatusCallback(newStatusCallback);
        }
    };
    
    this.dedicateChannelForMovableRequest =
        function dedicateChannelForMovableRequest() {

        checkReady();
        
        var dedicatedChannelHandle = { internalDedicatedChannel: null };
        dedicatedChannels.push(dedicatedChannelHandle);
        createInternalDedicatedChannel(dedicatedChannelHandle);
        
        return dedicatedChannelHandle;
    };
    
    this.requestData = function requestData(
        codestreamPartParams,
        callback,
        failureCallback,
        numQualityLayers,
        dedicatedChannelHandleToMove) {

        checkReady();
        
        var request = {
            isEnded: false,
            internalRequest: null,
            
            codestreamPartParams: codestreamPartParams,
            callback: callback,
            failureCallback: failureCallback,
            numQualityLayers: numQualityLayers
            };
        
        var channel;
        var moveDedicatedChannel = dedicatedChannelHandleToMove !== undefined;
        
        if (moveDedicatedChannel) {
            channel = dedicatedChannelHandleToMove.internalDedicatedChannel;
        } else {
            channel = activeSession.tryGetChannel();
            
            if (channel === null) {
                nonDedicatedRequestsWaitingForSend.push(request);
                return request;
            } else if (channel.getIsDedicatedForMovableRequest()) {
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'Expected non-movable channel');
            }
        }
        
        if (channel.getIsDedicatedForMovableRequest() !== moveDedicatedChannel) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'getIsDedicatedForMovableRequest inconsistency');
        }

        request.internalRequest = channel.requestData(
            codestreamPartParams,
            callback,
            failureCallback,
            numQualityLayers);

        return request;
    };
    
    this.stopRequestAsync = function stopRequestAsync(request) {
        request.isEnded = true;
        
        if (request.internalRequest !== null) {
            request.internalRequest.stopRequestAsync();
        }
    };
    
    this.reconnect = reconnect;
    
    function reconnect() {
        if (sessionWaitingForReady !== null) {
            throw new jGlobals.jpipExceptions.IllegalOperationException(
                'Previous session still not established');
        }
        
        if (sessionWaitingForDisconnect !== null) {
            if (statusCallback !== null) {
                statusCallback({
                    isReady: true,
                    exception: //jpipExceptions.InvalidOperationException(
                        'Previous session that should be closed still alive.' +
                        'Maybe old requestContexts have not beed closed. ' +
                        'Reconnect will not be done' //);
                    });
            }
            
            return;
        }
        
        databinsSaver.cleanupUnregisteredDatabins();
        createInternalSession();
    }
    
    function createInternalSession() {
        var targetId;
        if (activeSession !== null) {
            targetId = activeSession.getTargetId();
        }
        
        sessionWaitingForReady = jpipFactory.createSession(
            maxChannelsInSession,
            maxRequestsWaitingForResponseInChannel,
            targetId,
            codestreamStructure,
            databinsSaver);
            
        sessionWaitingForReady.setStatusCallback(waitingForReadyCallback);
        
        sessionWaitingForReady.open(url);
    }
    
    function createInternalDedicatedChannel(dedicatedChannelHandle) {
        var channel = activeSession.tryGetChannel(
            /*dedicateForMovableRequest=*/true);
        
        if (channel === null) {
            throw new jGlobals.jpipExceptions.InvalidOperationException(
                'Too many concurrent requests. Limit the use of dedicated ' +
                '(movable) requests, enlarge maxChannelsInSession or wait ' +
                'for requests to finish and avoid create new ones');
        }
        
        if (!channel.getIsDedicatedForMovableRequest()) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'getIsDedicatedForMovableRequest inconsistency');
        }

        dedicatedChannelHandle.internalDedicatedChannel = channel;
    }
    
    function waitingForReadyCallback(status) {
        if (sessionWaitingForReady === null ||
            status.isReady !== sessionWaitingForReady.getIsReady()) {
            
            throw new jGlobals.jpipExceptions.InternalErrorException('Unexpected ' +
                'statusCallback when not registered to session or ' +
                'inconsistent isReady');
        }
        
        if (status.isReady) {
            if (sessionWaitingForDisconnect !== null) {
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'sessionWaitingForDisconnect should be null');
            }
            
            sessionWaitingForDisconnect = activeSession;
            activeSession = sessionWaitingForReady;
            sessionWaitingForReady = null;
            
            if (sessionWaitingForDisconnect !== null) {
                sessionWaitingForDisconnect.setStatusCallback(null);
                if (!tryDisconnectWaitingSession()) {
                    sessionWaitingForDisconnect.setRequestEndedCallback(
                        tryDisconnectWaitingSession);
                }
            }
            
            activeSession.setStatusCallback(statusCallback);
            activeSession.setRequestEndedCallback(activeSessionRequestEndedCallback);
            
            for (var i = 0; i < dedicatedChannels.length; ++i) {
                createInternalDedicatedChannel(dedicatedChannels[i]);
            }
        }
        
        if (statusCallback !== null) {
            statusCallback(status);
        }
    }
    
    function closeInternalSession(session) {
        if (session !== null) {
            ++waitingForCloseSessions;
            session.close(checkIfAllSessionsClosedAfterSessionClosed);
        }
    }
    
    function checkIfAllSessionsClosedAfterSessionClosed() {
        --waitingForCloseSessions;
        
        if (waitingForCloseSessions === 0 && lastClosedCallback !== undefined) {
            lastClosedCallback();
        }
    }
    
    function checkReady() {
        if (activeSession === null) {
            throw new jGlobals.jpipExceptions.InternalErrorException('This operation ' +
                'is forbidden when session is not ready');
        }
    }
    
    function activeSessionRequestEndedCallback(channelFreed) {
        var request = null;
        
        if (databinsSaver.getLoadedBytes() > maxJpipCacheSize) {
            reconnect();
        }
        
        if (channelFreed === null) {
            return;
        }
        
        if (channelFreed.getIsDedicatedForMovableRequest()) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'Expected non-movable channel as channelFreed');
        }
        
        do {
            if (nonDedicatedRequestsWaitingForSend.length === 0) {
                request = null;
                break;
            }
            
            request = nonDedicatedRequestsWaitingForSend.shift();
            if (request.internalRequest !== null) {
                throw new jGlobals.jpipExceptions.InternalErrorException('Request was ' +
                    'already sent but still in queue');
            }
        } while (request.isEnded);
        
        if (request !== null) {
            request.internalRequest = channelFreed.requestData(
                request.codestreamPartParams,
                request.callback,
                request.failureCallback,
                request.numQualityLayers);
        }
    }
    
    function tryDisconnectWaitingSession() {
        var canCloseSession = !sessionWaitingForDisconnect.hasActiveRequests();
        
        if (canCloseSession) {
            sessionWaitingForDisconnect.close();
            sessionWaitingForDisconnect = null;
        }
        
        return canCloseSession;
    }
};
},{"j2k-jpip-globals.js":12}],21:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipRequest = function JpipRequest(
    sessionHelper,
    messageHeaderParser,
    channel,
    requestUrl,
    callback,
    failureCallback) {
    
    var KB = 1024;
    var PROGRESSIVENESS_MIN_LENGTH_BYTES = 10 * KB;

    var RESPONSE_ENDED_SUCCESS = 1;
    var RESPONSE_ENDED_ABORTED = 2;
    var RESPONSE_ENDED_SENT_ANOTHER_MESSAGE = 3;
    
    var self = this;
    var isActive = false;
    var endedByUser = false;
    var lastRequestId;
    var responseLength = PROGRESSIVENESS_MIN_LENGTH_BYTES;
    
    this.startRequest = function startRequest() {
        if (isActive) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'startRequest called twice');
        } else if (endedByUser) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'request was already stopped');
        }
        
        isActive = true;
        sessionHelper.requestStarted();
        
        sendMessageOfDataRequest();
    };

    this.stopRequestAsync = function stopRequestAsync(request) {
        endedByUser = true;
    };
    
    this.getLastRequestId = function getLastRequestId() {
        if (!isActive) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'Unexpected call to getLastRequestId on inactive request');
        }
        
        return lastRequestId;
    };
    
    this.callCallbackAfterConcurrentRequestsFinished =
        function callCallbackAfterConcurrentRequestsFinished() {
        
        callback(self, /*isResponseDone=*/true);
    };
    
    function internalSuccessCallback(ajaxResponse, isResponseDone) {
        var failed = false;

        try {
            var endedReason = processAjaxResponse(ajaxResponse, isResponseDone);
            
            if (endedReason === RESPONSE_ENDED_SENT_ANOTHER_MESSAGE) {
                return;
            }
            
            failed = endedReason === RESPONSE_ENDED_ABORTED;
        } catch (e) {
            failed = true;
            sessionHelper.onException(e);
        }
        
        try {
            if (!failed) {
                sessionHelper.waitForConcurrentRequestsToEnd(self);
            }
            
            channel.requestEnded(ajaxResponse, self);

            if (failed && !endedByUser && failureCallback !== undefined) {
                failureCallback();
            }
            
            sessionHelper.checkConcurrentRequestsFinished();
        } catch (e) {
            sessionHelper.onException(e);
        }
    }
    
    function internalFailureCallback(ajaxResponse) {
        channel.requestEnded(ajaxResponse, self);
        sessionHelper.checkConcurrentRequestsFinished();
        
        if (failureCallback !== undefined) {
            failureCallback();
        }
    }
    
    function processAjaxResponse(ajaxResponse, isResponseDone) {
        if (!isResponseDone) {
            throw new jGlobals.jpipExceptions.InternalErrorException('AJAX ' +
                'callback called although response is not done yet ' +
                'and chunked encoding is not enabled');
        }
                
        var createdChannel = sessionHelper.getCreatedChannelId(
            ajaxResponse);
        
        if (createdChannel !== null) {
            if (channel.getChannelId() !== null) {
                sessionHelper.onException(
                    new jGlobals.jpipExceptions.IllegalDataException(
                        'Channel created although was not requested', 'D.2.3'));
            } else {
                channel.setChannelId(createdChannel);
            }
        } else if (channel.getChannelId() === null) {
            sessionHelper.onException(
                new jGlobals.jpipExceptions.IllegalDataException(
                    'Cannot extract cid from cnew response', 'D.2.3'));
        }
        
        var endOffset = saveToDatabinsFromOffset(ajaxResponse);
        
        if (endOffset === null) {
            return RESPONSE_ENDED_ABORTED;
        }
        
        var endedReason = parseEndOfResponse(ajaxResponse, endOffset);
        return endedReason;
    }
    
    function sendMessageOfDataRequest() {
        lastRequestId = channel.nextRequestId();
        
        var url = requestUrl +
            '&len=' + responseLength +
            '&qid=' + lastRequestId;
        
        responseLength *= 2;
        
        var shouldCreateChannel = channel.getChannelId() === null;
        if (shouldCreateChannel) {
            url += '&cnew=http';
            
            var existChannelInSession = sessionHelper.getFirstChannel();
                
            if (existChannelInSession !== null) {
                url += '&cid=' + existChannelInSession.getChannelId();
            }
            
            // NOTE: If existChannelInSession, maybe should remove "&stream=0"
        } else {
            url += '&cid=' + channel.getChannelId();
        }
        
        sessionHelper.sendAjax(
            url,
            internalSuccessCallback,
            internalFailureCallback);
    }
    
    function parseEndOfResponse(ajaxResponse, offset) {
        var endResponseResult = RESPONSE_ENDED_ABORTED;
        var bytes = new Uint8Array(ajaxResponse.response);
        
        if (offset > bytes.length - 2 ||
            bytes[offset] !== 0) {
            
            throw new jGlobals.jpipExceptions.IllegalDataException('Could not find ' +
                'End Of Response (EOR) code at the end of response', 'D.3');
        }
        
        switch (bytes[offset + 1]) {
            case jGlobals.jpipEndOfResponseReasons.IMAGE_DONE:
            case jGlobals.jpipEndOfResponseReasons.WINDOW_DONE:
            case jGlobals.jpipEndOfResponseReasons.QUALITY_LIMIT:
                endResponseResult = RESPONSE_ENDED_SUCCESS;
                break;
            
            case jGlobals.jpipEndOfResponseReasons.WINDOW_CHANGE:
                if (!endedByUser) {
                    throw new jGlobals.jpipExceptions.IllegalOperationException(
                        'Server response was terminated due to newer ' +
                        'request issued on same channel. That may be an ' +
                        'internal webjpip.js error - Check that movable ' +
                        'requests are well maintained');
                }
                break;
            
            case jGlobals.jpipEndOfResponseReasons.BYTE_LIMIT:
            case jGlobals.jpipEndOfResponseReasons.RESPONSE_LIMIT:
                if (!endedByUser) {
                    sendMessageOfDataRequest();
                    endResponseResult = RESPONSE_ENDED_SENT_ANOTHER_MESSAGE;
                }
                
                break;
            
            case jGlobals.jpipEndOfResponseReasons.SESSION_LIMIT:
                sessionHelper.onException(
                    new jGlobals.jpipExceptions.IllegalOperationException(
                        'Server resources associated with the session is ' +
                        'limitted, no further requests should be issued to ' +
                        'this session'));
                break;
            
            case jGlobals.jpipEndOfResponseReasons.NON_SPECIFIED:
                sessionHelper.onException(new jGlobals.jpipExceptions.IllegalOperationException(
                    'Server error terminated response with no reason specified'));
                break;
                    
            default:
                sessionHelper.onException(
                    new jGlobals.jpipExceptions.IllegalDataException(
                        'Server responded with illegal End Of Response ' +
                        '(EOR) code: ' + bytes[offset + 1]));
                break;
        }
        
        return endResponseResult;
    }
    
    function saveToDatabinsFromOffset(ajaxResponse) {
        try {
            var bytes = new Uint8Array(ajaxResponse.response);
            
            var offset = 0;
            var previousHeader;
            
            while (offset < bytes.length) {
                if (bytes[offset] === 0) {
                    // End Of Response (EOR)
                    break;
                }
                
                var header = messageHeaderParser.parseMessageHeader(
                    bytes, offset, previousHeader);
                
                if (header.bodyStart + header.messageBodyLength > bytes.length) {
                    return offset;
                }
                
                sessionHelper.getDatabinsSaver().saveData(header, bytes);
                
                offset = header.bodyStart + header.messageBodyLength;
                previousHeader = header;
            }
            
            return offset;
        } catch (e) {
            sessionHelper.onException(e);
            
            return null;
        }
    }
};
},{"j2k-jpip-globals.js":12}],22:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipSessionHelper = function JpipSessionHelper(
    dataRequestUrl,
    knownTargetId,
    codestreamStructure,
    databinsSaver,
    ajaxHelper) {
    
    var statusCallback = null;
    var requestEndedCallback = null;
    
    var channels = [];
    var firstChannel = null;

    var activeRequests = 0;
    var waitingForConcurrentRequests = [];

    var isReady = false;
    var targetId = knownTargetId || '0';
    
    this.onException = function onException(exception) {
        onStatusChange(exception);
    };
    
    this.getIsReady = function getIsReady() {
        return isReady;
    };
    
    this.setIsReady = function setIsReady(isReady_) {
        isReady = isReady_;
        onStatusChange();
    };
    
    this.getCodestreamStructure = function getCodestreamStructure() {
        return codestreamStructure;
    };
    
    this.getDatabinsSaver = function getDatabinsSaver() {
        return databinsSaver;
    };
    
    this.getDataRequestUrl = function getDataRequestUrl() {
        return dataRequestUrl;
    };
    
    this.getTargetId = function getTargetId() {
        return targetId;
    };
    
    this.getFirstChannel = function getFirstChannel() {
        return firstChannel;
    };
    
    this.setStatusCallback = function setStatusCallback(statusCallback_) {
        statusCallback = statusCallback_;
    };
    
    this.setRequestEndedCallback = function setRequestEndedCallback(
        requestEndedCallback_) {
        
        requestEndedCallback = requestEndedCallback_;
    };
    
    this.requestStarted = function requestStarted() {
        ++activeRequests;
    };
    
    this.requestEnded = function requestEnded(ajaxResponse, channel) {
        --activeRequests;
        
        var targetIdFromServer = ajaxResponse.getResponseHeader('JPIP-tid');
        if (targetIdFromServer !== '' && targetIdFromServer !== null) {
            if (targetId === '0') {
                targetId = targetIdFromServer;
            } else if (targetId !== targetIdFromServer) {
                throw new jGlobals.jpipExceptions.IllegalDataException(
                    'Server returned unmatched target ID');
            }
        }
        
        if (firstChannel === null) {
            firstChannel = channel;
        }
        
        var channelFreed = channel.getIsDedicatedForMovableRequest() ?
            null : channel;
        
        if (requestEndedCallback !== null) {
            requestEndedCallback(channelFreed);
        }
    };
    
    this.getActiveRequestsCount = function getActiveRequestsCount() {
        return activeRequests;
    };
    
    this.channelCreated = function channelCreated(channel) {
        channels.push(channel);
    };
    
    this.getCreatedChannelId = function getCreatedChannelId(ajaxResponse) {
        var cnewResponse = ajaxResponse.getResponseHeader('JPIP-cnew');
        if (!cnewResponse) {
            return null;
        }
        
        var keyValuePairsInResponse = cnewResponse.split(',');

        for (var i = 0; i < keyValuePairsInResponse.length; ++i) {
            var keyAndValue = keyValuePairsInResponse[i].split('=');

            if (keyAndValue[0] === 'cid') {
                return keyAndValue[1];
            }
        }
        
        return null;
    };
    
    this.waitForConcurrentRequestsToEnd =
        function waitForConcurrentRequestsToEnd(request) {
        
        var concurrentRequests = [];
        
        for (var i = 0; i < channels.length; ++i) {
            var requests = channels[i].getRequestsWaitingForResponse();
            var numRequests = requests.length;
            if (numRequests === 0) {
                continue;
            }
            
            var lastRequestId = requests[0].getLastRequestId();
            for (var j = 1; j < requests.length; ++j) {
                lastRequestId = Math.max(
                    lastRequestId, requests[j].getLastRequestId());
            }
            
            concurrentRequests.push({
                channel: channels[i],
                requestId: lastRequestId
                });
        }
        
        waitingForConcurrentRequests.push({
            request: request,
            concurrentRequests: concurrentRequests
            });
    };

    this.checkConcurrentRequestsFinished =
        function checkConcurrentRequestsFinished() {
        
        for (var i = waitingForConcurrentRequests.length - 1; i >= 0; --i) {
            var isAllConcurrentRequestsFinished = false;
            var concurrentRequests =
                waitingForConcurrentRequests[i].concurrentRequests;
            
            for (var j = concurrentRequests.length - 1; j >= 0; --j) {
                var waiting = concurrentRequests[j];
                
                if (waiting.channel.isAllOldRequestsEnded(waiting.requestId)) {
                    concurrentRequests[j] = concurrentRequests[
                        concurrentRequests.length - 1];
                    concurrentRequests.length -= 1;
                }
            }
            
            if (concurrentRequests.length > 0) {
                continue;
            }
            
            var request = waitingForConcurrentRequests[i].request;
            var callback = request.callback;
            
            waitingForConcurrentRequests[i] = waitingForConcurrentRequests[
                waitingForConcurrentRequests.length - 1];
            waitingForConcurrentRequests.length -= 1;
            
            request.callCallbackAfterConcurrentRequestsFinished();
        }
    };
    
    this.sendAjax = function sendAjax(
        url,
        callback,
        failureCallback) {
        
        var forkedFailureCallback;
        
        if (failureCallback) {
            forkedFailureCallback = function forkFailureCallback(ajaxResponse) {
                generalFailureCallback(ajaxResponse);
                failureCallback(ajaxResponse);
            };
        } else {
            forkedFailureCallback = generalFailureCallback;
        }
        
        ajaxHelper.request(url, callback, forkedFailureCallback);
    };
    
    function generalFailureCallback(ajaxResponse) {
        var exception = new jGlobals.jpipExceptions.InternalErrorException(
            'Bad jpip server response (status = ' + ajaxResponse.status + ')');
            
        onStatusChange(exception);
    }
    
    function onStatusChange(exception) {
        if (exception === undefined) {
            exception = null;
        }
        
        if (statusCallback !== null) {
            statusCallback({
                isReady: isReady,
                exception: exception
            });
        }
    }
};
},{"j2k-jpip-globals.js":12}],23:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipSession = function JpipSession(
    maxChannelsInSession,
    maxRequestsWaitingForResponseInChannel,
    knownTargetId,
    codestreamStructure,
    databinsSaver,
    setIntervalFunction,
    clearIntervalFunction,
    jpipFactory) {

    var SECOND = 1000;
    var KEEP_ALIVE_INTERVAL = 30 * SECOND;
    
    var channelManagementUrl;
    var dataRequestUrl;
    var closeSessionUrl;
    
    var isCloseCalled = false;
    var closeCallbackPending = null;

    var sessionHelper = null;
    var statusCallback = null;
    var requestEndedCallback = null;

    var nonDedicatedChannels = [];
    var channelsCreated = 0;
    var keepAliveIntervalHandle = null;
    
    this.open = function open(baseUrl) {
        if (sessionHelper !== null) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'session.open() should be called only once');
        }
        
        var queryParamsDelimiter = baseUrl.indexOf('?') < 0 ? '?' : '&';
        channelManagementUrl = baseUrl + queryParamsDelimiter + 'type=' + 
            (databinsSaver.getIsJpipTilePartStream() ? 'jpt-stream' : 'jpp-stream');
        dataRequestUrl = channelManagementUrl + '&stream=0';
        
        sessionHelper = jpipFactory.createSessionHelper(
            dataRequestUrl, knownTargetId, codestreamStructure, databinsSaver);
        
        if (statusCallback !== null) {
            sessionHelper.setStatusCallback(statusCallback);
        }
        
        if (requestEndedCallback !== null) {
            sessionHelper.setRequestEndedCallback(requestEndedCallback);
        }
        
        var channel = createChannel();
        
        channel.sendMinimalRequest(sessionReadyCallback);
    };
    
    this.getTargetId = function getTargetId() {
        ensureReady();
        return sessionHelper.getTargetId();
    };
    
    this.getIsReady = function getIsReady() {
        var isReady = sessionHelper !== null && sessionHelper.getIsReady();
        return isReady;
    };
    
    this.setStatusCallback = function setStatusCallback(statusCallback_) {
        statusCallback = statusCallback_;
        
        if (sessionHelper !== null) {
            sessionHelper.setStatusCallback(statusCallback_);
        }
    };
    
    this.setRequestEndedCallback = function setRequestEndedCallback(
        requestEndedCallback_) {
        
        requestEndedCallback = requestEndedCallback_;
        
        if (sessionHelper !== null) {
            sessionHelper.setRequestEndedCallback(requestEndedCallback_);
        }
    };
    
    this.hasActiveRequests = function hasActiveRequests() {
        ensureReady();

        var isActiveRequests = sessionHelper.getActiveRequestsCount() > 0;
        return isActiveRequests;
    };
    
    this.tryGetChannel = function tryGetChannel(dedicateForMovableRequest) {
        ensureReady();
        
        var canCreateNewChannel = channelsCreated < maxChannelsInSession;
        var searchOnlyChannelWithEmptyQueue =
            canCreateNewChannel || dedicateForMovableRequest;
        
        var maxRequestsInChannel = searchOnlyChannelWithEmptyQueue ?
            0 : maxRequestsWaitingForResponseInChannel - 1;

        var channel = getChannelWithMinimalWaitingRequests(
            maxRequestsInChannel,
            /*isExtractFromNonDedicatedList=*/dedicateForMovableRequest);
        
        if (channel === null && canCreateNewChannel) {
            channel = createChannel(dedicateForMovableRequest);
        }
        
        if (dedicateForMovableRequest && channel !== null) {
            channel.dedicateForMovableRequest();
        }
        
        return channel;
    };
    
    this.close = function close(closedCallback) {
        if (channelsCreated === 0) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'Cannot close session before open');
        }

        if (isCloseCalled) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'Cannot close session twice');
        }
        
        isCloseCalled = true;
        closeCallbackPending = closedCallback;
        
        if (closeSessionUrl !== undefined) {
            closeInternal();
        }
    };
    
    function closeInternal() {
        if (keepAliveIntervalHandle !== null) {
            clearIntervalFunction(keepAliveIntervalHandle);
        }
        
        sessionHelper.setIsReady(false);
        sessionHelper.sendAjax(closeSessionUrl, closeCallbackPending);
    }
    
    function createChannel(isDedicatedForMovableRequest) {
        ++channelsCreated;
        var channel = jpipFactory.createChannel(
            maxRequestsWaitingForResponseInChannel, sessionHelper);
        
        sessionHelper.channelCreated(channel);
        
        if (!isDedicatedForMovableRequest) {
            nonDedicatedChannels.push(channel);
        }

        return channel;
    }
    
    function getChannelWithMinimalWaitingRequests(
        maxRequestsInChannel, isExtractFromNonDedicatedList) {
        
        var channel = null;
        var index;
        var minimalWaitingRequests = maxRequestsInChannel + 1;
        
        for (var i = 0; i < nonDedicatedChannels.length; ++i) {
            var waitingRequests =
                nonDedicatedChannels[i].getAllQueuedRequestCount();
            
            if (waitingRequests < minimalWaitingRequests) {
                channel = nonDedicatedChannels[i];
                index = i;
                minimalWaitingRequests = waitingRequests;
            }
            
            if (waitingRequests === 0) {
                break;
            }
        }
        
        if (!isExtractFromNonDedicatedList || channel === null) {
            return channel;
        }
        
        nonDedicatedChannels[index] =
            nonDedicatedChannels[nonDedicatedChannels.length - 1];
        nonDedicatedChannels.length -= 1;
        
        return channel;
    }
    
    function sessionReadyCallback() {
        var mainHeaderDatabin = databinsSaver.getMainHeaderDatabin();
        if (!mainHeaderDatabin.isAllDatabinLoaded()) {
            throw new jGlobals.jpipExceptions.IllegalDataException(
                'Main header was not loaded on session creation');
        }
        
        var arbitraryChannel = sessionHelper.getFirstChannel();
        var arbitraryChannelId = arbitraryChannel.getChannelId();
        closeSessionUrl = channelManagementUrl +
            '&cclose=*' +
            '&cid=' + arbitraryChannelId;
            
        if (isCloseCalled) {
            closeInternal();
            return;
        }
        
        keepAliveIntervalHandle = setIntervalFunction(
            keepAliveHandler, KEEP_ALIVE_INTERVAL);
        
        sessionHelper.setIsReady(true);
    }
    
    function keepAliveHandler() {
        if (sessionHelper.getActiveRequestsCount() > 0) {
            return;
        }
        
        var arbitraryChannel = sessionHelper.getFirstChannel();
        arbitraryChannel.sendMinimalRequest(function dummyCallback() {});
    }
    
    function ensureReady() {
        if (sessionHelper === null || !sessionHelper.getIsReady()) {
            throw new jGlobals.jpipExceptions.InternalErrorException('Cannot perform ' +
                'this operation when the session is not ready');
        }
    }
};
},{"j2k-jpip-globals.js":12}],24:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipBitstreamReader = (function JpipBitstreamReaderClosure() {
    var zeroBitsUntilFirstOneBitMap = createZeroBitsUntilFirstOneBitMap();

    function JpipBitstreamReader(databin, transactionHelper) {
        var initialState = {
            nextOffsetToParse: 0,
            validBitsInCurrentByte: 0,
            originalByteWithoutShift: null,
            currentByte: null,
            isSkipNextByte: false
            };

        var streamState = transactionHelper.createTransactionalObject(initialState);
        var activeTransaction = null;
        
        Object.defineProperty(this, 'activeTransaction', {
            get: function getActiveTransaction() {
                if (activeTransaction === null ||
                    !activeTransaction.isActive) {
                    throw new jGlobals.jpipExceptions.InternalErrorException(
                        'No active transaction in bitstreamReader');
                }
                
                return activeTransaction;
            }
        });
        
        Object.defineProperty(this, 'bitsCounter', {
            get: function getBitsCounter() {
                var state = streamState.getValue(activeTransaction);
                
                tryValidateCurrentByte(databin, state);
                if (state.isSkipNextByte) {
                    throw new jGlobals.jpipExceptions.InternalErrorException(
                        'Unexpected state of bitstreamReader: ' +
                        'When 0xFF encountered, tryValidateCurrentByte ' +
                        'should skip the whole byte  after ' +
                        'shiftRemainingBitsInByte and clear isSkipNextByte. ' +
                        'However the flag is still set');
                }
                
                var result = state.nextOffsetToParse * 8 - state.validBitsInCurrentByte;
                
                return result;
            }
        });
        
        Object.defineProperty(this, 'databinOffset', {
            get: function getDatabinOffset() {
                var state = streamState.getValue(activeTransaction);
                
                if (state.isSkipNextByte) {
                    return state.nextOffsetToParse + 1;
                }
                
                if (state.validBitsInCurrentByte % 8 !== 0 ||
                    state.originalByteWithoutShift === 0xFF) {
                    
                    throw new jGlobals.jpipExceptions.InternalErrorException(
                        'Cannot calculate databin offset when bitstreamReader ' +
                        ' is in the middle of the byte');
                }
                
                return state.nextOffsetToParse - state.validBitsInCurrentByte / 8;
            },
            
            set: function setDatabinOffset(offsetInBytes) {
                var state = streamState.getValue(activeTransaction);
                state.validBitsInCurrentByte = 0;
                state.isSkipNextByte = false;
                state.originalByteWithoutShift = null;
                state.nextOffsetToParse = offsetInBytes;
            }
        });
        
        this.startNewTransaction = function startNewTransaction() {
            if (activeTransaction !== null && activeTransaction.isActive) {
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'Cannot start new transaction in bitstreamReader ' +
                    'while another transaction is active');
            }
            
            activeTransaction = transactionHelper.createTransaction();
        };
        
        this.shiftRemainingBitsInByte = function shiftRemainingBitsInByte() {
            var state = streamState.getValue(activeTransaction);

            state.isSkipNextByte = state.originalByteWithoutShift === 0xFF;
            state.validBitsInCurrentByte = Math.floor(
                state.validBitsInCurrentByte / 8);
        };
        
        this.shiftBit = function shiftBit() {
            var state = streamState.getValue(activeTransaction);
            if (!tryValidateCurrentByte(databin, state)) {
                return null;
            }
            
            var onesCount = countAndShiftBits(
                databin,
                state,
                /*isUntilZeroBit=*/true,
                /*maxBitsToShift=*/1);
            
            return onesCount;
        };
        
        this.countZerosAndShiftUntilFirstOneBit =
            function countZerosAndShiftUntilFirstOneBit(maxBitsToShift) {
                var state = streamState.getValue(activeTransaction);
                var result = countAndShiftBits(
                    databin, state, /*isUntilZeroBit=*/false, maxBitsToShift);
                return result;
        };
        
        this.countOnesAndShiftUntilFirstZeroBit =
            function countOnesAndShiftUntilFirstZeroBit(maxBitsToShift) {
                var state = streamState.getValue(activeTransaction);
                var result = countAndShiftBits(
                    databin, state, /*isUntilZeroBit=*/true, maxBitsToShift);
                return result;
        };
        
        this.shiftBits = function shiftBits(bitsCount) {
            var result = 0;
            var state = streamState.getValue(activeTransaction);
            var remainingBits = bitsCount;
            
            while (remainingBits > 0) {
                if (!tryValidateCurrentByte(databin, state)) {
                    return null;
                }
                
                var bitsToTake = Math.min(
                    state.validBitsInCurrentByte, remainingBits);
                
                var addToResult = state.currentByte >> (8 - bitsToTake);
                result = (result << bitsToTake) + addToResult;
                
                removeBitsFromByte(state, bitsToTake);
                remainingBits -= bitsToTake;
            }
            
            return result;
        };
    }
    
    function countAndShiftBits(databin, state, isUntilZeroBit, maxBitsToShift) {
        var countedBits = 0;
        var foundTerminatingBit;
        var remainingBits = maxBitsToShift;
        
        do {
            if (!tryValidateCurrentByte(databin, state)) {
                return null;
            }
            
            var byteValue = isUntilZeroBit ? ~state.currentByte : state.currentByte;
            var bitsCountIncludingTerminatingBit = Math.min(
                zeroBitsUntilFirstOneBitMap[byteValue],
                state.validBitsInCurrentByte + 1);
            
            var bitsCountNotIncludingTerminatingBit =
                bitsCountIncludingTerminatingBit - 1;
            
            if (remainingBits !== undefined) {
                if (bitsCountIncludingTerminatingBit > remainingBits) {
                    removeBitsFromByte(state, remainingBits);
                    countedBits += remainingBits;
                    break;
                }
                
                remainingBits -= bitsCountNotIncludingTerminatingBit;
            }
            
            countedBits += bitsCountNotIncludingTerminatingBit;
            
            foundTerminatingBit =
                bitsCountIncludingTerminatingBit <= state.validBitsInCurrentByte;

            if (foundTerminatingBit) {
                removeBitsFromByte(state, bitsCountIncludingTerminatingBit);
            } else {
                state.validBitsInCurrentByte = 0;
            }
        } while (!foundTerminatingBit);
        
        return countedBits;
    }
    
    function removeBitsFromByte(state, bitsCount) {
        state.validBitsInCurrentByte -= bitsCount;
        if (state.validBitsInCurrentByte > 0) {
            state.currentByte = (state.currentByte << bitsCount) & 0xFF;
        }
    }

    function tryValidateCurrentByte(databin, state) {
        if (state.validBitsInCurrentByte > 0) {
            return true;
        }
        
        var bytesNeeded = state.isSkipNextByte ? 2 : 1;
        
        var resultArray = [];
        var bytesCopied = databin.copyBytes(resultArray, /*resultStartOffset=*/0, {
            forceCopyAllRange: true,
            databinStartOffset: state.nextOffsetToParse,
            maxLengthToCopy: bytesNeeded
            });
        
        if (bytesCopied !== bytesNeeded) {
            return false;
        }

        var prevByte = state.originalByteWithoutShift;

        state.currentByte = resultArray[bytesNeeded - 1];
        state.validBitsInCurrentByte = 8;
        state.originalByteWithoutShift = state.currentByte;
        
        if (prevByte === 0xFF) {
            if ((resultArray[0] & 0x80) !== 0) {
                throw new jGlobals.j2kExceptions.IllegalDataException(
                    'Expected 0 bit after 0xFF byte', 'B.10.1');
            }
            
            // No need to skip another bit if already skip the whole byte
            if (!state.isSkipNextByte) {
                state.currentByte <<= 1;
                state.validBitsInCurrentByte = 7;
            }
        }
        
        state.isSkipNextByte = false;
        state.nextOffsetToParse += bytesNeeded;
        
        return true;
    }

    function createZeroBitsUntilFirstOneBitMap() {
        var arrayMap = new Array(255);
        
        arrayMap[0x00] = 9;
        arrayMap[0x01] = 8;
        arrayMap[0x02] = 7;
        arrayMap[0x03] = 7;
        
        var i;
        
        for (i = 0x04; i <= 0x07; ++i) {
            arrayMap[i] = 6;
        }
        
        for (i = 0x08; i <= 0x0F; ++i) {
            arrayMap[i] = 5;
        }

        for (i = 0x10; i <= 0x1F; ++i) {
            arrayMap[i] = 4;
        }

        for (i = 0x20; i <= 0x3F; ++i) {
            arrayMap[i] = 3;
        }
        
        for (i = 0x40; i <= 0x7F; ++i) {
            arrayMap[i] = 2;
        }
        
        for (i = 0x80; i <= 0xFF; ++i) {
            arrayMap[i] = 1;
        }
        
        // Avoid two's complement problems
        for (i = 0; i <= 0xFF; ++i) {
            arrayMap[i - 0x100] = arrayMap[i];
        }
        
        return arrayMap;
    }
    
    return JpipBitstreamReader;
})();
},{"j2k-jpip-globals.js":12}],25:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipCodeblockLengthParser = (function JpipCodeblockLengthParserClosure() {
    // B.10.7.
    
    var exactLog2Table = createExactLog2Table();
    
    function JpipCodeblockLengthParser(bitstreamReader, transactionHelper) {
        var lBlock = transactionHelper.createTransactionalObject({
            lBlockValue: 3
            });
        
        this.parse = function parse(codingPasses) {
            var addToLBlock = bitstreamReader.countOnesAndShiftUntilFirstZeroBit();
            if (addToLBlock === null) {
                return null;
            }
            
            var lBlockState = lBlock.getValue(bitstreamReader.activeTransaction);
            lBlockState.lBlockValue += addToLBlock;
            
            var codingPassesLog2 = exactLog2Table[codingPasses];
            if (codingPassesLog2 === undefined) {
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'Unexpected value of coding passes ' + codingPasses +
                    '. Expected positive integer <= 164');
            }
            
            var bitsCount = lBlockState.lBlockValue + codingPassesLog2;
            var length = bitstreamReader.shiftBits(bitsCount);
            
            return length;
        };
    }
    
    function createExactLog2Table() {
        var maxCodingPassesPossible = 164;
        var result = new Array(maxCodingPassesPossible);
        
        var inputValueLowerBound = 1;
        var inputValueUpperBound = 2;
        var log2Result = 0;
        
        while (inputValueLowerBound <= maxCodingPassesPossible) {
            for (var i = inputValueLowerBound; i < inputValueUpperBound; ++i) {
                result[i] = log2Result;
            }
            
            inputValueLowerBound *= 2;
            inputValueUpperBound *= 2;
            ++log2Result;
        }
        
        return result;
    }
    
    return JpipCodeblockLengthParser;
})();
},{"j2k-jpip-globals.js":12}],26:[function(require,module,exports){
'use strict';

module.exports.JpipCodingPassesNumberParser = (function JpipCodingPassesNumberParserClosure() {
    // Table B.4 in part 1 of the Jpeg2000 standard shows 7 cases
    // of values. The algorithm shown here separates those cases
    // into 16 cases, depends on the number of ones in the prefix
    // of the coded number until the first zero.
    // The parsing is done in two stages: first we count the ones until
    // the first zero, later we parse the other bits.
    
    // For example, the case of 1101 (which represents 4 according to
    // table B.4) is parsed in two stages. First we count the ones in
    // the beginning until the first zero, the result is 2 ('110'). Then we
    // parse the other bits ('1').
    
    // After the first parsing stage (count of ones), we know two things:
    // - How many bits we need to take after the first zero (single bit in
    //   the above case of '110' prefix).
    // - How much we need to add to the result of parsing the other bits (3
    //     in the above case of '110' prefix).
    
    // Actually the 16 cases were extracted from the table without any formula,
    // so we can refer the number of ones as 'keywords' only.

    var bitsNeededAfterCountOfOnes = createBitsNeededAfterCountOfOnesMap();
    var addToResultAfterCountOfOnes = createAddToResultAfterCountOfOnesMap();

    var jpipCodingPassesNumberParser = {
        parse: function parse(bitstreamReader) {
            
            var onesCount = bitstreamReader.countOnesAndShiftUntilFirstZeroBit(
                /*maxBitsToShift=*/16);
            
            if (onesCount === null) {
                return null;
            }
            
            var moreBitsNeeded = bitsNeededAfterCountOfOnes[onesCount];
            var moreBits = bitstreamReader.shiftBits(moreBitsNeeded);
            
            if (moreBits === null) {
                return null;
            }
            
            var addToResult = addToResultAfterCountOfOnes[onesCount];
            var result = moreBits + addToResult;
            
            return result;
        }
    };
    
    function createBitsNeededAfterCountOfOnesMap() {
        var result = new Array(17);
        
        // The case of '0': After 0 ones and single zero, needs no more bits
        result[0] = 0;

        // The case of '10': After 1 ones and single zero, needs no more bits
        result[1] = 0;
        
        // The cases of '110x': After 2 ones and single zero, needs another bit
        result[2] = 1;
        
        // The case of '1110': After 3 ones and single zero, needs no more bits
        result[3] = 0;
        
        // The cases of '1111 0000 0' to '1111 1111 0':
        // After 4 to 8 ones and single zero, needs bits to complete to 9 bits
        result[4] = 4;
        result[5] = 3;
        result[6] = 2;
        result[7] = 1;
        result[8] = 0;
        
        // The cases of '1111 11111 ...'
        // After at least 9 ones and single zero, needs bits to complete to 16 bits
        result[9] = 6;
        result[10] = 5;
        result[11] = 4;
        result[12] = 3;
        result[13] = 2;
        result[14] = 1;
        result[15] = 0;
        
        // The case of '1111 11111 1111 111'
        result[16] = 0;
        
        return result;
    }
    
    function createAddToResultAfterCountOfOnesMap() {
        var result = new Array(17);
        
        // The case of '0' (codeword for 1):
        // After 0 ones and single zero, add 1 to other 0 bits value
        result[0] = 1;

        // The case of '10' (codeword for 2):
        // After 1 ones and single zero, add 2 to other 0 bits value
        result[1] = 2;
        
        // The cases of '110x' (codewords for 3 and 4):
        // After 2 ones and single zero, add 3 to other single bit value
        result[2] = 3;
        
        // The case of '1110' (codeword for 5):
        // After 3 ones and single zero, add 5 to other 0 bits value
        result[3] = 5;
        
        // The cases of '1111 0000 0' to '1111 1111 0' (codewords for 6 to 36):
        // After 4 ones and single zero, add 6 to other 0/1/2/3/4 bits value
        result[4] = 6 + 0x00; // b00000
        result[5] = 6 + 0x10; // b10000
        result[6] = 6 + 0x18; // b11000
        result[7] = 6 + 0x1C; // b11100
        result[8] = 6 + 0x1E; // b11110
        
        // The cases of '1111 11111 ...' (codewords for 37 to 164):
        // After 9 ones and single zero, add 37 to other 0/1/2/3/4/5/6 bits value
        result[ 9] = 37 + 0x00; // b000000
        result[10] = 37 + 0x40; // b100000
        result[11] = 37 + 0x60; // b110000
        result[12] = 37 + 0x70; // b111000
        result[13] = 37 + 0x78; // b111100
        result[14] = 37 + 0x7C; // b111110
        result[15] = 37 + 0x7E; // b111111
        result[16] = 37 + 0x7F; // b111111
        
        return result;
    }
    
    return jpipCodingPassesNumberParser;
})();
},{}],27:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipPacketLengthCalculator = function JpipPacketLengthCalculator(
    tileStructure,
    componentStructure,
    databin,
    startOffsetInDatabin,
    precinct,
    jpipFactory) {
    
    var calculatedLengths = [];
    
    var bitstreamReader = jpipFactory.createBitstreamReader(databin);
    
    var numCodeblocksX =
        componentStructure.getNumCodeblocksXInPrecinct(precinct);
    var numCodeblocksY =
        componentStructure.getNumCodeblocksYInPrecinct(precinct);
        
    var numQualityLayersInTile = tileStructure.getNumQualityLayers();
    var isPacketHeaderNearData = tileStructure.getIsPacketHeaderNearData();
    var isStartOfPacketMarkerAllowed = tileStructure.getIsStartOfPacketMarkerAllowed();
    var isEndPacketHeaderMarkerAllowed =
        tileStructure.getIsEndPacketHeaderMarkerAllowed();
    
    var subbandParsers = initSubbandParsers();
    
    this.calculateEndOffsetOfLastFullPacket =
        function calculateFullPacketsAvailableOffsets(maxNumQualityLayers) {
        
        var isAllowedFullQuality =
            maxNumQualityLayers === undefined ||
            maxNumQualityLayers >= numQualityLayersInTile;
        
        var numQualityLayersToParse;
        if (!isAllowedFullQuality) {
            numQualityLayersToParse = maxNumQualityLayers;
        } else if (!databin.isAllDatabinLoaded()) {
            numQualityLayersToParse = numQualityLayersInTile;
        } else {
            var endOffset = databin.getDatabinLengthIfKnown();
            
            return {
                endOffset: endOffset,
                numQualityLayers: numQualityLayersInTile
                };
        }
        
        checkSupportedStructure();
        
        tryValidatePackets(numQualityLayersToParse);
        var result = getFullQualityLayersEndOffset(numQualityLayersToParse);
        
        return result;
    };
    
    this.getPacketOffsetsByCodeblockIndex = function getPacketOffsetsByCodeblockIndex(
        qualityLayer) {
        
        checkSupportedStructure();
        tryValidatePackets(qualityLayer + 1);
        
        if (calculatedLengths.length <= qualityLayer) {
            return null;
        }
        
        return calculatedLengths[qualityLayer];
    };
    
    function tryValidatePackets(qualityLayers) {
        while (calculatedLengths.length < qualityLayers) {
            bitstreamReader.startNewTransaction();
            
            var nextPacket = tryCalculateNextPacketLength(
                calculatedLengths.length);
            
            if (nextPacket === null) {
                bitstreamReader.activeTransaction.abort();
                return;
            }
            
            calculatedLengths.push(nextPacket);
            bitstreamReader.activeTransaction.commit();
        }
    }
    
    function tryCalculateNextPacketLength(qualityLayer) {
        var headerStartOffset;
        if (qualityLayer > 0) {
            var last = calculatedLengths[qualityLayer - 1];
            headerStartOffset =
                last.headerStartOffset +
                last.headerLength +
                last.overallBodyLengthBytes;
        } else {
            headerStartOffset = startOffsetInDatabin;
        }
            
        bitstreamReader.databinOffset = headerStartOffset;
        
        if (isPacketHeaderNearData && isStartOfPacketMarkerAllowed) {
            var isMarker = isMarkerHere(0x91);
            
            if (isMarker === null) {
                return null;
            } else if (isMarker) {
                var startOfPacketSegmentLength = 6;
                bitstreamReader.databinOffset += startOfPacketSegmentLength;
            }
        }
        
        var isPacketExistInQualityLayer = bitstreamReader.shiftBit();
        if (isPacketExistInQualityLayer === null) {
            return null;
        }
        
        if (!isPacketExistInQualityLayer) {
            bitstreamReader.shiftRemainingBitsInByte();
        
            return {
                headerStartOffset: headerStartOffset,
                headerLength: 1,
                codeblockBodyLengthByIndex: [],
                overallBodyLengthBytes: 0
                };
        }
        
        var bodyLength = actualCalculatePacketLengthAfterZeroLengthBit(
            qualityLayer);
        if (bodyLength === null) {
            return null;
        }
        
        var headerEndOffset = bitstreamReader.databinOffset;
        bodyLength.headerLength = headerEndOffset - headerStartOffset;

        bodyLength.headerStartOffset = headerStartOffset;
        
        return bodyLength;
    }
    
    function actualCalculatePacketLengthAfterZeroLengthBit(qualityLayer) {
        var bodyBytes = 0;
        var codeblockBodyLengthByIndex = null;
        
        for (var subband = 0; subband < subbandParsers.length; ++subband) {
            var parser = subbandParsers[subband];
            var subbandBodyLength = parser.calculateSubbandLength(qualityLayer);
            
            if (subbandBodyLength === null) {
                return null;
            }
            
            if (codeblockBodyLengthByIndex === null) {
                codeblockBodyLengthByIndex =
                    subbandBodyLength.codeblockBodyLengthByIndex;
            } else {
                codeblockBodyLengthByIndex = codeblockBodyLengthByIndex.concat(
                    subbandBodyLength.codeblockBodyLengthByIndex);
            }
            
            bodyBytes += subbandBodyLength.overallBodyLengthBytes;
        }

        bitstreamReader.shiftRemainingBitsInByte();
        
        if (isEndPacketHeaderMarkerAllowed) {
            var isMarker = isMarkerHere(0x92);
            
            if (isMarker === null) {
                return null;
            } else if (isMarker) {
                var endPacketHeaderMarkerLength = 2;
                bitstreamReader.databinOffset += endPacketHeaderMarkerLength;
            }
        }
        
        return {
            codeblockBodyLengthByIndex: codeblockBodyLengthByIndex,
            overallBodyLengthBytes: bodyBytes
            };
    }
    
    function getFullQualityLayersEndOffset(maxNumQualityLayers) {
        var numParsedQualityLayer = Math.min(
            maxNumQualityLayers, calculatedLengths.length);
        
        if (numParsedQualityLayer === 0) {
            return {
                endOffset: startOffsetInDatabin,
                numQualityLayers: 0
                };
        }
        
        var lastPacket = calculatedLengths[numParsedQualityLayer - 1];
        var endOffset =
            lastPacket.headerStartOffset +
            lastPacket.headerLength +
            lastPacket.overallBodyLengthBytes;
        
        var result = {
            endOffset: endOffset,
            numQualityLayers: numParsedQualityLayer
            };
        
        return result;
    }
    
    function initSubbandParsers() {
        var numSubbands = precinct.resolutionLevel === 0 ? 1 : 3;
        var result = [];
        
        for (var i = 0; i < numSubbands; ++i) {
            var numCodeblocksXInSubband;
            var numCodeblocksYInSubband;
            if (precinct.resolutionLevel === 0) {
                numCodeblocksXInSubband = numCodeblocksX;
                numCodeblocksYInSubband = numCodeblocksY;
            } else {
                // Treat the edge case of single redundant pixels column
                // (In other cases, numCodeblocksX is full duplication of 2.
                // See JpipComponentStructure implementation).
                if (i === 1) { // LH
                    numCodeblocksXInSubband = Math.ceil(numCodeblocksX / 2);
                } else { // HL or HH
                    numCodeblocksXInSubband = Math.floor(numCodeblocksX / 2);
                }
                
                // Treat the edge case of single redundant pixels row
                // (In other cases, numCodeblocksY is full duplication of 2.
                // See JpipComponentStructure implementation).
                if (i === 0) { // HL
                    numCodeblocksYInSubband = Math.ceil(numCodeblocksY / 2);
                } else { // LH or HH
                    numCodeblocksYInSubband = Math.floor(numCodeblocksY / 2);
                }
            }
            
            if (numCodeblocksXInSubband === 0 || numCodeblocksYInSubband === 0) {
                continue;
            }
            
            result.push(jpipFactory.createSubbandLengthInPacketHeaderCalculator(
                bitstreamReader,
                numCodeblocksXInSubband,
                numCodeblocksYInSubband));
        }
        
        return result;
    }
    
    function isMarkerHere(markerSecondByte) {
        var possibleMarker = new Array(2);
        var bytesCopied = databin.copyBytes(
            possibleMarker,
            /*resultStartOffset=*/0,
            {
                databinStartOffset: bitstreamReader.databinOffset,
                maxLengthToCopy: 2,
                forceCopyAllRange: false
            });
        
        switch (bytesCopied) {
            case 2:
                var isMarker =
                    possibleMarker[0] === 0xFF &&
                    possibleMarker[1] === markerSecondByte;
                
                return isMarker;

            case 1:
                if (possibleMarker[0] === 0xFF) {
                    return null;
                }
                
                return false;
            
            default:
                return null;
        }
    }
    
    function checkSupportedStructure() {
        if (!isPacketHeaderNearData) {
            throw new jGlobals.jpipExceptions.UnsupportedFeatureException(
                'PPM or PPT', 'A.7.4 and A.7.5');
        }
    }
};
},{"j2k-jpip-globals.js":12}],28:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipQualityLayersCache = function JpipQualityLayersCache(
    codestreamStructure, jpipFactory) {
    
    var CACHE_KEY = 'packetLengthCalculator';
    
    this.getPacketOffsetsByCodeblockIndex =
        function getPacketOffsetsByCodeblockIndex(
            precinctDatabin, qualityLayer, precinctPosition) {
        
        var packetLengthCalculator = getPacketParser(
            precinctDatabin, precinctPosition);
            
        var result = packetLengthCalculator.getPacketOffsetsByCodeblockIndex(
            qualityLayer);
        
        return result;
    };
    
    this.getQualityLayerOffset = function getQualityLayerOffset(
        precinctDatabin, maxNumQualityLayers, precinctPosition) {
        
        var loadedRanges = precinctDatabin.getExistingRanges();
        var endOffsetLoaded;
        
        var packetLengthCalculator = getPacketParser(
            precinctDatabin, precinctPosition);
            
        if (loadedRanges.length < 1 || loadedRanges[0].start > 0) {
            endOffsetLoaded = 0;
            maxNumQualityLayers = 0;
        } else {
            endOffsetLoaded = loadedRanges[0].start + loadedRanges[0].length;
        }
        
        var layersInPrecinct =
            packetLengthCalculator.calculateEndOffsetOfLastFullPacket(
                maxNumQualityLayers);
        
        while (endOffsetLoaded < layersInPrecinct.endOffset) {
            var reducedLayersToSearch = layersInPrecinct.numQualityLayers - 1;
            layersInPrecinct = packetLengthCalculator
                .calculateEndOffsetOfLastFullPacket(reducedLayersToSearch);
        }
        
        return layersInPrecinct;
    };

    function getPacketParser(precinctDatabin, precinctPosition) {
        var packetLengthCalculatorContainer =
            precinctDatabin.getCachedData(CACHE_KEY);
        
        if (packetLengthCalculatorContainer.calculator !== undefined) {
            return packetLengthCalculatorContainer.calculator;
        }
        
        if (precinctPosition === undefined) {
            throw new jGlobals.jpipExceptions.InternalErrorException('precinctPosition ' +
                'should be given on the first time of using QualityLayersCache ' +
                'on this precinct');
        }
        
        var tileStructure = codestreamStructure.getTileStructure(
            precinctPosition.tileIndex);
        
        var componentStructure = tileStructure.getComponentStructure(
            precinctPosition.component);
            
        packetLengthCalculatorContainer.calculator =
            jpipFactory.createPacketLengthCalculator(
                tileStructure,
                componentStructure,
                precinctDatabin,
                /*startOffsetInDatabin=*/0,
                precinctPosition);
        
        return packetLengthCalculatorContainer.calculator;
    }
};
},{"j2k-jpip-globals.js":12}],29:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipSubbandLengthInPacketHeaderCalculator =
    function JpipSubbandLengthInPacketHeaderCalculator(
        bitstreamReader,
        numCodeblocksX,
        numCodeblocksY,
        codingPassesNumberParser,
        transactionHelper,
        jpipFactory) {
    
    var codeblockLengthParsers = null;
    var isCodeblocksIncluded = null;
    var parsedQualityLayers = transactionHelper.createTransactionalObject(
        0, /*isValueType=*/true);
        
    var inclusionTree = jpipFactory.createTagTree(
        bitstreamReader, numCodeblocksX, numCodeblocksY);
    
    var zeroBitPlanesTree = jpipFactory.createTagTree(
        bitstreamReader, numCodeblocksX, numCodeblocksY);
    
    this.calculateSubbandLength = function calcualteSubbandLength(qualityLayer) {
        ensureQualityLayerNotParsedYet(qualityLayer);
        
        lazyInitArrays();
        
        inclusionTree.setMinimalValueIfNotReadBits(qualityLayer);
        
        var accumulatedBodyLengthBytes = 0;
        var codeblockIndex = 0;
        var codeblockLengthByIndex = new Array(numCodeblocksX * numCodeblocksY);
        
        for (var y = 0; y < numCodeblocksY; ++y) {
            for (var x = 0; x < numCodeblocksX; ++x) {
                var codeblockBodyLength = getNextCodeblockLength(x, y, qualityLayer);
                if (codeblockBodyLength === null) {
                    return null;
                }
                
                codeblockLengthByIndex[codeblockIndex++] = codeblockBodyLength;
                
                accumulatedBodyLengthBytes +=
                    codeblockBodyLength.codeblockBodyLengthBytes;
            }
        }
        
        parsedQualityLayers.setValue(
            bitstreamReader.activeTransaction, qualityLayer + 1);
        
        return {
            codeblockBodyLengthByIndex: codeblockLengthByIndex,
            overallBodyLengthBytes: accumulatedBodyLengthBytes
            };
    };
    
    function ensureQualityLayerNotParsedYet(qualityLayer) {
        var parsedQualityLayersValue = parsedQualityLayers.getValue(
            bitstreamReader.activeTransaction);
        
        if (parsedQualityLayersValue >= qualityLayer + 1) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'Unexpected quality layer to parse');
        }
    }
    
    function lazyInitArrays() {
        if (codeblockLengthParsers !== null) {
            return;
        }
        
        codeblockLengthParsers = new Array(numCodeblocksX);
        isCodeblocksIncluded = new Array(numCodeblocksX);
        
        for (var x = 0; x < numCodeblocksX; ++x) {
            codeblockLengthParsers[x] = new Array(numCodeblocksY);
            isCodeblocksIncluded[x] = new Array(numCodeblocksY);
            
            for (var y = 0; y < numCodeblocksY; ++y) {
                codeblockLengthParsers[x][y] =
                    jpipFactory.createCodeblockLengthParser(
                        bitstreamReader, transactionHelper);
                    
                isCodeblocksIncluded[x][y] = transactionHelper
                    .createTransactionalObject({ isIncluded: false });
            }
        }
    }
    
    function getNextCodeblockLength(x, y, qualityLayer) {
        var isCodeblockAlreadyIncluded = isCodeblocksIncluded[x][y].getValue(
            bitstreamReader.activeTransaction);
        
        var isCodeblockIncludedNow;
        if (isCodeblockAlreadyIncluded.isIncluded) {
            isCodeblockIncludedNow = bitstreamReader.shiftBit();
        } else {
            isCodeblockIncludedNow = inclusionTree.isSmallerThanOrEqualsTo(
                x, y, qualityLayer);
        }
            
        if (isCodeblockIncludedNow === null) {
            return null;
        } else if (!isCodeblockIncludedNow) {
            return {
                codeblockBodyLengthBytes: 0,
                codingPasses: 0
                };
        }
        
        var zeroBitPlanes = null;
        if (!isCodeblockAlreadyIncluded.isIncluded) {
            zeroBitPlanes = zeroBitPlanesTree.getValue(x, y);
            if (zeroBitPlanes === null) {
                return null;
            }
        }
        
        var codingPasses = codingPassesNumberParser.parse(bitstreamReader);
        if (codingPasses === null) {
            return null;
        }
        
        var lengthParser = codeblockLengthParsers[x][y];
        var bodyLengthBytes = lengthParser.parse(codingPasses);
        
        if (bodyLengthBytes === null) {
            return null;
        }
        
        isCodeblockAlreadyIncluded.isIncluded = true;
        
        var result = {
            codeblockBodyLengthBytes: bodyLengthBytes,
            codingPasses: codingPasses
            };
        
        if (zeroBitPlanes !== null) {
            result.zeroBitPlanes = zeroBitPlanes;
        }
        
        return result;
    }
};
},{"j2k-jpip-globals.js":12}],30:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipTagTree = function JpipTagTree(
    bitstreamReader, width, height, transactionHelper) {
    
    var isAlreadyReadBitsTransactionalObject =
        transactionHelper.createTransactionalObject(false, /*isValueType=*/true);
    var levels;
    
    createLevelsArray();
        
    this.setMinimalValueIfNotReadBits = function setMinimalValueIfNotReadBits(
        minimalValue) {
    
        if (isAlreadyReadBits()) {
            return;
        }
        
        var transactionalObject = levels[0].content[0];
        var node = transactionalObject.getValue(
            bitstreamReader.activeTransaction);
        
        node.minimalPossibleValue = minimalValue;
    };
    
    this.isSmallerThanOrEqualsTo = function isSmallerThanOrEqualsTo(
        x, y, value) {
        
        setAlreadyReadBits();
        
        var getNextNode = getRootToLeafIterator(x, y);
        var currentNode = getNextNode();
        var lastNode;
        
        while (currentNode !== null) {
            if (currentNode.minimalPossibleValue > value) {
                return false;
            }
            
            if (!currentNode.isFinalValue) {
                var maxBitsToShift = value - currentNode.minimalPossibleValue + 1;
                var addToValue = bitstreamReader.countZerosAndShiftUntilFirstOneBit(
                    maxBitsToShift);
                    
                if (addToValue === null) {
                    return null;
                }
                
                currentNode.minimalPossibleValue += addToValue;
                
                if (addToValue < maxBitsToShift) {
                    currentNode.isFinalValue = true;
                }
            }
            
            lastNode = currentNode;
            currentNode = getNextNode();
        }
        
        var result = lastNode.minimalPossibleValue <= value;
        if (result && !lastNode.isFinalValue) {
            throw new jGlobals.jpipExceptions.InternalErrorException(
                'Wrong parsing in TagTree.isSmallerThanOrEqualsTo: ' +
                'not sure if value is smaller than asked');
        }
        
        return result;
    };
    
    this.getValue = function getValue(x, y) {
        var getNextNode = getRootToLeafIterator(x, y);
        var currentNode = getNextNode();
        var leaf;
        
        setAlreadyReadBits();
        
        while (currentNode !== null) {
            if (!currentNode.isFinalValue) {
                var addToValue =
                    bitstreamReader.countZerosAndShiftUntilFirstOneBit();
                
                if (addToValue === null) {
                    return null;
                }

                currentNode.minimalPossibleValue += addToValue;
                currentNode.isFinalValue = true;
            }
            
            leaf = currentNode;
            currentNode = getNextNode();
        }
        
        return leaf.minimalPossibleValue;
    };
    
    function createLevelsArray() {
        levels = [];
        var levelWidth = width;
        var levelHeight = height;
        
        while (levelWidth >= 1 || levelHeight >= 1) {
            levelWidth = Math.ceil(levelWidth);
            levelHeight = Math.ceil(levelHeight);
            
            var elementCount = levelWidth * levelHeight;
            levels.unshift({
                width: levelWidth,
                height: levelHeight,
                content: new Array(elementCount)
                });
            
            levelWidth /= 2;
            levelHeight /= 2;
        }
        
        initNode(0, 0);
    }
    
    function getRootToLeafIterator(x, y) {
        var level = 0;
        var prevIteratedNode = null;
        
        function getNext() {
            if (level === null) {
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'Iterated too deep in tag tree');
            }
            
            if (level === levels.length) {
                level = null;
                return null;
            }
            
            var shiftFactor = levels.length - level - 1;
            var currentX = Math.floor(x >> shiftFactor);
            var currentY = Math.floor(y >> shiftFactor);
            
            var indexInLevel = levels[level].width * currentY + currentX;
            
            var transactionalObject = levels[level].content[indexInLevel];
            
            if (transactionalObject === undefined) {
                transactionalObject = initNode(level, indexInLevel);
            }
            
            var result = transactionalObject.getValue(
                bitstreamReader.activeTransaction);
            
            if (prevIteratedNode !== null &&
                prevIteratedNode.minimalPossibleValue > result.minimalPossibleValue) {
                
                result.minimalPossibleValue = prevIteratedNode.minimalPossibleValue;
            }

            prevIteratedNode = result;
            ++level;
            return result;
        }
        
        return getNext;
    }
    
    function initNode(level, indexInLevel) {
        var objectValue = {
            minimalPossibleValue: 0,
            isFinalValue: false
            };
            
        var transactionalObject = transactionHelper.createTransactionalObject(
            objectValue);
        
        levels[level].content[indexInLevel] = transactionalObject;
        return transactionalObject;
    }
    
    function isAlreadyReadBits() {
        var isAlreadyReadBitsTransactionalValue =
            isAlreadyReadBitsTransactionalObject.getValue(
                bitstreamReader.activeTransaction);
        
        return isAlreadyReadBitsTransactionalValue;
    }
    
    function setAlreadyReadBits() {
        isAlreadyReadBitsTransactionalObject.setValue(
            bitstreamReader.activeTransaction, true);
    }
};
},{"j2k-jpip-globals.js":12}],31:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.mutualExclusiveTransactionHelper = {
    createTransaction: function createTransaction() {
        // This code is executed a LOT. For optimization, state is represented
        // directly as numbers (I couldn't think about more readable way which
        // is performance-equivalent).
        
        // state = 1 ==> Transaction is active
        // state = 2 ==> Transaction has committed successfully
        // state = 3 ==> Transaction has been aborted
        
        var state = 1;
        
        var transaction = {
            get isAborted() {
                return state === 3;
            },
            
            get isActive() {
                return state === 1;
            },
            
            commit: function commit() {
                terminate(true);
            },
        
            abort: function abort() {
                terminate(false);
            }
        };
        
        function terminate(isSuccessful_) {
            if (!transaction.isActive) {
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'Cannot terminate an already terminated transaction');
            }
            state = isSuccessful_ ? 2 : 3;
        }
            
        return transaction;
    },
    
    createTransactionalObject: function commitTransaction(
        initialValue, isValueType) {
        
        var value = null;
        var prevValue = initialValue;
        var lastAccessedTransaction = {
            isActive: false,
            isAborted: true
            };
        var clone = isValueType ? cloneValueType : cloneByJSON;
        
        var transactionalObject = {
            getValue: function getValue(activeTransaction) {
                ensureAllowedAccess(activeTransaction);

                if (lastAccessedTransaction === activeTransaction) {
                    return value;
                }
                
                if (lastAccessedTransaction.isAborted) {
                    value = clone(prevValue);
                } else {
                    prevValue = clone(value);
                }

                lastAccessedTransaction = activeTransaction;
                return value;
            },
            
            setValue: function setValue(activeTransaction, newValue) {
                ensureAllowedAccess(activeTransaction);

                if (lastAccessedTransaction === activeTransaction) {
                    value = newValue;
                    return;
                }
                
                if (!lastAccessedTransaction.isAborted) {
                    prevValue = clone(value);
                }
                
                lastAccessedTransaction = activeTransaction;
                value = newValue;
            }
        };
        
        function ensureAllowedAccess(activeTransaction) {
            if (!activeTransaction.isActive) {
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'Cannot use terminated transaction to access objects');
            }
            
            if (activeTransaction !== lastAccessedTransaction &&
                lastAccessedTransaction.isActive) {
                
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'Cannot simultanously access transactional object ' +
                    'from two active transactions');
            }
        }
        
        function cloneValueType(value) {
            return value;
        }
        
        function cloneByJSON(value) {
            var newValue = JSON.parse(JSON.stringify(value));
            return newValue;
        }
        
        return transactionalObject;
    }
};
},{"j2k-jpip-globals.js":12}],32:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipCodestreamClient = require('jpip-codestream-client.js');
module.exports.JpipCodestreamSizesCalculator = require('jpip-codestream-sizes-calculator.js');
module.exports.j2kExceptions = jGlobals.j2kExceptions;
module.exports.jpipExceptions = jGlobals.jpipExceptions;
module.exports.Internals = {
    jpipRuntimeFactory: require('jpip-runtime-factory.js'),
    jGlobals: jGlobals
};
},{"j2k-jpip-globals.js":12,"jpip-codestream-client.js":1,"jpip-codestream-sizes-calculator.js":2,"jpip-runtime-factory.js":13}],33:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipCodestreamReconstructor = function JpipCodestreamReconstructor(
    codestreamStructure,
    databinsSaver,
    headerModifier,
    qualityLayersCache) {
    
    this.reconstructCodestream = function reconstructCodestream(
        minNumQualityLayers) {
        
        var result = [];
        var currentOffset = createMainHeader(result);
        
        if (currentOffset === null) {
            return null;
        }
        
        var numTiles =
            codestreamStructure.getNumTilesX() * codestreamStructure.getNumTilesY();
        
        var codestreamPart;
        
        if (minNumQualityLayers === undefined) {
            minNumQualityLayers = 'max';
        }
        
        for (var tileId = 0; tileId < numTiles; ++tileId) {
            var tileBytesCopied = createTile(
                result,
                currentOffset,
                tileId,
                tileId,
                codestreamPart,
                minNumQualityLayers);
            
            currentOffset += tileBytesCopied;
            
            if (tileBytesCopied === null) {
                return null;
            }
        }
        
        var markerBytesCopied = copyBytes(
            result, currentOffset, jGlobals.j2kMarkers.EndOfCodestream);
        currentOffset += markerBytesCopied;
        result.length = currentOffset;

        return result;
    };
    
    this.createCodestreamForRegion = function createCodestreamForRegion(
        params, minNumQualityLayers, isOnlyHeadersWithoutBitstream) {
        
        var codestream = [];
        var currentOffset = createMainHeader(
            codestream, params.numResolutionLevelsToCut);
        
        if (currentOffset === null) {
            return null;
        }
        
        var tileIdToWrite = 0;
        var tileIterator = codestreamStructure.getTilesIterator(params);
        
        var firstTileId = tileIterator.tileIndex;
        
        var firstTileLeft = codestreamStructure.getTileLeft(
            firstTileId, params.numResolutionLevelsToCut);
        var firstTileTop = codestreamStructure.getTileTop(
            firstTileId, params.numResolutionLevelsToCut);
            
        var offsetX = params.minX - firstTileLeft;
        var offsetY = params.minY - firstTileTop;
        
        do {
            var tileIdOriginal = tileIterator.tileIndex;
            
            var tileBytesCopied = createTile(
                codestream,
                currentOffset,
                tileIdToWrite++,
                tileIdOriginal,
                params,
                minNumQualityLayers,
                isOnlyHeadersWithoutBitstream);
                
            currentOffset += tileBytesCopied;
        
            if (tileBytesCopied === null) {
                return null;
            }
        } while (tileIterator.tryAdvance());
        
        var markerBytesCopied = copyBytes(
            codestream, currentOffset, jGlobals.j2kMarkers.EndOfCodestream);
        currentOffset += markerBytesCopied;

        headerModifier.modifyImageSize(codestream, params);
        
        if (codestream === null) {
            return null;
        }
        
        codestream.length = currentOffset;

        return {
            codestream: codestream,
            offsetX: offsetX,
            offsetY: offsetY
            };
    };
    
    this.createCodestreamForTile = function createCodestreamForTile(
        tileId,
        numResolutionLevelsToCut,
        minNumQualityLayers,
        maxNumQualityLayers) {
        
        var result = [];
        var currentOffset = createMainHeader(result, numResolutionLevelsToCut);
        
        if (currentOffset === null) {
            return null;
        }
        
        // TODO: Delete this function and test createCodestreamForRegion instead
        
        var codestreamPartParams = {
            numResolutionLevelsToCut: numResolutionLevelsToCut,
            maxNumQualityLayers: maxNumQualityLayers
            };
        
        var tileBytesCopied = createTile(
            result,
            currentOffset,
            /*tileIdToWrite=*/0,
            /*tileIdOriginal=*/tileId,
            codestreamPartParams,
            minNumQualityLayers);
            
        currentOffset += tileBytesCopied;
        
        if (tileBytesCopied === null) {
            return null;
        }

        var markerBytesCopied = copyBytes(
            result, currentOffset, jGlobals.j2kMarkers.EndOfCodestream);
        currentOffset += markerBytesCopied;
        
        var numTilesX = codestreamStructure.getNumTilesX();
        var tileX = tileId % numTilesX;
        var tileY = Math.floor(tileId / numTilesX);
        
        headerModifier.modifyImageSize(result, {
            numResolutionLevelsToCut: numResolutionLevelsToCut,
            minTileX: tileX,
            maxTileXExclusive: tileX + 1,
            minTileY: tileY,
            maxTileYExclusive: tileY + 1
            });
        
        result.length = currentOffset;
        
        return result;
    };
    
    function createMainHeader(result, numResolutionLevelsToCut) {
        if (databinsSaver.getIsJpipTilePartStream()) {
            throw new jGlobals.jpipExceptions.UnsupportedFeatureException(
                'reconstruction of codestream from JPT (Jpip Tile-part) stream', 'A.3.4');
        }
        
        var mainHeader = databinsSaver.getMainHeaderDatabin();
        var currentOffset = mainHeader.copyBytes(result, /*startOffset=*/0, {
            forceCopyAllRange: true
            });
        
        if (currentOffset === null) {
            return null;
        }
        
        var bytesAdded = headerModifier.modifyMainOrTileHeader(
            result, mainHeader, /*offset=*/0, numResolutionLevelsToCut);
        
        currentOffset += bytesAdded;
        
        bytesAdded = addMamazavComment(result, currentOffset);
        currentOffset += bytesAdded;
        
        return currentOffset;
    }
    
    function createTile(
        result,
        currentOffset,
        tileIdToWrite,
        tileIdOriginal,
        codestreamPartParams,
        minNumQualityLayers,
        isOnlyHeadersWithoutBitstream) {
        
        var tileStructure = codestreamStructure.getTileStructure(
            tileIdOriginal);

        var startTileOffset = currentOffset;
        var tileHeaderDatabin = databinsSaver.getTileHeaderDatabin(
            tileIdOriginal);
        
        var numResolutionLevelsToCut;
        if (codestreamPartParams !== undefined) {
            numResolutionLevelsToCut = codestreamPartParams.numResolutionLevelsToCut;
        }
        
        var tileHeaderOffsets = createTileHeaderAndGetOffsets(
            result,
            currentOffset,
            tileHeaderDatabin,
            tileIdToWrite,
            numResolutionLevelsToCut);
        
        if (tileHeaderOffsets === null) {
            return null;
        }
            
        currentOffset = tileHeaderOffsets.endTileHeaderOffset;
        
        if (!isOnlyHeadersWithoutBitstream) {
            var tileBytesCopied = createTileBitstream(
                result,
                currentOffset,
                tileStructure,
                tileIdOriginal,
                codestreamPartParams,
                minNumQualityLayers);
                
            currentOffset += tileBytesCopied;
            
            if (tileBytesCopied === null) {
                return null;
            }
        }

        var endTileOffset = currentOffset;
        
        var headerAndDataLength =
            endTileOffset - tileHeaderOffsets.startOfTileHeaderOffset;

        headerModifier.modifyInt32(
            result,
            tileHeaderOffsets.headerAndDataLengthPlaceholderOffset,
            headerAndDataLength);

        var bytesCopied = endTileOffset - startTileOffset;
        return bytesCopied;
    }
    
    function createTileHeaderAndGetOffsets(
        result,
        currentOffset,
        tileHeaderDatabin,
        tileIdToWrite,
        numResolutionLevelsToCut) {
        
        var startOfTileHeaderOffset = currentOffset;
    
        var bytesCopied = copyBytes(
            result, currentOffset, jGlobals.j2kMarkers.StartOfTile);
        currentOffset += bytesCopied;
        
        // A.4.2
        
        var startOfTileSegmentLength = [0, 10]; // Lsot
        bytesCopied = copyBytes(result, currentOffset, startOfTileSegmentLength);
        currentOffset += bytesCopied;
        
        var tileIndex = [tileIdToWrite >>> 8, tileIdToWrite & 0xFF]; // Isot
        bytesCopied = copyBytes(result, currentOffset, tileIndex);
        currentOffset += bytesCopied;
        
        var headerAndDataLengthPlaceholderOffset = currentOffset;
        var headerAndDataLengthPlaceholder = [0, 0, 0, 0]; // Psot
        bytesCopied = copyBytes(result, currentOffset, headerAndDataLengthPlaceholder);
        currentOffset += bytesCopied;
        
        var tilePartIndex = [0]; // TPsot
        bytesCopied = copyBytes(result, currentOffset, tilePartIndex);
        currentOffset += bytesCopied;
        
        var numberOfTileparts = [1]; // TNsot
        bytesCopied = copyBytes(result, currentOffset, numberOfTileparts);
        currentOffset += bytesCopied;
        
        var afterStartOfTileSegmentOffset = currentOffset;
        bytesCopied = tileHeaderDatabin.copyBytes(result, currentOffset, {
            forceCopyAllRange: true
            });
        currentOffset += bytesCopied;
        
        if (bytesCopied === null) {
            // NOTE: Can create empty tile
            return null;
        }
        
        var isEndedWithStartOfDataMarker =
            result[currentOffset - 2] === jGlobals.j2kMarkers.StartOfData[0] &&
            result[currentOffset - 1] === jGlobals.j2kMarkers.StartOfData[1];
            
        if (!isEndedWithStartOfDataMarker) {
            bytesCopied = copyBytes(
                result, currentOffset, jGlobals.j2kMarkers.StartOfData);
            currentOffset += bytesCopied;
        }
        
        var bytesAdded = headerModifier.modifyMainOrTileHeader(
            result,
            tileHeaderDatabin,
            afterStartOfTileSegmentOffset,
            numResolutionLevelsToCut);
        
        currentOffset += bytesAdded;

        var offsets = {
            startOfTileHeaderOffset: startOfTileHeaderOffset,
            headerAndDataLengthPlaceholderOffset: headerAndDataLengthPlaceholderOffset,
            endTileHeaderOffset: currentOffset
            };
        
        return offsets;
    }
    
    function createTileBitstream(
        result,
        currentOffset,
        tileStructure,
        tileIdOriginal,
        codestreamPartParams,
        minNumQualityLayers) {
        
        var numQualityLayersInTile = tileStructure.getNumQualityLayers();
        var maxNumQualityLayers;
        var iterator = tileStructure.getPrecinctIterator(
            tileIdOriginal,
            codestreamPartParams,
            /*isIteratePrecinctsNotInCodestreamPart=*/true);

        var allBytesCopied = 0;
        var hasMorePackets;
        
        if (codestreamPartParams !== undefined) {
            maxNumQualityLayers = codestreamPartParams.maxNumQualityLayers;
        }
        
        if (minNumQualityLayers === 'max') {
            minNumQualityLayers = numQualityLayersInTile;
        }
        
        do {
            var emptyPacketsToPush = numQualityLayersInTile;
            
            if (iterator.isInCodestreamPart) {
                var inClassId =
                    tileStructure.precinctPositionToInClassIndex(iterator);
                var precinctDatabin = databinsSaver.getPrecinctDatabin(inClassId);
                
                var qualityLayerOffset = qualityLayersCache.getQualityLayerOffset(
                    precinctDatabin,
                    maxNumQualityLayers,
                    iterator);
                
                var bytesToCopy = qualityLayerOffset.endOffset;
                emptyPacketsToPush =
                    numQualityLayersInTile - qualityLayerOffset.numQualityLayers;
                
                if (qualityLayerOffset.numQualityLayers < minNumQualityLayers) {
                    return null;
                }
                
                var bytesCopied = precinctDatabin.copyBytes(result, currentOffset, {
                    forceCopyAllRange: true,
                    maxLengthToCopy: bytesToCopy
                    });
                
                if (bytesCopied === null) {
                    bytesCopied = 0;
                    emptyPacketsToPush = numQualityLayersInTile;
                }
                
                allBytesCopied += bytesCopied;
                currentOffset += bytesCopied;
            }
            
            for (var i = 0; i < emptyPacketsToPush; ++i) {
                result[currentOffset++] = 0;
            }
            allBytesCopied += emptyPacketsToPush;
        }
        while (iterator.tryAdvance());
        
        return allBytesCopied;
    }
    
    function addMamazavComment(result, currentOffset) {
        var startOffset = currentOffset;
    
        result[currentOffset++] = 0xFF;
        result[currentOffset++] = 0x64;
        result[currentOffset++] = 0x00;
        result[currentOffset++] = 0x09;
        result[currentOffset++] = 77;
        result[currentOffset++] = 97;
        result[currentOffset++] = 109;
        result[currentOffset++] = 97;
        result[currentOffset++] = 122;
        result[currentOffset++] = 97;
        result[currentOffset++] = 118;
        
        var bytesAdded = currentOffset - startOffset;
        return bytesAdded;
    }
        
    function copyBytes(result, resultStartOffset, bytesToCopy) {
        for (var i = 0; i < bytesToCopy.length; ++i) {
            result[i + resultStartOffset] = bytesToCopy[i];
        }
        
        return bytesToCopy.length;
    }
};
},{"j2k-jpip-globals.js":12}],34:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipHeaderModifier = function JpipHeaderModifier(
    codestreamStructure, offsetsCalculator, progressionOrder) {

    var encodedProgressionOrder = encodeProgressionOrder(progressionOrder);
        
    this.modifyMainOrTileHeader = function modifyMainOrTileHeader(
        result, originalDatabin, databinOffsetInResult, numResolutionLevelsToCut) {
        
        modifyProgressionOrder(result, originalDatabin, databinOffsetInResult);
        
        if (numResolutionLevelsToCut === undefined) {
            return 0;
        }
        
        var bestResolutionLevelsRanges =
            offsetsCalculator.getRangesOfBestResolutionLevelsData(
                originalDatabin, numResolutionLevelsToCut);
        
        if (bestResolutionLevelsRanges.numDecompositionLevelsOffset !== null) {
            var offset =
                databinOffsetInResult +
                bestResolutionLevelsRanges.numDecompositionLevelsOffset;
                
            result[offset] -= numResolutionLevelsToCut;
        }
        
        var bytesRemoved = removeRanges(
            result, bestResolutionLevelsRanges.ranges, databinOffsetInResult);
        
        var bytesAdded = -bytesRemoved;
        return bytesAdded;
    };
    
    this.modifyImageSize = function modifyImageSize(result, codestreamPartParams) {
        var newTileWidth = codestreamStructure.getTileWidth(
            codestreamPartParams.numResolutionLevelsToCut);
        var newTileHeight = codestreamStructure.getTileHeight(
            codestreamPartParams.numResolutionLevelsToCut);
        
        var newReferenceGridSize = codestreamStructure.getSizeOfPart(
            codestreamPartParams);
        
        var sizMarkerOffset = offsetsCalculator.getImageAndTileSizeOffset();
            
        var referenceGridSizeOffset =
            sizMarkerOffset + jGlobals.j2kOffsets.REFERENCE_GRID_SIZE_OFFSET_AFTER_SIZ_MARKER;

        var imageOffsetBytesOffset = referenceGridSizeOffset + 8;
        var tileSizeBytesOffset = referenceGridSizeOffset + 16;
        var firstTileOffsetBytesOffset = referenceGridSizeOffset + 24;
        
        modifyInt32(result, referenceGridSizeOffset, newReferenceGridSize.width);
        modifyInt32(result, referenceGridSizeOffset + 4, newReferenceGridSize.height);
        
        modifyInt32(result, tileSizeBytesOffset, newTileWidth);
        modifyInt32(result, tileSizeBytesOffset + 4, newTileHeight);
        
        modifyInt32(result, imageOffsetBytesOffset, 0);
        modifyInt32(result, imageOffsetBytesOffset + 4, 0);
                
        modifyInt32(result, firstTileOffsetBytesOffset, 0);
        modifyInt32(result, firstTileOffsetBytesOffset + 4, 0);
    };
    
    this.modifyInt32 = modifyInt32;
    
    function modifyProgressionOrder(result, originalDatabin, databinOffsetInResult) {
        var codingStyleOffset = offsetsCalculator.getCodingStyleOffset(originalDatabin);
        
        if (codingStyleOffset !== null) {
            var progressionOrderOffset =
                databinOffsetInResult + codingStyleOffset + 5;
            
            result[progressionOrderOffset] = encodedProgressionOrder;
        }
    }
    
    function removeRanges(result, rangesToRemove, addOffset) {
        if (rangesToRemove.length === 0) {
            return 0; // zero bytes removed
        }
        
        for (var i = 0; i < rangesToRemove.length; ++i) {
            var offset =
                addOffset +
                rangesToRemove[i].markerSegmentLengthOffset;
                
            var originalMarkerSegmentLength =
                (result[offset] << 8) + result[offset + 1];
            
            var newMarkerSegmentLength =
                originalMarkerSegmentLength - rangesToRemove[i].length;
            
            result[offset] = newMarkerSegmentLength >>> 8;
            result[offset + 1] = newMarkerSegmentLength & 0xFF;
        }
        
        var offsetTarget = addOffset + rangesToRemove[0].start;
        var offsetSource = offsetTarget;
        for (var j = 0; j < rangesToRemove.length; ++j) {
            offsetSource += rangesToRemove[j].length;
            
            var nextRangeOffset =
                j + 1 < rangesToRemove.length ?
                    addOffset + rangesToRemove[j + 1].start :
                    result.length;

            for (; offsetSource < nextRangeOffset; ++offsetSource) {
                result[offsetTarget] = result[offsetSource];
                ++offsetTarget;
            }
        }
        
        var bytesRemoved = offsetSource - offsetTarget;
        
        return bytesRemoved;
    }

    function modifyInt32(bytes, offset, newValue) {
        bytes[offset++] = newValue >>> 24;
        bytes[offset++] = (newValue >>> 16) & 0xFF;
        bytes[offset++] = (newValue >>> 8) & 0xFF;
        bytes[offset++] = newValue & 0xFF;
    }

    function encodeProgressionOrder(progressionOrder) {
        // A.6.1
        
        // Table A.16
        
        switch (progressionOrder) {
            case 'LRCP':
                return 0;
                
            case 'RLCP':
                return 1;
                
            case 'RPCL':
                return 2;
            
            case 'PCRL':
                return 3;
                
            case 'CPRL':
                return 4;
            
            default:
                throw new jGlobals.j2kExceptions.IllegalDataException('Progression order of ' + progressionOrder, 'A.6.1, table A.16');
        }
    }
};
},{"j2k-jpip-globals.js":12}],35:[function(require,module,exports){
'use strict';

var jGlobals = require('j2k-jpip-globals.js');

module.exports.JpipPacketsDataCollector = function JpipPacketsDataCollector(
    codestreamStructure,
    databinsSaver,
    qualityLayersCache,
    jpipFactory) {
    
    this.getAllCodeblocksData = function getCodeblocksData(
        codestreamPartParams, minNumQualityLayers) {
        
        var alreadyReturnedCodeblocks = jpipFactory.createObjectPoolByDatabin();
        var codeblocksData = getNewCodeblocksDataAndUpdateReturnedCodeblocks(
            codestreamPartParams, minNumQualityLayers, alreadyReturnedCodeblocks);
        
        return {
            codeblocksData: codeblocksData,
            alreadyReturnedCodeblocks: alreadyReturnedCodeblocks
            };
    };
    
    this.getNewCodeblocksDataAndUpdateReturnedCodeblocks =
        getNewCodeblocksDataAndUpdateReturnedCodeblocks;
        
    function getNewCodeblocksDataAndUpdateReturnedCodeblocks(
        codestreamPartParams, minNumQualityLayers, alreadyReturnedCodeblocks) {
        
        var tileIterator = codestreamStructure.getTilesIterator(
            codestreamPartParams);
        
        var tileIndexInCodestreamPart = 0;
        var dummyOffset = 0;
        var result = {
            packetDataOffsets: [],
            data: jpipFactory.createCompositeArray(dummyOffset),
            allRelevantBytesLoaded: 0
            };
        
        do {
            var tileStructure = codestreamStructure.getTileStructure(
                tileIterator.tileIndex);
            
            var precinctIterator = tileStructure.getPrecinctIterator(
                tileIterator.tileIndex, codestreamPartParams);
            
            var maxNumQualityLayers = tileStructure.getNumQualityLayers();
            
            if (codestreamPartParams.maxNumQualityLayers !== undefined) {
                maxNumQualityLayers = Math.min(
                    maxNumQualityLayers, codestreamPartParams.maxNumQualityLayers);
            }
            
            if (minNumQualityLayers === 'max') {
                minNumQualityLayers = maxNumQualityLayers;
            } else if (minNumQualityLayers > maxNumQualityLayers) {
                throw new jGlobals.jpipExceptions.InternalErrorException(
                    'minNumQualityLayers is larger than maxNumQualityLayers');
            }
            
            do {
                if (!precinctIterator.isInCodestreamPart) {
                    throw new jGlobals.jpipExceptions.InternalErrorException(
                        'Unexpected precinct not in codestream part');
                }
                
                var inClassIndex = tileStructure.precinctPositionToInClassIndex(
                    precinctIterator);
                    
                var precinctDatabin = databinsSaver.getPrecinctDatabin(
                    inClassIndex);
                
                var returnedInPrecinct =
                    alreadyReturnedCodeblocks.getObject(precinctDatabin);
                if (returnedInPrecinct.layerPerCodeblock === undefined) {
                    returnedInPrecinct.layerPerCodeblock = [];
                }
            
                var layerReached = pushPackets(
                    result,
                    tileIndexInCodestreamPart,
                    precinctIterator,
                    precinctDatabin,
                    returnedInPrecinct,
                    maxNumQualityLayers);
                
                if (layerReached < minNumQualityLayers) {
                    // NOTE: alreadyReturnedCodeblocks is wrong in this stage,
                    // because it was updated with a data which will not be
                    // returned. I don't care about it now because returning
                    // null here means something bad happened (an exception is
                    // thrown in RequestContext when this happens).
                    // If some day the consistency of alreadyReturnedCodeblocks
                    // is important then a new object should be returned on each
                    // call to this function, or a transactional style should be
                    // used here to abort all non-returned data.
                    
                    return null;
                }
            } while (precinctIterator.tryAdvance());
            
            ++tileIndexInCodestreamPart;
        } while (tileIterator.tryAdvance());
        
        var dataAsUint8 = new Uint8Array(result.data.getLength());
        result.data.copyToTypedArray(dataAsUint8, 0, 0, result.data.getLength());
        result.data = dataAsUint8;
        
        return result;
    }

    function pushPackets(
        result,
        tileIndexInCodestreamPart,
        precinctIterator,
        precinctDatabin,
        returnedCodeblocksInPrecinct,
        maxNumQualityLayers) {
        
        var layer;
        var offsetInPrecinctDatabin;
        
        for (layer = 0; layer < maxNumQualityLayers; ++layer) {
            var codeblockOffsetsInDatabin =
                qualityLayersCache.getPacketOffsetsByCodeblockIndex(
                    precinctDatabin, layer, precinctIterator);
            
            if (codeblockOffsetsInDatabin === null) {
                break;
            }
            
            offsetInPrecinctDatabin =
                codeblockOffsetsInDatabin.headerStartOffset +
                codeblockOffsetsInDatabin.headerLength;
            
            var numCodeblocks =
                codeblockOffsetsInDatabin.codeblockBodyLengthByIndex.length;
            var codeblockOffsetsInResult = new Array(numCodeblocks);
            
            var isIncompletePacket = false;
            
            for (var i = 0; i < numCodeblocks; ++i) {
                var returned = returnedCodeblocksInPrecinct.layerPerCodeblock[i];
                if (returned === undefined) {
                    returned = { layer: -1 };
                    returnedCodeblocksInPrecinct.layerPerCodeblock[i] = returned;
                } else if (returned.layer >= layer) {
                    continue;
                }
                
                var codeblock =
                    codeblockOffsetsInDatabin.codeblockBodyLengthByIndex[i];
                
                var offsetInResultArray = result.data.getLength();
                
                var bytesCopied = precinctDatabin.copyToCompositeArray(
                    result.data,
                    {
                        databinStartOffset: offsetInPrecinctDatabin,
                        maxLengthToCopy: codeblock.codeblockBodyLengthBytes,
                        forceCopyAllRange: true
                    });
                
                if (bytesCopied !== codeblock.codeblockBodyLengthBytes) {
                    codeblockOffsetsInResult.length = i;
                    isIncompletePacket = true;
                    break;
                }
                
                returned.layer = layer;
                codeblockOffsetsInResult[i] = {
                    start: offsetInResultArray,
                    end: offsetInResultArray + codeblock.codeblockBodyLengthBytes,
                    codingpasses: codeblock.codingPasses,
                    zeroBitPlanes: codeblock.zeroBitPlanes
                    };
                
                offsetInPrecinctDatabin += codeblock.codeblockBodyLengthBytes;
            }
            
            var packet = {
                tileIndex: tileIndexInCodestreamPart,
                r: precinctIterator.resolutionLevel,
                p: precinctIterator.precinctIndexInComponentResolution,
                c: precinctIterator.component,
                l: layer,
                codeblockOffsets: codeblockOffsetsInResult
                };

            result.packetDataOffsets.push(packet);
            
            if (isIncompletePacket) {
                break;
            }
        }
        
        result.allRelevantBytesLoaded += offsetInPrecinctDatabin;
        return layer;
    }    
};
},{"j2k-jpip-globals.js":12}]},{},[32])(32)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvYXBpL2pwaXAtY29kZXN0cmVhbS1jbGllbnQuanMiLCJzcmMvYXBpL2pwaXAtY29kZXN0cmVhbS1zaXplcy1jYWxjdWxhdG9yLmpzIiwic3JjL2FwaS9qcGlwLXJlcXVlc3QtY29udGV4dC5qcyIsInNyYy9kYXRhYmlucy9jb21wb3NpdGUtYXJyYXkuanMiLCJzcmMvZGF0YWJpbnMvanBpcC1kYXRhYmluLXBhcnRzLmpzIiwic3JjL2RhdGFiaW5zL2pwaXAtZGF0YWJpbnMtc2F2ZXIuanMiLCJzcmMvZGF0YWJpbnMvanBpcC1vYmplY3QtcG9vbC1ieS1kYXRhYmluLmpzIiwic3JjL2RhdGFiaW5zL2pwaXAtcmVxdWVzdC1kYXRhYmlucy1saXN0ZW5lci5qcyIsInNyYy9pbWFnZS1zdHJ1Y3R1cmVzL2pwaXAtY29kZXN0cmVhbS1zdHJ1Y3R1cmUuanMiLCJzcmMvaW1hZ2Utc3RydWN0dXJlcy9qcGlwLWNvbXBvbmVudC1zdHJ1Y3R1cmUuanMiLCJzcmMvaW1hZ2Utc3RydWN0dXJlcy9qcGlwLXRpbGUtc3RydWN0dXJlLmpzIiwic3JjL21pc2MvajJrLWpwaXAtZ2xvYmFscy5qcyIsInNyYy9taXNjL2pwaXAtcnVudGltZS1mYWN0b3J5LmpzIiwic3JjL21pc2Mvc2ltcGxlLWFqYXgtaGVscGVyLmpzIiwic3JjL3BhcnNlcnMvanBpcC1tYXJrZXJzLXBhcnNlci5qcyIsInNyYy9wYXJzZXJzL2pwaXAtb2Zmc2V0cy1jYWxjdWxhdG9yLmpzIiwic3JjL3BhcnNlcnMvanBpcC1zdHJ1Y3R1cmUtcGFyc2VyLmpzIiwic3JjL3Byb3RvY29sL2pwaXAtY2hhbm5lbC5qcyIsInNyYy9wcm90b2NvbC9qcGlwLW1lc3NhZ2UtaGVhZGVyLXBhcnNlci5qcyIsInNyYy9wcm90b2NvbC9qcGlwLXJlY29ubmVjdGFibGUtcmVxdWVzdGVyLmpzIiwic3JjL3Byb3RvY29sL2pwaXAtcmVxdWVzdC5qcyIsInNyYy9wcm90b2NvbC9qcGlwLXNlc3Npb24taGVscGVyLmpzIiwic3JjL3Byb3RvY29sL2pwaXAtc2Vzc2lvbi5qcyIsInNyYy9xdWFsaXR5LWxheWVycy9qcGlwLWJpdHN0cmVhbS1yZWFkZXIuanMiLCJzcmMvcXVhbGl0eS1sYXllcnMvanBpcC1jb2RlYmxvY2stbGVuZ3RoLXBhcnNlci5qcyIsInNyYy9xdWFsaXR5LWxheWVycy9qcGlwLWNvZGluZy1wYXNzZXMtbnVtYmVyLXBhcnNlci5qcyIsInNyYy9xdWFsaXR5LWxheWVycy9qcGlwLXBhY2tldC1sZW5ndGgtY2FsY3VsYXRvci5qcyIsInNyYy9xdWFsaXR5LWxheWVycy9qcGlwLXF1YWxpdHktbGF5ZXJzLWNhY2hlLmpzIiwic3JjL3F1YWxpdHktbGF5ZXJzL2pwaXAtc3ViYmFuZC1sZW5ndGgtaW4tcGFja2V0LWhlYWRlci1jYWxjdWxhdG9yLmpzIiwic3JjL3F1YWxpdHktbGF5ZXJzL2pwaXAtdGFnLXRyZWUuanMiLCJzcmMvcXVhbGl0eS1sYXllcnMvbXV0dWFsLWV4Y2x1c2l2ZS10cmFuc2FjdGlvbi1oZWxwZXIuanMiLCJzcmMvd2VianBpcC1leHBvcnRzLmpzIiwic3JjL3dyaXRlcnMvanBpcC1jb2Rlc3RyZWFtLXJlY29uc3RydWN0b3IuanMiLCJzcmMvd3JpdGVycy9qcGlwLWhlYWRlci1tb2RpZmllci5qcyIsInNyYy93cml0ZXJzL2pwaXAtcGFja2V0cy1kYXRhLWNvbGxlY3Rvci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBqR2xvYmFscyA9IHJlcXVpcmUoJ2oyay1qcGlwLWdsb2JhbHMuanMnKTtcclxudmFyIGpwaXBSdW50aW1lRmFjdG9yeSA9IHJlcXVpcmUoJ2pwaXAtcnVudGltZS1mYWN0b3J5LmpzJyk7IFxyXG5cclxubW9kdWxlLmV4cG9ydHMuSnBpcENvZGVzdHJlYW1DbGllbnQgPSBmdW5jdGlvbiBKcGlwQ29kZXN0cmVhbUNsaWVudChvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIHZhciBqcGlwRmFjdG9yeSA9IGpwaXBSdW50aW1lRmFjdG9yeTtcclxuXHJcbiAgICB2YXIgZGF0YWJpbnNTYXZlciA9IGpwaXBGYWN0b3J5LmNyZWF0ZURhdGFiaW5zU2F2ZXIoLyppc0pwaXBUaWxlcGFydFN0cmVhbT0qL2ZhbHNlKTtcclxuICAgIHZhciBtYWluSGVhZGVyRGF0YWJpbiA9IGRhdGFiaW5zU2F2ZXIuZ2V0TWFpbkhlYWRlckRhdGFiaW4oKTtcclxuXHJcbiAgICB2YXIgbWFya2Vyc1BhcnNlciA9IGpwaXBGYWN0b3J5LmNyZWF0ZU1hcmtlcnNQYXJzZXIobWFpbkhlYWRlckRhdGFiaW4pO1xyXG4gICAgdmFyIG9mZnNldHNDYWxjdWxhdG9yID0ganBpcEZhY3RvcnkuY3JlYXRlT2Zmc2V0c0NhbGN1bGF0b3IoXHJcbiAgICAgICAgbWFpbkhlYWRlckRhdGFiaW4sIG1hcmtlcnNQYXJzZXIpO1xyXG4gICAgdmFyIHN0cnVjdHVyZVBhcnNlciA9IGpwaXBGYWN0b3J5LmNyZWF0ZVN0cnVjdHVyZVBhcnNlcihcclxuICAgICAgICBkYXRhYmluc1NhdmVyLCBtYXJrZXJzUGFyc2VyLCBvZmZzZXRzQ2FsY3VsYXRvcik7XHJcbiAgICBcclxuICAgIHZhciBwcm9ncmVzc2lvbk9yZGVyID0gJ1JQQ0wnO1xyXG4gICAgdmFyIGNvZGVzdHJlYW1TdHJ1Y3R1cmUgPSBqcGlwRmFjdG9yeS5jcmVhdGVDb2Rlc3RyZWFtU3RydWN0dXJlKFxyXG4gICAgICAgIHN0cnVjdHVyZVBhcnNlciwgcHJvZ3Jlc3Npb25PcmRlcik7XHJcbiAgICBcclxuICAgIHZhciBxdWFsaXR5TGF5ZXJzQ2FjaGUgPSBqcGlwRmFjdG9yeS5jcmVhdGVRdWFsaXR5TGF5ZXJzQ2FjaGUoXHJcbiAgICAgICAgY29kZXN0cmVhbVN0cnVjdHVyZSk7XHJcbiAgICAgICAgXHJcbiAgICB2YXIgaGVhZGVyTW9kaWZpZXIgPSBqcGlwRmFjdG9yeS5jcmVhdGVIZWFkZXJNb2RpZmllcihcclxuICAgICAgICBjb2Rlc3RyZWFtU3RydWN0dXJlLCBvZmZzZXRzQ2FsY3VsYXRvciwgcHJvZ3Jlc3Npb25PcmRlcik7XHJcbiAgICB2YXIgcmVjb25zdHJ1Y3RvciA9IGpwaXBGYWN0b3J5LmNyZWF0ZUNvZGVzdHJlYW1SZWNvbnN0cnVjdG9yKFxyXG4gICAgICAgIGNvZGVzdHJlYW1TdHJ1Y3R1cmUsIGRhdGFiaW5zU2F2ZXIsIGhlYWRlck1vZGlmaWVyLCBxdWFsaXR5TGF5ZXJzQ2FjaGUpO1xyXG4gICAgdmFyIHBhY2tldHNEYXRhQ29sbGVjdG9yID0ganBpcEZhY3RvcnkuY3JlYXRlUGFja2V0c0RhdGFDb2xsZWN0b3IoXHJcbiAgICAgICAgY29kZXN0cmVhbVN0cnVjdHVyZSwgZGF0YWJpbnNTYXZlciwgcXVhbGl0eUxheWVyc0NhY2hlKTtcclxuICAgIFxyXG4gICAgdmFyIG1heENoYW5uZWxzSW5TZXNzaW9uID0gb3B0aW9ucy5tYXhDaGFubmVsc0luU2Vzc2lvbiB8fCAxO1xyXG4gICAgdmFyIG1heFJlcXVlc3RzV2FpdGluZ0ZvclJlc3BvbnNlSW5DaGFubmVsID1cclxuICAgICAgICBvcHRpb25zLm1heFJlcXVlc3RzV2FpdGluZ0ZvclJlc3BvbnNlSW5DaGFubmVsIHx8IDE7XHJcbiAgICAgICAgXHJcbiAgICB2YXIgcmVxdWVzdGVyID0ganBpcEZhY3RvcnkuY3JlYXRlUmVjb25uZWN0YWJsZVJlcXVlc3RlcihcclxuICAgICAgICBtYXhDaGFubmVsc0luU2Vzc2lvbixcclxuICAgICAgICBtYXhSZXF1ZXN0c1dhaXRpbmdGb3JSZXNwb25zZUluQ2hhbm5lbCxcclxuICAgICAgICBjb2Rlc3RyZWFtU3RydWN0dXJlLFxyXG4gICAgICAgIGRhdGFiaW5zU2F2ZXIpO1xyXG4gICAgXHJcbiAgICB2YXIganBpcE9iamVjdHNGb3JSZXF1ZXN0Q29udGV4dCA9IHtcclxuICAgICAgICByZXF1ZXN0ZXI6IHJlcXVlc3RlcixcclxuICAgICAgICByZWNvbnN0cnVjdG9yOiByZWNvbnN0cnVjdG9yLFxyXG4gICAgICAgIHBhY2tldHNEYXRhQ29sbGVjdG9yOiBwYWNrZXRzRGF0YUNvbGxlY3RvcixcclxuICAgICAgICBxdWFsaXR5TGF5ZXJzQ2FjaGU6IHF1YWxpdHlMYXllcnNDYWNoZSxcclxuICAgICAgICBjb2Rlc3RyZWFtU3RydWN0dXJlOiBjb2Rlc3RyZWFtU3RydWN0dXJlLFxyXG4gICAgICAgIGRhdGFiaW5zU2F2ZXI6IGRhdGFiaW5zU2F2ZXIsXHJcbiAgICAgICAganBpcEZhY3Rvcnk6IGpwaXBGYWN0b3J5XHJcbiAgICAgICAgfTtcclxuICAgIFxyXG4gICAgdmFyIHN0YXR1c0NhbGxiYWNrID0gbnVsbDtcclxuICAgIFxyXG4gICAgdGhpcy5zZXRTdGF0dXNDYWxsYmFjayA9IGZ1bmN0aW9uIHNldFN0YXR1c0NhbGxiYWNrQ2xvc3VyZShjYWxsYmFjaykge1xyXG4gICAgICAgIHN0YXR1c0NhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3Rlci5zZXRTdGF0dXNDYWxsYmFjayhyZXF1ZXN0ZXJTdGF0dXNDYWxsYmFjayk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVxdWVzdGVyLnNldFN0YXR1c0NhbGxiYWNrKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMub3BlbiA9IGZ1bmN0aW9uIG9wZW4oYmFzZVVybCkge1xyXG4gICAgICAgIHJlcXVlc3Rlci5vcGVuKGJhc2VVcmwpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKGNsb3NlZENhbGxiYWNrKSB7XHJcbiAgICAgICAgcmVxdWVzdGVyLmNsb3NlKGNsb3NlZENhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0U2l6ZXNQYXJhbXMgPSBmdW5jdGlvbiBnZXRTaXplc1BhcmFtcygpIHtcclxuICAgICAgICBpZiAoIXJlcXVlc3Rlci5nZXRJc1JlYWR5KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLklsbGVnYWxPcGVyYXRpb25FeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAnQ2Fubm90IGdldCBjb2Rlc3RyZWFtIHN0cnVjdHVyZSBiZWZvcmUgaW1hZ2UgaXMgcmVhZHknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IGNvZGVzdHJlYW1TdHJ1Y3R1cmUuZ2V0U2l6ZXNQYXJhbXMoKTtcclxuICAgICAgICB2YXIgY2xvbmVkUGFyYW1zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwYXJhbXMpKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgdGlsZSA9IGNvZGVzdHJlYW1TdHJ1Y3R1cmUuZ2V0RGVmYXVsdFRpbGVTdHJ1Y3R1cmUoKTtcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGlsZS5nZXREZWZhdWx0Q29tcG9uZW50U3RydWN0dXJlKCk7XHJcblxyXG4gICAgICAgIGNsb25lZFBhcmFtcy5kZWZhdWx0TnVtUXVhbGl0eUxheWVycyA9XHJcbiAgICAgICAgICAgIHRpbGUuZ2V0TnVtUXVhbGl0eUxheWVycygpO1xyXG4gICAgICAgIGNsb25lZFBhcmFtcy5kZWZhdWx0TnVtUmVzb2x1dGlvbkxldmVscyA9XHJcbiAgICAgICAgICAgIGNvbXBvbmVudC5nZXROdW1SZXNvbHV0aW9uTGV2ZWxzKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGNsb25lZFBhcmFtcztcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuY3JlYXRlRGF0YVJlcXVlc3QgPSBmdW5jdGlvbiBjcmVhdGVEYXRhUmVxdWVzdChcclxuICAgICAgICBjb2Rlc3RyZWFtUGFydFBhcmFtcywgY2FsbGJhY2ssIHVzZXJDb250ZXh0VmFycywgb3B0aW9ucykge1xyXG4gICAgICAgIFxyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIGlmIChvcHRpb25zLmlzT25seVdhaXRGb3JEYXRhICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkFyZ3VtZW50RXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgJ29wdGlvbnMuaXNPbmx5V2FpdEZvckRhdGEnLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5pc09ubHlXYWl0Rm9yRGF0YSxcclxuICAgICAgICAgICAgICAgICdpc09ubHlXYWl0Rm9yRGF0YSBpcyBzdXBwb3J0ZWQgb25seSBmb3IgcHJvZ3Jlc3NpdmUgcmVxdWVzdCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgY29kZXN0cmVhbVBhcnRQYXJhbXNNb2RpZmllZCA9IGNhc3RDb2Rlc3RyZWFtUGFydFBhcmFtcyhcclxuICAgICAgICAgICAgY29kZXN0cmVhbVBhcnRQYXJhbXMpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBwcm9ncmVzc2l2ZW5lc3M7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMudXNlQ2FjaGVkRGF0YU9ubHkpIHtcclxuICAgICAgICAgICAgcHJvZ3Jlc3NpdmVuZXNzID0gWyB7IG1pbk51bVF1YWxpdHlMYXllcnM6IDAgfSBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBtYXhOdW1RdWFsaXR5TGF5ZXJzID0gY29kZXN0cmVhbVBhcnRQYXJhbXMubWF4TnVtUXVhbGl0eUxheWVycztcclxuICAgICAgICAgICAgdmFyIG1pbk51bVF1YWxpdHlMYXllcnMgPVxyXG4gICAgICAgICAgICAgICAgbWF4TnVtUXVhbGl0eUxheWVycyA9PT0gdW5kZWZpbmVkID8gJ21heCcgOiBtYXhOdW1RdWFsaXR5TGF5ZXJzO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcHJvZ3Jlc3NpdmVuZXNzID0gWyB7IG1pbk51bVF1YWxpdHlMYXllcnM6IG1pbk51bVF1YWxpdHlMYXllcnMgfSBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgcmVxdWVzdENvbnRleHQgPSBqcGlwRmFjdG9yeS5jcmVhdGVSZXF1ZXN0Q29udGV4dChcclxuICAgICAgICAgICAganBpcE9iamVjdHNGb3JSZXF1ZXN0Q29udGV4dCxcclxuICAgICAgICAgICAgY29kZXN0cmVhbVBhcnRQYXJhbXNNb2RpZmllZCxcclxuICAgICAgICAgICAgY2FsbGJhY2ssXHJcbiAgICAgICAgICAgIHByb2dyZXNzaXZlbmVzcyxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGlzYWJsZVNlcnZlclJlcXVlc3RzOiAhIW9wdGlvbnMudXNlQ2FjaGVkRGF0YU9ubHksXHJcbiAgICAgICAgICAgICAgICBpc01vdmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgdXNlckNvbnRleHRWYXJzOiB1c2VyQ29udGV4dFZhcnMsXHJcbiAgICAgICAgICAgICAgICBmYWlsdXJlQ2FsbGJhY2s6IG9wdGlvbnMuZmFpbHVyZUNhbGxiYWNrXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiByZXF1ZXN0Q29udGV4dDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuY3JlYXRlUHJvZ3Jlc3NpdmVEYXRhUmVxdWVzdCA9IGZ1bmN0aW9uIGNyZWF0ZVByb2dyZXNzaXZlRGF0YVJlcXVlc3QoXHJcbiAgICAgICAgY29kZXN0cmVhbVBhcnRQYXJhbXMsXHJcbiAgICAgICAgY2FsbGJhY2ssXHJcbiAgICAgICAgdXNlckNvbnRleHRWYXJzLFxyXG4gICAgICAgIG9wdGlvbnMsXHJcbiAgICAgICAgcHJvZ3Jlc3NpdmVuZXNzKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgaWYgKG9wdGlvbnMudXNlQ2FjaGVkRGF0YU9ubHkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuQXJndW1lbnRFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAnb3B0aW9ucy51c2VDYWNoZWREYXRhT25seScsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnVzZUNhY2hlZERhdGFPbmx5LFxyXG4gICAgICAgICAgICAgICAgJ3VzZUNhY2hlZERhdGFPbmx5IGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb2dyZXNzaXZlIHJlcXVlc3QnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGNvZGVzdHJlYW1QYXJ0UGFyYW1zTW9kaWZpZWQgPSBjYXN0Q29kZXN0cmVhbVBhcnRQYXJhbXMoXHJcbiAgICAgICAgICAgIGNvZGVzdHJlYW1QYXJ0UGFyYW1zKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgcHJvZ3Jlc3NpdmVuZXNzTW9kaWZpZWQ7XHJcbiAgICAgICAgaWYgKHByb2dyZXNzaXZlbmVzcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHByb2dyZXNzaXZlbmVzc01vZGlmaWVkID0gZ2V0QXV0b21hdGljUHJvZ3Jlc3NpdmVuZXNzU3RhZ2VzKFxyXG4gICAgICAgICAgICAgICAgY29kZXN0cmVhbVBhcnRQYXJhbXNNb2RpZmllZC5tYXhOdW1RdWFsaXR5TGF5ZXJzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwcm9ncmVzc2l2ZW5lc3NNb2RpZmllZCA9IGNhc3RQcm9ncmVzc2l2ZW5lc3NQYXJhbXMoXHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzc2l2ZW5lc3MsIGNvZGVzdHJlYW1QYXJ0UGFyYW1zTW9kaWZpZWQubWF4TnVtUXVhbGl0eUxheWVycywgJ21heE51bVF1YWxpdHlMYXllcnMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlcXVlc3RDb250ZXh0ID0ganBpcEZhY3RvcnkuY3JlYXRlUmVxdWVzdENvbnRleHQoXHJcbiAgICAgICAgICAgIGpwaXBPYmplY3RzRm9yUmVxdWVzdENvbnRleHQsXHJcbiAgICAgICAgICAgIGNvZGVzdHJlYW1QYXJ0UGFyYW1zTW9kaWZpZWQsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrLFxyXG4gICAgICAgICAgICBwcm9ncmVzc2l2ZW5lc3NNb2RpZmllZCxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGlzYWJsZVNlcnZlclJlcXVlc3RzOiAhIW9wdGlvbnMuaXNPbmx5V2FpdEZvckRhdGEsXHJcbiAgICAgICAgICAgICAgICBpc01vdmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgdXNlckNvbnRleHRWYXJzOiB1c2VyQ29udGV4dFZhcnMsXHJcbiAgICAgICAgICAgICAgICBmYWlsdXJlQ2FsbGJhY2s6IG9wdGlvbnMuZmFpbHVyZUNhbGxiYWNrXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiByZXF1ZXN0Q29udGV4dDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuY3JlYXRlTW92YWJsZVJlcXVlc3QgPSBmdW5jdGlvbiBjcmVhdGVNb3ZhYmxlUmVxdWVzdChcclxuICAgICAgICBjYWxsYmFjaywgdXNlckNvbnRleHRWYXJzKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTk9URTogVGhpbmsgb2YgdGhlIGNvcnJlY3QgQVBJIG9mIHByb2dyZXNzaXZlbmVzcyBpbiBtb3ZhYmxlIHJlcXVlc3RzXHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHpvbWJpZUNvZGVzdHJlYW1QYXJ0UGFyYW1zID0gbnVsbDtcclxuICAgICAgICB2YXIgcHJvZ3Jlc3NpdmVuZXNzID0gZ2V0QXV0b21hdGljUHJvZ3Jlc3NpdmVuZXNzU3RhZ2VzKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlcXVlc3RDb250ZXh0ID0ganBpcEZhY3RvcnkuY3JlYXRlUmVxdWVzdENvbnRleHQoXHJcbiAgICAgICAgICAgIGpwaXBPYmplY3RzRm9yUmVxdWVzdENvbnRleHQsXHJcbiAgICAgICAgICAgIHpvbWJpZUNvZGVzdHJlYW1QYXJ0UGFyYW1zLFxyXG4gICAgICAgICAgICBjYWxsYmFjayxcclxuICAgICAgICAgICAgcHJvZ3Jlc3NpdmVuZXNzLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkaXNhYmxlU2VydmVyUmVxdWVzdHM6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgaXNNb3ZhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdXNlckNvbnRleHRWYXJzOiB1c2VyQ29udGV4dFZhcnNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIHJldHVybiByZXF1ZXN0Q29udGV4dDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMucmVjb25uZWN0ID0gZnVuY3Rpb24gcmVjb25uZWN0KCkge1xyXG4gICAgICAgIHJlcXVlc3Rlci5yZWNvbm5lY3QoKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHJlcXVlc3RlclN0YXR1c0NhbGxiYWNrKHJlcXVlc3RlclN0YXR1cykge1xyXG4gICAgICAgIHZhciBzZXJpYWxpemFibGVFeGNlcHRpb24gPSBudWxsO1xyXG4gICAgICAgIGlmIChyZXF1ZXN0ZXJTdGF0dXMuZXhjZXB0aW9uICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNlcmlhbGl6YWJsZUV4Y2VwdGlvbiA9IHJlcXVlc3RlclN0YXR1cy5leGNlcHRpb24udG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHN0YXR1cyA9IHtcclxuICAgICAgICAgICAgaXNSZWFkeTogcmVxdWVzdGVyU3RhdHVzLmlzUmVhZHksXHJcbiAgICAgICAgICAgIGV4Y2VwdGlvbjogc2VyaWFsaXphYmxlRXhjZXB0aW9uXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgc3RhdHVzQ2FsbGJhY2soc3RhdHVzKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gY2FzdFByb2dyZXNzaXZlbmVzc1BhcmFtcyhwcm9ncmVzc2l2ZW5lc3MsIG1heE51bVF1YWxpdHlMYXllcnMsIHByb3BlcnR5TmFtZSkge1xyXG4gICAgICAgIC8vIEVuc3VyZSB0aGFuIG1pbk51bVF1YWxpdHlMYXllcnMgaXMgZ2l2ZW4gZm9yIGFsbCBpdGVtc1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkocHJvZ3Jlc3NpdmVuZXNzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvZ3Jlc3NpdmVuZXNzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBtaW5OdW1RdWFsaXR5TGF5ZXJzID0gcHJvZ3Jlc3NpdmVuZXNzW2ldLm1pbk51bVF1YWxpdHlMYXllcnM7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAobWluTnVtUXVhbGl0eUxheWVycyAhPT0gJ21heCcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXhOdW1RdWFsaXR5TGF5ZXJzICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgICAgICAgICBtaW5OdW1RdWFsaXR5TGF5ZXJzID4gbWF4TnVtUXVhbGl0eUxheWVycykge1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5Bcmd1bWVudEV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Byb2dyZXNzaXZlbmVzc1snICsgaSArICddLm1pbk51bVF1YWxpdHlMYXllcnMnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5OdW1RdWFsaXR5TGF5ZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluTnVtUXVhbGl0eUxheWVycyBpcyBiaWdnZXIgdGhhbiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmZXRjaFBhcmFtcy5tYXhOdW1RdWFsaXR5TGF5ZXJzJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIG1pbk51bVF1YWxpdHlMYXllcnMgPSB2YWxpZGF0ZU51bWVyaWNQYXJhbShcclxuICAgICAgICAgICAgICAgICAgICBtaW5OdW1RdWFsaXR5TGF5ZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAncHJvZ3Jlc3NpdmVuZXNzWycgKyBpICsgJ10ubWluTnVtUXVhbGl0eUxheWVycycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXN1bHRbaV0gPSB7IG1pbk51bVF1YWxpdHlMYXllcnM6IG1pbk51bVF1YWxpdHlMYXllcnMgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gZ2V0QXV0b21hdGljUHJvZ3Jlc3NpdmVuZXNzU3RhZ2VzKG1heE51bVF1YWxpdHlMYXllcnMpIHtcclxuICAgICAgICAvLyBDcmVhdGUgcHJvZ3Jlc3NpdmVuZXNzIG9mICgxLCAyLCAzLCAoI21heC1xdWFsaXR5LzIpLCAoI21heC1xdWFsaXR5KSlcclxuXHJcbiAgICAgICAgdmFyIHByb2dyZXNzaXZlbmVzcyA9IFtdO1xyXG5cclxuICAgICAgICAvLyBObyBwcm9ncmVzc2l2ZW5lc3MsIHdhaXQgZm9yIGFsbCBxdWFsaXR5IGxheWVycyB0byBiZSBmZXRjaGVkXHJcbiAgICAgICAgdmFyIHRpbGVTdHJ1Y3R1cmUgPSBjb2Rlc3RyZWFtU3RydWN0dXJlLmdldERlZmF1bHRUaWxlU3RydWN0dXJlKCk7XHJcbiAgICAgICAgdmFyIG51bVF1YWxpdHlMYXllcnNOdW1lcmljID0gdGlsZVN0cnVjdHVyZS5nZXROdW1RdWFsaXR5TGF5ZXJzKCk7XHJcbiAgICAgICAgdmFyIG1heE51bVF1YWxpdHlMYXllcnNOdW1lcmljT3JNYXggPSAnbWF4JztcclxuICAgICAgICBcclxuICAgICAgICBpZiAobWF4TnVtUXVhbGl0eUxheWVycyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG51bVF1YWxpdHlMYXllcnNOdW1lcmljID0gTWF0aC5taW4oXHJcbiAgICAgICAgICAgICAgICBudW1RdWFsaXR5TGF5ZXJzTnVtZXJpYywgbWF4TnVtUXVhbGl0eUxheWVycyk7XHJcbiAgICAgICAgICAgIG1heE51bVF1YWxpdHlMYXllcnNOdW1lcmljT3JNYXggPSBudW1RdWFsaXR5TGF5ZXJzTnVtZXJpYztcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGZpcnN0UXVhbGl0eUxheWVyc0NvdW50ID0gbnVtUXVhbGl0eUxheWVyc051bWVyaWMgPCA0ID9cclxuICAgICAgICAgICAgbnVtUXVhbGl0eUxheWVyc051bWVyaWMgLSAxOiAzO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZmlyc3RRdWFsaXR5TGF5ZXJzQ291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICBwcm9ncmVzc2l2ZW5lc3MucHVzaCh7IG1pbk51bVF1YWxpdHlMYXllcnM6IGkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBtaWRkbGVRdWFsaXR5ID0gTWF0aC5yb3VuZChudW1RdWFsaXR5TGF5ZXJzTnVtZXJpYyAvIDIpO1xyXG4gICAgICAgIGlmIChtaWRkbGVRdWFsaXR5ID4gZmlyc3RRdWFsaXR5TGF5ZXJzQ291bnQpIHtcclxuICAgICAgICAgICAgcHJvZ3Jlc3NpdmVuZXNzLnB1c2goeyBtaW5OdW1RdWFsaXR5TGF5ZXJzOiBtaWRkbGVRdWFsaXR5IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBwcm9ncmVzc2l2ZW5lc3MucHVzaCh7XHJcbiAgICAgICAgICAgIG1pbk51bVF1YWxpdHlMYXllcnM6IG1heE51bVF1YWxpdHlMYXllcnNOdW1lcmljT3JNYXhcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHByb2dyZXNzaXZlbmVzcztcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gY2FzdENvZGVzdHJlYW1QYXJ0UGFyYW1zKGNvZGVzdHJlYW1QYXJ0UGFyYW1zKSB7XHJcbiAgICAgICAgdmFyIG51bVJlc29sdXRpb25MZXZlbHNUb0N1dCA9IHZhbGlkYXRlTnVtZXJpY1BhcmFtKFxyXG4gICAgICAgICAgICBjb2Rlc3RyZWFtUGFydFBhcmFtcy5udW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQsXHJcbiAgICAgICAgICAgICdudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQnLFxyXG4gICAgICAgICAgICAvKmRlZmF1bHRWYWx1ZT0qL3VuZGVmaW5lZCxcclxuICAgICAgICAgICAgLyphbGxvd1VuZGVmaWVuZD0qL3RydWUpO1xyXG5cclxuICAgICAgICB2YXIgbWF4TnVtUXVhbGl0eUxheWVycyA9IHZhbGlkYXRlTnVtZXJpY1BhcmFtKFxyXG4gICAgICAgICAgICBjb2Rlc3RyZWFtUGFydFBhcmFtcy5tYXhOdW1RdWFsaXR5TGF5ZXJzLFxyXG4gICAgICAgICAgICAnbWF4TnVtUXVhbGl0eUxheWVycycsXHJcbiAgICAgICAgICAgIC8qZGVmYXVsdFZhbHVlPSovdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAvKmFsbG93VW5kZWZpZW5kPSovdHJ1ZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIG1pblggPSB2YWxpZGF0ZU51bWVyaWNQYXJhbShjb2Rlc3RyZWFtUGFydFBhcmFtcy5taW5YLCAnbWluWCcpO1xyXG4gICAgICAgIHZhciBtaW5ZID0gdmFsaWRhdGVOdW1lcmljUGFyYW0oY29kZXN0cmVhbVBhcnRQYXJhbXMubWluWSwgJ21pblknKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgbWF4WCA9IHZhbGlkYXRlTnVtZXJpY1BhcmFtKFxyXG4gICAgICAgICAgICBjb2Rlc3RyZWFtUGFydFBhcmFtcy5tYXhYRXhjbHVzaXZlLCAnbWF4WEV4Y2x1c2l2ZScpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBtYXhZID0gdmFsaWRhdGVOdW1lcmljUGFyYW0oXHJcbiAgICAgICAgICAgIGNvZGVzdHJlYW1QYXJ0UGFyYW1zLm1heFlFeGNsdXNpdmUsICdtYXhZRXhjbHVzaXZlJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGxldmVsV2lkdGggPSBjb2Rlc3RyZWFtU3RydWN0dXJlLmdldExldmVsV2lkdGgobnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0KTtcclxuICAgICAgICB2YXIgbGV2ZWxIZWlnaHQgPSBjb2Rlc3RyZWFtU3RydWN0dXJlLmdldExldmVsSGVpZ2h0KG51bVJlc29sdXRpb25MZXZlbHNUb0N1dCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKG1pblggPCAwIHx8IG1heFggPiBsZXZlbFdpZHRoIHx8XHJcbiAgICAgICAgICAgIG1pblkgPCAwIHx8IG1heFkgPiBsZXZlbEhlaWdodCB8fFxyXG4gICAgICAgICAgICBtaW5YID49IG1heFggfHwgbWluWSA+PSBtYXhZKSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuQXJndW1lbnRFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAnY29kZXN0cmVhbVBhcnRQYXJhbXMnLCBjb2Rlc3RyZWFtUGFydFBhcmFtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgIG1pblg6IG1pblgsXHJcbiAgICAgICAgICAgIG1pblk6IG1pblksXHJcbiAgICAgICAgICAgIG1heFhFeGNsdXNpdmU6IG1heFgsXHJcbiAgICAgICAgICAgIG1heFlFeGNsdXNpdmU6IG1heFksXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQ6IG51bVJlc29sdXRpb25MZXZlbHNUb0N1dCxcclxuICAgICAgICAgICAgbWF4TnVtUXVhbGl0eUxheWVyczogbWF4TnVtUXVhbGl0eUxheWVyc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlTnVtZXJpY1BhcmFtKFxyXG4gICAgICAgIGlucHV0VmFsdWUsIHByb3BlcnR5TmFtZSwgZGVmYXVsdFZhbHVlLCBhbGxvd1VuZGVmaW5lZCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChpbnB1dFZhbHVlID09PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgKGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGFsbG93VW5kZWZpbmVkKSkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9ICtpbnB1dFZhbHVlO1xyXG4gICAgICAgIGlmIChpc05hTihyZXN1bHQpIHx8IHJlc3VsdCAhPT0gTWF0aC5mbG9vcihyZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5Bcmd1bWVudEV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZSwgaW5wdXRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiB0aGlzO1xyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBqR2xvYmFscyA9IHJlcXVpcmUoJ2oyay1qcGlwLWdsb2JhbHMuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLkpwaXBDb2Rlc3RyZWFtU2l6ZXNDYWxjdWxhdG9yID0gZnVuY3Rpb24gSnBpcENvZGVzdHJlYW1TaXplc0NhbGN1bGF0b3IoXHJcbiAgICBwYXJhbXMpIHtcclxuICAgIFxyXG4gICAgdmFyIEVER0VfVFlQRV9OT19FREdFID0gMDtcclxuICAgIHZhciBFREdFX1RZUEVfRklSU1QgPSAxO1xyXG4gICAgdmFyIEVER0VfVFlQRV9MQVNUID0gMjtcclxuXHJcbiAgICB0aGlzLkVER0VfVFlQRV9OT19FREdFID0gRURHRV9UWVBFX05PX0VER0U7XHJcbiAgICB0aGlzLkVER0VfVFlQRV9GSVJTVCA9IEVER0VfVFlQRV9GSVJTVDtcclxuICAgIHRoaXMuRURHRV9UWVBFX0xBU1QgPSBFREdFX1RZUEVfTEFTVDtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRTaXplT2ZQYXJ0ID0gZ2V0U2l6ZU9mUGFydDtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRUaWxlc0Zyb21QaXhlbHMgPSBnZXRUaWxlc0Zyb21QaXhlbHM7XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0TnVtVGlsZXNYID0gZ2V0TnVtVGlsZXNYO1xyXG4gICAgXHJcbiAgICB0aGlzLmdldE51bVRpbGVzWSA9IGdldE51bVRpbGVzWTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRMZXZlbFdpZHRoID0gZ2V0TGV2ZWxXaWR0aDtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRMZXZlbEhlaWdodCA9IGdldExldmVsSGVpZ2h0O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldFRpbGVXaWR0aCA9IGdldFRpbGVXaWR0aDtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRUaWxlSGVpZ2h0ID0gZ2V0VGlsZUhlaWdodDtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRGaXJzdFRpbGVPZmZzZXRYID0gZ2V0Rmlyc3RUaWxlT2Zmc2V0WDtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRGaXJzdFRpbGVPZmZzZXRZID0gZ2V0Rmlyc3RUaWxlT2Zmc2V0WTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRGaXJzdFRpbGVXaWR0aCA9IGdldEZpcnN0VGlsZVdpZHRoO1xyXG4gICAgXHJcbiAgICB0aGlzLmdldEZpcnN0VGlsZUhlaWdodCA9IGdldEZpcnN0VGlsZUhlaWdodDtcclxuICAgIFxyXG4gICAgdGhpcy5pc0VkZ2VUaWxlSWQgPSBpc0VkZ2VUaWxlSWQ7XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0VGlsZVNpemUgPSBnZXRUaWxlU2l6ZTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXREZWZhdWx0TnVtUmVzb2x1dGlvbkxldmVscyA9XHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0RGVmYXVsdE51bVJlc29sdXRpb25MZXZlbHMoKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHBhcmFtcy5kZWZhdWx0TnVtUmVzb2x1dGlvbkxldmVscyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93ICdUaGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgb25seSB3aGVuIGpwaXBTaXplc0NhbGN1bGF0b3IgJyArXHJcbiAgICAgICAgICAgICAgICAnaXMgY3JlYXRlZCBmcm9tIHBhcmFtcyByZXR1cm5lZCBieSBqcGlwQ29kZXN0cmVhbUNsaWVudC4gJyArXHJcbiAgICAgICAgICAgICAgICAnSXQgc2hhbGwgYmUgdXNlZCBmb3IgSlBJUCBBUEkgcHVycG9zZXMgb25seSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBwYXJhbXMuZGVmYXVsdE51bVJlc29sdXRpb25MZXZlbHM7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldERlZmF1bHROdW1RdWFsaXR5TGF5ZXJzID1cclxuICAgICAgICBmdW5jdGlvbiBnZXREZWZhdWx0TnVtUXVhbGl0eUxheWVycygpIHtcclxuICAgICAgICBcclxuICAgICAgICBpZiAocGFyYW1zLmRlZmF1bHROdW1RdWFsaXR5TGF5ZXJzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgJ1RoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBvbmx5IHdoZW4ganBpcFNpemVzQ2FsY3VsYXRvciAnICtcclxuICAgICAgICAgICAgICAgICdpcyBjcmVhdGVkIGZyb20gcGFyYW1zIHJldHVybmVkIGJ5IGpwaXBDb2Rlc3RyZWFtQ2xpZW50LiAnICtcclxuICAgICAgICAgICAgICAgICdJdCBzaGFsbCBiZSB1c2VkIGZvciBKUElQIEFQSSBwdXJwb3NlcyBvbmx5JztcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5kZWZhdWx0TnVtUXVhbGl0eUxheWVycztcclxuICAgIH07XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGdldFNpemVPZlBhcnQoY29kZXN0cmVhbVBhcnRQYXJhbXMpIHtcclxuICAgICAgICB2YXIgbnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0ID1cclxuICAgICAgICAgICAgY29kZXN0cmVhbVBhcnRQYXJhbXMubnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0O1xyXG4gICAgICAgIHZhciB0aWxlV2lkdGggPSBnZXRUaWxlV2lkdGgobnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0KTtcclxuICAgICAgICB2YXIgdGlsZUhlaWdodCA9IGdldFRpbGVIZWlnaHQobnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0KTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgdGlsZUJvdW5kcyA9IGdldFRpbGVzRnJvbVBpeGVscyhjb2Rlc3RyZWFtUGFydFBhcmFtcyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGZpcnN0VGlsZUluZGV4ID1cclxuICAgICAgICAgICAgdGlsZUJvdW5kcy5taW5UaWxlWCArIHRpbGVCb3VuZHMubWluVGlsZVkgKiBnZXROdW1UaWxlc1goKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgdmFyIGxhc3RUaWxlSW5kZXggPVxyXG4gICAgICAgICAgICAodGlsZUJvdW5kcy5tYXhUaWxlWEV4Y2x1c2l2ZSAtIDEpICtcclxuICAgICAgICAgICAgKHRpbGVCb3VuZHMubWF4VGlsZVlFeGNsdXNpdmUgLSAxKSAqIGdldE51bVRpbGVzWCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBmaXJzdEVkZ2VUeXBlID0gaXNFZGdlVGlsZUlkKGZpcnN0VGlsZUluZGV4KTtcclxuICAgICAgICB2YXIgbGFzdEVkZ2VUeXBlID0gaXNFZGdlVGlsZUlkKGxhc3RUaWxlSW5kZXgpO1xyXG4gICAgICAgIHZhciBmaXJzdFNpemUgPSBnZXRUaWxlU2l6ZShmaXJzdEVkZ2VUeXBlLCBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQpO1xyXG4gICAgICAgIHZhciBsYXN0U2l6ZSA9IGdldFRpbGVTaXplKGxhc3RFZGdlVHlwZSwgbnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0KTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgd2lkdGggPSBmaXJzdFNpemVbMF07XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IGZpcnN0U2l6ZVsxXTtcclxuXHJcbiAgICAgICAgdmFyIHRpbGVzWCA9IHRpbGVCb3VuZHMubWF4VGlsZVhFeGNsdXNpdmUgLSB0aWxlQm91bmRzLm1pblRpbGVYO1xyXG4gICAgICAgIHZhciB0aWxlc1kgPSB0aWxlQm91bmRzLm1heFRpbGVZRXhjbHVzaXZlIC0gdGlsZUJvdW5kcy5taW5UaWxlWTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAodGlsZXNYID4gMSkge1xyXG4gICAgICAgICAgICB3aWR0aCArPSBsYXN0U2l6ZVswXTtcclxuICAgICAgICAgICAgd2lkdGggKz0gdGlsZVdpZHRoICogKHRpbGVzWCAtIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAodGlsZXNZID4gMSkge1xyXG4gICAgICAgICAgICBoZWlnaHQgKz0gbGFzdFNpemVbMV07XHJcbiAgICAgICAgICAgIGhlaWdodCArPSB0aWxlSGVpZ2h0ICogKHRpbGVzWSAtIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGdldFRpbGVzRnJvbVBpeGVscyhwYXJ0UGFyYW1zKSB7XHJcbiAgICAgICAgdmFyIG51bVJlc29sdXRpb25MZXZlbHNUb0N1dCA9XHJcbiAgICAgICAgICAgIHBhcnRQYXJhbXMubnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0O1xyXG5cclxuICAgICAgICB2YXIgdGlsZVdpZHRoID0gZ2V0VGlsZVdpZHRoKG51bVJlc29sdXRpb25MZXZlbHNUb0N1dCk7XHJcbiAgICAgICAgdmFyIHRpbGVIZWlnaHQgPSBnZXRUaWxlSGVpZ2h0KG51bVJlc29sdXRpb25MZXZlbHNUb0N1dCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGZpcnN0VGlsZVdpZHRoID0gZ2V0Rmlyc3RUaWxlV2lkdGgobnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0KTtcclxuICAgICAgICB2YXIgZmlyc3RUaWxlSGVpZ2h0ID0gZ2V0Rmlyc3RUaWxlSGVpZ2h0KG51bVJlc29sdXRpb25MZXZlbHNUb0N1dCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHN0YXJ0WE5vRmlyc3QgPSAocGFydFBhcmFtcy5taW5YIC0gZmlyc3RUaWxlV2lkdGgpIC8gdGlsZVdpZHRoO1xyXG4gICAgICAgIHZhciBzdGFydFlOb0ZpcnN0ID0gKHBhcnRQYXJhbXMubWluWSAtIGZpcnN0VGlsZUhlaWdodCkgLyB0aWxlSGVpZ2h0O1xyXG4gICAgICAgIHZhciBlbmRYTm9GaXJzdCA9IChwYXJ0UGFyYW1zLm1heFhFeGNsdXNpdmUgLSBmaXJzdFRpbGVXaWR0aCkgLyB0aWxlV2lkdGg7XHJcbiAgICAgICAgdmFyIGVuZFlOb0ZpcnN0ID0gKHBhcnRQYXJhbXMubWF4WUV4Y2x1c2l2ZSAtIGZpcnN0VGlsZUhlaWdodCkgLyB0aWxlSGVpZ2h0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBtaW5UaWxlWCA9IE1hdGgubWF4KDAsIDEgKyBzdGFydFhOb0ZpcnN0KTtcclxuICAgICAgICB2YXIgbWluVGlsZVkgPSBNYXRoLm1heCgwLCAxICsgc3RhcnRZTm9GaXJzdCk7XHJcbiAgICAgICAgdmFyIG1heFRpbGVYID0gTWF0aC5taW4oZ2V0TnVtVGlsZXNYKCksIDEgKyBlbmRYTm9GaXJzdCk7XHJcbiAgICAgICAgdmFyIG1heFRpbGVZID0gTWF0aC5taW4oZ2V0TnVtVGlsZXNZKCksIDEgKyBlbmRZTm9GaXJzdCk7XHJcblxyXG4gICAgICAgIHZhciBib3VuZHMgPSB7XHJcbiAgICAgICAgICAgIG1pblRpbGVYOiBNYXRoLmZsb29yKG1pblRpbGVYKSxcclxuICAgICAgICAgICAgbWluVGlsZVk6IE1hdGguZmxvb3IobWluVGlsZVkpLFxyXG4gICAgICAgICAgICBtYXhUaWxlWEV4Y2x1c2l2ZTogTWF0aC5jZWlsKG1heFRpbGVYKSxcclxuICAgICAgICAgICAgbWF4VGlsZVlFeGNsdXNpdmU6IE1hdGguY2VpbChtYXhUaWxlWSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gYm91bmRzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFRpbGVTaXplKGVkZ2VUeXBlLCBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQpIHtcclxuICAgICAgICB2YXIgdGlsZVdpZHRoID0gZ2V0VGlsZURpbWVuc2lvblNpemUoXHJcbiAgICAgICAgICAgIGVkZ2VUeXBlLmhvcml6b250YWxFZGdlVHlwZSxcclxuICAgICAgICAgICAgZ2V0Rmlyc3RUaWxlV2lkdGgsXHJcbiAgICAgICAgICAgIGdldExldmVsV2lkdGgsXHJcbiAgICAgICAgICAgIGdldFRpbGVXaWR0aCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHRpbGVIZWlnaHQgPSBnZXRUaWxlRGltZW5zaW9uU2l6ZShcclxuICAgICAgICAgICAgZWRnZVR5cGUudmVydGljYWxFZGdlVHlwZSxcclxuICAgICAgICAgICAgZ2V0Rmlyc3RUaWxlSGVpZ2h0LFxyXG4gICAgICAgICAgICBnZXRMZXZlbEhlaWdodCxcclxuICAgICAgICAgICAgZ2V0VGlsZUhlaWdodCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKG51bVJlc29sdXRpb25MZXZlbHNUb0N1dCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IDEgPDwgbnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0O1xyXG4gICAgICAgICAgICB0aWxlV2lkdGggPSBNYXRoLmNlaWwodGlsZVdpZHRoIC8gc2NhbGUpO1xyXG4gICAgICAgICAgICB0aWxlSGVpZ2h0ID0gTWF0aC5jZWlsKHRpbGVIZWlnaHQgLyBzY2FsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBbdGlsZVdpZHRoLCB0aWxlSGVpZ2h0XTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRUaWxlRGltZW5zaW9uU2l6ZShcclxuICAgICAgICBlZGdlVHlwZSwgZ2V0Rmlyc3RUaWxlU2l6ZSwgZ2V0TGV2ZWxTaXplLCBnZXROb25FZGdlVGlsZVNpemUpIHtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHN3aXRjaCAoZWRnZVR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBFREdFX1RZUEVfRklSU1Q6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBnZXRGaXJzdFRpbGVTaXplKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhc2UgRURHRV9UWVBFX0xBU1Q6XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9uRWRnZVRpbGVTaXplID0gZ2V0Tm9uRWRnZVRpbGVTaXplKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGhXaXRob3V0Rmlyc3QgPSBnZXRMZXZlbFNpemUoKSAtIGdldEZpcnN0VGlsZVNpemUoKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHdpZHRoV2l0aG91dEZpcnN0ICUgbm9uRWRnZVRpbGVTaXplO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbm9uRWRnZVRpbGVTaXplO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhc2UgRURHRV9UWVBFX05PX0VER0U6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBnZXROb25FZGdlVGlsZVNpemUoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbnRlcm5hbEVycm9yRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICdVbmV4cGVjdGVkIGVkZ2UgdHlwZTogJyArIGVkZ2VUeXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzRWRnZVRpbGVJZCh0aWxlSWQpIHtcclxuICAgICAgICB2YXIgbnVtVGlsZXNYID0gZ2V0TnVtVGlsZXNYKCk7XHJcbiAgICAgICAgdmFyIG51bVRpbGVzWSA9IGdldE51bVRpbGVzWSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciB0aWxlWCA9IHRpbGVJZCAlIG51bVRpbGVzWDtcclxuICAgICAgICB2YXIgdGlsZVkgPSBNYXRoLmZsb29yKHRpbGVJZCAvIG51bVRpbGVzWCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHRpbGVZID4gbnVtVGlsZXNZIHx8IHRpbGVYIDwgMCB8fCB0aWxlWSA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAnVGlsZSBpbmRleCAnICsgdGlsZUlkICsgJyBpcyBub3QgaW4gcmFuZ2UnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGhvcml6b250YWxFZGdlID1cclxuICAgICAgICAgICAgdGlsZVggPT09IDAgPyBFREdFX1RZUEVfRklSU1QgOlxyXG4gICAgICAgICAgICB0aWxlWCA9PT0gKG51bVRpbGVzWCAtIDEpID8gRURHRV9UWVBFX0xBU1QgOlxyXG4gICAgICAgICAgICBFREdFX1RZUEVfTk9fRURHRTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgdmVydGljYWxFZGdlID1cclxuICAgICAgICAgICAgdGlsZVkgPT09IDAgPyBFREdFX1RZUEVfRklSU1QgOlxyXG4gICAgICAgICAgICB0aWxlWSA9PT0gKG51bVRpbGVzWSAtIDEpID8gRURHRV9UWVBFX0xBU1QgOlxyXG4gICAgICAgICAgICBFREdFX1RZUEVfTk9fRURHRTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICBob3Jpem9udGFsRWRnZVR5cGU6IGhvcml6b250YWxFZGdlLFxyXG4gICAgICAgICAgICB2ZXJ0aWNhbEVkZ2VUeXBlOiB2ZXJ0aWNhbEVkZ2VcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldE51bVRpbGVzWCgpIHtcclxuICAgICAgICB2YXIgbnVtVGlsZXNYID0gTWF0aC5jZWlsKHBhcmFtcy5pbWFnZVdpZHRoIC8gcGFyYW1zLnRpbGVXaWR0aCk7XHJcbiAgICAgICAgcmV0dXJuIG51bVRpbGVzWDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gZ2V0TnVtVGlsZXNZKCkge1xyXG4gICAgICAgIHZhciBudW1UaWxlc1kgPSBNYXRoLmNlaWwocGFyYW1zLmltYWdlSGVpZ2h0IC8gcGFyYW1zLnRpbGVIZWlnaHQpO1xyXG4gICAgICAgIHJldHVybiBudW1UaWxlc1k7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGdldExldmVsV2lkdGgobnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0KSB7XHJcbiAgICAgICAgaWYgKG51bVJlc29sdXRpb25MZXZlbHNUb0N1dCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXMuaW1hZ2VXaWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHNpemUgPSBnZXRTaXplT2ZQYXJ0KHtcclxuICAgICAgICAgICAgbWluWDogMCxcclxuICAgICAgICAgICAgbWF4WEV4Y2x1c2l2ZTogcGFyYW1zLmltYWdlV2lkdGgsXHJcbiAgICAgICAgICAgIG1pblk6IDAsXHJcbiAgICAgICAgICAgIG1heFlFeGNsdXNpdmU6IHBhcmFtcy5pbWFnZUhlaWdodCxcclxuICAgICAgICAgICAgbnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0OiBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHNpemUud2lkdGg7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGdldExldmVsSGVpZ2h0KG51bVJlc29sdXRpb25MZXZlbHNUb0N1dCkge1xyXG4gICAgICAgIGlmIChudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLmltYWdlSGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgc2l6ZSA9IGdldFNpemVPZlBhcnQoe1xyXG4gICAgICAgICAgICBtaW5YOiAwLFxyXG4gICAgICAgICAgICBtYXhYRXhjbHVzaXZlOiBwYXJhbXMuaW1hZ2VXaWR0aCxcclxuICAgICAgICAgICAgbWluWTogMCxcclxuICAgICAgICAgICAgbWF4WUV4Y2x1c2l2ZTogcGFyYW1zLmltYWdlSGVpZ2h0LFxyXG4gICAgICAgICAgICBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQ6IG51bVJlc29sdXRpb25MZXZlbHNUb0N1dFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gc2l6ZS5oZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0VGlsZVdpZHRoKG51bVJlc29sdXRpb25MZXZlbHNUb0N1dCkge1xyXG4gICAgICAgIGlmIChudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLnRpbGVXaWR0aDtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICB2YXIgc2NhbGUgPSAxIDw8IG51bVJlc29sdXRpb25MZXZlbHNUb0N1dDtcclxuICAgICAgICB2YXIgd2lkdGggPSBNYXRoLmNlaWwocGFyYW1zLnRpbGVXaWR0aCAvIHNjYWxlKTtcclxuICAgICAgICByZXR1cm4gd2lkdGg7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGdldFRpbGVIZWlnaHQobnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0KSB7XHJcbiAgICAgICAgaWYgKG51bVJlc29sdXRpb25MZXZlbHNUb0N1dCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXMudGlsZUhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICB2YXIgc2NhbGUgPSAxIDw8IG51bVJlc29sdXRpb25MZXZlbHNUb0N1dDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5jZWlsKHBhcmFtcy50aWxlSGVpZ2h0IC8gc2NhbGUpO1xyXG4gICAgICAgIHJldHVybiBoZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGdldEZpcnN0VGlsZU9mZnNldFgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5maXJzdFRpbGVPZmZzZXRYO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBnZXRGaXJzdFRpbGVPZmZzZXRZKCkge1xyXG4gICAgICAgIHJldHVybiBwYXJhbXMuZmlyc3RUaWxlT2Zmc2V0WTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRGaXJzdFRpbGVXaWR0aChudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQpIHtcclxuICAgICAgICB2YXIgZmlyc3RUaWxlV2lkdGhCZXN0TGV2ZWwgPVxyXG4gICAgICAgICAgICBnZXRUaWxlV2lkdGgoKSAtIGdldEZpcnN0VGlsZU9mZnNldFgoKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgaW1hZ2VXaWR0aCA9IGdldExldmVsV2lkdGgoKTtcclxuICAgICAgICBpZiAoZmlyc3RUaWxlV2lkdGhCZXN0TGV2ZWwgPiBpbWFnZVdpZHRoKSB7XHJcbiAgICAgICAgICAgIGZpcnN0VGlsZVdpZHRoQmVzdExldmVsID0gaW1hZ2VXaWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHNjYWxlID0gMSA8PCBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQ7XHJcbiAgICAgICAgdmFyIGZpcnN0VGlsZVdpZHRoID0gTWF0aC5jZWlsKGZpcnN0VGlsZVdpZHRoQmVzdExldmVsIC8gc2NhbGUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBmaXJzdFRpbGVXaWR0aDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gZ2V0Rmlyc3RUaWxlSGVpZ2h0KG51bVJlc29sdXRpb25MZXZlbHNUb0N1dCkge1xyXG4gICAgICAgIHZhciBmaXJzdFRpbGVIZWlnaHRCZXN0TGV2ZWwgPVxyXG4gICAgICAgICAgICBnZXRUaWxlSGVpZ2h0KCkgLSBnZXRGaXJzdFRpbGVPZmZzZXRZKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGltYWdlSGVpZ2h0ID0gZ2V0TGV2ZWxIZWlnaHQoKTtcclxuICAgICAgICBpZiAoZmlyc3RUaWxlSGVpZ2h0QmVzdExldmVsID4gaW1hZ2VIZWlnaHQpIHtcclxuICAgICAgICAgICAgZmlyc3RUaWxlSGVpZ2h0QmVzdExldmVsID0gaW1hZ2VIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBzY2FsZSA9IDEgPDwgbnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0O1xyXG4gICAgICAgIHZhciBmaXJzdFRpbGVIZWlnaHQgPSBNYXRoLmNlaWwoZmlyc3RUaWxlSGVpZ2h0QmVzdExldmVsIC8gc2NhbGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gZmlyc3RUaWxlSGVpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBqR2xvYmFscyA9IHJlcXVpcmUoJ2oyay1qcGlwLWdsb2JhbHMuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLkpwaXBSZXF1ZXN0Q29udGV4dCA9IChmdW5jdGlvbiBKcGlwUmVxdWVzdENvbnRleHQoKSB7XHJcbiAgICB2YXIgU1RBVFVTX0FDVElWRSA9IDE7XHJcbiAgICB2YXIgU1RBVFVTX1dBSVRJTkdfRk9SX1VTRVJfSU5QVVQgPSAyO1xyXG4gICAgdmFyIFNUQVRVU19QQVVTRUQgPSAzO1xyXG4gICAgdmFyIFNUQVRVU19FTkRFRCA9IDQ7XHJcbiAgICBcclxuICAgIHZhciBTVEFUVVNfWk9NQklFX09GX01PVkFCTEVfUkVRVUVTVCA9IDU7XHJcbiAgICBcclxuICAgIHZhciByZXF1ZXN0SWRDb3VudGVyID0gMDtcclxuICAgIHZhciBzaG93TG9ncyA9IGZhbHNlO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBKcGlwUmVxdWVzdENvbnRleHQoXHJcbiAgICAgICAganBpcE9iamVjdHMsIGNvZGVzdHJlYW1QYXJ0UGFyYW1zLCBjYWxsYmFjaywgcHJvZ3Jlc3NpdmVuZXNzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGRpc2FibGVTZXJ2ZXJSZXF1ZXN0cyA9IG9wdGlvbnMuZGlzYWJsZVNlcnZlclJlcXVlc3RzO1xyXG4gICAgICAgIHZhciBpc01vdmFibGUgPSBvcHRpb25zLmlzTW92YWJsZTtcclxuICAgICAgICB2YXIgdXNlckNvbnRleHRWYXJzID0gb3B0aW9ucy51c2VyQ29udGV4dFZhcnM7XHJcbiAgICAgICAgdmFyIGZhaWx1cmVDYWxsYmFjayA9IG9wdGlvbnMuZmFpbHVyZUNhbGxiYWNrO1xyXG4gICAgICAgIHZhciBsYXN0U2VydmVyUmVxdWVzdCA9IG51bGw7XHJcbiAgICAgICAgdmFyIHN0YXR1c1doZW5GaW5pc2hlZCA9IGlzTW92YWJsZSA/XHJcbiAgICAgICAgICAgIFNUQVRVU19aT01CSUVfT0ZfTU9WQUJMRV9SRVFVRVNUOiBTVEFUVVNfV0FJVElOR19GT1JfVVNFUl9JTlBVVDtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgcmVxdWVzdGVyID0ganBpcE9iamVjdHMucmVxdWVzdGVyO1xyXG4gICAgICAgIHZhciByZWNvbnN0cnVjdG9yID0ganBpcE9iamVjdHMucmVjb25zdHJ1Y3RvcjtcclxuICAgICAgICB2YXIgcGFja2V0c0RhdGFDb2xsZWN0b3IgPSBqcGlwT2JqZWN0cy5wYWNrZXRzRGF0YUNvbGxlY3RvcjtcclxuICAgICAgICB2YXIgcXVhbGl0eUxheWVyc0NhY2hlID0ganBpcE9iamVjdHMucXVhbGl0eUxheWVyc0NhY2hlO1xyXG4gICAgICAgIHZhciBjb2Rlc3RyZWFtU3RydWN0dXJlID0ganBpcE9iamVjdHMuY29kZXN0cmVhbVN0cnVjdHVyZTtcclxuICAgICAgICB2YXIgZGF0YWJpbnNTYXZlciA9IGpwaXBPYmplY3RzLmRhdGFiaW5zU2F2ZXI7XHJcbiAgICAgICAgdmFyIGpwaXBGYWN0b3J5ID0ganBpcE9iamVjdHMuanBpcEZhY3Rvcnk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gbnVsbDtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb2dyZXNzaXZlU3RhZ2VzRmluaXNoZWQgPSAwO1xyXG4gICAgICAgIHZhciBhbHJlYWR5UmV0dXJuZWRDb2RlYmxvY2tzID0gbnVsbDtcclxuICAgICAgICB2YXIgcXVhbGl0eUxheWVyc1JlYWNoZWQgPSAwO1xyXG5cclxuICAgICAgICB2YXIgc3RhdHVzID0gZ2V0SW5pdGlhbFN0YXR1cyhjb2Rlc3RyZWFtUGFydFBhcmFtcywgaXNNb3ZhYmxlKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgaXNGYWlsdXJlID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGlzV2FpdGluZ0ZvclF1YWxpdHlMYXllciA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBpc1dhaXRpbmdGb3JTZXJ2ZXIgPSBmYWxzZTtcclxuICAgICAgICB2YXIgaXNSZXF1ZXN0RG9uZSA9IGZhbHNlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBkZWRpY2F0ZWRDaGFubmVsSGFuZGxlID0gb3B0aW9ucy5kZWRpY2F0ZWRDaGFubmVsSGFuZGxlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciByZXF1ZXN0SWQgPSArK3JlcXVlc3RJZENvdW50ZXI7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5nZXRSZXF1ZXN0SWQgPSBmdW5jdGlvbiBnZXRSZXF1ZXN0SWQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0SWQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmNyZWF0ZU1vdmVkUmVxdWVzdCA9IGZ1bmN0aW9uIG1vdmUoXHJcbiAgICAgICAgICAgIG5ld0NvZGVzdHJlYW1QYXJ0UGFyYW1zLCBuZXdQcm9ncmVzc2l2ZW5lc3MpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFRPRE86IE1vdmUgbG9naWMgb2YgY2FzdGluZyBwcm9ncmVzc2l2ZW5lc3MgZnJvbSB0aGVcclxuICAgICAgICAgICAgLy8gY29kZXN0cmVhbUNsaWVudCB0byBoZXJlXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoIWlzTW92YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkludmFsaWRPcGVyYXRpb25FeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgJ2NyZWF0ZU1vdmVkUmVxdWVzdCgpIGlzIHN1cHBvcnRlZCBvbmx5IGZvciBtb3ZhYmxlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdyZXF1ZXN0cy4gQ3JlYXRlIHRoZSByZXF1ZXN0IHdpdGggb3B0aW9ucy5pc01vdmFibGUgPSB0cnVlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGVuc3VyZU5vRmFpbHVyZSgpO1xyXG5cclxuICAgICAgICAgICAgdXBkYXRlU3RhdHVzKFNUQVRVU19FTkRFRCwgJ2NyZWF0ZU1vdmVkUmVxdWVzdCgpJyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVkaWNhdGVkQ2hhbm5lbEhhbmRsZSA9PT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgICAgICBkZWRpY2F0ZWRDaGFubmVsSGFuZGxlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVkT3B0aW9ucy5kZWRpY2F0ZWRDaGFubmVsSGFuZGxlID0gZGVkaWNhdGVkQ2hhbm5lbEhhbmRsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHJlcXVlc3RDb250ZXh0ID0gbmV3IEpwaXBSZXF1ZXN0Q29udGV4dChcclxuICAgICAgICAgICAgICAgIGpwaXBPYmplY3RzLFxyXG4gICAgICAgICAgICAgICAgbmV3Q29kZXN0cmVhbVBhcnRQYXJhbXMgfHwgY29kZXN0cmVhbVBhcnRQYXJhbXMsXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcclxuICAgICAgICAgICAgICAgIG5ld1Byb2dyZXNzaXZlbmVzcyB8fCBwcm9ncmVzc2l2ZW5lc3MsXHJcbiAgICAgICAgICAgICAgICBtb2RpZmllZE9wdGlvbnMpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RDb250ZXh0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5pZ25vcmVQcmV2aW91c0ZhaWx1cmUgPSBmdW5jdGlvbiBpZ25vcmVQcmV2aW91c0ZhaWx1cmUoKSB7XHJcbiAgICAgICAgICAgIGlzRmFpbHVyZSA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5jcmVhdGVDb2Rlc3RyZWFtID0gZnVuY3Rpb24gY3JlYXRlQ29kZXN0cmVhbShcclxuICAgICAgICAgICAgaXNPbmx5SGVhZGVyc1dpdGhvdXRCaXRzdHJlYW0sIG1heE51bVF1YWxpdHlMYXllcnMpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGVuc3VyZU5vRmFpbHVyZSgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IGdldFBhcmFtc0ZvckRhdGFXcml0ZXIobWF4TnVtUXVhbGl0eUxheWVycyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgY29kZXN0cmVhbSA9IHJlY29uc3RydWN0b3IuY3JlYXRlQ29kZXN0cmVhbUZvclJlZ2lvbihcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5jb2Rlc3RyZWFtUGFydFBhcmFtcyxcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5taW5OdW1RdWFsaXR5TGF5ZXJzLFxyXG4gICAgICAgICAgICAgICAgaXNPbmx5SGVhZGVyc1dpdGhvdXRCaXRzdHJlYW0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGNvZGVzdHJlYW0gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbnRlcm5hbEVycm9yRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICdDb3VsZCBub3QgcmVjb25zdHJ1Y3QgY29kZXN0cmVhbSBhbHRob3VnaCAnICtcclxuICAgICAgICAgICAgICAgICAgICAncHJvZ3Jlc3NpdmVuZXNzIHN0YWdlIGhhcyBiZWVuIHJlYWNoZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIGNvZGVzdHJlYW07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmdldE5ld0NvZGVibG9ja3NEYXRhID0gZnVuY3Rpb24gZ2V0TmV3Q29kZWJsb2Nrc0RhdGEoXHJcbiAgICAgICAgICAgIG1heE51bVF1YWxpdHlMYXllcnMpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGVuc3VyZU5vRmFpbHVyZSgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFscmVhZHlSZXR1cm5lZENvZGVibG9ja3MgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBnZXRBbGxDb2RlYmxvY2tzRGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IGdldFBhcmFtc0ZvckRhdGFXcml0ZXIobWF4TnVtUXVhbGl0eUxheWVycyk7XHJcbiAgICAgICAgICAgIHZhciBjb2RlYmxvY2tzRGF0YSA9IHBhY2tldHNEYXRhQ29sbGVjdG9yXHJcbiAgICAgICAgICAgICAgICAuZ2V0TmV3Q29kZWJsb2Nrc0RhdGFBbmRVcGRhdGVSZXR1cm5lZENvZGVibG9ja3MoXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNvZGVzdHJlYW1QYXJ0UGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5taW5OdW1RdWFsaXR5TGF5ZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIGFscmVhZHlSZXR1cm5lZENvZGVibG9ja3MpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGNvZGVibG9ja3NEYXRhID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAnQ291bGQgbm90IGNvbGxlY3QgY29kZWJsb2NrcyBhbHRob3VnaCBwcm9ncmVzc2l2ZW5lc3MgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3N0YWdlIGhhcyBiZWVuIHJlYWNoZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIGNvZGVibG9ja3NEYXRhO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5lbmRBc3luYyA9IGZ1bmN0aW9uIGVuZEFzeW5jKCkge1xyXG4gICAgICAgICAgICBpZiAoaXNNb3ZhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW52YWxpZE9wZXJhdGlvbkV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAnZW5kQXN5bmMoKSBpcyBub3Qgc3VwcG9ydGVkIGZvciBtb3ZhYmxlIHJlcXVlc3RzJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGVuc3VyZU5vRmFpbHVyZSgpO1xyXG4gICAgICAgICAgICBlbnN1cmVOb3RFbmRlZChzdGF0dXMpO1xyXG4gICAgICAgICAgICB1cGRhdGVTdGF0dXMoU1RBVFVTX0VOREVELCAnZW5kQXN5bmMoKScpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gTk9URTogVGhpcyB3aWxsIGJlIHVzZWQgd2hlbiByZWNvbm5lY3QgaXMgaW1wbGVtZW50ZWQsIHRvIG5vdGVcclxuICAgICAgICAgICAgLy8gdGhhdCB0aGUgZGF0YSByZWxhdGVkIHRvIHRoaXMgcmVxdWVzdCB0aGF0IGhhZCBiZWVuIGFscmVhZHlcclxuICAgICAgICAgICAgLy8gcmVjaWV2ZWQgaXMgbm90IG5lZWRlZCB0byBiZSBjb3BpZWQgdG8gdGhlIG5ldyBjbGllbnRcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMucGF1c2VBc3luYyA9IGZ1bmN0aW9uIHBhdXNlQXN5bmMoKSB7XHJcbiAgICAgICAgICAgIGVuc3VyZU5vRmFpbHVyZSgpO1xyXG4gICAgICAgICAgICBlbnN1cmVOb3RFbmRlZChzdGF0dXMpO1xyXG4gICAgICAgICAgICB1cGRhdGVTdGF0dXMoU1RBVFVTX1BBVVNFRCwgJ3BhdXNlQXN5bmMoKScpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5oYXNEYXRhID0gZnVuY3Rpb24gaGFzRGF0YSgpIHtcclxuICAgICAgICAgICAgZW5zdXJlTm9GYWlsdXJlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9ncmVzc2l2ZVN0YWdlc0ZpbmlzaGVkID4gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuZ2V0QWxsQ29kZWJsb2Nrc0RhdGEgPSBnZXRBbGxDb2RlYmxvY2tzRGF0YTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnRyeUNvbnRpbnVlUmVxdWVzdCA9IHRyeUNvbnRpbnVlUmVxdWVzdDtcclxuICAgICAgICBcclxuICAgICAgICBmdW5jdGlvbiBnZXRBbGxDb2RlYmxvY2tzRGF0YShtYXhOdW1RdWFsaXR5TGF5ZXJzKSB7XHJcbiAgICAgICAgICAgIGVuc3VyZU5vRmFpbHVyZSgpO1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gZ2V0UGFyYW1zRm9yRGF0YVdyaXRlcihtYXhOdW1RdWFsaXR5TGF5ZXJzKTtcclxuICAgICAgICAgICAgdmFyIGNvZGVibG9ja3MgPSBwYWNrZXRzRGF0YUNvbGxlY3Rvci5nZXRBbGxDb2RlYmxvY2tzRGF0YShcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5jb2Rlc3RyZWFtUGFydFBhcmFtcyxcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5taW5OdW1RdWFsaXR5TGF5ZXJzKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChjb2RlYmxvY2tzLmNvZGVibG9ja3NEYXRhID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAnQ291bGQgbm90IGNvbGxlY3QgY29kZWJsb2NrcyBhbHRob3VnaCBwcm9ncmVzc2l2ZW5lc3MgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3N0YWdlIGhhcyBiZWVuIHJlYWNoZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgYWxyZWFkeVJldHVybmVkQ29kZWJsb2NrcyA9IGNvZGVibG9ja3MuYWxyZWFkeVJldHVybmVkQ29kZWJsb2NrcztcclxuICAgICAgICAgICAgcmV0dXJuIGNvZGVibG9ja3MuY29kZWJsb2Nrc0RhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZ1bmN0aW9uIHRyeUNvbnRpbnVlUmVxdWVzdCgpIHtcclxuICAgICAgICAgICAgZW5zdXJlTm9GYWlsdXJlKCk7XHJcbiAgICAgICAgICAgIGVuc3VyZU5vdEVuZGVkKHN0YXR1cyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAobGlzdGVuZXIgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0ganBpcEZhY3RvcnkuY3JlYXRlUmVxdWVzdERhdGFiaW5zTGlzdGVuZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgY29kZXN0cmVhbVBhcnRQYXJhbXMsXHJcbiAgICAgICAgICAgICAgICAgICAgcXVhbGl0eUxheWVyUmVhY2hlZENhbGxiYWNrLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVzdHJlYW1TdHJ1Y3R1cmUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YWJpbnNTYXZlcixcclxuICAgICAgICAgICAgICAgICAgICBxdWFsaXR5TGF5ZXJzQ2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB0cnlBZHZhbmNlUHJvZ3Jlc3NpdmVTdGFnZSgpO1xyXG4gICAgICAgICAgICAgICAgaXNSZXF1ZXN0RG9uZSA9IHByb2dyZXNzaXZlU3RhZ2VzRmluaXNoZWQgPT09IHByb2dyZXNzaXZlbmVzcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChpc1dhaXRpbmdGb3JTZXJ2ZXIpIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZVN0YXR1cyhcclxuICAgICAgICAgICAgICAgICAgICBTVEFUVVNfQUNUSVZFLCAndHJ5Q29udGludWVSZXF1ZXN0KCk6IGlzV2FpdGluZ0ZvclNlcnZlcicpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXF1ZXN0RG9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbnRlcm5hbEVycm9yRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnSW5jb25zaXN0ZW50IHN0YXRlOiBpc1dhaXRpbmdGb3JTZXJ2ZXI9dHJ1ZSwgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICduZWVkTW9yZVJlcXVlc3RzPWZhbHNlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHJldHVybiAhaXNSZXF1ZXN0RG9uZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGlzUmVxdWVzdERvbmUpIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZVN0YXR1cyhcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNXaGVuRmluaXNoZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgJ3RyeUNvbnRpbnVlUmVxdWVzdCgpOiAhbmVlZE1vcmVSZXF1ZXN0cycpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiAhaXNSZXF1ZXN0RG9uZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaXNXYWl0aW5nRm9yUXVhbGl0eUxheWVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBuZXdTdGF0dXMgPSBpc1JlcXVlc3REb25lID8gc3RhdHVzV2hlbkZpbmlzaGVkIDogU1RBVFVTX0FDVElWRTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHVwZGF0ZVN0YXR1cyhuZXdTdGF0dXMsICd0cnlDb250aW51ZVJlcXVlc3QoKTogZW5kIGZ1bmN0aW9uJyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoaXNXYWl0aW5nRm9yU2VydmVyIHx8IGRpc2FibGVTZXJ2ZXJSZXF1ZXN0cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICFpc1JlcXVlc3REb25lO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBzdGlsbCB3YWl0aW5nIGZvciBxdWFsaXR5IGxheWVyIGJ1dCBubyByZXF1ZXN0IHRvIHNlcnZlclxyXG4gICAgICAgICAgICAvLyBoYXMgYmVlbiBkb25lLCB0aGVuIHJlcXVlc3QgZGF0YSBmcm9tIHNlcnZlclxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGxhc3RTZXJ2ZXJSZXF1ZXN0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0ZXIuc3RvcFJlcXVlc3RBc3luYyhsYXN0U2VydmVyUmVxdWVzdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpc1dhaXRpbmdGb3JTZXJ2ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgbnVtUXVhbGl0eUxheWVyc1RvV2FpdCA9XHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzc2l2ZW5lc3NbcHJvZ3Jlc3NpdmVTdGFnZXNGaW5pc2hlZF0ubWluTnVtUXVhbGl0eUxheWVycztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChpc01vdmFibGUgJiYgZGVkaWNhdGVkQ2hhbm5lbEhhbmRsZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBkZWRpY2F0ZWRDaGFubmVsSGFuZGxlID1cclxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZXIuZGVkaWNhdGVDaGFubmVsRm9yTW92YWJsZVJlcXVlc3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbGFzdFNlcnZlclJlcXVlc3QgPSByZXF1ZXN0ZXIucmVxdWVzdERhdGEoXHJcbiAgICAgICAgICAgICAgICBjb2Rlc3RyZWFtUGFydFBhcmFtcyxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RlckNhbGxiYWNrT25BbGxEYXRhUmVjaWV2ZWQsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0ZXJDYWxsYmFja09uRmFpbHVyZSxcclxuICAgICAgICAgICAgICAgIG51bVF1YWxpdHlMYXllcnNUb1dhaXQsXHJcbiAgICAgICAgICAgICAgICBkZWRpY2F0ZWRDaGFubmVsSGFuZGxlKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAhaXNSZXF1ZXN0RG9uZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgZnVuY3Rpb24gcmVxdWVzdGVyQ2FsbGJhY2tPbkFsbERhdGFSZWNpZXZlZChyZXF1ZXN0LCBpc1Jlc3BvbnNlRG9uZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNSZXNwb25zZURvbmUgJiYgcmVxdWVzdCA9PT0gbGFzdFNlcnZlclJlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbGxlZ2FsRGF0YUV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAnSlBJUCBzZXJ2ZXIgbm90IHJldHVybmVkIGFsbCBkYXRhJywgJ0QuMycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZ1bmN0aW9uIHJlcXVlc3RlckNhbGxiYWNrT25GYWlsdXJlKCkge1xyXG4gICAgICAgICAgICB1cGRhdGVTdGF0dXMoU1RBVFVTX0VOREVELCAnZW5kQXN5bmMoKScpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGZhaWx1cmVDYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBmYWlsdXJlQ2FsbGJhY2soc2VsZiwgdXNlckNvbnRleHRWYXJzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlzRmFpbHVyZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgZnVuY3Rpb24gcXVhbGl0eUxheWVyUmVhY2hlZENhbGxiYWNrKHF1YWxpdHlMYXllcnNSZWFjaGVkXykge1xyXG4gICAgICAgICAgICBxdWFsaXR5TGF5ZXJzUmVhY2hlZCA9IHF1YWxpdHlMYXllcnNSZWFjaGVkXztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IFNUQVRVU19FTkRFRCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNwZXRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgJ0NhbGxiYWNrIGZyb20gcmVxdWVzdERhdGFiaW5zTGlzdGVuZXIgYWZ0ZXIgcmVxdWVzdCBlbmRlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoIWlzV2FpdGluZ0ZvclF1YWxpdHlMYXllciAvKiAmJiAhZGlzYWJsZVNlcnZlclJlcXVlc3RzICovKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICh0cnlBZHZhbmNlUHJvZ3Jlc3NpdmVTdGFnZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBpc1dhaXRpbmdGb3JRdWFsaXR5TGF5ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlzV2FpdGluZ0ZvclNlcnZlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB1cGRhdGVTdGF0dXMoXHJcbiAgICAgICAgICAgICAgICBTVEFUVVNfV0FJVElOR19GT1JfVVNFUl9JTlBVVCwgJ3F1YWxpdHlMYXllclJlYWNoZWRDYWxsYmFjaycpO1xyXG5cclxuICAgICAgICAgICAgLy8gRG8gbm90IGNhbGwgY2FsbGJhY2sgZnJvbSB3aXRoaW4gdHJ5Q29udGludWVSZXF1ZXN0KCkgY2FsbGVkXHJcbiAgICAgICAgICAgIC8vIGJ5IHRoZSB1c2VyOiBhdm9pZCByZWN1cnNpdmUgY2FsbHMsIGhlIGNhbiBwZXJmb3JtIGhpcyBvcGVyYXRpb25zXHJcbiAgICAgICAgICAgIC8vIGFmdGVyIHRyeUNvbnRpbnVlUmVxdWVzdCgpIHJldHVybnNcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChpc1JlcXVlc3REb25lKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAnUmVxdWVzdCBhbHJlYWR5IGRvbmUgYnV0IGNhbGxiYWNrIGlzIGNhbGxlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpc1JlcXVlc3REb25lID0gcHJvZ3Jlc3NpdmVTdGFnZXNGaW5pc2hlZCA9PT0gcHJvZ3Jlc3NpdmVuZXNzLmxlbmd0aDtcclxuICAgICAgICAgICAgY2FsbGJhY2soc2VsZiwgdXNlckNvbnRleHRWYXJzLCBpc1JlcXVlc3REb25lKTtcclxuXHJcbiAgICAgICAgICAgIGVuc3VyZU5vdFdhaXRpbmdGb3JVc2VySW5wdXQoc3RhdHVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgZnVuY3Rpb24gdHJ5QWR2YW5jZVByb2dyZXNzaXZlU3RhZ2UoKSB7XHJcbiAgICAgICAgICAgIHZhciBudW1RdWFsaXR5TGF5ZXJzVG9XYWl0ID1cclxuICAgICAgICAgICAgICAgIHByb2dyZXNzaXZlbmVzc1twcm9ncmVzc2l2ZVN0YWdlc0ZpbmlzaGVkXS5taW5OdW1RdWFsaXR5TGF5ZXJzO1xyXG5cclxuICAgICAgICAgICAgaWYgKHF1YWxpdHlMYXllcnNSZWFjaGVkIDwgbnVtUXVhbGl0eUxheWVyc1RvV2FpdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAocXVhbGl0eUxheWVyc1JlYWNoZWQgPT09ICdtYXgnKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzc2l2ZVN0YWdlc0ZpbmlzaGVkID0gcHJvZ3Jlc3NpdmVuZXNzLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgd2hpbGUgKHByb2dyZXNzaXZlU3RhZ2VzRmluaXNoZWQgPCBwcm9ncmVzc2l2ZW5lc3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcXVhbGl0eUxheWVyc1JlcXVpcmVkID1cclxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc2l2ZW5lc3NbcHJvZ3Jlc3NpdmVTdGFnZXNGaW5pc2hlZF0ubWluTnVtUXVhbGl0eUxheWVycztcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKHF1YWxpdHlMYXllcnNSZXF1aXJlZCA9PT0gJ21heCcgfHxcclxuICAgICAgICAgICAgICAgICAgICBxdWFsaXR5TGF5ZXJzUmVxdWlyZWQgPiBxdWFsaXR5TGF5ZXJzUmVhY2hlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICArK3Byb2dyZXNzaXZlU3RhZ2VzRmluaXNoZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBmdW5jdGlvbiBnZXRQYXJhbXNGb3JEYXRhV3JpdGVyKG1heE51bVF1YWxpdHlMYXllcnMpIHtcclxuICAgICAgICAgICAgZW5zdXJlTm90RW5kZWQoc3RhdHVzLCAvKmFsbG93Wm9tYmllPSovdHJ1ZSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoY29kZXN0cmVhbVBhcnRQYXJhbXMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbnZhbGlkT3BlcmF0aW9uRXhjZXB0aW9uKCdDYW5ub3QgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2dldCBkYXRhIG9mIHpvbWJpZSByZXF1ZXN0IHdpdGggbm8gY29kZXN0cmVhbVBhcnRQYXJhbXMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGlzUmVxdWVzdERvbmUgPSBwcm9ncmVzc2l2ZVN0YWdlc0ZpbmlzaGVkID09PSBwcm9ncmVzc2l2ZW5lc3MubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoIWlzUmVxdWVzdERvbmUpIHtcclxuICAgICAgICAgICAgICAgIGVuc3VyZU5vdFdhaXRpbmdGb3JVc2VySW5wdXQoc3RhdHVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHByb2dyZXNzaXZlU3RhZ2VzRmluaXNoZWQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbGxlZ2FsT3BlcmF0aW9uRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICdDYW5ub3QgY3JlYXRlIGNvZGVzdHJlYW0gYmVmb3JlIGZpcnN0IHByb2dyZXNzaXZlbmVzcyAnICtcclxuICAgICAgICAgICAgICAgICAgICAnc3RhZ2UgaGFzIGJlZW4gcmVhY2hlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgbWluTnVtUXVhbGl0eUxheWVycyA9XHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzc2l2ZW5lc3NbcHJvZ3Jlc3NpdmVTdGFnZXNGaW5pc2hlZCAtIDFdLm1pbk51bVF1YWxpdHlMYXllcnM7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgbmV3UGFyYW1zID0gY29kZXN0cmVhbVBhcnRQYXJhbXM7XHJcbiAgICAgICAgICAgIGlmIChtYXhOdW1RdWFsaXR5TGF5ZXJzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIG5ld1BhcmFtcyA9IE9iamVjdC5jcmVhdGUoY29kZXN0cmVhbVBhcnRQYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgbmV3UGFyYW1zLm1heE51bVF1YWxpdHlMYXllcnMgPSBtYXhOdW1RdWFsaXR5TGF5ZXJzO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAobWluTnVtUXVhbGl0eUxheWVycyAhPT0gJ21heCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5OdW1RdWFsaXR5TGF5ZXJzID0gTWF0aC5taW4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbk51bVF1YWxpdHlMYXllcnMsIG1heE51bVF1YWxpdHlMYXllcnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgY29kZXN0cmVhbVBhcnRQYXJhbXM6IG5ld1BhcmFtcyxcclxuICAgICAgICAgICAgICAgIG1pbk51bVF1YWxpdHlMYXllcnM6IG1pbk51bVF1YWxpdHlMYXllcnNcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVN0YXR1cyhuZXdTdGF0dXMsIGxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmIChzaG93TG9ncykge1xyXG4gICAgICAgICAgICAgICAgLyogZ2xvYmFsIGNvbnNvbGU6IGZhbHNlICovXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVxdWVzdCAnICsgcmVxdWVzdElkICsgJyBzdGF0dXMgY2hhbmdlZDogJyArXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzICsgJyAtPiAnICsgbmV3U3RhdHVzICsgJyAoJyArIGxvY2F0aW9uICsgJyknKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyICE9PSBudWxsICYmIG5ld1N0YXR1cyA9PT0gU1RBVFVTX0VOREVEKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci51bnJlZ2lzdGVyKCk7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN0YXR1cyA9IG5ld1N0YXR1cztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChuZXdTdGF0dXMgIT09IFNUQVRVU19QQVVTRUQgJiYgbmV3U3RhdHVzICE9PSBTVEFUVVNfRU5ERUQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGxhc3RTZXJ2ZXJSZXF1ZXN0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0ZXIuc3RvcFJlcXVlc3RBc3luYyhsYXN0U2VydmVyUmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICBsYXN0U2VydmVyUmVxdWVzdCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGVuc3VyZU5vRmFpbHVyZSgpIHtcclxuICAgICAgICAgICAgaWYgKGlzRmFpbHVyZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxlIHByZXZpb3VzIHJlcXVlc3QgZnJvbSBzZXJ2ZXIuICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdVc2UgaWdub3JlUHJldmlvdXNGYWlsdXJlKCkgdG8gaWdub3JlIGFuZCBjb250aW51ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBlbnN1cmVOb3RFbmRlZChzdGF0dXMsIGFsbG93Wm9tYmllKSB7XHJcbiAgICAgICAgdmFyIG5vdEVuZGVkRGVzY3JpcHRpb24gPVxyXG4gICAgICAgICAgICAnQ2Fubm90IHBlcmZvcm0gdGhpcyBvcGVyYXRpb24gYWZ0ZXIgcmVxdWVzdCBlbmRlZCc7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZW5zdXJlTm9TdGF0dXMoc3RhdHVzLCBTVEFUVVNfRU5ERUQsIG5vdEVuZGVkRGVzY3JpcHRpb24pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChhbGxvd1pvbWJpZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBub1pvbWJpZURlc2NyaXB0aW9uID1cclxuICAgICAgICAgICAgJ0Nhbm5vdCBwZXJmb3JtIHRoaXMgb3BlcmF0aW9uIG9uIHpvbWJpZSByZXF1ZXN0ICg9IHJlcXVlc3Qgd2l0aCAnICtcclxuICAgICAgICAgICAgJ2NvZGVzdHJlYW1QYXJ0UGFyYW1zID0gbnVsbCwgdXNlZCBhcyB0aGUgZmlyc3QgcmVxdWVzdCBvZiAnICtcclxuICAgICAgICAgICAgJ21vdmFibGUgcmVxdWVzdCc7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZW5zdXJlTm9TdGF0dXMoXHJcbiAgICAgICAgICAgIHN0YXR1cyxcclxuICAgICAgICAgICAgU1RBVFVTX1pPTUJJRV9PRl9NT1ZBQkxFX1JFUVVFU1QsXHJcbiAgICAgICAgICAgIG5vWm9tYmllRGVzY3JpcHRpb24pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBlbnN1cmVOb3RXYWl0aW5nRm9yVXNlcklucHV0KHN0YXR1cykge1xyXG4gICAgICAgIHZhciBkZXNjcmlwdGlvbiA9XHJcbiAgICAgICAgICAgICdDYWxsIGZvciBlbmRBc3luYygpLCBwYXVzZUFzeW5jKCkgb3IgdHJ5Q29udGludWVSZXF1ZXN0KCkgaGFzICcgK1xyXG4gICAgICAgICAgICAgICAgJ25vdCBiZWVuIHBlcmZvcm1lZCc7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICBlbnN1cmVOb1N0YXR1cyhzdGF0dXMsIFNUQVRVU19XQUlUSU5HX0ZPUl9VU0VSX0lOUFVULCBkZXNjcmlwdGlvbik7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGVuc3VyZU5vU3RhdHVzKHN0YXR1cywgdW5leHBlY3RlZFN0YXR1cywgZXhjZXB0aW9uRGVzY3JpcHRpb24pIHtcclxuICAgICAgICBpZiAoc3RhdHVzID09PSB1bmV4cGVjdGVkU3RhdHVzKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbGxlZ2FsT3BlcmF0aW9uRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgZXhjZXB0aW9uRGVzY3JpcHRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXR1cyhjb2Rlc3RyZWFtUGFydFBhcmFtcywgaXNNb3ZhYmxlKSB7XHJcbiAgICAgICAgaWYgKGNvZGVzdHJlYW1QYXJ0UGFyYW1zICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTVEFUVVNfUEFVU0VEO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb3ZhYmxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTVEFUVVNfWk9NQklFX09GX01PVkFCTEVfUkVRVUVTVDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkFyZ3VtZW50RXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAnY29kZXN0cmVhbVBhcnRQYXJhbXMnLFxyXG4gICAgICAgICAgICBjb2Rlc3RyZWFtUGFydFBhcmFtcyxcclxuICAgICAgICAgICAgJ05vbiBtb3ZhYmxlIHJlcXVlc3QgbXVzdCAgaGF2ZSBjb2Rlc3RyZWFtUGFydFBhcmFtcyAhPT0gbnVsbCcpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gSnBpcFJlcXVlc3RDb250ZXh0O1xyXG59KSgpOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBqR2xvYmFscyA9IHJlcXVpcmUoJ2oyay1qcGlwLWdsb2JhbHMuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLkNvbXBvc2l0ZUFycmF5ID0gZnVuY3Rpb24gQ29tcG9zaXRlQXJyYXkob2Zmc2V0KSB7XHJcbiAgICB2YXIgbGVuZ3RoID0gMDtcclxuICAgIHZhciBpbnRlcm5hbFBhcnRzID0gW107XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gZ2V0TGVuZ3RoKCkge1xyXG4gICAgICAgIHJldHVybiBsZW5ndGg7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gZ2V0T2Zmc2V0KCkge1xyXG4gICAgICAgIHJldHVybiBvZmZzZXQ7XHJcbiAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgdGhpcy5wdXNoU3ViQXJyYXkgPSBmdW5jdGlvbiBwdXNoU3ViQXJyYXkoc3ViQXJyYXkpIHtcclxuICAgICAgICBpbnRlcm5hbFBhcnRzLnB1c2goc3ViQXJyYXkpO1xyXG4gICAgICAgIGxlbmd0aCArPSBzdWJBcnJheS5sZW5ndGg7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmNvcHlUb090aGVyQXRUaGVFbmQgPSBmdW5jdGlvbiBjb3B5VG9PdGhlckF0VGhlRW5kKHJlc3VsdCwgbWluT2Zmc2V0LCBtYXhPZmZzZXQpIHtcclxuICAgICAgICBjaGVja09mZnNldHNUb0NvcHkobWluT2Zmc2V0LCBtYXhPZmZzZXQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBpdGVyYXRvciA9IGdldEludGVybmFsUGFydHNJdGVyYXRvcihtaW5PZmZzZXQsIG1heE9mZnNldCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTk9URTogV2hhdCBpZiBkYXRhIG5vdCBpbiBmaXJzdCBwYXJ0P1xyXG4gICAgICAgIFxyXG4gICAgICAgIHdoaWxlICh0cnlBZHZhbmNlSXRlcmF0b3IoaXRlcmF0b3IpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoU3ViQXJyYXkoaXRlcmF0b3Iuc3ViQXJyYXkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5jb3B5VG9UeXBlZEFycmF5ID0gZnVuY3Rpb24gY29weVRvVHlwZWRBcnJheShcclxuICAgICAgICByZXN1bHRBcnJheSwgcmVzdWx0QXJyYXlPZmZzZXQsIG1pbk9mZnNldCwgbWF4T2Zmc2V0KSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2hlY2tPZmZzZXRzVG9Db3B5KG1pbk9mZnNldCwgbWF4T2Zmc2V0KTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgaXRlcmF0b3IgPSBnZXRJbnRlcm5hbFBhcnRzSXRlcmF0b3IobWluT2Zmc2V0LCBtYXhPZmZzZXQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIE5PVEU6IFdoYXQgaWYgZGF0YSBub3QgaW4gZmlyc3QgcGFydD9cclxuICAgICAgICBcclxuICAgICAgICB3aGlsZSAodHJ5QWR2YW5jZUl0ZXJhdG9yKGl0ZXJhdG9yKSkge1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0SW5SZXN1bHQgPVxyXG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iub2Zmc2V0IC0gcmVzdWx0QXJyYXlPZmZzZXQ7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXN1bHRBcnJheS5zZXQoaXRlcmF0b3Iuc3ViQXJyYXksIG9mZnNldEluUmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuY29weVRvQXJyYXkgPSBmdW5jdGlvbiBjb3B5VG9BcnJheShcclxuICAgICAgICByZXN1bHRBcnJheSwgcmVzdWx0QXJyYXlPZmZzZXQsIG1pbk9mZnNldCwgbWF4T2Zmc2V0KSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2hlY2tPZmZzZXRzVG9Db3B5KG1pbk9mZnNldCwgbWF4T2Zmc2V0KTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgaXRlcmF0b3IgPSBnZXRJbnRlcm5hbFBhcnRzSXRlcmF0b3IobWluT2Zmc2V0LCBtYXhPZmZzZXQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIE5PVEU6IFdoYXQgaWYgZGF0YSBub3QgaW4gZmlyc3QgcGFydD9cclxuICAgICAgICBcclxuICAgICAgICB3aGlsZSAodHJ5QWR2YW5jZUl0ZXJhdG9yKGl0ZXJhdG9yKSkge1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0SW5SZXN1bHQgPVxyXG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iub2Zmc2V0IC0gcmVzdWx0QXJyYXlPZmZzZXQ7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZXJhdG9yLnN1YkFycmF5Lmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRBcnJheVtvZmZzZXRJblJlc3VsdCsrXSA9IGl0ZXJhdG9yLnN1YkFycmF5W2pdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5jb3B5VG9PdGhlciA9IGZ1bmN0aW9uIGNvcHlUb090aGVyKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyLmdldE9mZnNldCgpID4gb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbnRlcm5hbEVycm9yRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgJ0NvbXBvc2l0ZUFycmF5OiBUcnlpbmcgdG8gY29weSBwYXJ0IGludG8gYSBsYXR0ZXIgcGFydCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgb3RoZXJFbmRPZmZzZXQgPSBvdGhlci5nZXRPZmZzZXQoKSArIG90aGVyLmdldExlbmd0aCgpO1xyXG4gICAgICAgIHZhciBpc090aGVyQ29udGFpbnNUaGlzID0gb2Zmc2V0ICsgbGVuZ3RoIDw9IG90aGVyRW5kT2Zmc2V0O1xyXG4gICAgICAgIGlmIChpc090aGVyQ29udGFpbnNUaGlzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAvLyBEbyBub3Qgb3ZlcnJpZGUgYWxyZWFkeSBleGlzdCBkYXRhIChmb3IgZWZmaWNpZW5jeSlcclxuICAgICAgICB2YXIgbWluT2Zmc2V0ID0gb3RoZXJFbmRPZmZzZXQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gZ2V0SW50ZXJuYWxQYXJ0c0l0ZXJhdG9yKG1pbk9mZnNldCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKCF0cnlBZHZhbmNlSXRlcmF0b3IoaXRlcmF0b3IpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbnRlcm5hbEVycm9yRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgJ0NvbXBvc2l0ZUFycmF5OiBDb3VsZCBub3QgbWVyZ2UgcGFydHMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGV4cGVjdGVkT2Zmc2V0VmFsdWUgPSBtaW5PZmZzZXQ7XHJcblxyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLm9mZnNldCAhPT0gZXhwZWN0ZWRPZmZzZXRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgJ0NvbXBvc2l0ZUFycmF5OiBOb24tY29udGludW91cyB2YWx1ZSBvZiAnICtcclxuICAgICAgICAgICAgICAgICAgICAncmFuZ2VUb0NvcHkub2Zmc2V0LiBFeHBlY3RlZDogJyArIGV4cGVjdGVkT2Zmc2V0VmFsdWUgK1xyXG4gICAgICAgICAgICAgICAgICAgICAnLCBBY3R1YWw6ICcgKyBpdGVyYXRvci5vZmZzZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBvdGhlci5wdXNoU3ViQXJyYXkoaXRlcmF0b3Iuc3ViQXJyYXkpO1xyXG4gICAgICAgICAgICBleHBlY3RlZE9mZnNldFZhbHVlICs9IGl0ZXJhdG9yLnN1YkFycmF5Lmxlbmd0aDtcclxuICAgICAgICB9IHdoaWxlICh0cnlBZHZhbmNlSXRlcmF0b3IoaXRlcmF0b3IpKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGNoZWNrT2Zmc2V0c1RvQ29weShtaW5PZmZzZXQsIG1heE9mZnNldCkge1xyXG4gICAgICAgIGlmIChtaW5PZmZzZXQgPT09IHVuZGVmaW5lZCB8fCBtYXhPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICdtaW5PZmZzZXQgb3IgbWF4T2Zmc2V0IGlzIHVuZGVmaW5lZCBmb3IgQ29tcG9zaXRlQXJyYXkuY29weVRvQXJyYXknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKG1pbk9mZnNldCA8IG9mZnNldCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICdtaW5PZmZzZXQgKCcgKyBtaW5PZmZzZXQgKyAnKSBtdXN0IGJlIHNtYWxsZXIgdGhhbiAnICtcclxuICAgICAgICAgICAgICAgICdDb21wb3NpdGVBcnJheSBvZmZzZXQgKCcgKyBvZmZzZXQgKyAnKScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAobWF4T2Zmc2V0ID4gb2Zmc2V0ICsgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbnRlcm5hbEVycm9yRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgJ21heE9mZnNldCAoJyArIG1heE9mZnNldCArICcpIG11c3QgYmUgbGFyZ2VyIHRoYW4gJyArXHJcbiAgICAgICAgICAgICAgICAnQ29tcG9zaXRlQXJyYXkgZW5kIG9mZnNldCAoJyArIG9mZnNldCArIGxlbmd0aCArICcpJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBnZXRJbnRlcm5hbFBhcnRzSXRlcmF0b3IobWluT2Zmc2V0LCBtYXhPZmZzZXQpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSBNYXRoLm1heChvZmZzZXQsIG1pbk9mZnNldCk7XHJcblxyXG4gICAgICAgIHZhciBlbmQgPSBvZmZzZXQgKyBsZW5ndGg7XHJcbiAgICAgICAgaWYgKG1heE9mZnNldCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgbWF4T2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHN0YXJ0ID49IGVuZCkge1xyXG4gICAgICAgICAgICB2YXIgZW1wdHlJdGVyYXRvciA9IHtcclxuICAgICAgICAgICAgICAgIGludGVybmFsSXRlcmF0b3JEYXRhOiB7IGlzRW5kT2ZSYW5nZTogdHJ1ZSB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4gZW1wdHlJdGVyYXRvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0ge1xyXG4gICAgICAgICAgICBzdWJBcnJheTogbnVsbCxcclxuICAgICAgICAgICAgb2Zmc2V0OiAtMSxcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGludGVybmFsSXRlcmF0b3JEYXRhOiB7XHJcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZCxcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRTdWJBcnJheTogbnVsbCxcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRJbnRlcm5hbFBhcnRPZmZzZXQ6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBuZXh0SW50ZXJuYWxQYXJ0T2Zmc2V0OiBvZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50SW50ZXJuYWxQYXJ0SW5kZXg6IC0xLFxyXG4gICAgICAgICAgICAgICAgaXNFbmRPZlJhbmdlOiBmYWxzZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgYWxyZWFkeVJlYWNoZWRUb1RoZUVuZCA9IGZhbHNlO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgaWYgKGFscmVhZHlSZWFjaGVkVG9UaGVFbmQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbnRlcm5hbEVycm9yRXhjZXB0aW9uKCdJdGVyYXRvciByZWFjaGVkICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICd0byB0aGUgZW5kIGFsdGhvdWdoIG5vIGRhdGEgaGFzIGJlZW4gaXRlcmF0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgYWxyZWFkeVJlYWNoZWRUb1RoZUVuZCA9ICF0cnlBZHZhbmNlSXRlcmF0b3IoaXRlcmF0b3IpO1xyXG4gICAgICAgIH0gd2hpbGUgKHN0YXJ0ID49IGl0ZXJhdG9yLmludGVybmFsSXRlcmF0b3JEYXRhLm5leHRJbnRlcm5hbFBhcnRPZmZzZXQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBjdXRGaXJzdFN1YkFycmF5ID1cclxuICAgICAgICAgICAgc3RhcnQgLSBpdGVyYXRvci5pbnRlcm5hbEl0ZXJhdG9yRGF0YS5jdXJyZW50SW50ZXJuYWxQYXJ0T2Zmc2V0O1xyXG4gICAgICAgIGl0ZXJhdG9yLmludGVybmFsSXRlcmF0b3JEYXRhLmN1cnJlbnRTdWJBcnJheSA9XHJcbiAgICAgICAgICAgIGl0ZXJhdG9yLmludGVybmFsSXRlcmF0b3JEYXRhLmN1cnJlbnRTdWJBcnJheS5zdWJhcnJheShjdXRGaXJzdFN1YkFycmF5KTtcclxuICAgICAgICBpdGVyYXRvci5pbnRlcm5hbEl0ZXJhdG9yRGF0YS5jdXJyZW50SW50ZXJuYWxQYXJ0T2Zmc2V0ID0gc3RhcnQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiB0cnlBZHZhbmNlSXRlcmF0b3IoaXRlcmF0b3IpIHtcclxuICAgICAgICB2YXIgaW50ZXJuYWxJdGVyYXRvckRhdGEgPSBpdGVyYXRvci5pbnRlcm5hbEl0ZXJhdG9yRGF0YTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoaW50ZXJuYWxJdGVyYXRvckRhdGEuaXNFbmRPZlJhbmdlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaXRlcmF0b3Iuc3ViQXJyYXkgPSBpbnRlcm5hbEl0ZXJhdG9yRGF0YS5jdXJyZW50U3ViQXJyYXk7XHJcbiAgICAgICAgaXRlcmF0b3Iub2Zmc2V0ID0gaW50ZXJuYWxJdGVyYXRvckRhdGEuY3VycmVudEludGVybmFsUGFydE9mZnNldDtcclxuICAgICAgICBcclxuICAgICAgICArK2ludGVybmFsSXRlcmF0b3JEYXRhLmN1cnJlbnRJbnRlcm5hbFBhcnRJbmRleDtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoaW50ZXJuYWxJdGVyYXRvckRhdGEubmV4dEludGVybmFsUGFydE9mZnNldCA+PSBpbnRlcm5hbEl0ZXJhdG9yRGF0YS5lbmQpIHtcclxuICAgICAgICAgICAgaW50ZXJuYWxJdGVyYXRvckRhdGEuaXNFbmRPZlJhbmdlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBlbnN1cmVOb0VuZE9mQXJyYXlSZWFjaGVkKGludGVybmFsSXRlcmF0b3JEYXRhLmN1cnJlbnRJbnRlcm5hbFBhcnRJbmRleCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaW50ZXJuYWxJdGVyYXRvckRhdGEuY3VycmVudFN1YkFycmF5ID0gaW50ZXJuYWxQYXJ0c1tcclxuICAgICAgICAgICAgaW50ZXJuYWxJdGVyYXRvckRhdGEuY3VycmVudEludGVybmFsUGFydEluZGV4XTtcclxuICAgICAgICBpbnRlcm5hbEl0ZXJhdG9yRGF0YS5jdXJyZW50SW50ZXJuYWxQYXJ0T2Zmc2V0ID1cclxuICAgICAgICAgICAgaW50ZXJuYWxJdGVyYXRvckRhdGEubmV4dEludGVybmFsUGFydE9mZnNldDtcclxuICAgICAgICB2YXIgY3VycmVudEludGVybmFsUGFydExlbmd0aCA9XHJcbiAgICAgICAgICAgIGludGVybmFsUGFydHNbaW50ZXJuYWxJdGVyYXRvckRhdGEuY3VycmVudEludGVybmFsUGFydEluZGV4XS5sZW5ndGg7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaW50ZXJuYWxJdGVyYXRvckRhdGEubmV4dEludGVybmFsUGFydE9mZnNldCA9XHJcbiAgICAgICAgICAgIGludGVybmFsSXRlcmF0b3JEYXRhLmN1cnJlbnRJbnRlcm5hbFBhcnRPZmZzZXQgKyBjdXJyZW50SW50ZXJuYWxQYXJ0TGVuZ3RoO1xyXG5cclxuICAgICAgICB2YXIgY3V0TGFzdFN1YkFycmF5ID1cclxuICAgICAgICAgICAgaW50ZXJuYWxJdGVyYXRvckRhdGEuZW5kIC0gaW50ZXJuYWxJdGVyYXRvckRhdGEuY3VycmVudEludGVybmFsUGFydE9mZnNldDtcclxuICAgICAgICB2YXIgaXNMYXN0U3ViQXJyYXkgPVxyXG4gICAgICAgICAgICBjdXRMYXN0U3ViQXJyYXkgPCBpbnRlcm5hbEl0ZXJhdG9yRGF0YS5jdXJyZW50U3ViQXJyYXkubGVuZ3RoO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChpc0xhc3RTdWJBcnJheSkge1xyXG4gICAgICAgICAgICBpbnRlcm5hbEl0ZXJhdG9yRGF0YS5jdXJyZW50U3ViQXJyYXkgPSBpbnRlcm5hbEl0ZXJhdG9yRGF0YVxyXG4gICAgICAgICAgICAgICAgLmN1cnJlbnRTdWJBcnJheS5zdWJhcnJheSgwLCBjdXRMYXN0U3ViQXJyYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gZW5zdXJlTm9FbmRPZkFycmF5UmVhY2hlZChjdXJyZW50SW50ZXJuYWxQYXJ0SW5kZXgpIHtcclxuICAgICAgICBpZiAoY3VycmVudEludGVybmFsUGFydEluZGV4ID49IGludGVybmFsUGFydHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbnRlcm5hbEVycm9yRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgJ0NvbXBvc2l0ZUFycmF5OiBlbmQgb2YgcGFydCBoYXMgcmVhY2hlZC4gQ2hlY2sgZW5kIGNhbGN1bGF0aW9uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbi8vIEEuMi4xLlxyXG5cclxubW9kdWxlLmV4cG9ydHMuSnBpcERhdGFiaW5QYXJ0cyA9IGZ1bmN0aW9uIEpwaXBEYXRhYmluUGFydHMoXHJcbiAgICBjbGFzc0lkLCBpbkNsYXNzSWQsIGpwaXBGYWN0b3J5KSB7XHJcblxyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIHZhciBwYXJ0cyA9IFtdO1xyXG4gICAgdmFyIGRhdGFiaW5MZW5ndGhJZktub3duID0gbnVsbDtcclxuICAgIHZhciBsb2FkZWRCeXRlcyA9IDA7XHJcbiAgICBcclxuICAgIHZhciBjYWNoZWREYXRhID0gW107XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0RGF0YWJpbkxlbmd0aElmS25vd24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gZGF0YWJpbkxlbmd0aElmS25vd247XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldExvYWRlZEJ5dGVzID0gZnVuY3Rpb24gZ2V0TG9hZGVkQnl0ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIGxvYWRlZEJ5dGVzO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5pc0FsbERhdGFiaW5Mb2FkZWQgPSBmdW5jdGlvbiBpc0FsbERhdGFiaW5Mb2FkZWQoKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICBcclxuICAgICAgICBzd2l0Y2ggKHBhcnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBkYXRhYmluTGVuZ3RoSWZLbm93biA9PT0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9XHJcbiAgICAgICAgICAgICAgICAgICAgcGFydHNbMF0uZ2V0T2Zmc2V0KCkgPT09IDAgJiZcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0c1swXS5nZXRMZW5ndGgoKSA9PT0gZGF0YWJpbkxlbmd0aElmS25vd247XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRDYWNoZWREYXRhID0gZnVuY3Rpb24gZ2V0Q2FjaGVkRGF0YShrZXkpIHtcclxuICAgICAgICB2YXIgb2JqID0gY2FjaGVkRGF0YVtrZXldO1xyXG4gICAgICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBvYmogPSB7fTtcclxuICAgICAgICAgICAgY2FjaGVkRGF0YVtrZXldID0gb2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRDbGFzc0lkID0gZnVuY3Rpb24gZ2V0Q2xhc3NJZCgpIHtcclxuICAgICAgICByZXR1cm4gY2xhc3NJZDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0SW5DbGFzc0lkID0gZnVuY3Rpb24gZ2V0SW5DbGFzc0lkKCkge1xyXG4gICAgICAgIHJldHVybiBpbkNsYXNzSWQ7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmNvcHlUb0NvbXBvc2l0ZUFycmF5ID0gZnVuY3Rpb24gY29weVRvQ29tcG9zaXRlQXJyYXkocmVzdWx0LCByYW5nZU9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZHVtbXlSZXN1bHRTdGFydE9mZnNldCA9IDA7XHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IGdldFBhcmFtc0ZvckNvcHlCeXRlcyhkdW1teVJlc3VsdFN0YXJ0T2Zmc2V0LCByYW5nZU9wdGlvbnMpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChwYXJhbXMucmVzdWx0V2l0aG91dENvcHkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLnJlc3VsdFdpdGhvdXRDb3B5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgbWF4TGVuZ3RoQ29waWVkID0gaXRlcmF0ZVJhbmdlKFxyXG4gICAgICAgICAgICBwYXJhbXMuZGF0YWJpblN0YXJ0T2Zmc2V0LFxyXG4gICAgICAgICAgICBwYXJhbXMubWF4TGVuZ3RoVG9Db3B5LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRQYXJ0VG9SZXN1bHRJbkNvcHlUb0NvbXBvc2l0ZUFycmF5KHBhcnQsIG1pbk9mZnNldEluUGFydCwgbWF4T2Zmc2V0SW5QYXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0LmNvcHlUb090aGVyQXRUaGVFbmQoXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LFxyXG4gICAgICAgICAgICAgICAgICAgIG1pbk9mZnNldEluUGFydCxcclxuICAgICAgICAgICAgICAgICAgICBtYXhPZmZzZXRJblBhcnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gbWF4TGVuZ3RoQ29waWVkO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5jb3B5Qnl0ZXMgPSBmdW5jdGlvbihyZXN1bHRBcnJheSwgcmVzdWx0U3RhcnRPZmZzZXQsIHJhbmdlT3B0aW9ucykge1xyXG4gICAgICAgIHZhciBwYXJhbXMgPSBnZXRQYXJhbXNGb3JDb3B5Qnl0ZXMocmVzdWx0U3RhcnRPZmZzZXQsIHJhbmdlT3B0aW9ucyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHBhcmFtcy5yZXN1bHRXaXRob3V0Q29weSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXMucmVzdWx0V2l0aG91dENvcHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciByZXN1bHRBcnJheU9mZnNldEluRGF0YWJpbiA9IHBhcmFtcy5kYXRhYmluU3RhcnRPZmZzZXQgLSBwYXJhbXMucmVzdWx0U3RhcnRPZmZzZXQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIG1heExlbmd0aENvcGllZCA9IGl0ZXJhdGVSYW5nZShcclxuICAgICAgICAgICAgcGFyYW1zLmRhdGFiaW5TdGFydE9mZnNldCxcclxuICAgICAgICAgICAgcGFyYW1zLm1heExlbmd0aFRvQ29weSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkUGFydFRvUmVzdWx0SW5Db3B5Qnl0ZXMocGFydCwgbWluT2Zmc2V0SW5QYXJ0LCBtYXhPZmZzZXRJblBhcnQpIHtcclxuICAgICAgICAgICAgICAgIHBhcnQuY29weVRvQXJyYXkoXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0QXJyYXksXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0QXJyYXlPZmZzZXRJbkRhdGFiaW4sXHJcbiAgICAgICAgICAgICAgICAgICAgbWluT2Zmc2V0SW5QYXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgIG1heE9mZnNldEluUGFydCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBtYXhMZW5ndGhDb3BpZWQ7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldEV4aXN0aW5nUmFuZ2VzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShwYXJ0cy5sZW5ndGgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgcmVzdWx0W2ldID0ge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHBhcnRzW2ldLmdldE9mZnNldCgpLFxyXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBwYXJ0c1tpXS5nZXRMZW5ndGgoKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuYWRkRGF0YSA9IGZ1bmN0aW9uKGhlYWRlciwgbWVzc2FnZSkge1xyXG4gICAgICAgIGlmIChoZWFkZXIuaXNMYXN0Qnl0ZUluRGF0YWJpbikge1xyXG4gICAgICAgICAgICBkYXRhYmluTGVuZ3RoSWZLbm93biA9IGhlYWRlci5tZXNzYWdlT2Zmc2V0RnJvbURhdGFiaW5TdGFydCArIGhlYWRlci5tZXNzYWdlQm9keUxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGhlYWRlci5tZXNzYWdlQm9keUxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbmV3UGFydCA9IGpwaXBGYWN0b3J5LmNyZWF0ZUNvbXBvc2l0ZUFycmF5KFxyXG4gICAgICAgICAgICBoZWFkZXIubWVzc2FnZU9mZnNldEZyb21EYXRhYmluU3RhcnQpO1xyXG5cclxuICAgICAgICB2YXIgZW5kT2Zmc2V0SW5NZXNzYWdlID0gaGVhZGVyLmJvZHlTdGFydCArIGhlYWRlci5tZXNzYWdlQm9keUxlbmd0aDtcclxuICAgICAgICBuZXdQYXJ0LnB1c2hTdWJBcnJheShtZXNzYWdlLnN1YmFycmF5KGhlYWRlci5ib2R5U3RhcnQsIGVuZE9mZnNldEluTWVzc2FnZSkpO1xyXG5cclxuICAgICAgICAvLyBGaW5kIHdoZXJlIHRvIHB1c2ggdGhlIG5ldyBtZXNzYWdlXHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGluZGV4Rmlyc3RQYXJ0QWZ0ZXIgPSBmaW5kRmlyc3RQYXJ0QWZ0ZXJPZmZzZXQoaGVhZGVyLm1lc3NhZ2VPZmZzZXRGcm9tRGF0YWJpblN0YXJ0KTtcclxuICAgICAgICB2YXIgaW5kZXhGaXJzdFBhcnROZWFyT3JBZnRlciA9IGluZGV4Rmlyc3RQYXJ0QWZ0ZXI7XHJcblxyXG4gICAgICAgIGlmIChpbmRleEZpcnN0UGFydEFmdGVyID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgcHJldmlvdXNQYXJ0ID0gcGFydHNbaW5kZXhGaXJzdFBhcnRBZnRlciAtIDFdO1xyXG4gICAgICAgICAgICB2YXIgcHJldmlvdXNQYXJ0RW5kT2Zmc2V0ID1cclxuICAgICAgICAgICAgICAgIHByZXZpb3VzUGFydC5nZXRPZmZzZXQoKSArIHByZXZpb3VzUGFydC5nZXRMZW5ndGgoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChwcmV2aW91c1BhcnRFbmRPZmZzZXQgPT09IGhlYWRlci5tZXNzYWdlT2Zmc2V0RnJvbURhdGFiaW5TdGFydCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2FuIG1lcmdlIGFsc28gcHJldmlvdXMgcGFydFxyXG4gICAgICAgICAgICAgICAgLS1pbmRleEZpcnN0UGFydE5lYXJPckFmdGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaW5kZXhGaXJzdFBhcnROZWFyT3JBZnRlciA+PSBwYXJ0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcGFydHMucHVzaChuZXdQYXJ0KTtcclxuICAgICAgICAgICAgbG9hZGVkQnl0ZXMgKz0gaGVhZGVyLm1lc3NhZ2VCb2R5TGVuZ3RoO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgZmlyc3RQYXJ0TmVhck9yQWZ0ZXIgPSBwYXJ0c1tpbmRleEZpcnN0UGFydE5lYXJPckFmdGVyXTtcclxuICAgICAgICB2YXIgZW5kT2Zmc2V0SW5EYXRhYmluID1cclxuICAgICAgICAgICAgaGVhZGVyLm1lc3NhZ2VPZmZzZXRGcm9tRGF0YWJpblN0YXJ0ICsgaGVhZGVyLm1lc3NhZ2VCb2R5TGVuZ3RoO1xyXG4gICAgICAgIGlmIChmaXJzdFBhcnROZWFyT3JBZnRlci5nZXRPZmZzZXQoKSA+IGVuZE9mZnNldEluRGF0YWJpbikge1xyXG4gICAgICAgICAgICAvLyBOb3QgZm91bmQgYW4gb3ZlcmxhcHBpbmcgcGFydCwgcHVzaCBhIG5ld1xyXG4gICAgICAgICAgICAvLyBwYXJ0IGluIHRoZSBtaWRkbGUgb2YgdGhlIHBhcnRzIGFycmF5XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aDsgaSA+IGluZGV4Rmlyc3RQYXJ0TmVhck9yQWZ0ZXI7IC0taSkge1xyXG4gICAgICAgICAgICAgICAgcGFydHNbaV0gPSBwYXJ0c1tpIC0gMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHBhcnRzW2luZGV4Rmlyc3RQYXJ0TmVhck9yQWZ0ZXJdID0gbmV3UGFydDtcclxuICAgICAgICAgICAgbG9hZGVkQnl0ZXMgKz0gaGVhZGVyLm1lc3NhZ2VCb2R5TGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBNZXJnZSBmaXJzdCBhbmQgbGFzdCBvdmVybGFwcGluZyBwYXJ0cyAtIGFsbCB0aGUgcmVzdCAoaWYgYW55KSBhcmUgaW4gdGhlIG1pZGRsZSBvZiB0aGUgbmV3IHBhcnRcclxuICAgICAgICBcclxuICAgICAgICB2YXIgYnl0ZXNBbHJlYWR5U2F2ZWQgPSBmaXJzdFBhcnROZWFyT3JBZnRlci5nZXRMZW5ndGgoKTtcclxuXHJcbiAgICAgICAgdmFyIHNob3VsZFN3YXAgPVxyXG4gICAgICAgICAgICBmaXJzdFBhcnROZWFyT3JBZnRlci5nZXRPZmZzZXQoKSA+IGhlYWRlci5tZXNzYWdlT2Zmc2V0RnJvbURhdGFiaW5TdGFydDtcclxuICAgICAgICBpZiAoc2hvdWxkU3dhcCkge1xyXG4gICAgICAgICAgICBwYXJ0c1tpbmRleEZpcnN0UGFydE5lYXJPckFmdGVyXSA9IG5ld1BhcnQ7XHJcbiAgICAgICAgICAgIG5ld1BhcnQgPSBmaXJzdFBhcnROZWFyT3JBZnRlcjtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGZpcnN0UGFydE5lYXJPckFmdGVyID0gcGFydHNbaW5kZXhGaXJzdFBhcnROZWFyT3JBZnRlcl07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBuZXdQYXJ0LmNvcHlUb090aGVyKGZpcnN0UGFydE5lYXJPckFmdGVyKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgZW5kT2Zmc2V0ID1cclxuICAgICAgICAgICAgZmlyc3RQYXJ0TmVhck9yQWZ0ZXIuZ2V0T2Zmc2V0KCkgKyBmaXJzdFBhcnROZWFyT3JBZnRlci5nZXRMZW5ndGgoKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgcGFydFRvTWVyZ2VJbmRleDtcclxuICAgICAgICBmb3IgKHBhcnRUb01lcmdlSW5kZXggPSBpbmRleEZpcnN0UGFydE5lYXJPckFmdGVyO1xyXG4gICAgICAgICAgICBwYXJ0VG9NZXJnZUluZGV4IDwgcGFydHMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgKytwYXJ0VG9NZXJnZUluZGV4KSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoZW5kT2Zmc2V0IDwgcGFydHNbcGFydFRvTWVyZ2VJbmRleCArIDFdLmdldE9mZnNldCgpKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgYnl0ZXNBbHJlYWR5U2F2ZWQgKz0gcGFydHNbcGFydFRvTWVyZ2VJbmRleCArIDFdLmdldExlbmd0aCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgcGFydHNUb0RlbGV0ZSA9IHBhcnRUb01lcmdlSW5kZXggLSBpbmRleEZpcnN0UGFydE5lYXJPckFmdGVyO1xyXG4gICAgICAgIGlmIChwYXJ0c1RvRGVsZXRlID4gMCkge1xyXG4gICAgICAgICAgICBwYXJ0c1twYXJ0VG9NZXJnZUluZGV4XS5jb3B5VG9PdGhlcihmaXJzdFBhcnROZWFyT3JBZnRlcik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBEZWxldGUgYWxsIG1pZGRsZSBhbmQgbWVyZ2VkIHBhcnRzIGV4Y2VwdCAxXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaW5kZXhGaXJzdFBhcnROZWFyT3JBZnRlciArIDE7IGogPCBwYXJ0cy5sZW5ndGggLSBwYXJ0c1RvRGVsZXRlOyArK2opIHtcclxuICAgICAgICAgICAgICAgIHBhcnRzW2pdID0gcGFydHNbaiArIHBhcnRzVG9EZWxldGVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBwYXJ0cy5sZW5ndGggLT0gcGFydHNUb0RlbGV0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgbG9hZGVkQnl0ZXMgKz0gZmlyc3RQYXJ0TmVhck9yQWZ0ZXIuZ2V0TGVuZ3RoKCkgLSBieXRlc0FscmVhZHlTYXZlZDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGdldFBhcmFtc0ZvckNvcHlCeXRlcyhyZXN1bHRTdGFydE9mZnNldCwgcmFuZ2VPcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGZvcmNlQ29weUFsbFJhbmdlID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGRhdGFiaW5TdGFydE9mZnNldCA9IDA7XHJcbiAgICAgICAgdmFyIG1heExlbmd0aFRvQ29weTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAocmFuZ2VPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZm9yY2VDb3B5QWxsUmFuZ2UgPSAhIXJhbmdlT3B0aW9ucy5mb3JjZUNvcHlBbGxSYW5nZTtcclxuICAgICAgICAgICAgZGF0YWJpblN0YXJ0T2Zmc2V0ID0gcmFuZ2VPcHRpb25zLmRhdGFiaW5TdGFydE9mZnNldDtcclxuICAgICAgICAgICAgbWF4TGVuZ3RoVG9Db3B5ID0gcmFuZ2VPcHRpb25zLm1heExlbmd0aFRvQ29weTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChkYXRhYmluU3RhcnRPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgZGF0YWJpblN0YXJ0T2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAocmVzdWx0U3RhcnRPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXN1bHRTdGFydE9mZnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChtYXhMZW5ndGhUb0NvcHkgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0V2l0aG91dENvcHk6IDAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKChkYXRhYmluTGVuZ3RoSWZLbm93biAhPT0gbnVsbCkgJiYgKGRhdGFiaW5TdGFydE9mZnNldCA+PSBkYXRhYmluTGVuZ3RoSWZLbm93bikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0V2l0aG91dENvcHk6ICghIW1heExlbmd0aFRvQ29weSAmJiBmb3JjZUNvcHlBbGxSYW5nZSA/IG51bGwgOiAwKSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgZmlyc3RSZWxldmFudFBhcnRJbmRleCA9IGZpbmRGaXJzdFBhcnRBZnRlck9mZnNldChkYXRhYmluU3RhcnRPZmZzZXQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChmaXJzdFJlbGV2YW50UGFydEluZGV4ID09PSBwYXJ0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0V2l0aG91dENvcHk6IChmb3JjZUNvcHlBbGxSYW5nZSA/IG51bGwgOiAwKSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoZm9yY2VDb3B5QWxsUmFuZ2UpIHtcclxuICAgICAgICAgICAgdmFyIGlzQWxsUmVxdWVzdGVkUmFuZ2VFeGlzdCA9XHJcbiAgICAgICAgICAgICAgICBpc0FsbFJhbmdlRXhpc3QoZGF0YWJpblN0YXJ0T2Zmc2V0LCBtYXhMZW5ndGhUb0NvcHksIGZpcnN0UmVsZXZhbnRQYXJ0SW5kZXgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKCFpc0FsbFJlcXVlc3RlZFJhbmdlRXhpc3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdFdpdGhvdXRDb3B5OiBudWxsIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHBhcmFtcyA9IHtcclxuICAgICAgICAgICAgZGF0YWJpblN0YXJ0T2Zmc2V0OiBkYXRhYmluU3RhcnRPZmZzZXQsXHJcbiAgICAgICAgICAgIG1heExlbmd0aFRvQ29weTogbWF4TGVuZ3RoVG9Db3B5LFxyXG4gICAgICAgICAgICByZXN1bHRTdGFydE9mZnNldDogcmVzdWx0U3RhcnRPZmZzZXRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gcGFyYW1zO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBpc0FsbFJhbmdlRXhpc3QoXHJcbiAgICAgICAgZGF0YWJpblN0YXJ0T2Zmc2V0LCBtYXhMZW5ndGhUb0NvcHksIGZpcnN0UmVsZXZhbnRQYXJ0SW5kZXgpIHtcclxuICAgICAgICBcclxuICAgICAgICBpZiAocGFydHNbZmlyc3RSZWxldmFudFBhcnRJbmRleF0uZ2V0T2Zmc2V0KCkgPiBkYXRhYmluU3RhcnRPZmZzZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAobWF4TGVuZ3RoVG9Db3B5KSB7XHJcbiAgICAgICAgICAgIHZhciB1bnVzZWRFbGVtZW50cyA9XHJcbiAgICAgICAgICAgICAgICBkYXRhYmluU3RhcnRPZmZzZXQgLSBwYXJ0c1tmaXJzdFJlbGV2YW50UGFydEluZGV4XS5nZXRPZmZzZXQoKTtcclxuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZUxlbmd0aCA9XHJcbiAgICAgICAgICAgICAgICBwYXJ0c1tmaXJzdFJlbGV2YW50UGFydEluZGV4XS5nZXRMZW5ndGgoKSAtIHVudXNlZEVsZW1lbnRzO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGlzVW50aWxNYXhMZW5ndGhFeGlzdCA9IGF2YWlsYWJsZUxlbmd0aCA+PSBtYXhMZW5ndGhUb0NvcHk7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1VudGlsTWF4TGVuZ3RoRXhpc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChkYXRhYmluTGVuZ3RoSWZLbm93biA9PT0gbnVsbCB8fFxyXG4gICAgICAgICAgICBmaXJzdFJlbGV2YW50UGFydEluZGV4IDwgcGFydHMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgbGFzdFBhcnQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcclxuICAgICAgICB2YXIgZW5kT2Zmc2V0UmVjaWV2ZWQgPSBsYXN0UGFydC5nZXRPZmZzZXQoKSArIGxhc3RQYXJ0LmdldExlbmd0aCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBpc1VudGlsRW5kT2ZEYXRhYmluRXhpc3QgPSBlbmRPZmZzZXRSZWNpZXZlZCA9PT0gZGF0YWJpbkxlbmd0aElmS25vd247XHJcbiAgICAgICAgcmV0dXJuIGlzVW50aWxFbmRPZkRhdGFiaW5FeGlzdDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gaXRlcmF0ZVJhbmdlKFxyXG4gICAgICAgICAgICBkYXRhYmluU3RhcnRPZmZzZXQsXHJcbiAgICAgICAgICAgIG1heExlbmd0aFRvQ29weSxcclxuICAgICAgICBhZGRTdWJQYXJ0VG9SZXN1bHQpIHtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgbWluT2Zmc2V0SW5EYXRhYmluVG9Db3B5ID0gZGF0YWJpblN0YXJ0T2Zmc2V0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBtYXhPZmZzZXRJbkRhdGFiaW5Ub0NvcHk7XHJcbiAgICAgICAgaWYgKG1heExlbmd0aFRvQ29weSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG1heE9mZnNldEluRGF0YWJpblRvQ29weSA9IGRhdGFiaW5TdGFydE9mZnNldCArIG1heExlbmd0aFRvQ29weTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbGFzdFBhcnQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgbWF4T2Zmc2V0SW5EYXRhYmluVG9Db3B5ID0gbGFzdFBhcnQuZ2V0T2Zmc2V0KCkgKyBsYXN0UGFydC5nZXRMZW5ndGgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICB2YXIgbGFzdENvcGllZFBhcnQgPSBudWxsO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKHBhcnRzW2ldLmdldE9mZnNldCgpID49IG1heE9mZnNldEluRGF0YWJpblRvQ29weSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50TWluT2Zmc2V0SW5EYXRhYmluVG9Db3B5ID0gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgICAgICBtaW5PZmZzZXRJbkRhdGFiaW5Ub0NvcHksIHBhcnRzW2ldLmdldE9mZnNldCgpKTtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRNYXhPZmZzZXRJbkRhdGFiaW5Ub0NvcHkgPSBNYXRoLm1pbihcclxuICAgICAgICAgICAgICAgIG1heE9mZnNldEluRGF0YWJpblRvQ29weSwgcGFydHNbaV0uZ2V0T2Zmc2V0KCkgKyBwYXJ0c1tpXS5nZXRMZW5ndGgoKSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIGFkZFN1YlBhcnRUb1Jlc3VsdChcclxuICAgICAgICAgICAgICAgIHBhcnRzW2ldLFxyXG4gICAgICAgICAgICAgICAgY3VycmVudE1pbk9mZnNldEluRGF0YWJpblRvQ29weSxcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXhPZmZzZXRJbkRhdGFiaW5Ub0NvcHkpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbGFzdENvcGllZFBhcnQgPSBwYXJ0c1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGxhc3RDb3BpZWRQYXJ0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgbGFzdE9mZnNldENvcGllZCA9IE1hdGgubWluKFxyXG4gICAgICAgICAgICBsYXN0Q29waWVkUGFydC5nZXRPZmZzZXQoKSArIGxhc3RDb3BpZWRQYXJ0LmdldExlbmd0aCgpLFxyXG4gICAgICAgICAgICBtYXhPZmZzZXRJbkRhdGFiaW5Ub0NvcHkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBtYXhMZW5ndGhDb3BpZWQgPSBsYXN0T2Zmc2V0Q29waWVkIC0gZGF0YWJpblN0YXJ0T2Zmc2V0O1xyXG4gICAgICAgIHJldHVybiBtYXhMZW5ndGhDb3BpZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmluZEZpcnN0UGFydEFmdGVyT2Zmc2V0KG9mZnNldCkge1xyXG4gICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBwYXJ0cy5sZW5ndGg7ICsraW5kZXgpIHtcclxuICAgICAgICAgICAgaWYgKHBhcnRzW2luZGV4XS5nZXRPZmZzZXQoKSArIHBhcnRzW2luZGV4XS5nZXRMZW5ndGgoKSA+IG9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gdGhpcztcclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgakdsb2JhbHMgPSByZXF1aXJlKCdqMmstanBpcC1nbG9iYWxzLmpzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5KcGlwRGF0YWJpbnNTYXZlciA9IGZ1bmN0aW9uIEpwaXBEYXRhYmluc1NhdmVyKGlzSnBpcFRpbGVQYXJ0U3RyZWFtLCBqcGlwRmFjdG9yeSkge1xyXG4gICAgdmFyIFBSRUNJTkNUX05PX0FVWF9DTEFTUyA9IDA7XHJcbiAgICB2YXIgUFJFQ0lOQ1RfV0lUSF9BVVhfQ0xBU1MgPSAxO1xyXG4gICAgdmFyIFRJTEVfSEVBREVSX0NMQVNTID0gMjtcclxuICAgIHZhciBUSUxFX05PX0FVWF9DTEFTUyA9IDQ7XHJcbiAgICB2YXIgVElMRV9XSVRIX0FVWF9DTEFTUyA9IDU7XHJcblxyXG4gICAgdmFyIGRhdGFiaW5zQnlDbGFzcyA9IFtdO1xyXG4gICAgdmFyIGZvcmJpZGRlbkluSnBwID0gW107XHJcbiAgICB2YXIgZm9yYmlkZGVuSW5KcHQgPSBbXTtcclxuICAgIFxyXG4gICAgdmFyIGxvYWRlZEJ5dGVzID0gMDtcclxuICAgIHZhciBsb2FkZWRCeXRlc0luUmVnaXN0ZXJlZERhdGFiaW5zID0gMDtcclxuXHJcbiAgICAvLyBWYWxpZCBvbmx5IGlmIGlzSnBpcFRpbGVQYXJ0U3RyZWFtID0gZmFsc2VcclxuICAgIFxyXG4gICAgZGF0YWJpbnNCeUNsYXNzW1RJTEVfSEVBREVSX0NMQVNTXSA9IGNyZWF0ZURhdGFiaW5zQXJyYXkoKTtcclxuICAgIGRhdGFiaW5zQnlDbGFzc1tQUkVDSU5DVF9OT19BVVhfQ0xBU1NdID0gY3JlYXRlRGF0YWJpbnNBcnJheSgpO1xyXG4gICAgZGF0YWJpbnNCeUNsYXNzW1BSRUNJTkNUX1dJVEhfQVVYX0NMQVNTXSA9IGRhdGFiaW5zQnlDbGFzc1tcclxuICAgICAgICBQUkVDSU5DVF9OT19BVVhfQ0xBU1NdO1xyXG4gICAgXHJcbiAgICBmb3JiaWRkZW5JbkpwdFtUSUxFX0hFQURFUl9DTEFTU10gPSB0cnVlO1xyXG4gICAgZm9yYmlkZGVuSW5KcHRbUFJFQ0lOQ1RfTk9fQVVYX0NMQVNTXSA9IHRydWU7XHJcbiAgICBmb3JiaWRkZW5JbkpwdFtQUkVDSU5DVF9XSVRIX0FVWF9DTEFTU10gPSB0cnVlO1xyXG4gICAgXHJcbiAgICAvLyBWYWxpZCBvbmx5IGlmIGlzSnBpcFRpbGVQYXJ0U3RyZWFtID0gdHJ1ZVxyXG5cclxuICAgIGRhdGFiaW5zQnlDbGFzc1tUSUxFX05PX0FVWF9DTEFTU10gPSBjcmVhdGVEYXRhYmluc0FycmF5KCk7XHJcbiAgICBkYXRhYmluc0J5Q2xhc3NbVElMRV9XSVRIX0FVWF9DTEFTU10gPSBkYXRhYmluc0J5Q2xhc3NbXHJcbiAgICAgICAgVElMRV9OT19BVVhfQ0xBU1NdO1xyXG4gICAgXHJcbiAgICBmb3JiaWRkZW5JbkpwcFtUSUxFX05PX0FVWF9DTEFTU10gPSB0cnVlO1xyXG4gICAgZm9yYmlkZGVuSW5KcHBbVElMRV9XSVRIX0FVWF9DTEFTU10gPSB0cnVlO1xyXG4gICAgXHJcbiAgICB2YXIgbWFpbkhlYWRlckRhdGFiaW4gPSBqcGlwRmFjdG9yeS5jcmVhdGVEYXRhYmluUGFydHMoNiwgMCk7XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0SXNKcGlwVGlsZVBhcnRTdHJlYW0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gaXNKcGlwVGlsZVBhcnRTdHJlYW07XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldExvYWRlZEJ5dGVzID0gZnVuY3Rpb24gZ2V0TG9hZGVkQnl0ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIGxvYWRlZEJ5dGVzO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmdldE1haW5IZWFkZXJEYXRhYmluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBtYWluSGVhZGVyRGF0YWJpbjtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0VGlsZUhlYWRlckRhdGFiaW4gPSBmdW5jdGlvbihpbkNsYXNzSW5kZXgpIHtcclxuICAgICAgICB2YXIgZGF0YWJpbiA9IGdldERhdGFiaW5Gcm9tQXJyYXkoXHJcbiAgICAgICAgICAgIGRhdGFiaW5zQnlDbGFzc1tUSUxFX0hFQURFUl9DTEFTU10sXHJcbiAgICAgICAgICAgIFRJTEVfSEVBREVSX0NMQVNTLFxyXG4gICAgICAgICAgICBpbkNsYXNzSW5kZXgsXHJcbiAgICAgICAgICAgIC8qaXNKcGlwVGlsZVBhcnRTdHJlYW1FeHBlY3RlZD0qL2ZhbHNlLFxyXG4gICAgICAgICAgICAndGlsZUhlYWRlcicpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBkYXRhYmluO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRQcmVjaW5jdERhdGFiaW4gPSBmdW5jdGlvbihpbkNsYXNzSW5kZXgpIHtcclxuICAgICAgICB2YXIgZGF0YWJpbiA9IGdldERhdGFiaW5Gcm9tQXJyYXkoXHJcbiAgICAgICAgICAgIGRhdGFiaW5zQnlDbGFzc1tQUkVDSU5DVF9OT19BVVhfQ0xBU1NdLFxyXG4gICAgICAgICAgICBQUkVDSU5DVF9OT19BVVhfQ0xBU1MsXHJcbiAgICAgICAgICAgIGluQ2xhc3NJbmRleCxcclxuICAgICAgICAgICAgLyppc0pwaXBUaWxlUGFydFN0cmVhbUV4cGVjdGVkPSovZmFsc2UsXHJcbiAgICAgICAgICAgICdwcmVjaW5jdCcpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBkYXRhYmluO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRUaWxlRGF0YWJpbiA9IGZ1bmN0aW9uKGluQ2xhc3NJbmRleCkge1xyXG4gICAgICAgIHZhciBkYXRhYmluID0gZ2V0RGF0YWJpbkZyb21BcnJheShcclxuICAgICAgICAgICAgZGF0YWJpbnNCeUNsYXNzW1RJTEVfTk9fQVVYX0NMQVNTXSxcclxuICAgICAgICAgICAgVElMRV9OT19BVVhfQ0xBU1MsXHJcbiAgICAgICAgICAgIGluQ2xhc3NJbmRleCxcclxuICAgICAgICAgICAgLyppc0pwaXBUaWxlUGFydFN0cmVhbUV4cGVjdGVkPSovdHJ1ZSxcclxuICAgICAgICAgICAgJ3RpbGVQYXJ0Jyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGRhdGFiaW47XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKFxyXG4gICAgICAgIGRhdGFiaW4sIGV2ZW50LCBsaXN0ZW5lciwgbGlzdGVuZXJUaGlzKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGV2ZW50ICE9PSAnZGF0YUFycml2ZWQnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbnRlcm5hbEVycm9yRXhjZXB0aW9uKCdVbnN1cHBvcnRlZCBldmVudDogJyArXHJcbiAgICAgICAgICAgICAgICBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBjbGFzc0lkID0gZGF0YWJpbi5nZXRDbGFzc0lkKCk7XHJcbiAgICAgICAgdmFyIGluQ2xhc3NJZCA9IGRhdGFiaW4uZ2V0SW5DbGFzc0lkKCk7XHJcbiAgICAgICAgdmFyIGRhdGFiaW5zQXJyYXkgPSBkYXRhYmluc0J5Q2xhc3NbY2xhc3NJZF07XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGRhdGFiaW4gIT09IGRhdGFiaW5zQXJyYXkuZGF0YWJpbnNbaW5DbGFzc0lkXSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbignVW5tYXRjaGVkIGRhdGFiaW4gJyArXHJcbiAgICAgICAgICAgICAgICAnd2l0aCBjbGFzcy1JRD0nICsgY2xhc3NJZCArICcgYW5kIGluLWNsYXNzLUlEPScgKyBpbkNsYXNzSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoZGF0YWJpbnNBcnJheS5saXN0ZW5lcnNbaW5DbGFzc0lkXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGRhdGFiaW5zQXJyYXkubGlzdGVuZXJzW2luQ2xhc3NJZF0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGRhdGFiaW5zQXJyYXkubGlzdGVuZXJzW2luQ2xhc3NJZF0ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGxvYWRlZEJ5dGVzSW5SZWdpc3RlcmVkRGF0YWJpbnMgKz0gZGF0YWJpbi5nZXRMb2FkZWRCeXRlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBkYXRhYmluc0FycmF5Lmxpc3RlbmVyc1tpbkNsYXNzSWRdLnB1c2goe1xyXG4gICAgICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXHJcbiAgICAgICAgICAgIGxpc3RlbmVyVGhpczogbGlzdGVuZXJUaGlzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGRhdGFiaW5zQXJyYXkuZGF0YWJpbnNXaXRoTGlzdGVuZXJzW2luQ2xhc3NJZF0gPSBkYXRhYmluO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihcclxuICAgICAgICBkYXRhYmluLCBldmVudCwgbGlzdGVuZXIpIHtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoZXZlbnQgIT09ICdkYXRhQXJyaXZlZCcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24oJ1Vuc3VwcG9ydGVkIGV2ZW50OiAnICtcclxuICAgICAgICAgICAgICAgIGV2ZW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjbGFzc0lkID0gZGF0YWJpbi5nZXRDbGFzc0lkKCk7XHJcbiAgICAgICAgdmFyIGluQ2xhc3NJZCA9IGRhdGFiaW4uZ2V0SW5DbGFzc0lkKCk7XHJcbiAgICAgICAgdmFyIGRhdGFiaW5zQXJyYXkgPSBkYXRhYmluc0J5Q2xhc3NbY2xhc3NJZF07XHJcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IGRhdGFiaW5zQXJyYXkubGlzdGVuZXJzW2luQ2xhc3NJZF07XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGRhdGFiaW4gIT09IGRhdGFiaW5zQXJyYXkuZGF0YWJpbnNbaW5DbGFzc0lkXSB8fFxyXG4gICAgICAgICAgICBkYXRhYmluICE9PSBkYXRhYmluc0FycmF5LmRhdGFiaW5zV2l0aExpc3RlbmVyc1tpbkNsYXNzSWRdKSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbignVW5tYXRjaGVkIGRhdGFiaW4gJyArXHJcbiAgICAgICAgICAgICAgICAnd2l0aCBjbGFzcy1JRD0nICsgY2xhc3NJZCArICcgYW5kIGluLWNsYXNzLUlEPScgKyBpbkNsYXNzSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldID0gbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5sZW5ndGggLT0gMTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZGF0YWJpbnNBcnJheS5kYXRhYmluc1dpdGhMaXN0ZW5lcnNbaW5DbGFzc0lkXTtcclxuICAgICAgICAgICAgICAgICAgICBsb2FkZWRCeXRlc0luUmVnaXN0ZXJlZERhdGFiaW5zIC09IGRhdGFiaW4uZ2V0TG9hZGVkQnl0ZXMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbnRlcm5hbEVycm9yRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAnQ291bGQgbm90IHVucmVnaXN0ZXIgbGlzdGVuZXIgZnJvbSBkYXRhYmluJyk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmNsZWFudXBVbnJlZ2lzdGVyZWREYXRhYmlucyA9IGZ1bmN0aW9uIGNsZWFudXBVbnJlZ2lzdGVyZWREYXRhYmlucygpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFiaW5zQnlDbGFzcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoZGF0YWJpbnNCeUNsYXNzW2ldID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgZGF0YWJpbnMgPSBkYXRhYmluc0J5Q2xhc3NbaV0uZGF0YWJpbnNXaXRoTGlzdGVuZXJzO1xyXG4gICAgICAgICAgICBkYXRhYmluc0J5Q2xhc3NbaV0uZGF0YWJpbnMgPSBkYXRhYmlucy5zbGljZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBsb2FkZWRCeXRlcyA9IGxvYWRlZEJ5dGVzSW5SZWdpc3RlcmVkRGF0YWJpbnM7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuc2F2ZURhdGEgPSBmdW5jdGlvbiAoaGVhZGVyLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgLy8gQS4yLjJcclxuICAgICAgICBcclxuICAgICAgICBpZiAoaGVhZGVyLmNvZGVzdHJlYW1JbmRleCAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuVW5zdXBwb3J0ZWRGZWF0dXJlRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgJ05vbiB6ZXJvIENzbiAoQ29kZSBTdHJlYW0gSW5kZXgpJywgJ0EuMi4yJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHN3aXRjaCAoaGVhZGVyLmNsYXNzSWQpIHtcclxuICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgc2F2ZU1haW5IZWFkZXIoaGVhZGVyLCBtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhc2UgODpcclxuICAgICAgICAgICAgICAgIHNhdmVNZXRhZGF0YShoZWFkZXIsIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgLy8gQS4zLjIsIEEuMy4zLCBBLjMuNFxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YWJpbnNBcnJheSA9IGRhdGFiaW5zQnlDbGFzc1toZWFkZXIuY2xhc3NJZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YWJpbnNBcnJheSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIEEuMi4yXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHZhciBpc0pwdEV4cGVjdGVkID0gISFmb3JiaWRkZW5JbkpwcFtoZWFkZXIuY2xhc3NJZF07XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YWJpbiA9IGdldERhdGFiaW5Gcm9tQXJyYXkoXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YWJpbnNBcnJheSxcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXIuY2xhc3NJZCxcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXIuaW5DbGFzc0lkLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzSnB0RXhwZWN0ZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgJzxjbGFzcyBJRCAnICsgaGVhZGVyLmNsYXNzSWQgKyAnPicpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZXNCZWZvcmUgPSBkYXRhYmluLmdldExvYWRlZEJ5dGVzKCk7XHJcbiAgICAgICAgICAgICAgICBkYXRhYmluLmFkZERhdGEoaGVhZGVyLCBtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIHZhciBieXRlc0RpZmZlcmVuY2UgPSBkYXRhYmluLmdldExvYWRlZEJ5dGVzKCkgLSBieXRlc0JlZm9yZTtcclxuICAgICAgICAgICAgICAgIGxvYWRlZEJ5dGVzICs9IGJ5dGVzRGlmZmVyZW5jZTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IGRhdGFiaW5zQXJyYXkubGlzdGVuZXJzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFiaW5MaXN0ZW5lcnMgPSBsaXN0ZW5lcnNbaGVhZGVyLmluQ2xhc3NJZF07XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhYmluTGlzdGVuZXJzICE9PSB1bmRlZmluZWQgJiYgZGF0YWJpbkxpc3RlbmVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVkQnl0ZXNJblJlZ2lzdGVyZWREYXRhYmlucyArPSBieXRlc0RpZmZlcmVuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2FsTGlzdGVuZXJzID0gZGF0YWJpbkxpc3RlbmVycy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jYWxMaXN0ZW5lcnMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbG9jYWxMaXN0ZW5lcnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyLmNhbGwobGlzdGVuZXIubGlzdGVuZXJUaGlzLCBkYXRhYmluKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHNhdmVNYWluSGVhZGVyKGhlYWRlciwgbWVzc2FnZSkge1xyXG4gICAgICAgIC8vIEEuMy41XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGhlYWRlci5pbkNsYXNzSWQgIT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLklsbGVnYWxEYXRhRXhjZXB0aW9uKCdNYWluIGhlYWRlciBkYXRhLWJpbiB3aXRoICcgK1xyXG4gICAgICAgICAgICAgICAgJ2luLWNsYXNzIGluZGV4IG90aGVyIHRoYW4gemVybyBpcyBub3QgdmFsaWQnLCAnQS4zLjUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGJ5dGVzQmVmb3JlID0gbWFpbkhlYWRlckRhdGFiaW4uZ2V0TG9hZGVkQnl0ZXMoKTtcclxuICAgICAgICBtYWluSGVhZGVyRGF0YWJpbi5hZGREYXRhKGhlYWRlciwgbWVzc2FnZSk7XHJcbiAgICAgICAgdmFyIGJ5dGVzRGlmZmVyZW5jZSA9IG1haW5IZWFkZXJEYXRhYmluLmdldExvYWRlZEJ5dGVzKCkgLSBieXRlc0JlZm9yZTtcclxuICAgICAgICBcclxuICAgICAgICBsb2FkZWRCeXRlcyArPSBieXRlc0RpZmZlcmVuY2U7XHJcbiAgICAgICAgbG9hZGVkQnl0ZXNJblJlZ2lzdGVyZWREYXRhYmlucyArPSBieXRlc0RpZmZlcmVuY2U7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHNhdmVNZXRhZGF0YShoZWFkZXIsIG1lc3NhZ2UpIHtcclxuICAgICAgICAvLyBBLjMuNlxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5VbnN1cHBvcnRlZEZlYXR1cmVFeGNlcHRpb24oJ3JlY2lldmUgbWV0YWRhdGEtYmluJywgJ0EuMy42Jyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gaWdub3JlIHVudXNlZCBtZXRhZGF0YSAobGVnYWwgYWNjb3JkaW5nIHRvIEEuMi4yKS5cclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gZ2V0RGF0YWJpbkZyb21BcnJheShcclxuICAgICAgICBkYXRhYmluc0FycmF5LFxyXG4gICAgICAgIGNsYXNzSWQsXHJcbiAgICAgICAgaW5DbGFzc0lkLFxyXG4gICAgICAgIGlzSnBpcFRpbGVQYXJ0U3RyZWFtRXhwZWN0ZWQsXHJcbiAgICAgICAgZGF0YWJpblR5cGVEZXNjcmlwdGlvbikge1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChpc0pwaXBUaWxlUGFydFN0cmVhbUV4cGVjdGVkICE9PSBpc0pwaXBUaWxlUGFydFN0cmVhbSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuV3JvbmdTdHJlYW1FeGNlcHRpb24oJ2RhdGFiaW4gb2YgdHlwZSAnICtcclxuICAgICAgICAgICAgICAgIGRhdGFiaW5UeXBlRGVzY3JpcHRpb24sIGlzSnBpcFRpbGVQYXJ0U3RyZWFtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGRhdGFiaW4gPSBkYXRhYmluc0FycmF5LmRhdGFiaW5zW2luQ2xhc3NJZF07XHJcbiAgICAgICAgaWYgKCFkYXRhYmluKSB7XHJcbiAgICAgICAgICAgIGRhdGFiaW4gPSBqcGlwRmFjdG9yeS5jcmVhdGVEYXRhYmluUGFydHMoY2xhc3NJZCwgaW5DbGFzc0lkKTtcclxuICAgICAgICAgICAgZGF0YWJpbnNBcnJheS5kYXRhYmluc1tpbkNsYXNzSWRdID0gZGF0YWJpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGRhdGFiaW47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGFiaW5zQXJyYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZGF0YWJpbnM6IFtdLFxyXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IFtdLFxyXG4gICAgICAgICAgICBkYXRhYmluc1dpdGhMaXN0ZW5lcnM6IFtdXHJcbiAgICAgICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiB0aGlzO1xyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBqR2xvYmFscyA9IHJlcXVpcmUoJ2oyay1qcGlwLWdsb2JhbHMuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLkpwaXBPYmplY3RQb29sQnlEYXRhYmluID0gZnVuY3Rpb24gSnBpcE9iamVjdFBvb2xCeURhdGFiaW4oKSB7XHJcbiAgICB2YXIgZGF0YWJpbklkVG9PYmplY3QgPSBbXTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRPYmplY3QgPSBmdW5jdGlvbiBnZXRPYmplY3QoZGF0YWJpbikge1xyXG4gICAgICAgIHZhciBjbGFzc0lkID0gZGF0YWJpbi5nZXRDbGFzc0lkKCk7XHJcbiAgICAgICAgdmFyIGluQ2xhc3NJZFRvT2JqZWN0ID0gZGF0YWJpbklkVG9PYmplY3RbY2xhc3NJZF07XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGluQ2xhc3NJZFRvT2JqZWN0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaW5DbGFzc0lkVG9PYmplY3QgPSBbXTtcclxuICAgICAgICAgICAgZGF0YWJpbklkVG9PYmplY3RbY2xhc3NJZF0gPSBpbkNsYXNzSWRUb09iamVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGluQ2xhc3NJZCA9IGRhdGFiaW4uZ2V0SW5DbGFzc0lkKCk7XHJcbiAgICAgICAgdmFyIG9iaiA9IGluQ2xhc3NJZFRvT2JqZWN0W2luQ2xhc3NJZF07XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG9iaiA9IHt9O1xyXG4gICAgICAgICAgICBvYmouZGF0YWJpbiA9IGRhdGFiaW47XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpbkNsYXNzSWRUb09iamVjdFtpbkNsYXNzSWRdID0gb2JqO1xyXG4gICAgICAgIH0gZWxzZSBpZiAob2JqLmRhdGFiaW4gIT09IGRhdGFiaW4pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAnRGF0YWJpbiBJRHMgYXJlIG5vdCB1bmlxdWUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH07XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGpHbG9iYWxzID0gcmVxdWlyZSgnajJrLWpwaXAtZ2xvYmFscy5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuSnBpcFJlcXVlc3REYXRhYmluc0xpc3RlbmVyID0gZnVuY3Rpb24gSnBpcFJlcXVlc3REYXRhYmluc0xpc3RlbmVyKFxyXG4gICAgY29kZXN0cmVhbVBhcnRQYXJhbXMsXHJcbiAgICBxdWFsaXR5TGF5ZXJSZWFjaGVkQ2FsbGJhY2ssXHJcbiAgICBjb2Rlc3RyZWFtU3RydWN0dXJlLFxyXG4gICAgZGF0YWJpbnNTYXZlcixcclxuICAgIHF1YWxpdHlMYXllcnNDYWNoZSxcclxuICAgIGpwaXBGYWN0b3J5KSB7XHJcbiAgICBcclxuICAgIHZhciBudW1RdWFsaXR5TGF5ZXJzVG9XYWl0Rm9yO1xyXG4gICAgdmFyIHRpbGVIZWFkZXJzTm90TG9hZGVkID0gMDtcclxuICAgIHZhciBtaW5OdW1RdWFsaXR5TGF5ZXJzUmVhY2hlZCA9IDA7XHJcbiAgICB2YXIgdW5yZWdpc3RlcmVkID0gZmFsc2U7XHJcbiAgICBcclxuICAgIHZhciByZWdpc3RlcmVkVGlsZUhlYWRlckRhdGFiaW5zID0gW107XHJcbiAgICB2YXIgcmVnaXN0ZXJlZFByZWNpbmN0RGF0YWJpbnMgPSBbXTtcclxuICAgIHZhciBhY2N1bXVsYXRlZERhdGFQZXJEYXRhYmluID0ganBpcEZhY3RvcnkuY3JlYXRlT2JqZWN0UG9vbEJ5RGF0YWJpbigpO1xyXG4gICAgdmFyIHByZWNpbmN0Q291bnRCeVJlYWNoZWRRdWFsaXR5TGF5ZXIgPSBbXTtcclxuICAgIFxyXG4gICAgcmVnaXN0ZXIoKTtcclxuICAgIFxyXG4gICAgdGhpcy51bnJlZ2lzdGVyID0gZnVuY3Rpb24gdW5yZWdpc3RlcigpIHtcclxuICAgICAgICBpZiAodW5yZWdpc3RlcmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdGVyZWRUaWxlSGVhZGVyRGF0YWJpbnMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgZGF0YWJpbnNTYXZlci5yZW1vdmVFdmVudExpc3RlbmVyKFxyXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJlZFRpbGVIZWFkZXJEYXRhYmluc1tpXSxcclxuICAgICAgICAgICAgICAgICdkYXRhQXJyaXZlZCcsXHJcbiAgICAgICAgICAgICAgICB0aWxlSGVhZGVyRGF0YUFycml2ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZ2lzdGVyZWRQcmVjaW5jdERhdGFiaW5zLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgIGRhdGFiaW5zU2F2ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcclxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWRQcmVjaW5jdERhdGFiaW5zW2pdLFxyXG4gICAgICAgICAgICAgICAgJ2RhdGFBcnJpdmVkJyxcclxuICAgICAgICAgICAgICAgIHByZWNpbmN0RGF0YUFycml2ZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB1bnJlZ2lzdGVyZWQgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXIoKSB7XHJcbiAgICAgICAgKyt0aWxlSGVhZGVyc05vdExvYWRlZDtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgdGlsZUl0ZXJhdG9yID0gY29kZXN0cmVhbVN0cnVjdHVyZS5nZXRUaWxlc0l0ZXJhdG9yKGNvZGVzdHJlYW1QYXJ0UGFyYW1zKTtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHZhciB0aWxlSW5kZXggPSB0aWxlSXRlcmF0b3IudGlsZUluZGV4O1xyXG4gICAgICAgICAgICB2YXIgZGF0YWJpbiA9IGRhdGFiaW5zU2F2ZXIuZ2V0VGlsZUhlYWRlckRhdGFiaW4odGlsZUluZGV4KTtcclxuICAgICAgICAgICAgcmVnaXN0ZXJlZFRpbGVIZWFkZXJEYXRhYmlucy5wdXNoKGRhdGFiaW4pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZGF0YWJpbnNTYXZlci5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgICAgICAgICAgICAgZGF0YWJpbiwgJ2RhdGFBcnJpdmVkJywgdGlsZUhlYWRlckRhdGFBcnJpdmVkKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICArK3RpbGVIZWFkZXJzTm90TG9hZGVkO1xyXG4gICAgICAgICAgICB0aWxlSGVhZGVyRGF0YUFycml2ZWQoZGF0YWJpbik7XHJcbiAgICAgICAgfSB3aGlsZSAodGlsZUl0ZXJhdG9yLnRyeUFkdmFuY2UoKSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLS10aWxlSGVhZGVyc05vdExvYWRlZDtcclxuICAgICAgICB0cnlBZHZhbmNlUXVhbGl0eUxheWVyc1JlYWNoZWQoKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gdGlsZUhlYWRlckRhdGFBcnJpdmVkKHRpbGVIZWFkZXJEYXRhYmluKSB7XHJcbiAgICAgICAgaWYgKCF0aWxlSGVhZGVyRGF0YWJpbi5pc0FsbERhdGFiaW5Mb2FkZWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciB0aWxlQWNjdW11bGF0ZWREYXRhID0gYWNjdW11bGF0ZWREYXRhUGVyRGF0YWJpbi5nZXRPYmplY3QoXHJcbiAgICAgICAgICAgIHRpbGVIZWFkZXJEYXRhYmluKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAodGlsZUFjY3VtdWxhdGVkRGF0YS5pc0FscmVhZHlMb2FkZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0aWxlQWNjdW11bGF0ZWREYXRhLmlzQWxyZWFkeUxvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgLS10aWxlSGVhZGVyc05vdExvYWRlZDtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgdGlsZUluZGV4ID0gdGlsZUhlYWRlckRhdGFiaW4uZ2V0SW5DbGFzc0lkKCk7XHJcbiAgICAgICAgdmFyIHRpbGVTdHJ1Y3R1cmUgPSBjb2Rlc3RyZWFtU3RydWN0dXJlLmdldFRpbGVTdHJ1Y3R1cmUodGlsZUluZGV4KTtcclxuICAgICAgICB2YXIgbWF4TnVtUXVhbGl0eUxheWVyc0luVGlsZSA9IHRpbGVTdHJ1Y3R1cmUuZ2V0TnVtUXVhbGl0eUxheWVycygpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBwcmVjaW5jdEl0ZXJhdG9yID0gdGlsZVN0cnVjdHVyZS5nZXRQcmVjaW5jdEl0ZXJhdG9yKFxyXG4gICAgICAgICAgICB0aWxlSW5kZXgsIGNvZGVzdHJlYW1QYXJ0UGFyYW1zKTtcclxuXHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBpZiAoIXByZWNpbmN0SXRlcmF0b3IuaXNJbkNvZGVzdHJlYW1QYXJ0KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAnVW5leHBlY3RlZCBwcmVjaW5jdCBub3QgaW4gY29kZXN0cmVhbSBwYXJ0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBpbkNsYXNzSWQgPSB0aWxlU3RydWN0dXJlLnByZWNpbmN0UG9zaXRpb25Ub0luQ2xhc3NJbmRleChcclxuICAgICAgICAgICAgICAgIHByZWNpbmN0SXRlcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBwcmVjaW5jdERhdGFiaW4gPSBkYXRhYmluc1NhdmVyLmdldFByZWNpbmN0RGF0YWJpbihpbkNsYXNzSWQpO1xyXG4gICAgICAgICAgICByZWdpc3RlcmVkUHJlY2luY3REYXRhYmlucy5wdXNoKHByZWNpbmN0RGF0YWJpbik7XHJcbiAgICAgICAgICAgIHZhciBhY2N1bXVsYXRlZERhdGEgPSBhY2N1bXVsYXRlZERhdGFQZXJEYXRhYmluLmdldE9iamVjdChcclxuICAgICAgICAgICAgICAgIHByZWNpbmN0RGF0YWJpbik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoYWNjdW11bGF0ZWREYXRhLm1heE51bVF1YWxpdHlMYXllcnNJblRpbGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24oJ1RpbGUgd2FzICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdpdGVyYXRlZCB0d2ljZSBpbiBjb2Rlc3RyZWFtIHBhcnQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgYWNjdW11bGF0ZWREYXRhLm1heE51bVF1YWxpdHlMYXllcnNJblRpbGUgPSBtYXhOdW1RdWFsaXR5TGF5ZXJzSW5UaWxlO1xyXG4gICAgICAgICAgICBpbmNyZW1lbnRQcmVjaW5jdFF1YWxpdHlMYXllcnMoXHJcbiAgICAgICAgICAgICAgICBwcmVjaW5jdERhdGFiaW4sIGFjY3VtdWxhdGVkRGF0YSwgcHJlY2luY3RJdGVyYXRvcik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBkYXRhYmluc1NhdmVyLmFkZEV2ZW50TGlzdGVuZXIoXHJcbiAgICAgICAgICAgICAgICBwcmVjaW5jdERhdGFiaW4sICdkYXRhQXJyaXZlZCcsIHByZWNpbmN0RGF0YUFycml2ZWQpO1xyXG4gICAgICAgIH0gd2hpbGUgKHByZWNpbmN0SXRlcmF0b3IudHJ5QWR2YW5jZSgpKTtcclxuICAgICAgICBcclxuICAgICAgICB0cnlBZHZhbmNlUXVhbGl0eUxheWVyc1JlYWNoZWQoKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gcHJlY2luY3REYXRhQXJyaXZlZChwcmVjaW5jdERhdGFiaW4pIHtcclxuICAgICAgICB2YXIgYWNjdW11bGF0ZWREYXRhID0gYWNjdW11bGF0ZWREYXRhUGVyRGF0YWJpbi5nZXRPYmplY3QoXHJcbiAgICAgICAgICAgIHByZWNpbmN0RGF0YWJpbik7XHJcblxyXG4gICAgICAgIHZhciBvbGRRdWFsaXR5TGF5ZXJzUmVhY2hlZCA9IGFjY3VtdWxhdGVkRGF0YS5udW1RdWFsaXR5TGF5ZXJzUmVhY2hlZDtcclxuICAgICAgICB2YXIgbWF4TnVtUXVhbGl0eUxheWVyc0luVGlsZSA9XHJcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkRGF0YS5tYXhOdW1RdWFsaXR5TGF5ZXJzSW5UaWxlO1xyXG5cclxuICAgICAgICBpZiAob2xkUXVhbGl0eUxheWVyc1JlYWNoZWQgPT09IG1heE51bVF1YWxpdHlMYXllcnNJblRpbGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAtLXByZWNpbmN0Q291bnRCeVJlYWNoZWRRdWFsaXR5TGF5ZXJbb2xkUXVhbGl0eUxheWVyc1JlYWNoZWRdO1xyXG4gICAgICAgIGluY3JlbWVudFByZWNpbmN0UXVhbGl0eUxheWVycyhwcmVjaW5jdERhdGFiaW4sIGFjY3VtdWxhdGVkRGF0YSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdHJ5QWR2YW5jZVF1YWxpdHlMYXllcnNSZWFjaGVkKCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGluY3JlbWVudFByZWNpbmN0UXVhbGl0eUxheWVycyhcclxuICAgICAgICBwcmVjaW5jdERhdGFiaW4sIGFjY3VtdWxhdGVkRGF0YSwgcHJlY2luY3RJdGVyYXRvck9wdGlvbmFsKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHF1YWxpdHlMYXllcnMgPSBxdWFsaXR5TGF5ZXJzQ2FjaGUuZ2V0UXVhbGl0eUxheWVyT2Zmc2V0KFxyXG4gICAgICAgICAgICBwcmVjaW5jdERhdGFiaW4sXHJcbiAgICAgICAgICAgIGNvZGVzdHJlYW1QYXJ0UGFyYW1zLm1heE51bVF1YWxpdHlMYXllcnMsXHJcbiAgICAgICAgICAgIHByZWNpbmN0SXRlcmF0b3JPcHRpb25hbCk7XHJcblxyXG4gICAgICAgIHZhciBudW1RdWFsaXR5TGF5ZXJzUmVhY2hlZCA9IHF1YWxpdHlMYXllcnMubnVtUXVhbGl0eUxheWVycztcclxuICAgICAgICBhY2N1bXVsYXRlZERhdGEubnVtUXVhbGl0eUxheWVyc1JlYWNoZWQgPSBudW1RdWFsaXR5TGF5ZXJzUmVhY2hlZDtcclxuXHJcbiAgICAgICAgdmFyIG1heE51bVF1YWxpdHlMYXllcnNJblRpbGUgPVxyXG4gICAgICAgICAgICBhY2N1bXVsYXRlZERhdGEubWF4TnVtUXVhbGl0eUxheWVyc0luVGlsZTtcclxuXHJcbiAgICAgICAgaWYgKG51bVF1YWxpdHlMYXllcnNSZWFjaGVkID09PSBtYXhOdW1RdWFsaXR5TGF5ZXJzSW5UaWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHByZXZDb3VudCA9XHJcbiAgICAgICAgICAgIHByZWNpbmN0Q291bnRCeVJlYWNoZWRRdWFsaXR5TGF5ZXJbbnVtUXVhbGl0eUxheWVyc1JlYWNoZWRdIHx8IDA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcHJlY2luY3RDb3VudEJ5UmVhY2hlZFF1YWxpdHlMYXllcltudW1RdWFsaXR5TGF5ZXJzUmVhY2hlZF0gPVxyXG4gICAgICAgICAgICBwcmV2Q291bnQgKyAxO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiB0cnlBZHZhbmNlUXVhbGl0eUxheWVyc1JlYWNoZWQoKSB7XHJcbiAgICAgICAgaWYgKHByZWNpbmN0Q291bnRCeVJlYWNoZWRRdWFsaXR5TGF5ZXJbbWluTnVtUXVhbGl0eUxheWVyc1JlYWNoZWRdID4gMCB8fFxyXG4gICAgICAgICAgICBtaW5OdW1RdWFsaXR5TGF5ZXJzUmVhY2hlZCA9PT0gJ21heCcgfHxcclxuICAgICAgICAgICAgbWluTnVtUXVhbGl0eUxheWVyc1JlYWNoZWQgPj0gbnVtUXVhbGl0eUxheWVyc1RvV2FpdEZvciB8fFxyXG4gICAgICAgICAgICB0aWxlSGVhZGVyc05vdExvYWRlZCA+IDApIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGhhc1ByZWNpbmN0c0luUXVhbGl0eUxheWVyO1xyXG4gICAgICAgIHZhciBtYXhRdWFsaXR5TGF5ZXJzID0gcHJlY2luY3RDb3VudEJ5UmVhY2hlZFF1YWxpdHlMYXllci5sZW5ndGg7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICArK21pbk51bVF1YWxpdHlMYXllcnNSZWFjaGVkO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKG1pbk51bVF1YWxpdHlMYXllcnNSZWFjaGVkID49IG1heFF1YWxpdHlMYXllcnMpIHtcclxuICAgICAgICAgICAgICAgIG1pbk51bVF1YWxpdHlMYXllcnNSZWFjaGVkID0gJ21heCc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaGFzUHJlY2luY3RzSW5RdWFsaXR5TGF5ZXIgPVxyXG4gICAgICAgICAgICAgICAgcHJlY2luY3RDb3VudEJ5UmVhY2hlZFF1YWxpdHlMYXllclttaW5OdW1RdWFsaXR5TGF5ZXJzUmVhY2hlZF0gPiAwO1xyXG4gICAgICAgIH0gd2hpbGUgKCFoYXNQcmVjaW5jdHNJblF1YWxpdHlMYXllcik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcXVhbGl0eUxheWVyUmVhY2hlZENhbGxiYWNrKG1pbk51bVF1YWxpdHlMYXllcnNSZWFjaGVkKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gZW5zdXJlUXVhbGl0eUxheWVyc1N0YXRpc3RpY3NGb3JEZWJ1ZygpIHtcclxuICAgICAgICB2YXIgcHJlY2luY3RDb3VudEJ5UmVhY2hlZFF1YWxpdHlMYXllckV4cGVjdGVkID0gW107XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RlcmVkUHJlY2luY3REYXRhYmlucy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgYWNjdW11bGF0ZWREYXRhID0gYWNjdW11bGF0ZWREYXRhUGVyRGF0YWJpbi5nZXRPYmplY3QoXHJcbiAgICAgICAgICAgICAgICByZWdpc3RlcmVkUHJlY2luY3REYXRhYmluc1tpXSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgbWF4TnVtUXVhbGl0eUxheWVyc0luVGlsZSA9XHJcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZERhdGEubWF4TnVtUXVhbGl0eUxheWVyc0luVGlsZTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAobWF4TnVtUXVhbGl0eUxheWVyc0luVGlsZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAnTm8gaW5mb3JtYXRpb24gb2YgbWF4TnVtUXVhbGl0eUxheWVyc0luVGlsZSBpbiAnICtcclxuICAgICAgICAgICAgICAgICAgICAnSnBpcFJlcXVlc3REYXRhYmluc0xpc3RlbmVyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBxdWFsaXR5TGF5ZXJzID0gcXVhbGl0eUxheWVyc0NhY2hlLmdldFF1YWxpdHlMYXllck9mZnNldChcclxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWRQcmVjaW5jdERhdGFiaW5zW2ldLFxyXG4gICAgICAgICAgICAgICAgY29kZXN0cmVhbVBhcnRQYXJhbXMubWF4TnVtUXVhbGl0eUxheWVycyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAocXVhbGl0eUxheWVycy5udW1RdWFsaXR5TGF5ZXJzID09PSBtYXhOdW1RdWFsaXR5TGF5ZXJzSW5UaWxlKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gcHJlY2luY3RDb3VudEJ5UmVhY2hlZFF1YWxpdHlMYXllckV4cGVjdGVkW1xyXG4gICAgICAgICAgICAgICAgcXVhbGl0eUxheWVycy5udW1RdWFsaXR5TGF5ZXJzXTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHByZWNpbmN0Q291bnRCeVJlYWNoZWRRdWFsaXR5TGF5ZXJFeHBlY3RlZFtcclxuICAgICAgICAgICAgICAgIHF1YWxpdHlMYXllcnMubnVtUXVhbGl0eUxheWVyc10gPSAob2xkVmFsdWUgfHwgMCkgKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgIHByZWNpbmN0Q291bnRCeVJlYWNoZWRRdWFsaXR5TGF5ZXJFeHBlY3RlZC5sZW5ndGgsXHJcbiAgICAgICAgICAgIHByZWNpbmN0Q291bnRCeVJlYWNoZWRRdWFsaXR5TGF5ZXIubGVuZ3RoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgdmFyIG1pbk51bVF1YWxpdHlMYXllcnNSZWFjaGVkRXhwZWN0ZWQgPSAnbWF4JztcclxuICAgICAgICBcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgIHZhciBpc0V4cGVjdGVkWmVybyA9IChwcmVjaW5jdENvdW50QnlSZWFjaGVkUXVhbGl0eUxheWVyRXhwZWN0ZWRbal0gfHwgMCkgPT09IDA7XHJcbiAgICAgICAgICAgIHZhciBpc0FjdHVhbFplcm8gPSAocHJlY2luY3RDb3VudEJ5UmVhY2hlZFF1YWxpdHlMYXllcltqXSB8fCAwKSA9PT0gMDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChpc0V4cGVjdGVkWmVybyAhPT0gaXNBY3R1YWxaZXJvKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAnV3JvbmcgYWNjdW11bGF0ZWQgc3RhdGlzdGljcyBpbiBKcGlwUmVxdWVzdERhdGFiaW5zTGlzdGVuZXInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGlzRXhwZWN0ZWRaZXJvKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHByZWNpbmN0Q291bnRCeVJlYWNoZWRRdWFsaXR5TGF5ZXJbal0gIT09XHJcbiAgICAgICAgICAgICAgICBwcmVjaW5jdENvdW50QnlSZWFjaGVkUXVhbGl0eUxheWVyRXhwZWN0ZWRbal0pIHtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24oJ1dyb25nICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdhY2N1bXVsYXRlZCBzdGF0aXN0aWNzIGluIEpwaXBSZXF1ZXN0RGF0YWJpbnNMaXN0ZW5lcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAobWluTnVtUXVhbGl0eUxheWVyc1JlYWNoZWRFeHBlY3RlZCA9PT0gJ21heCcpIHtcclxuICAgICAgICAgICAgICAgIG1pbk51bVF1YWxpdHlMYXllcnNSZWFjaGVkRXhwZWN0ZWQgPSBqO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChtaW5OdW1RdWFsaXR5TGF5ZXJzUmVhY2hlZCAhPT0gbWluTnVtUXVhbGl0eUxheWVyc1JlYWNoZWRFeHBlY3RlZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICdXcm9uZyBtaW5OdW1RdWFsaXR5TGF5ZXJzUmVhY2hlZCBpbiBKcGlwUmVxdWVzdERhdGFiaW5zTGlzdGVuZXInKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGpHbG9iYWxzID0gcmVxdWlyZSgnajJrLWpwaXAtZ2xvYmFscy5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuSnBpcENvZGVzdHJlYW1TdHJ1Y3R1cmUgPSBmdW5jdGlvbiBKcGlwQ29kZXN0cmVhbVN0cnVjdHVyZShcclxuICAgIGpwaXBTdHJ1Y3R1cmVQYXJzZXIsXHJcbiAgICBqcGlwRmFjdG9yeSxcclxuICAgIHByb2dyZXNzaW9uT3JkZXIpIHtcclxuXHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB2YXIgcGFyYW1zO1xyXG4gICAgdmFyIHNpemVzQ2FsY3VsYXRvcjtcclxuICAgIFxyXG4gICAgdmFyIGRlZmF1bHRUaWxlU3RydWN0dXJlQnlFZGdlVHlwZTtcclxuXHJcbiAgICB2YXIgY2FjaGVkVGlsZVN0cnVjdHVyZXMgPSBbXTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRTaXplc1BhcmFtcyA9IGZ1bmN0aW9uIGdldFNpemVzUGFyYW1zKCkge1xyXG4gICAgICAgIHZhbGlkYXRlUGFyYW1zKCk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0TnVtVGlsZXNYID0gZnVuY3Rpb24gZ2V0TnVtVGlsZXNYKCkge1xyXG4gICAgICAgIHZhbGlkYXRlUGFyYW1zKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIG51bVRpbGVzID0gc2l6ZXNDYWxjdWxhdG9yLmdldE51bVRpbGVzWCgpO1xyXG4gICAgICAgIHJldHVybiBudW1UaWxlcztcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0TnVtVGlsZXNZID0gZnVuY3Rpb24gZ2V0TnVtVGlsZXNZKCkge1xyXG4gICAgICAgIHZhbGlkYXRlUGFyYW1zKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIG51bVRpbGVzID0gc2l6ZXNDYWxjdWxhdG9yLmdldE51bVRpbGVzWSgpO1xyXG4gICAgICAgIHJldHVybiBudW1UaWxlcztcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5nZXROdW1Db21wb25lbnRzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFsaWRhdGVQYXJhbXMoKTtcclxuICAgICAgICByZXR1cm4gcGFyYW1zLm51bUNvbXBvbmVudHM7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldEltYWdlV2lkdGggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YWxpZGF0ZVBhcmFtcygpO1xyXG5cclxuICAgICAgICB2YXIgc2l6ZSA9IHNpemVzQ2FsY3VsYXRvci5nZXRMZXZlbFdpZHRoKCk7XHJcbiAgICAgICAgcmV0dXJuIHNpemU7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldEltYWdlSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFsaWRhdGVQYXJhbXMoKTtcclxuXHJcbiAgICAgICAgdmFyIHNpemUgPSBzaXplc0NhbGN1bGF0b3IuZ2V0TGV2ZWxIZWlnaHQoKTtcclxuICAgICAgICByZXR1cm4gc2l6ZTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0TGV2ZWxXaWR0aCA9IGZ1bmN0aW9uKG51bVJlc29sdXRpb25MZXZlbHNUb0N1dCkge1xyXG4gICAgICAgIHZhbGlkYXRlUGFyYW1zKCk7XHJcblxyXG4gICAgICAgIHZhciBzaXplID0gc2l6ZXNDYWxjdWxhdG9yLmdldExldmVsV2lkdGgobnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0KTtcclxuICAgICAgICByZXR1cm4gc2l6ZTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0TGV2ZWxIZWlnaHQgPSBmdW5jdGlvbihudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQpIHtcclxuICAgICAgICB2YWxpZGF0ZVBhcmFtcygpO1xyXG5cclxuICAgICAgICB2YXIgc2l6ZSA9IHNpemVzQ2FsY3VsYXRvci5nZXRMZXZlbEhlaWdodChudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQpO1xyXG4gICAgICAgIHJldHVybiBzaXplO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRUaWxlV2lkdGggPSBmdW5jdGlvbihudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQpIHtcclxuICAgICAgICB2YWxpZGF0ZVBhcmFtcygpO1xyXG5cclxuICAgICAgICB2YXIgc2l6ZSA9IHNpemVzQ2FsY3VsYXRvci5nZXRUaWxlV2lkdGgobnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0KTtcclxuICAgICAgICByZXR1cm4gc2l6ZTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0VGlsZUhlaWdodCA9IGZ1bmN0aW9uKG51bVJlc29sdXRpb25MZXZlbHNUb0N1dCkge1xyXG4gICAgICAgIHZhbGlkYXRlUGFyYW1zKCk7XHJcblxyXG4gICAgICAgIHZhciBzaXplID0gc2l6ZXNDYWxjdWxhdG9yLmdldFRpbGVIZWlnaHQobnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0KTtcclxuICAgICAgICByZXR1cm4gc2l6ZTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0Rmlyc3RUaWxlT2Zmc2V0WCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhbGlkYXRlUGFyYW1zKCk7XHJcblxyXG4gICAgICAgIHZhciBvZmZzZXQgPSBzaXplc0NhbGN1bGF0b3IuZ2V0Rmlyc3RUaWxlT2Zmc2V0WCgpO1xyXG4gICAgICAgIHJldHVybiBvZmZzZXQ7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldEZpcnN0VGlsZU9mZnNldFkgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YWxpZGF0ZVBhcmFtcygpO1xyXG5cclxuICAgICAgICB2YXIgb2Zmc2V0ID0gc2l6ZXNDYWxjdWxhdG9yLmdldEZpcnN0VGlsZU9mZnNldFkoKTtcclxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRUaWxlTGVmdCA9IGZ1bmN0aW9uIGdldFRpbGVMZWZ0KFxyXG4gICAgICAgIHRpbGVJbmRleCwgbnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0KSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFsaWRhdGVQYXJhbXMoKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgdGlsZVggPSB0aWxlSW5kZXggJSBzaXplc0NhbGN1bGF0b3IuZ2V0TnVtVGlsZXNYKCk7XHJcbiAgICAgICAgaWYgKHRpbGVYID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgdGlsZUxlZnQgPVxyXG4gICAgICAgICAgICAodGlsZVggLSAxKSAqIHNpemVzQ2FsY3VsYXRvci5nZXRUaWxlV2lkdGgobnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0KSArXHJcbiAgICAgICAgICAgIHNpemVzQ2FsY3VsYXRvci5nZXRGaXJzdFRpbGVXaWR0aChudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiB0aWxlTGVmdDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0VGlsZVRvcCA9IGZ1bmN0aW9uIGdldFRpbGVUb3AodGlsZUluZGV4LCBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQpIHtcclxuICAgICAgICB2YWxpZGF0ZVBhcmFtcygpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciB0aWxlWSA9IE1hdGguZmxvb3IodGlsZUluZGV4IC8gc2l6ZXNDYWxjdWxhdG9yLmdldE51bVRpbGVzWCgpKTtcclxuICAgICAgICBpZiAodGlsZVkgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciB0aWxlVG9wID1cclxuICAgICAgICAgICAgKHRpbGVZIC0gMSkgKiBzaXplc0NhbGN1bGF0b3IuZ2V0VGlsZUhlaWdodChudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQpICtcclxuICAgICAgICAgICAgc2l6ZXNDYWxjdWxhdG9yLmdldEZpcnN0VGlsZUhlaWdodChudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiB0aWxlVG9wO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXREZWZhdWx0VGlsZVN0cnVjdHVyZSA9IGZ1bmN0aW9uIGdldERlZmF1bHRUaWxlU3RydWN0dXJlKCkge1xyXG4gICAgICAgIHZhbGlkYXRlUGFyYW1zKCk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGdldERlZmF1bHRUaWxlU3RydWN0dXJlSW50ZXJuYWwoe1xyXG4gICAgICAgICAgICBob3Jpem9udGFsRWRnZVR5cGU6IHNpemVzQ2FsY3VsYXRvci5FREdFX1RZUEVfTk9fRURHRSxcclxuICAgICAgICAgICAgdmVydGljYWxFZGdlVHlwZTogc2l6ZXNDYWxjdWxhdG9yLkVER0VfVFlQRV9OT19FREdFXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRUaWxlU3RydWN0dXJlID0gZ2V0VGlsZVN0cnVjdHVyZTtcclxuXHJcbiAgICB0aGlzLnRpbGVQb3NpdGlvblRvSW5DbGFzc0luZGV4ID0gZnVuY3Rpb24odGlsZVBvc2l0aW9uKSB7XHJcbiAgICAgICAgdmFsaWRhdGVQYXJhbXMoKTtcclxuICAgICAgICB2YXIgdGlsZXNYID0gc2l6ZXNDYWxjdWxhdG9yLmdldE51bVRpbGVzWCgpO1xyXG4gICAgICAgIHZhciB0aWxlc1kgPSBzaXplc0NhbGN1bGF0b3IuZ2V0TnVtVGlsZXNZKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFsaWRhdGVBcmd1bWVudEluUmFuZ2UoJ3RpbGVQb3NpdGlvbi50aWxlWCcsIHRpbGVQb3NpdGlvbi50aWxlWCwgdGlsZXNYKTtcclxuICAgICAgICB2YWxpZGF0ZUFyZ3VtZW50SW5SYW5nZSgndGlsZVBvc2l0aW9uLnRpbGVZJywgdGlsZVBvc2l0aW9uLnRpbGVZLCB0aWxlc1kpO1xyXG5cclxuICAgICAgICB2YXIgaW5DbGFzc0luZGV4ID0gdGlsZVBvc2l0aW9uLnRpbGVYICsgdGlsZVBvc2l0aW9uLnRpbGVZICogdGlsZXNYO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBpbkNsYXNzSW5kZXg7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMudGlsZUluQ2xhc3NJbmRleFRvUG9zaXRpb24gPSBmdW5jdGlvbihpbkNsYXNzSW5kZXgpIHtcclxuICAgICAgICB2YWxpZGF0ZVBhcmFtcygpO1xyXG4gICAgICAgIHZhciB0aWxlc1ggPSBzaXplc0NhbGN1bGF0b3IuZ2V0TnVtVGlsZXNYKCk7XHJcbiAgICAgICAgdmFyIHRpbGVzWSA9IHNpemVzQ2FsY3VsYXRvci5nZXROdW1UaWxlc1koKTtcclxuICAgICAgICB2YXIgbnVtVGlsZXMgPSB0aWxlc1ggKiB0aWxlc1k7XHJcblxyXG4gICAgICAgIHZhbGlkYXRlQXJndW1lbnRJblJhbmdlKCdpbkNsYXNzSW5kZXgnLCBpbkNsYXNzSW5kZXgsIHRpbGVzWCAqIHRpbGVzWSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHRpbGVYID0gaW5DbGFzc0luZGV4ICUgdGlsZXNYO1xyXG4gICAgICAgIHZhciB0aWxlWSA9IChpbkNsYXNzSW5kZXggLSB0aWxlWCkgLyB0aWxlc1g7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgdGlsZVg6IHRpbGVYLFxyXG4gICAgICAgICAgICB0aWxlWTogdGlsZVlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRUaWxlc0l0ZXJhdG9yID0gZnVuY3Rpb24gZ2V0VGlsZXNJdGVyYXRvcihjb2Rlc3RyZWFtUGFydFBhcmFtcykge1xyXG4gICAgICAgIHZhbGlkYXRlUGFyYW1zKCk7XHJcbiAgICAgICAgdmFyIGJvdW5kcyA9IHNpemVzQ2FsY3VsYXRvci5nZXRUaWxlc0Zyb21QaXhlbHMoY29kZXN0cmVhbVBhcnRQYXJhbXMpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBzZXRhYmxlSXRlcmF0b3IgPSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRYOiBib3VuZHMubWluVGlsZVgsXHJcbiAgICAgICAgICAgIGN1cnJlbnRZOiBib3VuZHMubWluVGlsZVlcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBpdGVyYXRvciA9IHtcclxuICAgICAgICAgICAgZ2V0IHRpbGVJbmRleCgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaXJzdEluUm93ID1cclxuICAgICAgICAgICAgICAgICAgICBzZXRhYmxlSXRlcmF0b3IuY3VycmVudFkgKiBzaXplc0NhbGN1bGF0b3IuZ2V0TnVtVGlsZXNYKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBmaXJzdEluUm93ICsgc2V0YWJsZUl0ZXJhdG9yLmN1cnJlbnRYO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0cnlBZHZhbmNlOiBmdW5jdGlvbiB0cnlBZHZhbmNlKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUFkdmFuY2VUaWxlSXRlcmF0b3Ioc2V0YWJsZUl0ZXJhdG9yLCBib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRTaXplT2ZQYXJ0ID0gZnVuY3Rpb24gZ2V0U2l6ZU9mUGFydChjb2Rlc3RyZWFtUGFydFBhcmFtcykge1xyXG4gICAgICAgIHZhbGlkYXRlUGFyYW1zKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHNpemUgPSBzaXplc0NhbGN1bGF0b3IuZ2V0U2l6ZU9mUGFydChjb2Rlc3RyZWFtUGFydFBhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIHNpemU7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiB0cnlBZHZhbmNlVGlsZUl0ZXJhdG9yKHNldGFibGVJdGVyYXRvciwgYm91bmRzKSB7XHJcbiAgICAgICAgaWYgKHNldGFibGVJdGVyYXRvci5jdXJyZW50WSA+PSBib3VuZHMubWF4VGlsZVlFeGNsdXNpdmUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAnQ2Fubm90IGFkdmFuY2UgdGlsZSBpdGVyYXRvciBhZnRlciBlbmQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgKytzZXRhYmxlSXRlcmF0b3IuY3VycmVudFg7XHJcbiAgICAgICAgaWYgKHNldGFibGVJdGVyYXRvci5jdXJyZW50WCA8IGJvdW5kcy5tYXhUaWxlWEV4Y2x1c2l2ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgc2V0YWJsZUl0ZXJhdG9yLmN1cnJlbnRYID0gYm91bmRzLm1pblRpbGVYO1xyXG4gICAgICAgICsrc2V0YWJsZUl0ZXJhdG9yLmN1cnJlbnRZO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBpc01vcmVUaWxlc0F2YWlsYWJsZSA9XHJcbiAgICAgICAgICAgIHNldGFibGVJdGVyYXRvci5jdXJyZW50WSA8IGJvdW5kcy5tYXhUaWxlWUV4Y2x1c2l2ZTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gaXNNb3JlVGlsZXNBdmFpbGFibGU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGdldFRpbGVTdHJ1Y3R1cmUodGlsZUlkKSB7XHJcbiAgICAgICAgdmFsaWRhdGVQYXJhbXMoKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgbWF4VGlsZUlkID1cclxuICAgICAgICAgICAgc2l6ZXNDYWxjdWxhdG9yLmdldE51bVRpbGVzWCgpICogc2l6ZXNDYWxjdWxhdG9yLmdldE51bVRpbGVzWSgpLSAxO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh0aWxlSWQgPCAwIHx8IHRpbGVJZCA+IG1heFRpbGVJZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuQXJndW1lbnRFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAndGlsZUlkJyxcclxuICAgICAgICAgICAgICAgIHRpbGVJZCxcclxuICAgICAgICAgICAgICAgICdFeHBlY3RlZCB2YWx1ZSBiZXR3ZWVuIDAgYW5kICcgKyBtYXhUaWxlSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgaXNFZGdlID0gc2l6ZXNDYWxjdWxhdG9yLmlzRWRnZVRpbGVJZCh0aWxlSWQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChjYWNoZWRUaWxlU3RydWN0dXJlc1t0aWxlSWRdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFyIHRpbGVQYXJhbXMgPSBqcGlwU3RydWN0dXJlUGFyc2VyLnBhcnNlT3ZlcnJpZGVuVGlsZVBhcmFtcyh0aWxlSWQpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKCEhdGlsZVBhcmFtcykge1xyXG4gICAgICAgICAgICAgICAgY2FjaGVkVGlsZVN0cnVjdHVyZXNbdGlsZUlkXSA9IGNyZWF0ZVRpbGVTdHJ1Y3R1cmUodGlsZVBhcmFtcywgaXNFZGdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNhY2hlZFRpbGVTdHJ1Y3R1cmVzW3RpbGVJZF0gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChjYWNoZWRUaWxlU3RydWN0dXJlc1t0aWxlSWRdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRUaWxlU3RydWN0dXJlc1t0aWxlSWRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0RGVmYXVsdFRpbGVTdHJ1Y3R1cmVJbnRlcm5hbChpc0VkZ2UpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVBcmd1bWVudEluUmFuZ2UocGFyYW1OYW1lLCBwYXJhbVZhbHVlLCBzdXByaW11bVBhcmFtVmFsdWUpIHtcclxuICAgICAgICBpZiAocGFyYW1WYWx1ZSA8IDAgfHwgcGFyYW1WYWx1ZSA+PSBzdXByaW11bVBhcmFtVmFsdWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkFyZ3VtZW50RXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1WYWx1ZSxcclxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZSArICcgaXMgZXhwZWN0ZWQgdG8gYmUgYmV0d2VlbiAwIGFuZCAnICsgc3VwcmltdW1QYXJhbVZhbHVlIC0gMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBnZXREZWZhdWx0VGlsZVN0cnVjdHVyZUludGVybmFsKGVkZ2VUeXBlKSB7XHJcbiAgICAgICAgaWYgKCFkZWZhdWx0VGlsZVN0cnVjdHVyZUJ5RWRnZVR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIGRlZmF1bHRUaWxlUGFyYW1zID0ganBpcFN0cnVjdHVyZVBhcnNlci5wYXJzZURlZmF1bHRUaWxlUGFyYW1zKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBkZWZhdWx0VGlsZVN0cnVjdHVyZUJ5RWRnZVR5cGUgPSBuZXcgQXJyYXkoMyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBmb3IgKHZhciBob3Jpem9udGFsRWRnZSA9IDA7IGhvcml6b250YWxFZGdlIDwgMzsgKytob3Jpem9udGFsRWRnZSkge1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdFRpbGVTdHJ1Y3R1cmVCeUVkZ2VUeXBlW2hvcml6b250YWxFZGdlXSA9IG5ldyBBcnJheSgzKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdmVydGljYWxFZGdlID0gMDsgdmVydGljYWxFZGdlIDwgMzsgKyt2ZXJ0aWNhbEVkZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWRnZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9yaXpvbnRhbEVkZ2VUeXBlOiBob3Jpem9udGFsRWRnZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljYWxFZGdlVHlwZTogdmVydGljYWxFZGdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFRpbGVTdHJ1Y3R1cmVCeUVkZ2VUeXBlW2hvcml6b250YWxFZGdlXVt2ZXJ0aWNhbEVkZ2VdID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlVGlsZVN0cnVjdHVyZShkZWZhdWx0VGlsZVBhcmFtcywgZWRnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHN0cnVjdHVyZUJ5VmVydGljYWxUeXBlID1cclxuICAgICAgICAgICAgZGVmYXVsdFRpbGVTdHJ1Y3R1cmVCeUVkZ2VUeXBlW2VkZ2VUeXBlLmhvcml6b250YWxFZGdlVHlwZV07XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHRpbGVTdHJ1Y3R1cmUgPSBzdHJ1Y3R1cmVCeVZlcnRpY2FsVHlwZVtlZGdlVHlwZS52ZXJ0aWNhbEVkZ2VUeXBlXTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gdGlsZVN0cnVjdHVyZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gY3JlYXRlVGlsZVN0cnVjdHVyZSh0aWxlUGFyYW1zLCBlZGdlVHlwZSkge1xyXG4gICAgICAgIHZhbGlkYXRlUGFyYW1zKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHNpemVQYXJhbXMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRpbGVQYXJhbXMpKTtcclxuICAgICAgICBcclxuICAgICAgICBzaXplUGFyYW1zLnRpbGVTaXplID0gc2l6ZXNDYWxjdWxhdG9yLmdldFRpbGVTaXplKGVkZ2VUeXBlKTtcclxuICAgICAgICBcclxuICAgICAgICBzaXplUGFyYW1zLmRlZmF1bHRDb21wb25lbnRQYXJhbXMuc2NhbGVYID0gMTtcclxuICAgICAgICBzaXplUGFyYW1zLmRlZmF1bHRDb21wb25lbnRQYXJhbXMuc2NhbGVZID0gMTtcclxuICAgICAgICBcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemVQYXJhbXMucGFyYW1zUGVyQ29tcG9uZW50Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHNpemVQYXJhbXMucGFyYW1zUGVyQ29tcG9uZW50W2ldLnNjYWxlWCA9IHBhcmFtcy5jb21wb25lbnRzU2NhbGVYW2ldO1xyXG4gICAgICAgICAgICBzaXplUGFyYW1zLnBhcmFtc1BlckNvbXBvbmVudFtpXS5zY2FsZVkgPSBwYXJhbXMuY29tcG9uZW50c1NjYWxlWVtpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHRpbGVTdHJ1Y3R1cmUgPSBqcGlwRmFjdG9yeS5jcmVhdGVUaWxlU3RydWN0dXJlKHNpemVQYXJhbXMsIHNlbGYsIHByb2dyZXNzaW9uT3JkZXIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiB0aWxlU3RydWN0dXJlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVBhcmFtcyhzZWxmKSB7XHJcbiAgICAgICAgaWYgKCFwYXJhbXMpIHtcclxuICAgICAgICAgICAgcGFyYW1zID0ganBpcFN0cnVjdHVyZVBhcnNlci5wYXJzZUNvZGVzdHJlYW1TdHJ1Y3R1cmUoKTtcclxuICAgICAgICAgICAgc2l6ZXNDYWxjdWxhdG9yID0ganBpcEZhY3RvcnkuY3JlYXRlQ29kZXN0cmVhbVNpemVzQ2FsY3VsYXRvcihcclxuICAgICAgICAgICAgICAgIHBhcmFtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gdGhpcztcclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgakdsb2JhbHMgPSByZXF1aXJlKCdqMmstanBpcC1nbG9iYWxzLmpzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5KcGlwQ29tcG9uZW50U3RydWN0dXJlID0gZnVuY3Rpb24gSnBpcENvbXBvbmVudFN0cnVjdHVyZShcclxuICAgIHBhcmFtcywgdGlsZVN0cnVjdHVyZSkge1xyXG4gICAgXHJcbiAgICB2YXIgdGlsZVdpZHRoTGV2ZWwwO1xyXG4gICAgdmFyIHRpbGVIZWlnaHRMZXZlbDA7XHJcbiAgICBcclxuICAgIGluaXRpYWxpemUoKTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRDb21wb25lbnRTY2FsZVggPSBmdW5jdGlvbiBnZXRDb21wb25lbnRTY2FsZVgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5zY2FsZVg7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldENvbXBvbmVudFNjYWxlWSA9IGZ1bmN0aW9uIGdldENvbXBvbmVudFNjYWxlWSgpIHtcclxuICAgICAgICByZXR1cm4gcGFyYW1zLnNjYWxlWTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0TnVtUmVzb2x1dGlvbkxldmVscyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBwYXJhbXMubnVtUmVzb2x1dGlvbkxldmVscztcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0UHJlY2luY3RXaWR0aCA9IGZ1bmN0aW9uKHJlc29sdXRpb25MZXZlbCkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHBhcmFtcy5wcmVjaW5jdFdpZHRoUGVyTGV2ZWxbcmVzb2x1dGlvbkxldmVsXTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gd2lkdGg7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldFByZWNpbmN0SGVpZ2h0ID0gZnVuY3Rpb24ocmVzb2x1dGlvbkxldmVsKSB7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHBhcmFtcy5wcmVjaW5jdEhlaWdodFBlckxldmVsW3Jlc29sdXRpb25MZXZlbF07XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGhlaWdodDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0TWF4Q29kZWJsb2NrV2lkdGggPSBmdW5jdGlvbiBnZXRNYXhDb2RlYmxvY2tXaWR0aCgpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSBwYXJhbXMubWF4Q29kZWJsb2NrV2lkdGg7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHdpZHRoO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRNYXhDb2RlYmxvY2tIZWlnaHQgPSBmdW5jdGlvbiBnZXRNYXhDb2RlYmxvY2tIZWlnaHQoKSB7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHBhcmFtcy5tYXhDb2RlYmxvY2tIZWlnaHQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGhlaWdodDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0TnVtQ29kZWJsb2Nrc1hJblByZWNpbmN0ID1cclxuICAgICAgICBmdW5jdGlvbiBnZXROdW1Db2RlYmxvY2tzWChwcmVjaW5jdCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBudW1Db2RlYmxvY2tzWCA9IGNhbGN1bGF0ZU51bUNvZGVibG9ja3MoXHJcbiAgICAgICAgICAgIHByZWNpbmN0LFxyXG4gICAgICAgICAgICBwcmVjaW5jdC5wcmVjaW5jdFgsXHJcbiAgICAgICAgICAgIHBhcmFtcy5tYXhDb2RlYmxvY2tXaWR0aCxcclxuICAgICAgICAgICAgcGFyYW1zLnByZWNpbmN0V2lkdGhQZXJMZXZlbCxcclxuICAgICAgICAgICAgdGlsZVdpZHRoTGV2ZWwwKTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gbnVtQ29kZWJsb2Nrc1g7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldE51bUNvZGVibG9ja3NZSW5QcmVjaW5jdCA9XHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0TnVtQ29kZWJsb2Nrc1kocHJlY2luY3QpIHtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgbnVtQ29kZWJsb2Nrc1kgPSBjYWxjdWxhdGVOdW1Db2RlYmxvY2tzKFxyXG4gICAgICAgICAgICBwcmVjaW5jdCxcclxuICAgICAgICAgICAgcHJlY2luY3QucHJlY2luY3RZLFxyXG4gICAgICAgICAgICBwYXJhbXMubWF4Q29kZWJsb2NrSGVpZ2h0LFxyXG4gICAgICAgICAgICBwYXJhbXMucHJlY2luY3RIZWlnaHRQZXJMZXZlbCxcclxuICAgICAgICAgICAgdGlsZUhlaWdodExldmVsMCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIG51bUNvZGVibG9ja3NZO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLmdldE51bVByZWNpbmN0c1ggPSBmdW5jdGlvbihyZXNvbHV0aW9uTGV2ZWwpIHtcclxuICAgICAgICB2YXIgcHJlY2luY3RzWCA9IGNhbGN1bGF0ZU51bVByZWNpbmN0cyhcclxuICAgICAgICAgICAgdGlsZVdpZHRoTGV2ZWwwLCBwYXJhbXMucHJlY2luY3RXaWR0aFBlckxldmVsLCByZXNvbHV0aW9uTGV2ZWwpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICByZXR1cm4gcHJlY2luY3RzWDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0TnVtUHJlY2luY3RzWSA9IGZ1bmN0aW9uKHJlc29sdXRpb25MZXZlbCkge1xyXG4gICAgICAgIHZhciBwcmVjaW5jdHNZID0gY2FsY3VsYXRlTnVtUHJlY2luY3RzKFxyXG4gICAgICAgICAgICB0aWxlSGVpZ2h0TGV2ZWwwLCBwYXJhbXMucHJlY2luY3RIZWlnaHRQZXJMZXZlbCwgcmVzb2x1dGlvbkxldmVsKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHByZWNpbmN0c1k7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVOdW1QcmVjaW5jdHMoXHJcbiAgICAgICAgdGlsZVNpemVMZXZlbDAsIHByZWNpbmN0U2l6ZVBlckxldmVsLCByZXNvbHV0aW9uTGV2ZWwpIHtcclxuICAgIFxyXG4gICAgICAgIHZhciByZXNvbHV0aW9uRmFjdG9yID0gZ2V0UmVzb2x1dGlvbkZhY3RvcihyZXNvbHV0aW9uTGV2ZWwpO1xyXG4gICAgICAgIHZhciB0aWxlU2l6ZUluTGV2ZWwgPSB0aWxlU2l6ZUxldmVsMCAvIHJlc29sdXRpb25GYWN0b3I7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHByZWNpbmN0U2l6ZUluTGV2ZWwgPSBwcmVjaW5jdFNpemVQZXJMZXZlbFtyZXNvbHV0aW9uTGV2ZWxdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBudW1QcmVjaW5jdHMgPSBNYXRoLmNlaWwodGlsZVNpemVJbkxldmVsIC8gcHJlY2luY3RTaXplSW5MZXZlbCk7XHJcbiAgICAgICAgcmV0dXJuIG51bVByZWNpbmN0cztcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlTnVtQ29kZWJsb2NrcyhcclxuICAgICAgICBwcmVjaW5jdCxcclxuICAgICAgICBwcmVjaW5jdEluZGV4LFxyXG4gICAgICAgIG1heENvZGVibG9ja1NpemUsXHJcbiAgICAgICAgcHJlY2luY3RTaXplUGVyTGV2ZWwsXHJcbiAgICAgICAgdGlsZVNpemVMZXZlbDApIHtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgcmVzb2x1dGlvbkZhY3RvciA9IGdldFJlc29sdXRpb25GYWN0b3IocHJlY2luY3QucmVzb2x1dGlvbkxldmVsKTtcclxuICAgICAgICB2YXIgdGlsZVNpemVJbkxldmVsID0gTWF0aC5jZWlsKHRpbGVTaXplTGV2ZWwwIC8gcmVzb2x1dGlvbkZhY3Rvcik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHByZWNpbmN0QmVnaW5QaXhlbCA9XHJcbiAgICAgICAgICAgIHByZWNpbmN0SW5kZXggKiBwcmVjaW5jdFNpemVQZXJMZXZlbFtwcmVjaW5jdC5yZXNvbHV0aW9uTGV2ZWxdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBwcmVjaW5jdFNpemUgPSBNYXRoLm1pbihcclxuICAgICAgICAgICAgcHJlY2luY3RTaXplUGVyTGV2ZWxbcHJlY2luY3QucmVzb2x1dGlvbkxldmVsXSxcclxuICAgICAgICAgICAgdGlsZVNpemVJbkxldmVsIC0gcHJlY2luY3RCZWdpblBpeGVsKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgc3ViYmFuZFR5cGVGYWN0b3IgPSBwcmVjaW5jdC5yZXNvbHV0aW9uTGV2ZWwgPT09IDAgPyAxIDogMjtcclxuICAgICAgICB2YXIgc3ViYmFuZE9mUHJlY2luY3RTaXplID0gTWF0aC5jZWlsKHByZWNpbmN0U2l6ZSAvIHN1YmJhbmRUeXBlRmFjdG9yKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgbnVtQ29kZWJsb2NrcyA9IHN1YmJhbmRUeXBlRmFjdG9yICogTWF0aC5jZWlsKFxyXG4gICAgICAgICAgICBzdWJiYW5kT2ZQcmVjaW5jdFNpemUgLyBtYXhDb2RlYmxvY2tTaXplKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAocHJlY2luY3RTaXplICUgbWF4Q29kZWJsb2NrU2l6ZSA9PT0gMSAmJlxyXG4gICAgICAgICAgICBwcmVjaW5jdC5yZXNvbHV0aW9uTGV2ZWwgPiAwKSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAtLW51bUNvZGVibG9ja3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBudW1Db2RlYmxvY2tzO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBnZXRSZXNvbHV0aW9uRmFjdG9yKHJlc29sdXRpb25MZXZlbCkge1xyXG4gICAgICAgIHZhciBkaWZmZXJlbmNlRnJvbUJlc3RMZXZlbCA9IHBhcmFtcy5udW1SZXNvbHV0aW9uTGV2ZWxzIC0gcmVzb2x1dGlvbkxldmVsIC0gMTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgZmFjdG9yID0gMSA8PCBkaWZmZXJlbmNlRnJvbUJlc3RMZXZlbDtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gZmFjdG9yO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xyXG4gICAgICAgIGlmIChwYXJhbXMuc2NhbGVYICE9PSAxIHx8IHBhcmFtcy5zY2FsZVkgIT09IDEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmoya0V4Y2VwdGlvbnMuVW5zdXBwb3J0ZWRGZWF0dXJlRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgJ05vbiAxIGNvbXBvbmVudCBzY2FsZScsICdBLjUuMScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0aWxlV2lkdGhMZXZlbDAgPSBNYXRoLmZsb29yKFxyXG4gICAgICAgICAgICB0aWxlU3RydWN0dXJlLmdldFRpbGVXaWR0aCgpIC8gcGFyYW1zLnNjYWxlWCk7XHJcbiAgICAgICAgdGlsZUhlaWdodExldmVsMCA9IE1hdGguZmxvb3IoXHJcbiAgICAgICAgICAgIHRpbGVTdHJ1Y3R1cmUuZ2V0VGlsZUhlaWdodCgpIC8gcGFyYW1zLnNjYWxlWSk7XHJcbiAgICB9XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGpHbG9iYWxzID0gcmVxdWlyZSgnajJrLWpwaXAtZ2xvYmFscy5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuSnBpcFRpbGVTdHJ1Y3R1cmUgPSBmdW5jdGlvbiBKcGlwVGlsZVN0cnVjdHVyZShcclxuICAgIHNpemVQYXJhbXMsXHJcbiAgICBjb2Rlc3RyZWFtU3RydWN0dXJlLFxyXG4gICAganBpcEZhY3RvcnksXHJcbiAgICBwcm9ncmVzc2lvbk9yZGVyXHJcbiAgICApIHtcclxuICAgIFxyXG4gICAgdmFyIGRlZmF1bHRDb21wb25lbnRTdHJ1Y3R1cmU7XHJcbiAgICB2YXIgY29tcG9uZW50U3RydWN0dXJlcztcclxuICAgIHZhciBjb21wb25lbnRUb0luQ2xhc3NMZXZlbFN0YXJ0SW5kZXg7XHJcbiAgICB2YXIgbWluTnVtUmVzb2x1dGlvbkxldmVscztcclxuXHJcbiAgICB0aGlzLmdldFByb2dyZXNzaW9uT3JkZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gcHJvZ3Jlc3Npb25PcmRlcjtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0RGVmYXVsdENvbXBvbmVudFN0cnVjdHVyZSA9IGZ1bmN0aW9uIGdldERlZmF1bHRDb21wb25lbnRTdHJ1Y3R1cmUoY29tcG9uZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRDb21wb25lbnRTdHJ1Y3R1cmU7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldENvbXBvbmVudFN0cnVjdHVyZSA9IGZ1bmN0aW9uIGdldENvbXBvbmVudFN0cnVjdHVyZShjb21wb25lbnQpIHtcclxuICAgICAgICByZXR1cm4gY29tcG9uZW50U3RydWN0dXJlc1tjb21wb25lbnRdO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRUaWxlV2lkdGggPSBmdW5jdGlvbiBnZXRUaWxlV2lkdGhDbG9zdXJlKCkge1xyXG4gICAgICAgIHJldHVybiBzaXplUGFyYW1zLnRpbGVTaXplWzBdO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRUaWxlSGVpZ2h0ID0gZnVuY3Rpb24gZ2V0VGlsZUhlaWdodENsb3N1cmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHNpemVQYXJhbXMudGlsZVNpemVbMV07XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldE51bVF1YWxpdHlMYXllcnMgPSBmdW5jdGlvbiBnZXROdW1RdWFsaXR5TGF5ZXJzKCkge1xyXG4gICAgICAgIHJldHVybiBzaXplUGFyYW1zLm51bVF1YWxpdHlMYXllcnM7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldElzUGFja2V0SGVhZGVyTmVhckRhdGEgPSBmdW5jdGlvbiBnZXRJc1BhY2tldEhlYWRlck5lYXJEYXRhKCkge1xyXG4gICAgICAgIHJldHVybiBzaXplUGFyYW1zLmlzUGFja2V0SGVhZGVyc05lYXJEYXRhO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRJc1N0YXJ0T2ZQYWNrZXRNYXJrZXJBbGxvd2VkID0gZnVuY3Rpb24gZ2V0SXNTdGFydE9mUGFja2V0TWFya2VyQWxsb3dlZCgpIHtcclxuICAgICAgICByZXR1cm4gc2l6ZVBhcmFtcy5pc1N0YXJ0T2ZQYWNrZXRNYXJrZXJBbGxvd2VkO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRJc0VuZFBhY2tldEhlYWRlck1hcmtlckFsbG93ZWQgPVxyXG4gICAgICAgIGZ1bmN0aW9uIGdldElzRW5kUGFja2V0SGVhZGVyTWFya2VyQWxsb3dlZCgpIHtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gc2l6ZVBhcmFtcy5pc0VuZFBhY2tldEhlYWRlck1hcmtlckFsbG93ZWQ7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLnByZWNpbmN0SW5DbGFzc0luZGV4VG9Qb3NpdGlvbiA9IGZ1bmN0aW9uKGluQ2xhc3NJbmRleCkge1xyXG4gICAgICAgIC8vIEEuMy4yXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGluQ2xhc3NJbmRleCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkFyZ3VtZW50RXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgJ2luQ2xhc3NJbmRleCcsXHJcbiAgICAgICAgICAgICAgICBpbkNsYXNzSW5kZXgsXHJcbiAgICAgICAgICAgICAgICAnSW52YWxpZCBuZWdhdGl2ZSBpbi1jbGFzcyBpbmRleCBvZiBwcmVjaW5jdCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgbnVtVGlsZXMgPSBjb2Rlc3RyZWFtU3RydWN0dXJlLmdldE51bVRpbGVzWCgpICogY29kZXN0cmVhbVN0cnVjdHVyZS5nZXROdW1UaWxlc1koKTtcclxuICAgICAgICB2YXIgbnVtQ29tcG9uZW50cyA9IGNvZGVzdHJlYW1TdHJ1Y3R1cmUuZ2V0TnVtQ29tcG9uZW50cygpO1xyXG5cclxuICAgICAgICB2YXIgdGlsZUluZGV4ID0gaW5DbGFzc0luZGV4ICUgbnVtVGlsZXM7XHJcbiAgICAgICAgdmFyIGluQ2xhc3NJbmRleFdpdGhvdXRUaWxlID0gKGluQ2xhc3NJbmRleCAtIHRpbGVJbmRleCkgLyBudW1UaWxlcztcclxuICAgICAgICBcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gaW5DbGFzc0luZGV4V2l0aG91dFRpbGUgJSBudW1Db21wb25lbnRzO1xyXG4gICAgICAgIHZhciBjb21wb25lbnRTdHJ1Y3R1cmUgPSBjb21wb25lbnRTdHJ1Y3R1cmVzW2NvbXBvbmVudF07XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIG51bVJlc29sdXRpb25MZXZlbHMgPSBjb21wb25lbnRTdHJ1Y3R1cmUuZ2V0TnVtUmVzb2x1dGlvbkxldmVscygpO1xyXG4gICAgICAgIHZhciBwcmVjaW5jdEluZGV4ID0gKGluQ2xhc3NJbmRleFdpdGhvdXRUaWxlIC0gY29tcG9uZW50KSAvIG51bUNvbXBvbmVudHM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlc29sdXRpb25MZXZlbDtcclxuICAgICAgICB2YXIgbGV2ZWxTdGFydEluZGV4ID0gMDtcclxuICAgICAgICBmb3IgKHJlc29sdXRpb25MZXZlbCA9IDE7IHJlc29sdXRpb25MZXZlbCA8IG51bVJlc29sdXRpb25MZXZlbHM7ICsrcmVzb2x1dGlvbkxldmVsKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXh0TGV2ZWxTdGFydEluZGV4ID1cclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFRvSW5DbGFzc0xldmVsU3RhcnRJbmRleFtjb21wb25lbnRdW3Jlc29sdXRpb25MZXZlbF07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAobmV4dExldmVsU3RhcnRJbmRleCA+IHByZWNpbmN0SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBsZXZlbFN0YXJ0SW5kZXggPSBuZXh0TGV2ZWxTdGFydEluZGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAtLXJlc29sdXRpb25MZXZlbDtcclxuICAgICAgICB2YXIgcHJlY2luY3RJbmRleEluTGV2ZWwgPSBwcmVjaW5jdEluZGV4IC0gbGV2ZWxTdGFydEluZGV4O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBwcmVjaW5jdHNYID0gY29tcG9uZW50U3RydWN0dXJlLmdldE51bVByZWNpbmN0c1gocmVzb2x1dGlvbkxldmVsKTtcclxuICAgICAgICB2YXIgcHJlY2luY3RzWSA9IGNvbXBvbmVudFN0cnVjdHVyZS5nZXROdW1QcmVjaW5jdHNZKHJlc29sdXRpb25MZXZlbCk7XHJcblxyXG4gICAgICAgIHZhciBwcmVjaW5jdFggPSBwcmVjaW5jdEluZGV4SW5MZXZlbCAlIHByZWNpbmN0c1g7XHJcbiAgICAgICAgdmFyIHByZWNpbmN0WSA9IChwcmVjaW5jdEluZGV4SW5MZXZlbCAtIHByZWNpbmN0WCkgLyBwcmVjaW5jdHNYO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChwcmVjaW5jdFkgPj0gcHJlY2luY3RzWSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuQXJndW1lbnRFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAnaW5DbGFzc0luZGV4JyxcclxuICAgICAgICAgICAgICAgIGluQ2xhc3NJbmRleCxcclxuICAgICAgICAgICAgICAgICdJbnZhbGlkIGluLWNsYXNzIGluZGV4IG9mIHByZWNpbmN0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgIHRpbGVJbmRleDogdGlsZUluZGV4LFxyXG4gICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHByZWNpbmN0WDogcHJlY2luY3RYLFxyXG4gICAgICAgICAgICBwcmVjaW5jdFk6IHByZWNpbmN0WSxcclxuICAgICAgICAgICAgcmVzb2x1dGlvbkxldmVsOiByZXNvbHV0aW9uTGV2ZWxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5wcmVjaW5jdFBvc2l0aW9uVG9JbkNsYXNzSW5kZXggPSBmdW5jdGlvbihwcmVjaW5jdFBvc2l0aW9uKSB7XHJcbiAgICAgICAgLy8gQS4zLjJcclxuXHJcbiAgICAgICAgdmFyIG51bUNvbXBvbmVudHMgPSBjb2Rlc3RyZWFtU3RydWN0dXJlLmdldE51bUNvbXBvbmVudHMoKTtcclxuICAgICAgICB2YWxpZGF0ZUFyZ3VtZW50SW5SYW5nZShcclxuICAgICAgICAgICAgJ3ByZWNpbmN0UG9zaXRpb24uY29tcG9uZW50JywgcHJlY2luY3RQb3NpdGlvbi5jb21wb25lbnQsIG51bUNvbXBvbmVudHMpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBjb21wb25lbnRTdHJ1Y3R1cmUgPSBjb21wb25lbnRTdHJ1Y3R1cmVzW3ByZWNpbmN0UG9zaXRpb24uY29tcG9uZW50XTtcclxuXHJcbiAgICAgICAgdmFyIG51bVJlc29sdXRpb25MZXZlbHMgPSBjb21wb25lbnRTdHJ1Y3R1cmUuZ2V0TnVtUmVzb2x1dGlvbkxldmVscygpO1xyXG4gICAgICAgIHZhbGlkYXRlQXJndW1lbnRJblJhbmdlKFxyXG4gICAgICAgICAgICAncHJlY2luY3RQb3NpdGlvbi5yZXNvbHV0aW9uTGV2ZWwnLCBwcmVjaW5jdFBvc2l0aW9uLnJlc29sdXRpb25MZXZlbCwgbnVtUmVzb2x1dGlvbkxldmVscyk7XHJcblxyXG4gICAgICAgIHZhciBudW1UaWxlcyA9IGNvZGVzdHJlYW1TdHJ1Y3R1cmUuZ2V0TnVtVGlsZXNYKCkgKiBjb2Rlc3RyZWFtU3RydWN0dXJlLmdldE51bVRpbGVzWSgpO1xyXG4gICAgICAgIHZhciBwcmVjaW5jdHNYID0gY29tcG9uZW50U3RydWN0dXJlLmdldE51bVByZWNpbmN0c1gocHJlY2luY3RQb3NpdGlvbi5yZXNvbHV0aW9uTGV2ZWwpO1xyXG4gICAgICAgIHZhciBwcmVjaW5jdHNZID0gY29tcG9uZW50U3RydWN0dXJlLmdldE51bVByZWNpbmN0c1kocHJlY2luY3RQb3NpdGlvbi5yZXNvbHV0aW9uTGV2ZWwpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhbGlkYXRlQXJndW1lbnRJblJhbmdlKFxyXG4gICAgICAgICAgICAncHJlY2luY3RQb3NpdGlvbi5wcmVjaW5jdFgnLCBwcmVjaW5jdFBvc2l0aW9uLnByZWNpbmN0WCwgcHJlY2luY3RzWCk7XHJcbiAgICAgICAgdmFsaWRhdGVBcmd1bWVudEluUmFuZ2UoXHJcbiAgICAgICAgICAgICdwcmVjaW5jdFBvc2l0aW9uLnByZWNpbmN0WScsIHByZWNpbmN0UG9zaXRpb24ucHJlY2luY3RZLCBwcmVjaW5jdHNZKTtcclxuICAgICAgICB2YWxpZGF0ZUFyZ3VtZW50SW5SYW5nZShcclxuICAgICAgICAgICAgJ3ByZWNpbmN0UG9zaXRpb24udGlsZUluZGV4JywgcHJlY2luY3RQb3NpdGlvbi50aWxlSW5kZXgsIG51bVRpbGVzKTtcclxuXHJcbiAgICAgICAgdmFyIHByZWNpbmN0SW5kZXhJbkxldmVsID0gcHJlY2luY3RQb3NpdGlvbi5wcmVjaW5jdFggKyBcclxuICAgICAgICAgICAgcHJlY2luY3RQb3NpdGlvbi5wcmVjaW5jdFkgKiBwcmVjaW5jdHNYO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBsZXZlbFN0YXJ0SW5kZXggPSBjb21wb25lbnRUb0luQ2xhc3NMZXZlbFN0YXJ0SW5kZXhbcHJlY2luY3RQb3NpdGlvbi5jb21wb25lbnRdW3ByZWNpbmN0UG9zaXRpb24ucmVzb2x1dGlvbkxldmVsXTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgcHJlY2luY3RJbmRleCA9IHByZWNpbmN0SW5kZXhJbkxldmVsICsgbGV2ZWxTdGFydEluZGV4O1xyXG5cclxuICAgICAgICB2YXIgaW5DbGFzc0luZGV4V2l0aG91dFRpbGUgPVxyXG4gICAgICAgICAgICBwcmVjaW5jdFBvc2l0aW9uLmNvbXBvbmVudCArIHByZWNpbmN0SW5kZXggKiBjb2Rlc3RyZWFtU3RydWN0dXJlLmdldE51bUNvbXBvbmVudHMoKTtcclxuXHJcbiAgICAgICAgdmFyIGluQ2xhc3NJbmRleCA9IHByZWNpbmN0UG9zaXRpb24udGlsZUluZGV4ICsgXHJcbiAgICAgICAgICAgIGluQ2xhc3NJbmRleFdpdGhvdXRUaWxlICogY29kZXN0cmVhbVN0cnVjdHVyZS5nZXROdW1UaWxlc1goKSAqIGNvZGVzdHJlYW1TdHJ1Y3R1cmUuZ2V0TnVtVGlsZXNZKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGluQ2xhc3NJbmRleDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0UHJlY2luY3RJdGVyYXRvciA9IGZ1bmN0aW9uIGdldFByZWNpbmN0SXRlcmF0b3IoXHJcbiAgICAgICAgdGlsZUluZGV4LCBjb2Rlc3RyZWFtUGFydFBhcmFtcywgaXNJdGVyYXRlUHJlY2luY3RzTm90SW5Db2Rlc3RyZWFtUGFydCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQgPSAwO1xyXG4gICAgICAgIGlmIChjb2Rlc3RyZWFtUGFydFBhcmFtcyAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgIGNvZGVzdHJlYW1QYXJ0UGFyYW1zLm51bVJlc29sdXRpb25MZXZlbHNUb0N1dCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQgPSBjb2Rlc3RyZWFtUGFydFBhcmFtcy5udW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQ7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAobWluTnVtUmVzb2x1dGlvbkxldmVscyA8PSBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbnRlcm5hbEVycm9yRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICdDYW5ub3QgYWR2YW5jZSByZXNvbHV0aW9uOiBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQ9JyArXHJcbiAgICAgICAgICAgICAgICAgICAgY29kZXN0cmVhbVBhcnRQYXJhbXMubnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0ICsgJyBidXQgc2hvdWxkICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdiZSBzbWFsbGVyIHRoYW4gJyArIG1pbk51bVJlc29sdXRpb25MZXZlbHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcHJlY2luY3RzSW5Db2Rlc3RyZWFtUGFydFBlckxldmVsUGVyQ29tcG9uZW50ID1cclxuICAgICAgICAgICAgZ2V0UHJlY2luY3RzSW5Db2Rlc3RyZWFtUGFydFBlckxldmVsUGVyQ29tcG9uZW50KFxyXG4gICAgICAgICAgICAgICAgdGlsZUluZGV4LCBjb2Rlc3RyZWFtUGFydFBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICB2YXIgcHJlY2luY3RYID0gMDtcclxuICAgICAgICB2YXIgcHJlY2luY3RZID0gMDtcclxuICAgICAgICBpZiAoaXNJdGVyYXRlUHJlY2luY3RzTm90SW5Db2Rlc3RyZWFtUGFydCAmJlxyXG4gICAgICAgICAgICBwcmVjaW5jdHNJbkNvZGVzdHJlYW1QYXJ0UGVyTGV2ZWxQZXJDb21wb25lbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBmaXJzdFByZWNpbmN0c1JhbmdlID1cclxuICAgICAgICAgICAgICAgIHByZWNpbmN0c0luQ29kZXN0cmVhbVBhcnRQZXJMZXZlbFBlckNvbXBvbmVudFswXVswXTtcclxuICAgICAgICAgICAgcHJlY2luY3RYID0gZmlyc3RQcmVjaW5jdHNSYW5nZS5taW5QcmVjaW5jdFg7XHJcbiAgICAgICAgICAgIHByZWNpbmN0WSA9IGZpcnN0UHJlY2luY3RzUmFuZ2UubWluUHJlY2luY3RZO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBBLjYuMSBpbiBwYXJ0IDE6IENvcmUgQ29kaW5nIFN5c3RlbVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBzZXRhYmxlSXRlcmF0b3IgPSB7XHJcbiAgICAgICAgICAgIHByZWNpbmN0SW5kZXhJbkNvbXBvbmVudFJlc29sdXRpb246IDAsXHJcbiAgICAgICAgICAgIGNvbXBvbmVudDogMCxcclxuICAgICAgICAgICAgcHJlY2luY3RYOiBwcmVjaW5jdFgsXHJcbiAgICAgICAgICAgIHByZWNpbmN0WTogcHJlY2luY3RZLFxyXG4gICAgICAgICAgICByZXNvbHV0aW9uTGV2ZWw6IDAsXHJcbiAgICAgICAgICAgIGlzSW5Db2Rlc3RyZWFtUGFydDogdHJ1ZVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgaXRlcmF0b3IgPSB7XHJcbiAgICAgICAgICAgIGdldCB0aWxlSW5kZXgoKSB7IHJldHVybiB0aWxlSW5kZXg7IH0sXHJcbiAgICAgICAgICAgICAgICBnZXQgY29tcG9uZW50KCkgeyByZXR1cm4gc2V0YWJsZUl0ZXJhdG9yLmNvbXBvbmVudDsgfSxcclxuICAgICAgICAgICAgZ2V0IHByZWNpbmN0SW5kZXhJbkNvbXBvbmVudFJlc29sdXRpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0YWJsZUl0ZXJhdG9yLnByZWNpbmN0SW5kZXhJbkNvbXBvbmVudFJlc29sdXRpb247XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGdldCBwcmVjaW5jdFgoKSB7IHJldHVybiBzZXRhYmxlSXRlcmF0b3IucHJlY2luY3RYOyB9LFxyXG4gICAgICAgICAgICAgICAgZ2V0IHByZWNpbmN0WSgpIHsgcmV0dXJuIHNldGFibGVJdGVyYXRvci5wcmVjaW5jdFk7IH0sXHJcbiAgICAgICAgICAgICAgICBnZXQgcmVzb2x1dGlvbkxldmVsKCkgeyByZXR1cm4gc2V0YWJsZUl0ZXJhdG9yLnJlc29sdXRpb25MZXZlbDsgfSxcclxuICAgICAgICAgICAgZ2V0IGlzSW5Db2Rlc3RyZWFtUGFydCgpIHsgcmV0dXJuIHNldGFibGVJdGVyYXRvci5pc0luQ29kZXN0cmVhbVBhcnQ7IH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICBpdGVyYXRvci50cnlBZHZhbmNlID0gZnVuY3Rpb24gdHJ5QWR2YW5jZSgpIHtcclxuICAgICAgICAgICAgdmFyIGlzU3VjY2VlZGVkID0gdHJ5QWR2YW5jZVByZWNpbmN0SXRlcmF0b3IoXHJcbiAgICAgICAgICAgICAgICBzZXRhYmxlSXRlcmF0b3IsXHJcbiAgICAgICAgICAgICAgICBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQsXHJcbiAgICAgICAgICAgICAgICBwcmVjaW5jdHNJbkNvZGVzdHJlYW1QYXJ0UGVyTGV2ZWxQZXJDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBpc0l0ZXJhdGVQcmVjaW5jdHNOb3RJbkNvZGVzdHJlYW1QYXJ0KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiBpc1N1Y2NlZWRlZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQXJndW1lbnRJblJhbmdlKHBhcmFtTmFtZSwgcGFyYW1WYWx1ZSwgc3VwcmltdW1QYXJhbVZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHBhcmFtVmFsdWUgPCAwIHx8IHBhcmFtVmFsdWUgPj0gc3VwcmltdW1QYXJhbVZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5Bcmd1bWVudEV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZSxcclxuICAgICAgICAgICAgICAgIHBhcmFtVmFsdWUsXHJcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWUgKyAnIGlzIGV4cGVjdGVkIHRvIGJlIGJldHdlZW4gMCBhbmQgJyArIHN1cHJpbXVtUGFyYW1WYWx1ZSAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVUYXJnZXRQcm9ncmVzc2lvbk9yZGVyKHByb2dyZXNzaW9uT3JkZXIpIHtcclxuICAgICAgICBpZiAocHJvZ3Jlc3Npb25PcmRlci5sZW5ndGggIT09IDQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmoya0V4Y2VwdGlvbnMuSWxsZWdhbERhdGFFeGNlcHRpb24oJ0lsbGVnYWwgcHJvZ3Jlc3Npb24gb3JkZXIgJyArIHByb2dyZXNzaW9uT3JkZXIgKyAnOiB1bmV4cGVjdGVkIGxlbmd0aCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAocHJvZ3Jlc3Npb25PcmRlclszXSAhPT0gJ0wnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbGxlZ2FsRGF0YUV4Y2VwdGlvbignSWxsZWdhbCB0YXJnZXQgcHJvZ3Jlc3Npb24gb3JkZXIgb2YgJyArIHByb2dyZXNzaW9uT3JkZXIsICdBLjMuMi4xJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBoYXNQID0gcHJvZ3Jlc3Npb25PcmRlci5pbmRleE9mKCdQJykgPj0gMDtcclxuICAgICAgICB2YXIgaGFzQyA9IHByb2dyZXNzaW9uT3JkZXIuaW5kZXhPZignQycpID49IDA7XHJcbiAgICAgICAgdmFyIGhhc1IgPSBwcm9ncmVzc2lvbk9yZGVyLmluZGV4T2YoJ1InKSA+PSAwO1xyXG4gICAgICAgIGlmICghaGFzUCB8fCAhaGFzQyB8fCAhaGFzUikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuajJrRXhjZXB0aW9ucy5JbGxlZ2FsRGF0YUV4Y2VwdGlvbignSWxsZWdhbCBwcm9ncmVzc2lvbiBvcmRlciAnICsgcHJvZ3Jlc3Npb25PcmRlciArICc6IG1pc3NpbmcgbGV0dGVyJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChwcm9ncmVzc2lvbk9yZGVyICE9PSAnUlBDTCcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmoya0V4Y2VwdGlvbnMuVW5zdXBwb3J0ZWRGZWF0dXJlRXhjZXB0aW9uKCdQcm9ncmVzc2lvbiBvcmRlciBvZiAnICsgcHJvZ3Jlc3Npb25PcmRlciwgJ0EuNi4xJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBwcmVwcm9jZXNzUGFyYW1zKCkge1xyXG4gICAgICAgIGNvbXBvbmVudFRvSW5DbGFzc0xldmVsU3RhcnRJbmRleCA9IG5ldyBBcnJheShjb21wb25lbnRzKTtcclxuXHJcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBjb2Rlc3RyZWFtU3RydWN0dXJlLmdldE51bUNvbXBvbmVudHMoKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgZGVmYXVsdENvbXBvbmVudCA9IHNpemVQYXJhbXMuZGVmYXVsdENvbXBvbmVudFBhcmFtcztcclxuICAgICAgICBtaW5OdW1SZXNvbHV0aW9uTGV2ZWxzID0gZGVmYXVsdENvbXBvbmVudC5udW1SZXNvbHV0aW9uTGV2ZWxzO1xyXG4gICAgICAgIHZhciBpc0NvbXBvbmVudHNJZGVudGljYWxTaXplID0gdHJ1ZTtcclxuICAgICAgICB2YXIgaXNQcmVjaW5jdFBhcnRpdGlvbkZpdHNUb1RpbGVQYXJ0aXRpb24gPSB0cnVlO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbXBvbmVudHM7ICsrYykge1xyXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHNpemVQYXJhbXMucGFyYW1zUGVyQ29tcG9uZW50W2NdO1xyXG4gICAgICAgICAgICBtaW5OdW1SZXNvbHV0aW9uTGV2ZWxzID0gTWF0aC5taW4oXHJcbiAgICAgICAgICAgICAgICBtaW5OdW1SZXNvbHV0aW9uTGV2ZWxzLCBzaXplLm51bVJlc29sdXRpb25MZXZlbHMpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbXBvbmVudFRvSW5DbGFzc0xldmVsU3RhcnRJbmRleFtjXSA9IG5ldyBBcnJheShzaXplLm51bVJlc29sdXRpb25MZXZlbHMpO1xyXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50U3RydWN0dXJlID0gY29tcG9uZW50U3RydWN0dXJlc1tjXTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBhY2N1bXVsYXRlZE9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdExldmVsUHJlY2luY3RzWCA9IGNvbXBvbmVudFN0cnVjdHVyZS5nZXROdW1QcmVjaW5jdHNYKGMpO1xyXG4gICAgICAgICAgICB2YXIgZmlyc3RMZXZlbFByZWNpbmN0c1kgPSBjb21wb25lbnRTdHJ1Y3R1cmUuZ2V0TnVtUHJlY2luY3RzWShjKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgc2l6ZS5udW1SZXNvbHV0aW9uTGV2ZWxzOyArK3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFRvSW5DbGFzc0xldmVsU3RhcnRJbmRleFtjXVtyXSA9IGFjY3VtdWxhdGVkT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZWNpbmN0c1hJbkxldmVsID0gY29tcG9uZW50U3RydWN0dXJlLmdldE51bVByZWNpbmN0c1gocik7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJlY2luY3RzWUluTGV2ZWwgPSBjb21wb25lbnRTdHJ1Y3R1cmUuZ2V0TnVtUHJlY2luY3RzWShyKTtcclxuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkT2Zmc2V0ICs9IHByZWNpbmN0c1hJbkxldmVsICogcHJlY2luY3RzWUluTGV2ZWw7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRDb21wb25lbnQucHJlY2luY3RXaWR0aFBlckxldmVsW3JdICE9PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplLnByZWNpbmN0V2lkdGhQZXJMZXZlbFtyXSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDb21wb25lbnQucHJlY2luY3RIZWlnaHRQZXJMZXZlbFtyXSAhPT1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZS5wcmVjaW5jdEhlaWdodFBlckxldmVsW3JdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgaXNDb21wb25lbnRzSWRlbnRpY2FsU2l6ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgaXNIb3Jpem9udGFsUGFydGl0aW9uU3VwcG9ydGVkID1cclxuICAgICAgICAgICAgICAgICAgICBjaGVja0lmUHJlY2luY3RQYXJ0aXRpb25TdGFydHNJblRpbGVUb3BMZWZ0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplLm51bVJlc29sdXRpb25MZXZlbHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFN0cnVjdHVyZS5nZXRQcmVjaW5jdFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc3RyZWFtU3RydWN0dXJlLmdldExldmVsV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzdHJlYW1TdHJ1Y3R1cmUuZ2V0VGlsZVdpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgaXNWZXJ0aWNhbFBhcnRpdGlvblN1cHBvcnRlZCA9XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tJZlByZWNpbmN0UGFydGl0aW9uU3RhcnRzSW5UaWxlVG9wTGVmdChcclxuICAgICAgICAgICAgICAgICAgICAgICAgcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZS5udW1SZXNvbHV0aW9uTGV2ZWxzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRTdHJ1Y3R1cmUuZ2V0UHJlY2luY3RXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZXN0cmVhbVN0cnVjdHVyZS5nZXRMZXZlbFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc3RyZWFtU3RydWN0dXJlLmdldFRpbGVXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaXNQcmVjaW5jdFBhcnRpdGlvbkZpdHNUb1RpbGVQYXJ0aXRpb24gJj1cclxuICAgICAgICAgICAgICAgICAgICBpc0hvcml6b250YWxQYXJ0aXRpb25TdXBwb3J0ZWQgJiZcclxuICAgICAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsUGFydGl0aW9uU3VwcG9ydGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzQ29tcG9uZW50c0lkZW50aWNhbFNpemUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmoya0V4Y2VwdGlvbnMuVW5zdXBwb3J0ZWRGZWF0dXJlRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgJ1NwZWNpYWwgQ29kaW5nIFN0eWxlIGZvciBDb21wb25lbnQgKENPQyknLCAnQS42LjInKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKCFpc1ByZWNpbmN0UGFydGl0aW9uRml0c1RvVGlsZVBhcnRpdGlvbikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuajJrRXhjZXB0aW9ucy5VbnN1cHBvcnRlZEZlYXR1cmVFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAnUHJlY2luY3QgVG9wTGVmdCB3aGljaCBpcyBub3QgbWF0Y2hlZCB0byB0aWxlIFRvcExlZnQnLCAnQi42Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBjaGVja0lmUHJlY2luY3RQYXJ0aXRpb25TdGFydHNJblRpbGVUb3BMZWZ0KFxyXG4gICAgICAgIHJlc29sdXRpb25MZXZlbCxcclxuICAgICAgICBudW1SZXNvbHV0aW9uTGV2ZWxzLFxyXG4gICAgICAgIGdldFByZWNpbmN0U2l6ZUZ1bmN0aW9uLFxyXG4gICAgICAgIGdldExldmVsU2l6ZUZ1bmN0aW9uLFxyXG4gICAgICAgIGdldFRpbGVTaXplRnVuY3Rpb24pIHtcclxuICAgICAgICBcclxuICAgICAgICAvLyBKcGVnMjAwMCBzdGFuZGFyZCBhbGxvd3MgcGFydGl0aW9uIG9mIHRpbGVzIHdoaWNoIGRvZXMgbm90IGZpdFxyXG4gICAgICAgIC8vIGV4YWN0bHkgdGhlIHByZWNpbmN0cyBwYXJ0aXRpb24gKGkuZS4gdGhlIGZpcnN0IHByZWNpbmN0cyBcInZpcnR1YWxseVwiXHJcbiAgICAgICAgLy8gc3RhcnRzIGJlZm9yZSB0aGUgdGlsZSwgdGh1cyBpcyBzbWFsbGVyIHRoYW4gb3RoZXIpLlxyXG4gICAgICAgIC8vIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBub3cgaW4gdGhlIGNvZGUsIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGNoZWNrXHJcbiAgICAgICAgLy8gdGhhdCB0aGlzIGlzIG5vdCB0aGUgc2l0dWF0aW9uLlxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFRoZSBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgZmlyc3RUaWxlT2Zmc2V0IGlzIHplcm8gYW5kIGNvbXBvbmVudFNjYWxlXHJcbiAgICAgICAgLy8gaXMgb25lIChVbnN1cHBvcnRlZEV4Y2VwdGlvbnMgYXJlIHRocm93biBpbiBDb21wb25lbnRTdHJ1Y3R1cmUgYW5kXHJcbiAgICAgICAgLy8gQ29kZXN0cmVhbVN0cnVjdHVyZSBjbGFzc2VzKS5cclxuICAgICAgICBcclxuICAgICAgICB2YXIgcHJlY2luY3RTaXplID0gZ2V0UHJlY2luY3RTaXplRnVuY3Rpb24ocmVzb2x1dGlvbkxldmVsKTtcclxuICAgICAgICB2YXIgbGV2ZWxTaXplID0gZ2V0TGV2ZWxTaXplRnVuY3Rpb24ocmVzb2x1dGlvbkxldmVsKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAocHJlY2luY3RTaXplID4gbGV2ZWxTaXplKSB7XHJcbiAgICAgICAgICAgIC8vIFByZWNpbmN0IGlzIGxhcmdlciB0aGFuIGltYWdlIHRodXMgYW55d2F5IHRpbGUgaGFzIGEgc2luZ2xlXHJcbiAgICAgICAgICAgIC8vIHByZWNpbmN0XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHRpbGVTaXplID0gZ2V0VGlsZVNpemVGdW5jdGlvbihyZXNvbHV0aW9uTGV2ZWwpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBpc1ByZWNpbmN0UGFydGl0aW9uRml0c1RvVGlsZVBhcnRpdGlvbiA9XHJcbiAgICAgICAgICAgIHByZWNpbmN0U2l6ZSAlIHRpbGVTaXplID09PSAwIHx8XHJcbiAgICAgICAgICAgIHRpbGVTaXplICUgcHJlY2luY3RTaXplID09PSAwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBpc1ByZWNpbmN0UGFydGl0aW9uRml0c1RvVGlsZVBhcnRpdGlvbjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gZ2V0UHJlY2luY3RzSW5Db2Rlc3RyZWFtUGFydFBlckxldmVsUGVyQ29tcG9uZW50KFxyXG4gICAgICAgIHRpbGVJbmRleCwgY29kZXN0cmVhbVBhcnRQYXJhbXMpIHtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoY29kZXN0cmVhbVBhcnRQYXJhbXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBjb2Rlc3RyZWFtU3RydWN0dXJlLmdldE51bUNvbXBvbmVudHMoKTtcclxuICAgICAgICB2YXIgcGVyQ29tcG9uZW50UmVzdWx0ID0gbmV3IEFycmF5KGNvbXBvbmVudHMpO1xyXG4gICAgICAgIHZhciBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQgPVxyXG4gICAgICAgICAgICBjb2Rlc3RyZWFtUGFydFBhcmFtcy5udW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQgfHwgMDtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgdGlsZUxlZnRJbkxldmVsID0gY29kZXN0cmVhbVN0cnVjdHVyZS5nZXRUaWxlTGVmdChcclxuICAgICAgICAgICAgdGlsZUluZGV4LCBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQpO1xyXG4gICAgICAgIHZhciB0aWxlVG9wSW5MZXZlbCA9IGNvZGVzdHJlYW1TdHJ1Y3R1cmUuZ2V0VGlsZVRvcChcclxuICAgICAgICAgICAgdGlsZUluZGV4LCBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBtaW5YSW5UaWxlID1cclxuICAgICAgICAgICAgY29kZXN0cmVhbVBhcnRQYXJhbXMubWluWCAtIHRpbGVMZWZ0SW5MZXZlbDtcclxuICAgICAgICB2YXIgbWluWUluVGlsZSA9XHJcbiAgICAgICAgICAgIGNvZGVzdHJlYW1QYXJ0UGFyYW1zLm1pblkgLSB0aWxlVG9wSW5MZXZlbDtcclxuICAgICAgICB2YXIgbWF4WEluVGlsZSA9XHJcbiAgICAgICAgICAgIGNvZGVzdHJlYW1QYXJ0UGFyYW1zLm1heFhFeGNsdXNpdmUgLSB0aWxlTGVmdEluTGV2ZWw7XHJcbiAgICAgICAgdmFyIG1heFlJblRpbGUgPVxyXG4gICAgICAgICAgICBjb2Rlc3RyZWFtUGFydFBhcmFtcy5tYXhZRXhjbHVzaXZlIC0gdGlsZVRvcEluTGV2ZWw7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGNvZGVzdHJlYW1QYXJ0TGV2ZWxXaWR0aCA9IGNvZGVzdHJlYW1TdHJ1Y3R1cmUuZ2V0TGV2ZWxXaWR0aChcclxuICAgICAgICAgICAgbnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0KTtcclxuICAgICAgICB2YXIgY29kZXN0cmVhbVBhcnRMZXZlbEhlaWdodCA9IGNvZGVzdHJlYW1TdHJ1Y3R1cmUuZ2V0TGV2ZWxIZWlnaHQoXHJcbiAgICAgICAgICAgIG51bVJlc29sdXRpb25MZXZlbHNUb0N1dCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGNvbXBvbmVudCA9IDA7IGNvbXBvbmVudCA8IGNvbXBvbmVudHM7ICsrY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRTdHJ1Y3R1cmUgPSBjb21wb25lbnRTdHJ1Y3R1cmVzW2NvbXBvbmVudF07XHJcbiAgICAgICAgICAgIHZhciBsZXZlbHMgPSBjb21wb25lbnRTdHJ1Y3R1cmUuZ2V0TnVtUmVzb2x1dGlvbkxldmVscygpO1xyXG4gICAgICAgICAgICB2YXIgbGV2ZWxzSW5Db2Rlc3RyZWFtUGFydCA9IGxldmVscyAtIG51bVJlc29sdXRpb25MZXZlbHNUb0N1dDtcclxuICAgICAgICAgICAgdmFyIG51bVJlc29sdXRpb25MZXZlbHMgPSBjb21wb25lbnRTdHJ1Y3R1cmUuZ2V0TnVtUmVzb2x1dGlvbkxldmVscygpO1xyXG4gICAgICAgICAgICB2YXIgcGVyTGV2ZWxSZXN1bHQgPSBuZXcgQXJyYXkobGV2ZWxzKTtcclxuICAgICAgICBcclxuICAgICAgICAgICAgZm9yICh2YXIgbGV2ZWwgPSAwOyBsZXZlbCA8IGxldmVsc0luQ29kZXN0cmVhbVBhcnQ7ICsrbGV2ZWwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRTY2FsZVggPSBjb21wb25lbnRTdHJ1Y3R1cmUuZ2V0Q29tcG9uZW50U2NhbGVYKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50U2NhbGVZID0gY29tcG9uZW50U3RydWN0dXJlLmdldENvbXBvbmVudFNjYWxlWSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxldmVsSW5Db2Rlc3RyZWFtUGFydCA9IGxldmVsc0luQ29kZXN0cmVhbVBhcnQgLSBsZXZlbCAtIDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGV2ZWxTY2FsZVggPSBjb21wb25lbnRTY2FsZVggPDwgbGV2ZWxJbkNvZGVzdHJlYW1QYXJ0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGxldmVsU2NhbGVZID0gY29tcG9uZW50U2NhbGVZIDw8IGxldmVsSW5Db2Rlc3RyZWFtUGFydDtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIHJlZHVuZGFudCA9IDQ7IC8vIFJlZHVuZGFudCBwaXhlbHMgZm9yIHdhdmVsZXQgOS03IGNvbnZvbHV0aW9uXHJcbiAgICAgICAgICAgICAgICB2YXIgbWluWEluTGV2ZWwgPSBNYXRoLmZsb29yKG1pblhJblRpbGUgLyBsZXZlbFNjYWxlWCkgLSByZWR1bmRhbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWluWUluTGV2ZWwgPSBNYXRoLmZsb29yKG1pbllJblRpbGUgLyBsZXZlbFNjYWxlWSkgLSByZWR1bmRhbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF4WEluTGV2ZWwgPSBNYXRoLmNlaWwobWF4WEluVGlsZSAvIGxldmVsU2NhbGVYKSArIHJlZHVuZGFudDtcclxuICAgICAgICAgICAgICAgIHZhciBtYXhZSW5MZXZlbCA9IE1hdGguY2VpbChtYXhZSW5UaWxlIC8gbGV2ZWxTY2FsZVkpICsgcmVkdW5kYW50O1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgcHJlY2luY3RXaWR0aCA9XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50U3RydWN0dXJlLmdldFByZWNpbmN0V2lkdGgobGV2ZWwpICogY29tcG9uZW50U2NhbGVYO1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZWNpbmN0SGVpZ2h0ID1cclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRTdHJ1Y3R1cmUuZ2V0UHJlY2luY3RIZWlnaHQobGV2ZWwpICogY29tcG9uZW50U2NhbGVZO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgbWluUHJlY2luY3RYID0gTWF0aC5mbG9vcihtaW5YSW5MZXZlbCAvIHByZWNpbmN0V2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1pblByZWNpbmN0WSA9IE1hdGguZmxvb3IobWluWUluTGV2ZWwgLyBwcmVjaW5jdEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF4UHJlY2luY3RYID0gTWF0aC5jZWlsKG1heFhJbkxldmVsIC8gcHJlY2luY3RXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF4UHJlY2luY3RZID0gTWF0aC5jZWlsKG1heFlJbkxldmVsIC8gcHJlY2luY3RIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgcHJlY2luY3RzWCA9IGNvbXBvbmVudFN0cnVjdHVyZS5nZXROdW1QcmVjaW5jdHNYKGxldmVsKTtcclxuICAgICAgICAgICAgICAgIHZhciBwcmVjaW5jdHNZID0gY29tcG9uZW50U3RydWN0dXJlLmdldE51bVByZWNpbmN0c1kobGV2ZWwpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBwZXJMZXZlbFJlc3VsdFtsZXZlbF0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluUHJlY2luY3RYOiBNYXRoLm1heCgwLCBtaW5QcmVjaW5jdFgpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pblByZWNpbmN0WTogTWF0aC5tYXgoMCwgbWluUHJlY2luY3RZKSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhQcmVjaW5jdFhFeGNsdXNpdmU6IE1hdGgubWluKG1heFByZWNpbmN0WCwgcHJlY2luY3RzWCksXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4UHJlY2luY3RZRXhjbHVzaXZlOiBNYXRoLm1pbihtYXhQcmVjaW5jdFksIHByZWNpbmN0c1kpXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcGVyQ29tcG9uZW50UmVzdWx0W2NvbXBvbmVudF0gPSBwZXJMZXZlbFJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHBlckNvbXBvbmVudFJlc3VsdDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gdHJ5QWR2YW5jZVByZWNpbmN0SXRlcmF0b3IoXHJcbiAgICAgICAgc2V0YWJsZUl0ZXJhdG9yLFxyXG4gICAgICAgIG51bVJlc29sdXRpb25MZXZlbHNUb0N1dCxcclxuICAgICAgICBwcmVjaW5jdHNJbkNvZGVzdHJlYW1QYXJ0UGVyTGV2ZWxQZXJDb21wb25lbnQsXHJcbiAgICAgICAgaXNJdGVyYXRlUHJlY2luY3RzTm90SW5Db2Rlc3RyZWFtUGFydCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBuZWVkQWR2YW5jZU5leHRNZW1iZXIgPSB0cnVlO1xyXG4gICAgICAgIHZhciBwcmVjaW5jdHNSYW5nZUhhc2ggPSBpc0l0ZXJhdGVQcmVjaW5jdHNOb3RJbkNvZGVzdHJlYW1QYXJ0ID9cclxuICAgICAgICAgICAgbnVsbDogcHJlY2luY3RzSW5Db2Rlc3RyZWFtUGFydFBlckxldmVsUGVyQ29tcG9uZW50O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBuZWVkUmVzZXRQcmVjaW5jdFRvTWluaW1hbEluQ29kZXN0cmVhbVBhcnQgPSBmYWxzZTtcclxuICAgICAgICBcclxuICAgICAgICBmb3IgKHZhciBpID0gMjsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gYWR2YW5jZVByb2dyZXNzaW9uT3JkZXJNZW1iZXIoXHJcbiAgICAgICAgICAgICAgICBzZXRhYmxlSXRlcmF0b3IsIGksIG51bVJlc29sdXRpb25MZXZlbHNUb0N1dCwgcHJlY2luY3RzUmFuZ2VIYXNoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIG5lZWRBZHZhbmNlTmV4dE1lbWJlciA9IG5ld1ZhbHVlID09PSAwO1xyXG4gICAgICAgICAgICBpZiAoIW5lZWRBZHZhbmNlTmV4dE1lbWJlcikge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChwcm9ncmVzc2lvbk9yZGVyW2ldID09PSAnUCcgJiZcclxuICAgICAgICAgICAgICAgICFpc0l0ZXJhdGVQcmVjaW5jdHNOb3RJbkNvZGVzdHJlYW1QYXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIG5lZWRSZXNldFByZWNpbmN0VG9NaW5pbWFsSW5Db2Rlc3RyZWFtUGFydCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKG5lZWRBZHZhbmNlTmV4dE1lbWJlcikge1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgaGVyZSwgdGhlIGxhc3QgcHJlY2luY3QgaGFzIGJlZW4gcmVhY2hlZFxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBjb21wb25lbnRTdHJ1Y3R1cmUgPSBjb21wb25lbnRTdHJ1Y3R1cmVzW3NldGFibGVJdGVyYXRvci5jb21wb25lbnRdO1xyXG4gICAgICAgIHZhciBwcmVjaW5jdHNYID0gY29tcG9uZW50U3RydWN0dXJlLmdldE51bVByZWNpbmN0c1goXHJcbiAgICAgICAgICAgIHNldGFibGVJdGVyYXRvci5yZXNvbHV0aW9uTGV2ZWwpO1xyXG4gICAgICAgIHNldGFibGVJdGVyYXRvci5wcmVjaW5jdEluZGV4SW5Db21wb25lbnRSZXNvbHV0aW9uID1cclxuICAgICAgICAgICAgc2V0YWJsZUl0ZXJhdG9yLnByZWNpbmN0WCArIHNldGFibGVJdGVyYXRvci5wcmVjaW5jdFkgKiBwcmVjaW5jdHNYO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChwcmVjaW5jdHNJbkNvZGVzdHJlYW1QYXJ0UGVyTGV2ZWxQZXJDb21wb25lbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgc2V0YWJsZUl0ZXJhdG9yLmlzSW5Db2Rlc3RyZWFtUGFydCA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgcmFuZ2VQZXJMZXZlbCA9XHJcbiAgICAgICAgICAgIHByZWNpbmN0c0luQ29kZXN0cmVhbVBhcnRQZXJMZXZlbFBlckNvbXBvbmVudFtzZXRhYmxlSXRlcmF0b3IuY29tcG9uZW50XTtcclxuICAgICAgICB2YXIgcHJlY2luY3RzUmFuZ2UgPSByYW5nZVBlckxldmVsW3NldGFibGVJdGVyYXRvci5yZXNvbHV0aW9uTGV2ZWxdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChuZWVkUmVzZXRQcmVjaW5jdFRvTWluaW1hbEluQ29kZXN0cmVhbVBhcnQpIHtcclxuICAgICAgICAgICAgc2V0YWJsZUl0ZXJhdG9yLnByZWNpbmN0WCA9IHByZWNpbmN0c1JhbmdlLm1pblByZWNpbmN0WDtcclxuICAgICAgICAgICAgICAgIHNldGFibGVJdGVyYXRvci5wcmVjaW5jdFkgPSBwcmVjaW5jdHNSYW5nZS5taW5QcmVjaW5jdFk7XHJcbiAgICAgICAgICAgIHNldGFibGVJdGVyYXRvci5wcmVjaW5jdEluZGV4SW5Db21wb25lbnRSZXNvbHV0aW9uID1cclxuICAgICAgICAgICAgICAgIHNldGFibGVJdGVyYXRvci5wcmVjaW5jdFggKyBzZXRhYmxlSXRlcmF0b3IucHJlY2luY3RZICogcHJlY2luY3RzWDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgc2V0YWJsZUl0ZXJhdG9yLmlzSW5Db2Rlc3RyZWFtUGFydCA9XHJcbiAgICAgICAgICAgIHNldGFibGVJdGVyYXRvci5wcmVjaW5jdFggPj0gcHJlY2luY3RzUmFuZ2UubWluUHJlY2luY3RYICYmXHJcbiAgICAgICAgICAgIHNldGFibGVJdGVyYXRvci5wcmVjaW5jdFkgPj0gcHJlY2luY3RzUmFuZ2UubWluUHJlY2luY3RZICYmXHJcbiAgICAgICAgICAgIHNldGFibGVJdGVyYXRvci5wcmVjaW5jdFggPCBwcmVjaW5jdHNSYW5nZS5tYXhQcmVjaW5jdFhFeGNsdXNpdmUgJiZcclxuICAgICAgICAgICAgc2V0YWJsZUl0ZXJhdG9yLnByZWNpbmN0WSA8IHByZWNpbmN0c1JhbmdlLm1heFByZWNpbmN0WUV4Y2x1c2l2ZTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gYWR2YW5jZVByb2dyZXNzaW9uT3JkZXJNZW1iZXIoXHJcbiAgICAgICAgcHJlY2luY3RQb3NpdGlvbixcclxuICAgICAgICBtZW1iZXJJbmRleCxcclxuICAgICAgICBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQsXHJcbiAgICAgICAgcHJlY2luY3RzUmFuZ2UpIHtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgY29tcG9uZW50U3RydWN0dXJlID0gY29tcG9uZW50U3RydWN0dXJlc1twcmVjaW5jdFBvc2l0aW9uLmNvbXBvbmVudF07XHJcbiAgICAgICAgXHJcbiAgICAgICAgc3dpdGNoIChwcm9ncmVzc2lvbk9yZGVyW21lbWJlckluZGV4XSkge1xyXG4gICAgICAgICAgICBjYXNlICdSJzpcclxuICAgICAgICAgICAgICAgIHZhciBudW1SZXNvbHV0aW9uTGV2ZWxzID1cclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRTdHJ1Y3R1cmUuZ2V0TnVtUmVzb2x1dGlvbkxldmVscygpIC1cclxuICAgICAgICAgICAgICAgICAgICBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQ7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICsrcHJlY2luY3RQb3NpdGlvbi5yZXNvbHV0aW9uTGV2ZWw7XHJcbiAgICAgICAgICAgICAgICBwcmVjaW5jdFBvc2l0aW9uLnJlc29sdXRpb25MZXZlbCAlPSBudW1SZXNvbHV0aW9uTGV2ZWxzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWNpbmN0UG9zaXRpb24ucmVzb2x1dGlvbkxldmVsO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY2FzZSAnQyc6XHJcbiAgICAgICAgICAgICAgICArK3ByZWNpbmN0UG9zaXRpb24uY29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgcHJlY2luY3RQb3NpdGlvbi5jb21wb25lbnQgJT0gY29kZXN0cmVhbVN0cnVjdHVyZS5nZXROdW1Db21wb25lbnRzKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlY2luY3RQb3NpdGlvbi5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjYXNlICdQJzpcclxuICAgICAgICAgICAgICAgIHZhciBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZWNpbmN0c1JhbmdlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZWNpbmN0c1JhbmdlUGVyTGV2ZWwgPSBwcmVjaW5jdHNSYW5nZVtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2luY3RQb3NpdGlvbi5jb21wb25lbnRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmVjaW5jdHNSYW5nZUluTGV2ZWxDb21wb25lbnQgPSBwcmVjaW5jdHNSYW5nZVBlckxldmVsW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjaW5jdFBvc2l0aW9uLnJlc29sdXRpb25MZXZlbF07XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgbWluWCA9IHByZWNpbmN0c1JhbmdlSW5MZXZlbENvbXBvbmVudC5taW5QcmVjaW5jdFg7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluWSA9IHByZWNpbmN0c1JhbmdlSW5MZXZlbENvbXBvbmVudC5taW5QcmVjaW5jdFk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHByZWNpbmN0c1JhbmdlSW5MZXZlbENvbXBvbmVudC5tYXhQcmVjaW5jdFhFeGNsdXNpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4WSA9IHByZWNpbmN0c1JhbmdlSW5MZXZlbENvbXBvbmVudC5tYXhQcmVjaW5jdFlFeGNsdXNpdmU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFggPSBjb21wb25lbnRTdHJ1Y3R1cmUuZ2V0TnVtUHJlY2luY3RzWChcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2luY3RQb3NpdGlvbi5yZXNvbHV0aW9uTGV2ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFkgPSBjb21wb25lbnRTdHJ1Y3R1cmUuZ2V0TnVtUHJlY2luY3RzWShcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2luY3RQb3NpdGlvbi5yZXNvbHV0aW9uTGV2ZWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBwcmVjaW5jdFBvc2l0aW9uLnByZWNpbmN0WCAtPSAobWluWCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgcHJlY2luY3RQb3NpdGlvbi5wcmVjaW5jdFggJT0gKG1heFggLSBtaW5YKTtcclxuICAgICAgICAgICAgICAgIHByZWNpbmN0UG9zaXRpb24ucHJlY2luY3RYICs9IG1pblg7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmIChwcmVjaW5jdFBvc2l0aW9uLnByZWNpbmN0WCAhPSBtaW5YKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZWNpbmN0UG9zaXRpb24ucHJlY2luY3RYIC0gbWluWDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcHJlY2luY3RQb3NpdGlvbi5wcmVjaW5jdFkgLT0gKG1pblkgLSAxKTtcclxuICAgICAgICAgICAgICAgIHByZWNpbmN0UG9zaXRpb24ucHJlY2luY3RZICU9IChtYXhZIC0gbWluWSk7XHJcbiAgICAgICAgICAgICAgICBwcmVjaW5jdFBvc2l0aW9uLnByZWNpbmN0WSArPSBtaW5ZO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBwcmVjaW5jdFBvc2l0aW9uLnByZWNpbmN0WSAtIG1pblk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjYXNlICdMJyA6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAnQWR2YW5jaW5nIEwgaXMgbm90IHN1cHBvcnRlZCBpbiBKUElQJyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgJ1VuZXhwZWN0ZWQgbGV0dGVyIGluIHByb2dyZXNzaW9uIG9yZGVyOiAnICtcclxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc2lvbk9yZGVyW21lbWJlckluZGV4XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBkZWZhdWx0Q29tcG9uZW50U3RydWN0dXJlID0ganBpcEZhY3RvcnkuY3JlYXRlQ29tcG9uZW50U3RydWN0dXJlKFxyXG4gICAgICAgIHNpemVQYXJhbXMuZGVmYXVsdENvbXBvbmVudFBhcmFtcywgdGhpcyk7XHJcbiAgICAgICAgXHJcbiAgICBjb21wb25lbnRTdHJ1Y3R1cmVzID0gbmV3IEFycmF5KGNvZGVzdHJlYW1TdHJ1Y3R1cmUuZ2V0TnVtQ29tcG9uZW50cygpKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZXN0cmVhbVN0cnVjdHVyZS5nZXROdW1Db21wb25lbnRzKCk7ICsraSkge1xyXG4gICAgICAgIGNvbXBvbmVudFN0cnVjdHVyZXNbaV0gPSBqcGlwRmFjdG9yeS5jcmVhdGVDb21wb25lbnRTdHJ1Y3R1cmUoXHJcbiAgICAgICAgICAgIHNpemVQYXJhbXMucGFyYW1zUGVyQ29tcG9uZW50W2ldLCB0aGlzKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcHJlcHJvY2Vzc1BhcmFtcygpO1xyXG4gICAgXHJcbiAgICB2YWxpZGF0ZVRhcmdldFByb2dyZXNzaW9uT3JkZXIocHJvZ3Jlc3Npb25PcmRlcik7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuajJrTWFya2VycyA9IHtcclxuICAgIFN0YXJ0T2ZDb2Rlc3RyZWFtOiBbMHhGRiwgMHg0Rl0sIC8vIFNPQ1xyXG4gICAgSW1hZ2VBbmRUaWxlU2l6ZTogWzB4RkYsIDB4NTFdLCAvLyBTSVpcclxuICAgIENvZGluZ1N0eWxlRGVmYXVsdDogWzB4RkYsIDB4NTJdLCAvLyBDT0RcclxuICAgIENvZGluZ1N0eWxlQ29tcG9uZW50OiBbMHhGRiwgMHg1M10sIC8vIENPQ1xyXG4gICAgUXVhbnRpemF0aW9uRGVmYXVsdDogWzB4RkYsIDB4NUNdLCAvLyBRQ0RcclxuICAgIFByb2dyZXNzaW9uT3JkZXJDaGFuZ2U6IFsweEZGLCAweDVGXSwgLy8gUE9DXHJcbiAgICBQYWNrZWRQYWNrZXRIZWFkZXJzSW5NYWluSGVhZGVyOiBbMHhGRiwgMHg2MF0sIC8vIFBQTVxyXG4gICAgUGFja2VkUGFja2V0SGVhZGVyc0luVGlsZUhlYWRlcjogWzB4RkYsIDB4NjFdLCAvLyBQUFRcclxuICAgIFN0YXJ0T2ZUaWxlOiBbMHhGRiwgMHg5MF0sIC8vIFNPVFxyXG4gICAgU3RhcnRPZkRhdGE6IFsweEZGLCAweDkzXSwgLy8gU09EXHJcbiAgICBFbmRPZkNvZGVzdHJlYW06IFsweEZGLCAweEQ5XSwgLy8gRU9DXHJcbiAgICBDb21tZW50OiBbMHhGRiwgMHg2NF0gLy8gQ09NXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5qMmtPZmZzZXRzID0ge1xyXG4gICAgTUFSS0VSX1NJWkU6IDIsXHJcbiAgICBMRU5HVEhfRklFTERfU0laRTogMixcclxuICAgIFxyXG4gICAgTlVNX0NPTVBPTkVOVFNfT0ZGU0VUX0FGVEVSX1NJWl9NQVJLRVI6IDM4LFxyXG4gICAgUkVGRVJFTkNFX0dSSURfU0laRV9PRkZTRVRfQUZURVJfU0laX01BUktFUjogNlxyXG5cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLmpwaXBFbmRPZlJlc3BvbnNlUmVhc29ucyA9IHtcclxuICAgIElNQUdFX0RPTkUgOiAxLFxyXG4gICAgV0lORE9XX0RPTkUgOiAyLFxyXG4gICAgV0lORE9XX0NIQU5HRSA6IDMsXHJcbiAgICBCWVRFX0xJTUlUIDogNCxcclxuICAgIFFVQUxJVFlfTElNSVQgOiA1LFxyXG4gICAgU0VTU0lPTl9MSU1JVCA6IDYsXHJcbiAgICBSRVNQT05TRV9MSU1JVCA6IDcsXHJcbiAgICBOT05fU1BFQ0lGSUVEIDogOFxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMuajJrRXhjZXB0aW9ucyA9IHtcclxuICAgIFVuc3VwcG9ydGVkRmVhdHVyZUV4Y2VwdGlvbjogZnVuY3Rpb24oZmVhdHVyZSwgc3RhbmRhcmRTZWN0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGZlYXR1cmUgKyAnIChzcGVjaWZpZWQgaW4gc2VjdGlvbiAnICsgc3RhbmRhcmRTZWN0aW9uICsgJyBvZiBwYXJ0IDE6IENvcmUgQ29kaW5nIFN5c3RlbSBzdGFuZGFyZCkgaXMgbm90IHN1cHBvcnRlZCB5ZXQnO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdKMmsgVW5zdXBwb3J0ZWRGZWF0dXJlRXhjZXB0aW9uOiAnICsgdGhpcy5kZXNjcmlwdGlvbjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBQYXJzZUV4Y2VwdGlvbjogZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ0oyayBQYXJzZUV4Y2VwdGlvbjogJyArIHRoaXMuZGVzY3JpcHRpb247XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgSWxsZWdhbERhdGFFeGNlcHRpb246IGZ1bmN0aW9uKGlsbGVnYWxEYXRhRGVzY3JpcHRpb24sIHN0YW5kYXJkU2VjdGlvbikge1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBpbGxlZ2FsRGF0YURlc2NyaXB0aW9uICsgJyAoc2VlIHNlY3Rpb24gJyArIHN0YW5kYXJkU2VjdGlvbiArICcgb2YgcGFydCA5OiBJbnRlcmFjdGl2aXR5IHRvb2xzLCBBUElzIGFuZCBQcm90b2NvbHMpJztcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnSjJrIElsbGVnYWxEYXRhRXhjZXB0aW9uOiAnICsgdGhpcy5kZXNjcmlwdGlvbjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMuanBpcEV4Y2VwdGlvbnMgPSB7XHJcbiAgICBVbnN1cHBvcnRlZEZlYXR1cmVFeGNlcHRpb246IGZ1bmN0aW9uKGZlYXR1cmUsIHN0YW5kYXJkU2VjdGlvbikge1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBmZWF0dXJlICsgJyAoc3BlY2lmaWVkIGluIHNlY3Rpb24gJyArIHN0YW5kYXJkU2VjdGlvbiArICcgb2YgcGFydCA5OiBJbnRlcmFjdGl2aXR5IHRvb2xzLCBBUElzIGFuZCBQcm90b2NvbHMpIGlzIG5vdCBzdXBwb3J0ZWQgeWV0JztcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnSnBpcCBVbnN1cHBvcnRlZEZlYXR1cmVFeGNlcHRpb246ICcgKyB0aGlzLmRlc2NyaXB0aW9uO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIFBhcnNlRXhjZXB0aW9uOiBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnSnBpcCBQYXJzZUV4Y2VwdGlvbjogJyArIHRoaXMuZGVzY3JpcHRpb247XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgSWxsZWdhbERhdGFFeGNlcHRpb246IGZ1bmN0aW9uKGlsbGVnYWxEYXRhRGVzY3JpcHRpb24sIHN0YW5kYXJkU2VjdGlvbikge1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBpbGxlZ2FsRGF0YURlc2NyaXB0aW9uICsgJyAoc2VlIHNlY3Rpb24gJyArIHN0YW5kYXJkU2VjdGlvbiArICcgb2YgcGFydCA5OiBJbnRlcmFjdGl2aXR5IHRvb2xzLCBBUElzIGFuZCBQcm90b2NvbHMpJztcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnSnBpcCBJbGxlZ2FsRGF0YUV4Y2VwdGlvbjogJyArIHRoaXMuZGVzY3JpcHRpb247XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICBcclxuICAgIElsbGVnYWxPcGVyYXRpb25FeGNlcHRpb246IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdKcGlwIElsbGVnYWxPcGVyYXRpb25FeGNlcHRpb246ICcgKyB0aGlzLmRlc2NyaXB0aW9uO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBBcmd1bWVudEV4Y2VwdGlvbjogZnVuY3Rpb24oYXJndW1lbnROYW1lLCBhcmd1bWVudFZhbHVlLCBkZXNjcmlwdGlvbikge1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnQXJndW1lbnQgJyArIGFyZ3VtZW50TmFtZSArICcgaGFzIGludmFsaWQgdmFsdWUgJyArXHJcbiAgICAgICAgICAgIGFyZ3VtZW50VmFsdWUgKyAoZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCA/ICcgOicgKyBkZXNjcmlwdGlvbiA6ICcnKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnSnBpcCBBcmd1bWVudEV4Y2VwdGlvbjogJyArIHRoaXMuZGVzY3JpcHRpb247XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgV3JvbmdTdHJlYW1FeGNlcHRpb246IGZ1bmN0aW9uKHJlcXVlc3RlZE9wZXJhdGlvbiwgaXNKUFQpIHtcclxuICAgICAgICB2YXIgY29ycmVjdFN0cmVhbSA9ICdKUFAgKEpQSVAgUHJlY2luY3QpJztcclxuICAgICAgICB2YXIgd3JvbmdTdHJlYW0gPSAnSlBUIChKUElQIFRpbGUtcGFydCknO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChpc0pQVCkge1xyXG4gICAgICAgICAgICB2YXIgc3dhcCA9IGNvcnJlY3RTdHJlYW07XHJcbiAgICAgICAgICAgIGNvcnJlY3RTdHJlYW0gPSB3cm9uZ1N0cmVhbTtcclxuICAgICAgICAgICAgd3JvbmdTdHJlYW0gPSBzd2FwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gICAgJ1N0cmVhbSB0eXBlIGlzICcgKyB3cm9uZ1N0cmVhbSArICcsIGJ1dCAnICsgcmVxdWVzdGVkT3BlcmF0aW9uICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgaXMgYWxsb3dlZCBvbmx5IGluICcgKyBjb3JyZWN0U3RyZWFtICsgJyBzdHJlYW0nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ0pwaXAgV3JvbmdTdHJlYW1FeGNlcHRpb246ICcgKyB0aGlzLmRlc2NyaXB0aW9uO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIEludGVybmFsRXJyb3JFeGNlcHRpb246IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdKcGlwIEludGVybmFsRXJyb3JFeGNlcHRpb246ICcgKyB0aGlzLmRlc2NyaXB0aW9uO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5qMmtFeGNlcHRpb25zLlVuc3VwcG9ydGVkRmVhdHVyZUV4Y2VwdGlvbi5OYW1lID1cclxuICAgICdqMmtFeGNlcHRpb25zLlVuc3VwcG9ydGVkRmVhdHVyZUV4Y2VwdGlvbic7XHJcbm1vZHVsZS5leHBvcnRzLmoya0V4Y2VwdGlvbnMuUGFyc2VFeGNlcHRpb24uTmFtZSA9XHJcbiAgICAnajJrRXhjZXB0aW9ucy5QYXJzZUV4Y2VwdGlvbic7XHJcbm1vZHVsZS5leHBvcnRzLmoya0V4Y2VwdGlvbnMuSWxsZWdhbERhdGFFeGNlcHRpb24uTmFtZSA9XHJcbiAgICAnajJrRXhjZXB0aW9ucy5JbGxlZ2FsRGF0YUV4Y2VwdGlvbic7XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5qcGlwRXhjZXB0aW9ucy5VbnN1cHBvcnRlZEZlYXR1cmVFeGNlcHRpb24uTmFtZSA9XHJcbiAgICAnanBpcEV4Y2VwdGlvbnMuVW5zdXBwb3J0ZWRGZWF0dXJlRXhjZXB0aW9uJztcclxubW9kdWxlLmV4cG9ydHMuanBpcEV4Y2VwdGlvbnMuUGFyc2VFeGNlcHRpb24uTmFtZSA9XHJcbiAgICAnanBpcEV4Y2VwdGlvbnMuUGFyc2VFeGNlcHRpb24nO1xyXG5tb2R1bGUuZXhwb3J0cy5qcGlwRXhjZXB0aW9ucy5JbGxlZ2FsRGF0YUV4Y2VwdGlvbi5OYW1lID1cclxuICAgICdqcGlwRXhjZXB0aW9ucy5JbGxlZ2FsRGF0YUV4Y2VwdGlvbic7XHJcbm1vZHVsZS5leHBvcnRzLmpwaXBFeGNlcHRpb25zLklsbGVnYWxPcGVyYXRpb25FeGNlcHRpb24uTmFtZSA9XHJcbiAgICAnanBpcEV4Y2VwdGlvbnMuSWxsZWdhbE9wZXJhdGlvbkV4Y2VwdGlvbic7XHJcbm1vZHVsZS5leHBvcnRzLmpwaXBFeGNlcHRpb25zLkFyZ3VtZW50RXhjZXB0aW9uLk5hbWUgPVxyXG4gICAgJ2pwaXBFeGNlcHRpb25zLkFyZ3VtZW50RXhjZXB0aW9uJztcclxubW9kdWxlLmV4cG9ydHMuanBpcEV4Y2VwdGlvbnMuV3JvbmdTdHJlYW1FeGNlcHRpb24uTmFtZSA9XHJcbiAgICAnanBpcEV4Y2VwdGlvbnMuV3JvbmdTdHJlYW1FeGNlcHRpb24nO1xyXG5tb2R1bGUuZXhwb3J0cy5qcGlwRXhjZXB0aW9ucy5JbnRlcm5hbEVycm9yRXhjZXB0aW9uLk5hbWUgPVxyXG4gICAgJ2pwaXBFeGNlcHRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24nOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBzaW1wbGVBamF4SGVscGVyICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJ3NpbXBsZS1hamF4LWhlbHBlci5qcycgICAgICAgICAgICAgICAgICkuc2ltcGxlQWpheEhlbHBlcjtcclxudmFyIG11dHVhbEV4Y2x1c2l2ZVRyYW5zYWN0aW9uSGVscGVyID0gcmVxdWlyZSgnbXV0dWFsLWV4Y2x1c2l2ZS10cmFuc2FjdGlvbi1oZWxwZXIuanMnKS5tdXR1YWxFeGNsdXNpdmVUcmFuc2FjdGlvbkhlbHBlcjtcclxuXHJcbnZhciBqcGlwQ29kaW5nUGFzc2VzTnVtYmVyUGFyc2VyID0gcmVxdWlyZSgnanBpcC1jb2RpbmctcGFzc2VzLW51bWJlci1wYXJzZXIuanMnKS5qcGlwQ29kaW5nUGFzc2VzTnVtYmVyUGFyc2VyO1xyXG52YXIganBpcE1lc3NhZ2VIZWFkZXJQYXJzZXIgICAgICA9IHJlcXVpcmUoJ2pwaXAtbWVzc2FnZS1oZWFkZXItcGFyc2VyLmpzJyAgICAgICkuanBpcE1lc3NhZ2VIZWFkZXJQYXJzZXI7XHJcblxyXG52YXIgSnBpcENoYW5uZWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCdqcGlwLWNoYW5uZWwuanMnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLkpwaXBDaGFubmVsO1xyXG52YXIgSnBpcENvZGVzdHJlYW1SZWNvbnN0cnVjdG9yICAgICAgICAgICAgICAgPSByZXF1aXJlKCdqcGlwLWNvZGVzdHJlYW0tcmVjb25zdHJ1Y3Rvci5qcycgICAgICAgICAgICAgICAgICApLkpwaXBDb2Rlc3RyZWFtUmVjb25zdHJ1Y3RvcjtcclxudmFyIEpwaXBDb2Rlc3RyZWFtU2l6ZXNDYWxjdWxhdG9yICAgICAgICAgICAgID0gcmVxdWlyZSgnanBpcC1jb2Rlc3RyZWFtLXNpemVzLWNhbGN1bGF0b3IuanMnICAgICAgICAgICAgICAgKS5KcGlwQ29kZXN0cmVhbVNpemVzQ2FsY3VsYXRvcjtcclxudmFyIEpwaXBDb2Rlc3RyZWFtU3RydWN0dXJlICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnanBpcC1jb2Rlc3RyZWFtLXN0cnVjdHVyZS5qcycgICAgICAgICAgICAgICAgICAgICAgKS5KcGlwQ29kZXN0cmVhbVN0cnVjdHVyZTtcclxudmFyIEpwaXBDb21wb25lbnRTdHJ1Y3R1cmUgICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnanBpcC1jb21wb25lbnQtc3RydWN0dXJlLmpzJyAgICAgICAgICAgICAgICAgICAgICAgKS5KcGlwQ29tcG9uZW50U3RydWN0dXJlO1xyXG52YXIgQ29tcG9zaXRlQXJyYXkgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCdjb21wb3NpdGUtYXJyYXkuanMnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLkNvbXBvc2l0ZUFycmF5O1xyXG52YXIgSnBpcERhdGFiaW5QYXJ0cyAgICAgICAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCdqcGlwLWRhdGFiaW4tcGFydHMuanMnICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLkpwaXBEYXRhYmluUGFydHM7XHJcbnZhciBKcGlwRGF0YWJpbnNTYXZlciAgICAgICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2pwaXAtZGF0YWJpbnMtc2F2ZXIuanMnICAgICAgICAgICAgICAgICAgICAgICAgICAgICkuSnBpcERhdGFiaW5zU2F2ZXI7XHJcbnZhciBKcGlwSGVhZGVyTW9kaWZpZXIgICAgICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2pwaXAtaGVhZGVyLW1vZGlmaWVyLmpzJyAgICAgICAgICAgICAgICAgICAgICAgICAgICkuSnBpcEhlYWRlck1vZGlmaWVyO1xyXG52YXIgSnBpcE1hcmtlcnNQYXJzZXIgICAgICAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCdqcGlwLW1hcmtlcnMtcGFyc2VyLmpzJyAgICAgICAgICAgICAgICAgICAgICAgICAgICApLkpwaXBNYXJrZXJzUGFyc2VyO1xyXG52YXIgSnBpcE9iamVjdFBvb2xCeURhdGFiaW4gICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCdqcGlwLW9iamVjdC1wb29sLWJ5LWRhdGFiaW4uanMnICAgICAgICAgICAgICAgICAgICApLkpwaXBPYmplY3RQb29sQnlEYXRhYmluO1xyXG52YXIgSnBpcE9mZnNldHNDYWxjdWxhdG9yICAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCdqcGlwLW9mZnNldHMtY2FsY3VsYXRvci5qcycgICAgICAgICAgICAgICAgICAgICAgICApLkpwaXBPZmZzZXRzQ2FsY3VsYXRvcjtcclxudmFyIEpwaXBQYWNrZXRzRGF0YUNvbGxlY3RvciAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnanBpcC1wYWNrZXRzLWRhdGEtY29sbGVjdG9yLmpzJyAgICAgICAgICAgICAgICAgICAgKS5KcGlwUGFja2V0c0RhdGFDb2xsZWN0b3I7XHJcbnZhciBKcGlwUmVxdWVzdENvbnRleHQgICAgICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2pwaXAtcmVxdWVzdC1jb250ZXh0LmpzJyAgICAgICAgICAgICAgICAgICAgICAgICAgICkuSnBpcFJlcXVlc3RDb250ZXh0O1xyXG52YXIgSnBpcFJlcXVlc3REYXRhYmluc0xpc3RlbmVyICAgICAgICAgICAgICAgPSByZXF1aXJlKCdqcGlwLXJlcXVlc3QtZGF0YWJpbnMtbGlzdGVuZXIuanMnICAgICAgICAgICAgICAgICApLkpwaXBSZXF1ZXN0RGF0YWJpbnNMaXN0ZW5lcjtcclxudmFyIEpwaXBSZXF1ZXN0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnanBpcC1yZXF1ZXN0LmpzJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKS5KcGlwUmVxdWVzdDtcclxudmFyIEpwaXBTZXNzaW9uSGVscGVyICAgICAgICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnanBpcC1zZXNzaW9uLWhlbHBlci5qcycgICAgICAgICAgICAgICAgICAgICAgICAgICAgKS5KcGlwU2Vzc2lvbkhlbHBlcjtcclxudmFyIEpwaXBTZXNzaW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnanBpcC1zZXNzaW9uLmpzJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKS5KcGlwU2Vzc2lvbjtcclxudmFyIEpwaXBSZWNvbm5lY3RhYmxlUmVxdWVzdGVyICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnanBpcC1yZWNvbm5lY3RhYmxlLXJlcXVlc3Rlci5qcycgICAgICAgICAgICAgICAgICAgKS5KcGlwUmVjb25uZWN0YWJsZVJlcXVlc3RlcjtcclxudmFyIEpwaXBTdHJ1Y3R1cmVQYXJzZXIgICAgICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnanBpcC1zdHJ1Y3R1cmUtcGFyc2VyLmpzJyAgICAgICAgICAgICAgICAgICAgICAgICAgKS5KcGlwU3RydWN0dXJlUGFyc2VyO1xyXG52YXIgSnBpcFRpbGVTdHJ1Y3R1cmUgICAgICAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCdqcGlwLXRpbGUtc3RydWN0dXJlLmpzJyAgICAgICAgICAgICAgICAgICAgICAgICAgICApLkpwaXBUaWxlU3RydWN0dXJlO1xyXG52YXIgSnBpcEJpdHN0cmVhbVJlYWRlciAgICAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCdqcGlwLWJpdHN0cmVhbS1yZWFkZXIuanMnICAgICAgICAgICAgICAgICAgICAgICAgICApLkpwaXBCaXRzdHJlYW1SZWFkZXI7XHJcbnZhciBKcGlwVGFnVHJlZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2pwaXAtdGFnLXRyZWUuanMnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkuSnBpcFRhZ1RyZWU7XHJcbnZhciBKcGlwQ29kZWJsb2NrTGVuZ3RoUGFyc2VyICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJ2pwaXAtY29kZWJsb2NrLWxlbmd0aC1wYXJzZXIuanMnICAgICAgICAgICAgICAgICAgICkuSnBpcENvZGVibG9ja0xlbmd0aFBhcnNlcjtcclxudmFyIEpwaXBTdWJiYW5kTGVuZ3RoSW5QYWNrZXRIZWFkZXJDYWxjdWxhdG9yID0gcmVxdWlyZSgnanBpcC1zdWJiYW5kLWxlbmd0aC1pbi1wYWNrZXQtaGVhZGVyLWNhbGN1bGF0b3IuanMnKS5KcGlwU3ViYmFuZExlbmd0aEluUGFja2V0SGVhZGVyQ2FsY3VsYXRvcjtcclxudmFyIEpwaXBQYWNrZXRMZW5ndGhDYWxjdWxhdG9yICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnanBpcC1wYWNrZXQtbGVuZ3RoLWNhbGN1bGF0b3IuanMnICAgICAgICAgICAgICAgICAgKS5KcGlwUGFja2V0TGVuZ3RoQ2FsY3VsYXRvcjtcclxudmFyIEpwaXBRdWFsaXR5TGF5ZXJzQ2FjaGUgICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnanBpcC1xdWFsaXR5LWxheWVycy1jYWNoZS5qcycgICAgICAgICAgICAgICAgICAgICAgKS5KcGlwUXVhbGl0eUxheWVyc0NhY2hlO1xyXG5cclxudmFyIGpwaXBSdW50aW1lRmFjdG9yeSA9IHtcclxuICAgIGNyZWF0ZUNoYW5uZWw6IGZ1bmN0aW9uIGNyZWF0ZUNoYW5uZWwoXHJcbiAgICAgICAgbWF4UmVxdWVzdHNXYWl0aW5nRm9yUmVzcG9uc2VJbkNoYW5uZWwsIHNlc3Npb25IZWxwZXIpIHtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gbmV3IEpwaXBDaGFubmVsKFxyXG4gICAgICAgICAgICBtYXhSZXF1ZXN0c1dhaXRpbmdGb3JSZXNwb25zZUluQ2hhbm5lbCxcclxuICAgICAgICAgICAgc2Vzc2lvbkhlbHBlcixcclxuICAgICAgICAgICAganBpcFJ1bnRpbWVGYWN0b3J5KTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGNyZWF0ZUNvZGVzdHJlYW1SZWNvbnN0cnVjdG9yOiBmdW5jdGlvbihcclxuICAgICAgICBjb2Rlc3RyZWFtU3RydWN0dXJlLCBkYXRhYmluc1NhdmVyLCBoZWFkZXJNb2RpZmllciwgcXVhbGl0eUxheWVyc0NhY2hlKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIG5ldyBKcGlwQ29kZXN0cmVhbVJlY29uc3RydWN0b3IoXHJcbiAgICAgICAgICAgIGNvZGVzdHJlYW1TdHJ1Y3R1cmUsXHJcbiAgICAgICAgICAgIGRhdGFiaW5zU2F2ZXIsXHJcbiAgICAgICAgICAgIGhlYWRlck1vZGlmaWVyLFxyXG4gICAgICAgICAgICBxdWFsaXR5TGF5ZXJzQ2FjaGUpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgY3JlYXRlQ29kZXN0cmVhbVNpemVzQ2FsY3VsYXRvcjogZnVuY3Rpb24ocGFyYW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBKcGlwQ29kZXN0cmVhbVNpemVzQ2FsY3VsYXRvcihwYXJhbXMpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgY3JlYXRlQ29kZXN0cmVhbVN0cnVjdHVyZTogZnVuY3Rpb24oc3RydWN0dXJlUGFyc2VyLCBwcm9ncmVzc2lvbk9yZGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBKcGlwQ29kZXN0cmVhbVN0cnVjdHVyZShcclxuICAgICAgICAgICAgc3RydWN0dXJlUGFyc2VyLCBqcGlwUnVudGltZUZhY3RvcnksIHByb2dyZXNzaW9uT3JkZXIpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgY3JlYXRlQ29tcG9uZW50U3RydWN0dXJlOiBmdW5jdGlvbihwYXJhbXMsIHRpbGVTdHJ1Y3R1cmUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEpwaXBDb21wb25lbnRTdHJ1Y3R1cmUocGFyYW1zLCB0aWxlU3RydWN0dXJlKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGNyZWF0ZUNvbXBvc2l0ZUFycmF5OiBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2l0ZUFycmF5KG9mZnNldCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBjcmVhdGVEYXRhYmluUGFydHM6IGZ1bmN0aW9uKGNsYXNzSWQsIGluQ2xhc3NJZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgSnBpcERhdGFiaW5QYXJ0cyhjbGFzc0lkLCBpbkNsYXNzSWQsIGpwaXBSdW50aW1lRmFjdG9yeSk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBjcmVhdGVEYXRhYmluc1NhdmVyOiBmdW5jdGlvbihpc0pwaXBUaWxlcGFydFN0cmVhbSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgSnBpcERhdGFiaW5zU2F2ZXIoaXNKcGlwVGlsZXBhcnRTdHJlYW0sIGpwaXBSdW50aW1lRmFjdG9yeSk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBjcmVhdGVIZWFkZXJNb2RpZmllcjogZnVuY3Rpb24oXHJcbiAgICAgICAgY29kZXN0cmVhbVN0cnVjdHVyZSwgb2Zmc2V0c0NhbGN1bGF0b3IsIHByb2dyZXNzaW9uT3JkZXIpIHtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gbmV3IEpwaXBIZWFkZXJNb2RpZmllcihcclxuICAgICAgICAgICAgY29kZXN0cmVhbVN0cnVjdHVyZSwgb2Zmc2V0c0NhbGN1bGF0b3IsIHByb2dyZXNzaW9uT3JkZXIpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgY3JlYXRlTWFya2Vyc1BhcnNlcjogZnVuY3Rpb24obWFpbkhlYWRlckRhdGFiaW4pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEpwaXBNYXJrZXJzUGFyc2VyKFxyXG4gICAgICAgICAgICBtYWluSGVhZGVyRGF0YWJpbiwganBpcE1lc3NhZ2VIZWFkZXJQYXJzZXIsIGpwaXBSdW50aW1lRmFjdG9yeSk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBjcmVhdGVPYmplY3RQb29sQnlEYXRhYmluOiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEpwaXBPYmplY3RQb29sQnlEYXRhYmluKCk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBjcmVhdGVPZmZzZXRzQ2FsY3VsYXRvcjogZnVuY3Rpb24obWFpbkhlYWRlckRhdGFiaW4sIG1hcmtlcnNQYXJzZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEpwaXBPZmZzZXRzQ2FsY3VsYXRvcihtYWluSGVhZGVyRGF0YWJpbiwgbWFya2Vyc1BhcnNlcik7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBjcmVhdGVQYWNrZXRzRGF0YUNvbGxlY3RvcjogZnVuY3Rpb24oXHJcbiAgICAgICAgY29kZXN0cmVhbVN0cnVjdHVyZSwgZGF0YWJpbnNTYXZlciwgcXVhbGl0eUxheWVyc0NhY2hlKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIG5ldyBKcGlwUGFja2V0c0RhdGFDb2xsZWN0b3IoXHJcbiAgICAgICAgICAgIGNvZGVzdHJlYW1TdHJ1Y3R1cmUsXHJcbiAgICAgICAgICAgIGRhdGFiaW5zU2F2ZXIsXHJcbiAgICAgICAgICAgIHF1YWxpdHlMYXllcnNDYWNoZSxcclxuICAgICAgICAgICAganBpcFJ1bnRpbWVGYWN0b3J5KTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGNyZWF0ZVJlcXVlc3RDb250ZXh0OiBmdW5jdGlvbihcclxuICAgICAgICBqcGlwT2JqZWN0cyxcclxuICAgICAgICBjb2Rlc3RyZWFtUGFydFBhcmFtcyxcclxuICAgICAgICBjYWxsYmFjayxcclxuICAgICAgICBwcm9ncmVzc2l2ZW5lc3MsXHJcbiAgICAgICAgb3B0aW9ucykge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBuZXcgSnBpcFJlcXVlc3RDb250ZXh0KFxyXG4gICAgICAgICAgICBqcGlwT2JqZWN0cyxcclxuICAgICAgICAgICAgY29kZXN0cmVhbVBhcnRQYXJhbXMsXHJcbiAgICAgICAgICAgIGNhbGxiYWNrLFxyXG4gICAgICAgICAgICBwcm9ncmVzc2l2ZW5lc3MsXHJcbiAgICAgICAgICAgIG9wdGlvbnMpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgY3JlYXRlUmVxdWVzdERhdGFiaW5zTGlzdGVuZXI6IGZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3REYXRhYmluc0xpc3RlbmVyKFxyXG4gICAgICAgIGNvZGVzdHJlYW1QYXJ0UGFyYW1zLFxyXG4gICAgICAgIHF1YWxpdHlMYXllclJlYWNoZWRDYWxsYmFjayxcclxuICAgICAgICBjb2Rlc3RyZWFtU3RydWN0dXJlLFxyXG4gICAgICAgIGRhdGFiaW5zU2F2ZXIsXHJcbiAgICAgICAgcXVhbGl0eUxheWVyc0NhY2hlKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIG5ldyBKcGlwUmVxdWVzdERhdGFiaW5zTGlzdGVuZXIoXHJcbiAgICAgICAgICAgIGNvZGVzdHJlYW1QYXJ0UGFyYW1zLFxyXG4gICAgICAgICAgICBxdWFsaXR5TGF5ZXJSZWFjaGVkQ2FsbGJhY2ssXHJcbiAgICAgICAgICAgIGNvZGVzdHJlYW1TdHJ1Y3R1cmUsXHJcbiAgICAgICAgICAgIGRhdGFiaW5zU2F2ZXIsXHJcbiAgICAgICAgICAgIHF1YWxpdHlMYXllcnNDYWNoZSxcclxuICAgICAgICAgICAganBpcFJ1bnRpbWVGYWN0b3J5KTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGNyZWF0ZVJlcXVlc3Q6IGZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3QoXHJcbiAgICAgICAgc2Vzc2lvbkhlbHBlciwgY2hhbm5lbCwgcmVxdWVzdFVybCwgY2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBuZXcgSnBpcFJlcXVlc3QoXHJcbiAgICAgICAgICAgIHNlc3Npb25IZWxwZXIsXHJcbiAgICAgICAgICAgIGpwaXBNZXNzYWdlSGVhZGVyUGFyc2VyLFxyXG4gICAgICAgICAgICBjaGFubmVsLFxyXG4gICAgICAgICAgICByZXF1ZXN0VXJsLFxyXG4gICAgICAgICAgICBjYWxsYmFjayxcclxuICAgICAgICAgICAgZmFpbHVyZUNhbGxiYWNrKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGNyZWF0ZVNlc3Npb25IZWxwZXI6IGZ1bmN0aW9uIGNyZWF0ZVNlc3Npb25IZWxwZXIoXHJcbiAgICAgICAgZGF0YVJlcXVlc3RVcmwsXHJcbiAgICAgICAga25vd25UYXJnZXRJZCxcclxuICAgICAgICBjb2Rlc3RyZWFtU3RydWN0dXJlLFxyXG4gICAgICAgIGRhdGFiaW5zU2F2ZXIpIHtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gbmV3IEpwaXBTZXNzaW9uSGVscGVyKFxyXG4gICAgICAgICAgICBkYXRhUmVxdWVzdFVybCxcclxuICAgICAgICAgICAga25vd25UYXJnZXRJZCxcclxuICAgICAgICAgICAgY29kZXN0cmVhbVN0cnVjdHVyZSxcclxuICAgICAgICAgICAgZGF0YWJpbnNTYXZlcixcclxuICAgICAgICAgICAgc2ltcGxlQWpheEhlbHBlcik7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBjcmVhdGVTZXNzaW9uOiBmdW5jdGlvbiBjcmVhdGVTZXNzaW9uKFxyXG4gICAgICAgIG1heENoYW5uZWxzSW5TZXNzaW9uLFxyXG4gICAgICAgIG1heFJlcXVlc3RzV2FpdGluZ0ZvclJlc3BvbnNlSW5DaGFubmVsLFxyXG4gICAgICAgIHRhcmdldElkLFxyXG4gICAgICAgIGNvZGVzdHJlYW1TdHJ1Y3R1cmUsXHJcbiAgICAgICAgZGF0YWJpbnNTYXZlcikge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBuZXcgSnBpcFNlc3Npb24oXHJcbiAgICAgICAgICAgIG1heENoYW5uZWxzSW5TZXNzaW9uLFxyXG4gICAgICAgICAgICBtYXhSZXF1ZXN0c1dhaXRpbmdGb3JSZXNwb25zZUluQ2hhbm5lbCxcclxuICAgICAgICAgICAgdGFyZ2V0SWQsXHJcbiAgICAgICAgICAgIGNvZGVzdHJlYW1TdHJ1Y3R1cmUsXHJcbiAgICAgICAgICAgIGRhdGFiaW5zU2F2ZXIsXHJcbiAgICAgICAgICAgIHNldEludGVydmFsLFxyXG4gICAgICAgICAgICBjbGVhckludGVydmFsLFxyXG4gICAgICAgICAgICBqcGlwUnVudGltZUZhY3RvcnkpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgY3JlYXRlUmVjb25uZWN0YWJsZVJlcXVlc3RlcjogZnVuY3Rpb24oXHJcbiAgICAgICAgbWF4Q2hhbm5lbHNJblNlc3Npb24sXHJcbiAgICAgICAgbWF4UmVxdWVzdHNXYWl0aW5nRm9yUmVzcG9uc2VJbkNoYW5uZWwsXHJcbiAgICAgICAgY29kZXN0cmVhbVN0cnVjdHVyZSxcclxuICAgICAgICBkYXRhYmluc1NhdmVyKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIG5ldyBKcGlwUmVjb25uZWN0YWJsZVJlcXVlc3RlcihcclxuICAgICAgICAgICAgbWF4Q2hhbm5lbHNJblNlc3Npb24sXHJcbiAgICAgICAgICAgIG1heFJlcXVlc3RzV2FpdGluZ0ZvclJlc3BvbnNlSW5DaGFubmVsLFxyXG4gICAgICAgICAgICBjb2Rlc3RyZWFtU3RydWN0dXJlLFxyXG4gICAgICAgICAgICBkYXRhYmluc1NhdmVyLFxyXG4gICAgICAgICAgICBqcGlwUnVudGltZUZhY3RvcnkpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgY3JlYXRlU3RydWN0dXJlUGFyc2VyOiBmdW5jdGlvbihkYXRhYmluc1NhdmVyLCBtYXJrZXJzUGFyc2VyLCBvZmZzZXRzQ2FsY3VsYXRvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgSnBpcFN0cnVjdHVyZVBhcnNlcihcclxuICAgICAgICAgICAgZGF0YWJpbnNTYXZlciwgbWFya2Vyc1BhcnNlciwganBpcE1lc3NhZ2VIZWFkZXJQYXJzZXIsIG9mZnNldHNDYWxjdWxhdG9yKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGNyZWF0ZVRpbGVTdHJ1Y3R1cmU6IGZ1bmN0aW9uKFxyXG4gICAgICAgIHNpemVQYXJhbXMsIGNvZGVzdHJlYW1TdHJ1Y3R1cmUsIHByb2dyZXNzaW9uT3JkZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEpwaXBUaWxlU3RydWN0dXJlKFxyXG4gICAgICAgICAgICBzaXplUGFyYW1zLCBjb2Rlc3RyZWFtU3RydWN0dXJlLCBqcGlwUnVudGltZUZhY3RvcnksIHByb2dyZXNzaW9uT3JkZXIpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgY3JlYXRlQml0c3RyZWFtUmVhZGVyOiBmdW5jdGlvbiBjcmVhdGVCaXRzdHJlYW1SZWFkZXIoZGF0YWJpbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgSnBpcEJpdHN0cmVhbVJlYWRlcihcclxuICAgICAgICAgICAgZGF0YWJpbiwgbXV0dWFsRXhjbHVzaXZlVHJhbnNhY3Rpb25IZWxwZXIpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgY3JlYXRlVGFnVHJlZTogZnVuY3Rpb24gY3JlYXRlVGFnVHJlZShiaXRzdHJlYW1SZWFkZXIsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEpwaXBUYWdUcmVlKFxyXG4gICAgICAgICAgICBiaXRzdHJlYW1SZWFkZXIsIHdpZHRoLCBoZWlnaHQsIG11dHVhbEV4Y2x1c2l2ZVRyYW5zYWN0aW9uSGVscGVyKTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGNyZWF0ZUNvZGVibG9ja0xlbmd0aFBhcnNlcjogZnVuY3Rpb24gY3JlYXRlQ29kZWJsb2NrTGVuZ3RoUGFyc2VyKFxyXG4gICAgICAgIGJpdHN0cmVhbVJlYWRlciwgdHJhbnNhY3Rpb25IZWxwZXIpIHtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gbmV3IEpwaXBDb2RlYmxvY2tMZW5ndGhQYXJzZXIoXHJcbiAgICAgICAgICAgIGJpdHN0cmVhbVJlYWRlciwgbXV0dWFsRXhjbHVzaXZlVHJhbnNhY3Rpb25IZWxwZXIpO1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgY3JlYXRlU3ViYmFuZExlbmd0aEluUGFja2V0SGVhZGVyQ2FsY3VsYXRvciA6XHJcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlU3ViYmFuZExlbmd0aEluUGFja2V0SGVhZGVyQ2FsY3VsYXRvcihcclxuICAgICAgICAgICAgYml0c3RyZWFtUmVhZGVyLCBudW1Db2RlYmxvY2tzWEluU3ViYmFuZCwgbnVtQ29kZWJsb2Nrc1lJblN1YmJhbmQpIHtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gbmV3IEpwaXBTdWJiYW5kTGVuZ3RoSW5QYWNrZXRIZWFkZXJDYWxjdWxhdG9yKFxyXG4gICAgICAgICAgICBiaXRzdHJlYW1SZWFkZXIsXHJcbiAgICAgICAgICAgIG51bUNvZGVibG9ja3NYSW5TdWJiYW5kLFxyXG4gICAgICAgICAgICBudW1Db2RlYmxvY2tzWUluU3ViYmFuZCxcclxuICAgICAgICAgICAganBpcENvZGluZ1Bhc3Nlc051bWJlclBhcnNlcixcclxuICAgICAgICAgICAgbXV0dWFsRXhjbHVzaXZlVHJhbnNhY3Rpb25IZWxwZXIsXHJcbiAgICAgICAgICAgIGpwaXBSdW50aW1lRmFjdG9yeSk7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBjcmVhdGVQYWNrZXRMZW5ndGhDYWxjdWxhdG9yOiBmdW5jdGlvbiBjcmVhdGVQYWNrZXRMZW5ndGhDYWxjdWxhdG9yKFxyXG4gICAgICAgIHRpbGVTdHJ1Y3R1cmUsXHJcbiAgICAgICAgY29tcG9uZW50U3RydWN0dXJlLFxyXG4gICAgICAgIGRhdGFiaW4sXHJcbiAgICAgICAgc3RhcnRPZmZzZXRJbkRhdGFiaW4sXHJcbiAgICAgICAgcHJlY2luY3QpIHtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gbmV3IEpwaXBQYWNrZXRMZW5ndGhDYWxjdWxhdG9yKFxyXG4gICAgICAgICAgICB0aWxlU3RydWN0dXJlLFxyXG4gICAgICAgICAgICBjb21wb25lbnRTdHJ1Y3R1cmUsXHJcbiAgICAgICAgICAgIGRhdGFiaW4sXHJcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0SW5EYXRhYmluLFxyXG4gICAgICAgICAgICBwcmVjaW5jdCxcclxuICAgICAgICAgICAganBpcFJ1bnRpbWVGYWN0b3J5KTtcclxuICAgIH0sXHJcbiAgICBcclxuICAgIGNyZWF0ZVF1YWxpdHlMYXllcnNDYWNoZTogZnVuY3Rpb24gY3JlYXRlUXVhbGl0eUxheWVyc0NhY2hlKFxyXG4gICAgICAgIGNvZGVzdHJlYW1TdHJ1Y3R1cmUpIHtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gbmV3IEpwaXBRdWFsaXR5TGF5ZXJzQ2FjaGUoXHJcbiAgICAgICAgICAgIGNvZGVzdHJlYW1TdHJ1Y3R1cmUsXHJcbiAgICAgICAgICAgIGpwaXBSdW50aW1lRmFjdG9yeSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5qcGlwUnVudGltZUZhY3RvcnkgPSBqcGlwUnVudGltZUZhY3Rvcnk7IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGpHbG9iYWxzID0gcmVxdWlyZSgnajJrLWpwaXAtZ2xvYmFscy5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuc2ltcGxlQWpheEhlbHBlciA9IHtcclxuICAgIHJlcXVlc3Q6IGZ1bmN0aW9uIHJlcXVlc3QoXHJcbiAgICAgICAgdXJsLFxyXG4gICAgICAgIGNhbGxiYWNrRm9yQXN5bmNocm9ub3VzUmVxdWVzdCxcclxuICAgICAgICBmYWlsdXJlQ2FsbGJhY2tGb3JBc3luY2hyb25vdXNSZXF1ZXN0LFxyXG4gICAgICAgIHByb2dyZXNzaXZlUmVxdWVzdFF1YW50Qnl0ZXMpIHtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgYWpheFJlc3BvbnNlID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgdmFyIGlzU3luY2hyb25vdXMgPSBjYWxsYmFja0ZvckFzeW5jaHJvbm91c1JlcXVlc3QgPT09IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgdmFyIGlzRmluaXNoZWRSZXF1ZXN0ID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGJ5dGVzUmVjaWV2ZWRPbkxhc3RRdWFudCA9IDA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZnVuY3Rpb24gaW50ZXJuYWxBamF4Q2FsbGJhY2soZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNGaW5pc2hlZFJlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGFqYXhSZXNwb25zZS5yZWFkeVN0YXRlICE9PSA0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NpdmVSZXF1ZXN0UXVhbnRCeXRlcyA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgYWpheFJlc3BvbnNlLnJlc3BvbnNlID09PSBudWxsIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgYWpheFJlc3BvbnNlLnJlYWR5U3RhdGUgPCAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZXNSZWNpZXZlZCA9IGFqYXhSZXNwb25zZS5yZXNwb25zZS5ieXRlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJ5dGVzVGlsbExhc3RRdWFudCA9IGJ5dGVzUmVjaWV2ZWQgLSBieXRlc1JlY2lldmVkT25MYXN0UXVhbnQ7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmIChieXRlc1RpbGxMYXN0UXVhbnQgPCBwcm9ncmVzc2l2ZVJlcXVlc3RRdWFudEJ5dGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBieXRlc1JlY2lldmVkT25MYXN0UXVhbnQgPSBieXRlc1JlY2lldmVkO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaXNGaW5pc2hlZFJlcXVlc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAoYWpheFJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgYWpheFJlc3BvbnNlLnJlc3BvbnNlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbHVyZUNhbGxiYWNrRm9yQXN5bmNocm9ub3VzUmVxdWVzdChhamF4UmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKCFpc1N5bmNocm9ub3VzKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFja0ZvckFzeW5jaHJvbm91c1JlcXVlc3QoYWpheFJlc3BvbnNlLCBpc0ZpbmlzaGVkUmVxdWVzdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgYWpheFJlc3BvbnNlLm9wZW4oJ0dFVCcsIHVybCwgIWlzU3luY2hyb25vdXMpO1xyXG4gICAgICAgIGFqYXhSZXNwb25zZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBpbnRlcm5hbEFqYXhDYWxsYmFjaztcclxuICAgICAgICBcclxuICAgICAgICBpZiAoIWlzU3luY2hyb25vdXMpIHtcclxuICAgICAgICAgICAgLy8gTm90IHN1cHBvcnRlZCBmb3Igc3luY2hyb25vdXMgcmVxdWVzdHNcclxuICAgICAgICAgICAgYWpheFJlc3BvbnNlLm1velJlc3BvbnNlVHlwZSA9IGFqYXhSZXNwb25zZS5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHByb2dyZXNzaXZlUmVxdWVzdFF1YW50Qnl0ZXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBhamF4UmVzcG9uc2Uuc2V0UmVxdWVzdEhlYWRlcignWC1Db250ZW50LVR5cGUtT3B0aW9ucycsICdub3NuaWZmJyk7XHJcbiAgICAgICAgICAgIGFqYXhSZXNwb25zZS5vbnByb2dyZXNzID0gaW50ZXJuYWxBamF4Q2FsbGJhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGFqYXhSZXNwb25zZS5zZW5kKG51bGwpO1xyXG5cclxuICAgICAgICBpZiAoaXNTeW5jaHJvbm91cyAmJiAhaXNGaW5pc2hlZFJlcXVlc3QpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAnc3luY2hyb25vdXMgYWpheCBjYWxsIHdhcyBub3QgZmluaXNoZWQgc3luY2hyb25vdXNseScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gYWpheFJlc3BvbnNlO1xyXG4gICAgfVxyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBqR2xvYmFscyA9IHJlcXVpcmUoJ2oyay1qcGlwLWdsb2JhbHMuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLkpwaXBNYXJrZXJzUGFyc2VyID0gZnVuY3Rpb24gSnBpcE1hcmtlcnNQYXJzZXIoXHJcbiAgICBtYWluSGVhZGVyRGF0YWJpbiwgbWVzc2FnZUhlYWRlclBhcnNlciwganBpcEZhY3RvcnkpIHtcclxuICAgIFxyXG4gICAgdmFyIENBQ0hFX0tFWSA9ICdtYXJrZXJzJztcclxuICAgIFxyXG4gICAgdGhpcy5nZXRNYW5kYXRvcnlNYXJrZXJPZmZzZXRJbkRhdGFiaW4gPVxyXG4gICAgICAgIGZ1bmN0aW9uIGdldE1hbmRhdG9yeU1hcmtlck9mZnNldEluRGF0YWJpbkNsb3N1cmUoXHJcbiAgICAgICAgICAgIGRhdGFiaW4sIG1hcmtlciwgbWFya2VyTmFtZSwgc3RhbmRhcmRTZWN0aW9uKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIG9mZnNldCA9IGdldE1hcmtlck9mZnNldEluRGF0YWJpbihkYXRhYmluLCBtYXJrZXIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChvZmZzZXQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmoya0V4Y2VwdGlvbnMuSWxsZWdhbERhdGFFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICBtYXJrZXJOYW1lICsgJyBpcyBub3QgZm91bmQgd2hlcmUgZXhwZWN0ZWQgdG8gYmUnLFxyXG4gICAgICAgICAgICAgICAgc3RhbmRhcmRTZWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuY2hlY2tTdXBwb3J0ZWRNYXJrZXJzID0gZnVuY3Rpb24gY2hlY2tTdXBwb3J0ZWRNYXJrZXJzQ2xvc3VyZShcclxuICAgICAgICBkYXRhYmluLCBtYXJrZXJzLCBpc01hcmtlcnNTdXBwb3J0ZWQpIHtcclxuICAgICAgICBcclxuICAgICAgICBpc01hcmtlcnNTdXBwb3J0ZWQgPSAhIWlzTWFya2Vyc1N1cHBvcnRlZDtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgZGF0YWJpbk1hcmtlcnMgPSBnZXREYXRhYmluTWFya2VycyhcclxuICAgICAgICAgICAgZGF0YWJpbiwgLypmb3JjZUFsbE1hcmtlcnNQYXJzZWQ9Ki90cnVlKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgbWFya2Vyc0FzUHJvcGVydGllcyA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgbWFya2VyID0gZ2V0TWFya2VyQXNQcm9wZXJ0eU5hbWUoXHJcbiAgICAgICAgICAgICAgICBtYXJrZXJzW2ldLCAnanBpcE1hcmtlcnNQYXJzZXIuc3VwcG9ydGVkTWFya2Vyc1snICsgaSArICddJyk7XHJcbiAgICAgICAgICAgIG1hcmtlcnNBc1Byb3BlcnRpZXNbbWFya2VyXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAodmFyIGV4aXN0aW5nTWFya2VyIGluIGRhdGFiaW5NYXJrZXJzLm1hcmtlclRvT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBpc01hcmtlckluTGlzdCA9ICEhbWFya2Vyc0FzUHJvcGVydGllc1tleGlzdGluZ01hcmtlcl07XHJcbiAgICAgICAgICAgIGlmIChpc01hcmtlckluTGlzdCAhPT0gaXNNYXJrZXJzU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuajJrRXhjZXB0aW9ucy5VbnN1cHBvcnRlZEZlYXR1cmVFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgJ1Vuc3VwcG9ydGVkIG1hcmtlciBmb3VuZDogJyArIGV4aXN0aW5nTWFya2VyLCAndW5rbm93bicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRNYXJrZXJPZmZzZXRJbkRhdGFiaW4gPSBnZXRNYXJrZXJPZmZzZXRJbkRhdGFiaW47XHJcbiAgICBcclxuICAgIHRoaXMuaXNNYXJrZXIgPSBpc01hcmtlcjtcclxuICAgIFxyXG4gICAgZnVuY3Rpb24gaXNNYXJrZXIoZGF0YSwgbWFya2VyLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gKGRhdGFbb2Zmc2V0XSA9PT0gbWFya2VyWzBdKSAmJiAoZGF0YVtvZmZzZXQgKyAxXSA9PT0gbWFya2VyWzFdKTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldE1hcmtlck9mZnNldEluRGF0YWJpbihkYXRhYmluLCBtYXJrZXIpIHtcclxuICAgICAgICB2YXIgZGF0YWJpbk1hcmtlcnMgPSBnZXREYXRhYmluTWFya2VycyhcclxuICAgICAgICAgICAgZGF0YWJpbiwgLypmb3JjZUFsbE1hcmtlcnNQYXJzZWQ9Ki90cnVlKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgc3RyTWFya2VyID0gZ2V0TWFya2VyQXNQcm9wZXJ0eU5hbWUoXHJcbiAgICAgICAgICAgIG1hcmtlciwgJ1ByZWRlZmluZWQgbWFya2VyIGluIGpHbG9iYWxzLmoya01hcmtlcnMnKTtcclxuICAgICAgICB2YXIgb2Zmc2V0ID0gZGF0YWJpbk1hcmtlcnMubWFya2VyVG9PZmZzZXRbc3RyTWFya2VyXTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBvZmZzZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0RGF0YWJpbk1hcmtlcnMoZGF0YWJpbiwgZm9yY2VBbGxNYXJrZXJzUGFyc2VkKSB7XHJcbiAgICAgICAgdmFyIGRhdGFiaW5NYXJrZXJzID0gZGF0YWJpbi5nZXRDYWNoZWREYXRhKENBQ0hFX0tFWSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGRhdGFiaW5NYXJrZXJzLm1hcmtlclRvT2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZGF0YWJpbk1hcmtlcnMuaXNQYXJzZWRBbGxNYXJrZXJzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGRhdGFiaW5NYXJrZXJzLmxhc3RPZmZzZXRQYXJzZWQgPSAwO1xyXG4gICAgICAgICAgICBkYXRhYmluTWFya2Vycy5tYXJrZXJUb09mZnNldCA9IHt9O1xyXG4gICAgICAgICAgICBkYXRhYmluTWFya2Vycy5kYXRhYmluID0gZGF0YWJpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGRhdGFiaW5NYXJrZXJzLmlzUGFyc2VkQWxsTWFya2Vycykge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0YWJpbk1hcmtlcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBzdGFydE9mZnNldCA9IDA7XHJcbiAgICAgICAgdmFyIGJ5dGVzID0gW107XHJcbiAgICAgICAgdmFyIGNhblBhcnNlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKGRhdGFiaW4gPT09IG1haW5IZWFkZXJEYXRhYmluICYmIGRhdGFiaW5NYXJrZXJzLmxhc3RPZmZzZXRQYXJzZWQgPT09IDApIHtcclxuICAgICAgICAgICAgdmFyIGJ5dGVzQ29waWVkID0gZGF0YWJpbi5jb3B5Qnl0ZXMoYnl0ZXMsIC8qc3RhcnRPZmZzZXQ9Ki8wLCB7XHJcbiAgICAgICAgICAgICAgICBmb3JjZUNvcHlBbGxSYW5nZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIG1heExlbmd0aFRvQ29weTogakdsb2JhbHMuajJrT2Zmc2V0cy5NQVJLRVJfU0laRVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoYnl0ZXNDb3BpZWQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNhblBhcnNlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzTWFya2VyKGJ5dGVzLCBqR2xvYmFscy5qMmtNYXJrZXJzLlN0YXJ0T2ZDb2Rlc3RyZWFtLCAvKm9mZnNldD0qLzApKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuajJrRXhjZXB0aW9ucy5JbGxlZ2FsRGF0YUV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAnU09DIChTdGFydCBPZiBDb2Rlc3RyZWFtKSAnICtcclxuICAgICAgICAgICAgICAgICAgICAnaXMgbm90IGZvdW5kIHdoZXJlIGV4cGVjdGVkIHRvIGJlJyxcclxuICAgICAgICAgICAgICAgICAgICAnQS40LjEnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZGF0YWJpbk1hcmtlcnMubGFzdE9mZnNldFBhcnNlZCA9IDI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY2FuUGFyc2UpIHtcclxuICAgICAgICAgICAgYWN0dWFsUGFyc2VNYXJrZXJzKGRhdGFiaW5NYXJrZXJzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgYWZ0ZXJQYXJzZU1hcmtlcnMoZGF0YWJpbk1hcmtlcnMsIGZvcmNlQWxsTWFya2Vyc1BhcnNlZCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGRhdGFiaW5NYXJrZXJzO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBhY3R1YWxQYXJzZU1hcmtlcnMoZGF0YWJpbk1hcmtlcnMpIHtcclxuICAgICAgICB2YXIgb2Zmc2V0ID0gZGF0YWJpbk1hcmtlcnMubGFzdE9mZnNldFBhcnNlZDtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgYnl0ZXMgPSBbXTtcclxuICAgICAgICB2YXIgYnl0ZXNDb3BpZWQgPSBkYXRhYmluTWFya2Vycy5kYXRhYmluLmNvcHlCeXRlcyhieXRlcywgLypzdGFydE9mZnNldD0qLzAsIHtcclxuICAgICAgICAgICAgICAgIGZvcmNlQ29weUFsbFJhbmdlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbWF4TGVuZ3RoVG9Db3B5OiBqR2xvYmFscy5qMmtPZmZzZXRzLk1BUktFUl9TSVpFICsgakdsb2JhbHMuajJrT2Zmc2V0cy5MRU5HVEhfRklFTERfU0laRSxcclxuICAgICAgICAgICAgICAgIGRhdGFiaW5TdGFydE9mZnNldDogb2Zmc2V0XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICB3aGlsZSAoYnl0ZXNDb3BpZWQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIG1hcmtlciA9IGdldE1hcmtlckFzUHJvcGVydHlOYW1lKFxyXG4gICAgICAgICAgICAgICAgYnl0ZXMsXHJcbiAgICAgICAgICAgICAgICAnb2Zmc2V0ICcgKyBvZmZzZXQgKyAnIG9mIGRhdGFiaW4gd2l0aCBjbGFzcyBJRCA9ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFiaW5NYXJrZXJzLmRhdGFiaW4uZ2V0Q2xhc3NJZCgpICsgJyBhbmQgaW4gY2xhc3MgSUQgPSAnICtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhYmluTWFya2Vycy5kYXRhYmluLmdldEluQ2xhc3NJZCgpKTtcclxuICAgICAgICAgICAgZGF0YWJpbk1hcmtlcnMubWFya2VyVG9PZmZzZXRbbWFya2VyLnRvU3RyaW5nKCldID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBtZXNzYWdlSGVhZGVyUGFyc2VyLmdldEludDE2KGJ5dGVzLCBqR2xvYmFscy5qMmtPZmZzZXRzLk1BUktFUl9TSVpFKTtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IGxlbmd0aCArIGpHbG9iYWxzLmoya09mZnNldHMuTUFSS0VSX1NJWkU7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBieXRlc0NvcGllZCA9IGRhdGFiaW5NYXJrZXJzLmRhdGFiaW4uY29weUJ5dGVzKGJ5dGVzLCAvKnN0YXJ0T2Zmc2V0PSovMCwge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VDb3B5QWxsUmFuZ2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGhUb0NvcHk6IGpHbG9iYWxzLmoya09mZnNldHMuTUFSS0VSX1NJWkUgKyBqR2xvYmFscy5qMmtPZmZzZXRzLkxFTkdUSF9GSUVMRF9TSVpFLFxyXG4gICAgICAgICAgICAgICAgZGF0YWJpblN0YXJ0T2Zmc2V0OiBvZmZzZXRcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZGF0YWJpbk1hcmtlcnMubGFzdE9mZnNldFBhcnNlZCA9IG9mZnNldDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gYWZ0ZXJQYXJzZU1hcmtlcnMoZGF0YWJpbk1hcmtlcnMsIGZvcmNlQWxsTWFya2Vyc1BhcnNlZCkge1xyXG4gICAgICAgIHZhciBkYXRhYmluTGVuZ3RoID0gZGF0YWJpbk1hcmtlcnMuZGF0YWJpbi5nZXREYXRhYmluTGVuZ3RoSWZLbm93bigpO1xyXG4gICAgICAgIGRhdGFiaW5NYXJrZXJzLmlzUGFyc2VkQWxsTWFya2VycyA9IGRhdGFiaW5NYXJrZXJzLmxhc3RPZmZzZXRQYXJzZWQgPT09IGRhdGFiaW5MZW5ndGg7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKCFkYXRhYmluTWFya2Vycy5pc1BhcnNlZEFsbE1hcmtlcnMgJiYgZGF0YWJpbk1hcmtlcnMuZGF0YWJpbiAhPT0gbWFpbkhlYWRlckRhdGFiaW4pIHtcclxuICAgICAgICAgICAgdmFyIGJ5dGVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBieXRlc0NvcGllZCA9IGRhdGFiaW5NYXJrZXJzLmRhdGFiaW4uY29weUJ5dGVzKGJ5dGVzLCAvKnN0YXJ0T2Zmc2V0PSovMCwge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VDb3B5QWxsUmFuZ2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGhUb0NvcHk6IGpHbG9iYWxzLmoya09mZnNldHMuTUFSS0VSX1NJWkUsXHJcbiAgICAgICAgICAgICAgICBkYXRhYmluU3RhcnRPZmZzZXQ6IGRhdGFiaW5NYXJrZXJzLmxhc3RPZmZzZXRQYXJzZWRcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGJ5dGVzQ29waWVkICE9PSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICBpc01hcmtlcihieXRlcywgMCwgakdsb2JhbHMuajJrTWFya2Vycy5TdGFydE9mRGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgZGF0YWJpbk1hcmtlcnMubGFzdE9mZnNldFBhcnNlZCArPSBqR2xvYmFscy5qMmtPZmZzZXRzLk1BUktFUl9TSVpFO1xyXG4gICAgICAgICAgICAgICAgZGF0YWJpbk1hcmtlcnMuaXNQYXJzZWRBbGxNYXJrZXJzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoZm9yY2VBbGxNYXJrZXJzUGFyc2VkICYmICFkYXRhYmluTWFya2Vycy5pc1BhcnNlZEFsbE1hcmtlcnMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAnZGF0YS1iaW4gd2l0aCBjbGFzcyBJRCA9ICcgK1xyXG4gICAgICAgICAgICAgICAgZGF0YWJpbk1hcmtlcnMuZGF0YWJpbi5nZXRDbGFzc0lkKCkgKyAnIGFuZCBpbiBjbGFzcyBJRCA9ICcgK1xyXG4gICAgICAgICAgICAgICAgZGF0YWJpbk1hcmtlcnMuZGF0YWJpbi5nZXRJbkNsYXNzSWQoKSArXHJcbiAgICAgICAgICAgICAgICAnIHdhcyBub3QgcmVjaWV2ZWQgeWV0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBnZXRNYXJrZXJBc1Byb3BlcnR5TmFtZShieXRlcywgbWFya2VyUG9zaXRpb25EZXNjcmlwdGlvbikge1xyXG4gICAgICAgIGlmIChieXRlc1swXSAhPT0gMHhGRikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuajJrRXhjZXB0aW9ucy5JbGxlZ2FsRGF0YUV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICdFeHBlY3RlZCBtYXJrZXIgaW4gJyArIG1hcmtlclBvc2l0aW9uRGVzY3JpcHRpb24sICdBJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBtYXJrZXIgPSBieXRlc1sxXS50b1N0cmluZygxNik7XHJcbiAgICAgICAgcmV0dXJuIG1hcmtlcjtcclxuICAgIH1cclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgakdsb2JhbHMgPSByZXF1aXJlKCdqMmstanBpcC1nbG9iYWxzLmpzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5KcGlwT2Zmc2V0c0NhbGN1bGF0b3IgPSBmdW5jdGlvbiBKcGlwT2Zmc2V0c0NhbGN1bGF0b3IoXHJcbiAgICBtYWluSGVhZGVyRGF0YWJpbiwgbWFya2Vyc1BhcnNlcikge1xyXG4gICAgXHJcbiAgICB2YXIgc3VwcG9ydGVkTWFya2VycyA9IFtcclxuICAgICAgICBqR2xvYmFscy5qMmtNYXJrZXJzLkltYWdlQW5kVGlsZVNpemUsXHJcbiAgICAgICAgakdsb2JhbHMuajJrTWFya2Vycy5Db2RpbmdTdHlsZURlZmF1bHQsXHJcbiAgICAgICAgakdsb2JhbHMuajJrTWFya2Vycy5RdWFudGl6YXRpb25EZWZhdWx0LFxyXG4gICAgICAgIGpHbG9iYWxzLmoya01hcmtlcnMuQ29tbWVudFxyXG4gICAgICAgIF07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0Q29kaW5nU3R5bGVPZmZzZXQgPSBnZXRDb2RpbmdTdHlsZU9mZnNldDtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRDb2RpbmdTdHlsZUJhc2VQYXJhbXMgPSBnZXRDb2RpbmdTdHlsZUJhc2VQYXJhbXM7XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0SW1hZ2VBbmRUaWxlU2l6ZU9mZnNldCA9IGZ1bmN0aW9uIGdldEltYWdlQW5kVGlsZVNpemVPZmZzZXQoKSB7XHJcbiAgICAgICAgLy8gQS41LjEgKEltYWdlIGFuZCB0aWxlIHNpemUgbWFya2VyIHNlZ21lbnQpXHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHNpek1hcmtlck9mZnNldCA9IG1hcmtlcnNQYXJzZXIuZ2V0TWFuZGF0b3J5TWFya2VyT2Zmc2V0SW5EYXRhYmluKFxyXG4gICAgICAgICAgICBtYWluSGVhZGVyRGF0YWJpbixcclxuICAgICAgICAgICAgakdsb2JhbHMuajJrTWFya2Vycy5JbWFnZUFuZFRpbGVTaXplLFxyXG4gICAgICAgICAgICAnSW1hZ2UgYW5kIFRpbGUgU2l6ZSAoU0laKScsXHJcbiAgICAgICAgICAgICdBLjUuMScpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBzaXpNYXJrZXJPZmZzZXQ7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldFJhbmdlc09mQmVzdFJlc29sdXRpb25MZXZlbHNEYXRhID1cclxuICAgICAgICBmdW5jdGlvbiBnZXRSYW5nZXNXaXRoRGF0YU9mUmVzb2x1dGlvbkxldmVsc0Nsb3N1cmUoXHJcbiAgICAgICAgICAgIGRhdGFiaW4sIG51bVJlc29sdXRpb25MZXZlbHMpIHtcclxuICAgICAgICBcclxuICAgICAgICBtYXJrZXJzUGFyc2VyLmNoZWNrU3VwcG9ydGVkTWFya2VycyhcclxuICAgICAgICAgICAgZGF0YWJpbiwgc3VwcG9ydGVkTWFya2VycywgLyppc01hcmtlcnNTdXBwb3J0ZWQ9Ki90cnVlKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgbnVtRGVjb21wb3NpdGlvbkxldmVsc09mZnNldCA9IG51bGw7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGRhdGFiaW5Db2RpbmdTdHlsZURlZmF1bHRCYXNlUGFyYW1zID0gZ2V0Q29kaW5nU3R5bGVCYXNlUGFyYW1zKFxyXG4gICAgICAgICAgICBkYXRhYmluLCAvKmlzTWFuZGF0b3J5PSovZmFsc2UpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBkYXRhYmluT3JNYWluSGVhZGVyQ29kaW5nU3R5bGVCYXNlUGFyYW1zID0gZGF0YWJpbkNvZGluZ1N0eWxlRGVmYXVsdEJhc2VQYXJhbXM7XHJcbiAgICAgICAgaWYgKGRhdGFiaW5Db2RpbmdTdHlsZURlZmF1bHRCYXNlUGFyYW1zID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRhdGFiaW5Pck1haW5IZWFkZXJDb2RpbmdTdHlsZUJhc2VQYXJhbXMgPSBnZXRDb2RpbmdTdHlsZUJhc2VQYXJhbXMoXHJcbiAgICAgICAgICAgICAgICBtYWluSGVhZGVyRGF0YWJpbiwgLyppc01hbmRhdG9yeT0qL3RydWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG51bURlY29tcG9zaXRpb25MZXZlbHNPZmZzZXQgPVxyXG4gICAgICAgICAgICAgICAgZGF0YWJpbkNvZGluZ1N0eWxlRGVmYXVsdEJhc2VQYXJhbXMubnVtRGVjb21wb3NpdGlvbkxldmVsc09mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGNvZGluZ1N0eWxlTnVtUmVzb2x1dGlvbkxldmVscyA9IFxyXG4gICAgICAgICAgICBkYXRhYmluT3JNYWluSGVhZGVyQ29kaW5nU3R5bGVCYXNlUGFyYW1zLm51bVJlc29sdXRpb25MZXZlbHM7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIGlmIChjb2RpbmdTdHlsZU51bVJlc29sdXRpb25MZXZlbHMgPD0gbnVtUmVzb2x1dGlvbkxldmVscykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICdudW1SZXNvbHV0aW9uTGV2ZWxzICgnICsgbnVtUmVzb2x1dGlvbkxldmVscyArICcpIDw9IENPRC4nICtcclxuICAgICAgICAgICAgICAgICdudW1SZXNvbHV0aW9uTGV2ZWxzICgnICsgY29kaW5nU3R5bGVOdW1SZXNvbHV0aW9uTGV2ZWxzICsgJyknKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciByYW5nZXMgPSBbXTtcclxuXHJcbiAgICAgICAgYWRkUmFuZ2VPZkJlc3RSZXNvbHV0aW9uTGV2ZWxzSW5Db2RpbmdTdHlsZShcclxuICAgICAgICAgICAgcmFuZ2VzLCBkYXRhYmluQ29kaW5nU3R5bGVEZWZhdWx0QmFzZVBhcmFtcywgbnVtUmVzb2x1dGlvbkxldmVscyk7XHJcblxyXG4gICAgICAgIGFkZFJhbmdlT2ZCZXN0UmVzb2x1dGlvbkxldmVsc0luUXVhbnRpemF0aW9uKFxyXG4gICAgICAgICAgICByYW5nZXMsXHJcbiAgICAgICAgICAgIGRhdGFiaW4sXHJcbiAgICAgICAgICAgIGRhdGFiaW5Pck1haW5IZWFkZXJDb2RpbmdTdHlsZUJhc2VQYXJhbXMsXHJcbiAgICAgICAgICAgIG51bVJlc29sdXRpb25MZXZlbHMpO1xyXG5cclxuICAgICAgICB2YXIgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICByYW5nZXM6IHJhbmdlcyxcclxuICAgICAgICAgICAgbnVtRGVjb21wb3NpdGlvbkxldmVsc09mZnNldDogbnVtRGVjb21wb3NpdGlvbkxldmVsc09mZnNldFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBnZXRDb2RpbmdTdHlsZUJhc2VQYXJhbXMoXHJcbiAgICAgICAgZGF0YWJpbiwgaXNNYW5kYXRvcnkpIHtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgY29kaW5nU3R5bGVEZWZhdWx0T2Zmc2V0ID0gZ2V0Q29kaW5nU3R5bGVPZmZzZXQoXHJcbiAgICAgICAgICAgIGRhdGFiaW4sIGlzTWFuZGF0b3J5KTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoY29kaW5nU3R5bGVEZWZhdWx0T2Zmc2V0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgbnVtQnl0ZXMgPSA4O1xyXG4gICAgICAgIHZhciBieXRlc09mZnNldCA9IGNvZGluZ1N0eWxlRGVmYXVsdE9mZnNldCArIGpHbG9iYWxzLmoya09mZnNldHMuTUFSS0VSX1NJWkU7XHJcbiAgICAgICAgdmFyIGJ5dGVzID0gZ2V0Qnl0ZXMoZGF0YWJpbiwgbnVtQnl0ZXMsIGJ5dGVzT2Zmc2V0KTtcclxuXHJcbiAgICAgICAgdmFyIGNvZGluZ1N0eWxlRmxhZ3NGb3JBbGxDb21wb25lbnRzT2Zmc2V0ID0gMjsgLy8gU2NvZFxyXG4gICAgICAgIHZhciBjb2RpbmdTdHlsZUZsYWdzRm9yQWxsQ29tcG9uZW50cyA9XHJcbiAgICAgICAgICAgIGJ5dGVzW2NvZGluZ1N0eWxlRmxhZ3NGb3JBbGxDb21wb25lbnRzT2Zmc2V0XTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgdmFyIGlzRGVmYXVsdFByZWNpbmN0U2l6ZSA9ICEoY29kaW5nU3R5bGVGbGFnc0ZvckFsbENvbXBvbmVudHMgJiAweDEpO1xyXG4gICAgICAgIHZhciBpc1N0YXJ0T2ZQYWNrZXRNYXJrZXJBbGxvd2VkID0gISEoY29kaW5nU3R5bGVGbGFnc0ZvckFsbENvbXBvbmVudHMgJiAweDIpO1xyXG4gICAgICAgIHZhciBpc0VuZFBhY2tldEhlYWRlck1hcmtlckFsbG93ZWQgPSAhIShjb2RpbmdTdHlsZUZsYWdzRm9yQWxsQ29tcG9uZW50cyAmIDB4NCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIG51bURlY29tcG9zaXRpb25MZXZlbHNPZmZzZXRJbkJ5dGVzID0gNzsgLy8gU1Bjb2QsIDFzdCBieXRlXHJcbiAgICAgICAgdmFyIG51bURlY29tcG9zaXRpb25MZXZlbHMgPSBieXRlc1tudW1EZWNvbXBvc2l0aW9uTGV2ZWxzT2Zmc2V0SW5CeXRlc107XHJcbiAgICAgICAgdmFyIG51bVJlc29sdXRpb25MZXZlbHMgPSBudW1EZWNvbXBvc2l0aW9uTGV2ZWxzICsgMTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgbnVtRGVjb21wb3NpdGlvbkxldmVsc09mZnNldCA9IGJ5dGVzT2Zmc2V0ICsgbnVtRGVjb21wb3NpdGlvbkxldmVsc09mZnNldEluQnl0ZXM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHByZWNpbmN0U2l6ZXNPZmZzZXQgPSBpc0RlZmF1bHRQcmVjaW5jdFNpemUgPyBudWxsIDogY29kaW5nU3R5bGVEZWZhdWx0T2Zmc2V0ICsgMTQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgY29kaW5nU3R5bGVEZWZhdWx0T2Zmc2V0OiBjb2RpbmdTdHlsZURlZmF1bHRPZmZzZXQsXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpc0RlZmF1bHRQcmVjaW5jdFNpemU6IGlzRGVmYXVsdFByZWNpbmN0U2l6ZSxcclxuICAgICAgICAgICAgaXNTdGFydE9mUGFja2V0TWFya2VyQWxsb3dlZDogaXNTdGFydE9mUGFja2V0TWFya2VyQWxsb3dlZCxcclxuICAgICAgICAgICAgaXNFbmRQYWNrZXRIZWFkZXJNYXJrZXJBbGxvd2VkOiBpc0VuZFBhY2tldEhlYWRlck1hcmtlckFsbG93ZWQsXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBudW1SZXNvbHV0aW9uTGV2ZWxzOiBudW1SZXNvbHV0aW9uTGV2ZWxzLFxyXG4gICAgICAgICAgICBwcmVjaW5jdFNpemVzT2Zmc2V0OiBwcmVjaW5jdFNpemVzT2Zmc2V0LFxyXG4gICAgICAgICAgICBudW1EZWNvbXBvc2l0aW9uTGV2ZWxzT2Zmc2V0OiBudW1EZWNvbXBvc2l0aW9uTGV2ZWxzT2Zmc2V0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gYWRkUmFuZ2VPZkJlc3RSZXNvbHV0aW9uTGV2ZWxzSW5Db2RpbmdTdHlsZShcclxuICAgICAgICByYW5nZXMsIGNvZGluZ1N0eWxlRGVmYXVsdEJhc2VQYXJhbXMsIG51bVJlc29sdXRpb25MZXZlbHMpIHtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoY29kaW5nU3R5bGVEZWZhdWx0QmFzZVBhcmFtcyA9PT0gbnVsbCB8fFxyXG4gICAgICAgICAgICBjb2RpbmdTdHlsZURlZmF1bHRCYXNlUGFyYW1zLmlzRGVmYXVsdFByZWNpbmN0U2l6ZSkge1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgbGV2ZWxzTm90SW5SYW5nZSA9XHJcbiAgICAgICAgICAgIGNvZGluZ1N0eWxlRGVmYXVsdEJhc2VQYXJhbXMubnVtUmVzb2x1dGlvbkxldmVscyAtIG51bVJlc29sdXRpb25MZXZlbHM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGZpcnN0T2Zmc2V0SW5SYW5nZSA9XHJcbiAgICAgICAgICAgIGNvZGluZ1N0eWxlRGVmYXVsdEJhc2VQYXJhbXMucHJlY2luY3RTaXplc09mZnNldCArIGxldmVsc05vdEluUmFuZ2U7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIG1hcmtlckxlbmd0aE9mZnNldCA9IFxyXG4gICAgICAgICAgICBjb2RpbmdTdHlsZURlZmF1bHRCYXNlUGFyYW1zLmNvZGluZ1N0eWxlRGVmYXVsdE9mZnNldCArIGpHbG9iYWxzLmoya09mZnNldHMuTUFSS0VSX1NJWkU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHByZWNpbmN0U2l6ZXNSYW5nZSA9IHtcclxuICAgICAgICAgICAgbWFya2VyU2VnbWVudExlbmd0aE9mZnNldDogbWFya2VyTGVuZ3RoT2Zmc2V0LFxyXG4gICAgICAgICAgICBzdGFydDogZmlyc3RPZmZzZXRJblJhbmdlLFxyXG4gICAgICAgICAgICBsZW5ndGg6IG51bVJlc29sdXRpb25MZXZlbHNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBcclxuXHJcbiAgICAgICAgcmFuZ2VzLnB1c2gocHJlY2luY3RTaXplc1JhbmdlKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRRdWFudGl6YXRpb25EYXRhQnl0ZXNQZXJTdWJiYW5kKGRhdGFiaW4sIHF1YW50aXphdGlvblN0eWxlT2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHNxY2RPZmZzZXQgPSBxdWFudGl6YXRpb25TdHlsZU9mZnNldCArIDQ7IC8vIFNxY2RcclxuICAgICAgICB2YXIgYnl0ZXMgPSBnZXRCeXRlcyhkYXRhYmluLCAvKm51bUJ5dGVzPSovMSwgc3FjZE9mZnNldCk7XHJcbiAgICAgICAgdmFyIHF1YW50aXphdGlvblN0eWxlID0gYnl0ZXNbMF0gJiAweDFGO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBieXRlc1BlclN1YmJhbmQ7XHJcbiAgICAgICAgc3dpdGNoIChxdWFudGl6YXRpb25TdHlsZSkge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBieXRlc1BlclN1YmJhbmQgPSAxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGJ5dGVzUGVyU3ViYmFuZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgYnl0ZXNQZXJTdWJiYW5kID0gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmoya0V4Y2VwdGlvbnMuSWxsZWdhbERhdGFFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgJ1F1YW50aXphdGlvbiBzdHlsZSBvZiAnICsgcXVhbnRpemF0aW9uU3R5bGUsICdBLjYuNCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gYnl0ZXNQZXJTdWJiYW5kO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBhZGRSYW5nZU9mQmVzdFJlc29sdXRpb25MZXZlbHNJblF1YW50aXphdGlvbihcclxuICAgICAgICByYW5nZXMsXHJcbiAgICAgICAgZGF0YWJpbixcclxuICAgICAgICBjb2RpbmdTdHlsZURlZmF1bHRCYXNlUGFyYW1zLFxyXG4gICAgICAgIG51bVJlc29sdXRpb25MZXZlbHMpIHtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgcWNkTWFya2VyT2Zmc2V0ID0gbWFya2Vyc1BhcnNlci5nZXRNYXJrZXJPZmZzZXRJbkRhdGFiaW4oXHJcbiAgICAgICAgICAgIGRhdGFiaW4sIGpHbG9iYWxzLmoya01hcmtlcnMuUXVhbnRpemF0aW9uRGVmYXVsdCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHFjZE1hcmtlck9mZnNldCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBieXRlc1BlclN1YmJhbmQgPSBnZXRRdWFudGl6YXRpb25EYXRhQnl0ZXNQZXJTdWJiYW5kKFxyXG4gICAgICAgICAgICBkYXRhYmluLCBxY2RNYXJrZXJPZmZzZXQpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICBpZiAoYnl0ZXNQZXJTdWJiYW5kID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGxldmVsc05vdEluUmFuZ2UgPVxyXG4gICAgICAgICAgICBjb2RpbmdTdHlsZURlZmF1bHRCYXNlUGFyYW1zLm51bVJlc29sdXRpb25MZXZlbHMgLSBudW1SZXNvbHV0aW9uTGV2ZWxzO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBzdWJiYW5kc05vdEluUmFuZ2UgPSAxICsgMyAqIChsZXZlbHNOb3RJblJhbmdlIC0gMSk7XHJcbiAgICAgICAgdmFyIHN1YmJhbmRzSW5SYW5nZSA9IDMgKiBudW1SZXNvbHV0aW9uTGV2ZWxzO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBmaXJzdE9mZnNldEluUmFuZ2UgPVxyXG4gICAgICAgICAgICBxY2RNYXJrZXJPZmZzZXQgKyA1ICsgc3ViYmFuZHNOb3RJblJhbmdlICogYnl0ZXNQZXJTdWJiYW5kO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciByYW5nZUxlbmd0aCA9IHN1YmJhbmRzSW5SYW5nZSAqIGJ5dGVzUGVyU3ViYmFuZDtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgbWFya2VyTGVuZ3RoT2Zmc2V0ID0gcWNkTWFya2VyT2Zmc2V0ICsgakdsb2JhbHMuajJrT2Zmc2V0cy5NQVJLRVJfU0laRTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgcXVhbnRpemF0aW9uc1JhbmdlID0ge1xyXG4gICAgICAgICAgICBtYXJrZXJTZWdtZW50TGVuZ3RoT2Zmc2V0OiBtYXJrZXJMZW5ndGhPZmZzZXQsXHJcbiAgICAgICAgICAgIHN0YXJ0OiBmaXJzdE9mZnNldEluUmFuZ2UsXHJcbiAgICAgICAgICAgIGxlbmd0aDogcmFuZ2VMZW5ndGhcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICByYW5nZXMucHVzaChxdWFudGl6YXRpb25zUmFuZ2UpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBleHBlY3ROb0NvZGluZ1N0eWxlQ29tcG9uZW50KGRhdGFiaW4pIHtcclxuICAgICAgICB2YXIgY29jT2Zmc2V0ID0gbWFya2Vyc1BhcnNlci5nZXRNYXJrZXJPZmZzZXRJbkRhdGFiaW4oXHJcbiAgICAgICAgICAgIGRhdGFiaW4sIGpHbG9iYWxzLmoya01hcmtlcnMuQ29kaW5nU3R5bGVDb21wb25lbnQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChjb2NPZmZzZXQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gQS42LjJcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmoya0V4Y2VwdGlvbnMuVW5zdXBwb3J0ZWRGZWF0dXJlRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgJ0NPQyBNYXJrZXIgKENvZGluZyBTdHlsZSBDb21wb25lbnQpJywgJ0EuNi4yJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBnZXRDb2RpbmdTdHlsZU9mZnNldChkYXRhYmluLCBpc01hbmRhdG9yeSkge1xyXG4gICAgICAgIGV4cGVjdE5vQ29kaW5nU3R5bGVDb21wb25lbnQoZGF0YWJpbik7XHJcblxyXG4gICAgICAgIHZhciBvZmZzZXQ7XHJcbiAgICAgICAgaWYgKGlzTWFuZGF0b3J5KSB7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IG1hcmtlcnNQYXJzZXIuZ2V0TWFuZGF0b3J5TWFya2VyT2Zmc2V0SW5EYXRhYmluKFxyXG4gICAgICAgICAgICAgICAgZGF0YWJpbixcclxuICAgICAgICAgICAgICAgIGpHbG9iYWxzLmoya01hcmtlcnMuQ29kaW5nU3R5bGVEZWZhdWx0LFxyXG4gICAgICAgICAgICAgICAgJ0NPRCAoQ29kaW5nIHN0eWxlIERlZmF1bHQpJyxcclxuICAgICAgICAgICAgICAgICdBLjYuMScpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IG1hcmtlcnNQYXJzZXIuZ2V0TWFya2VyT2Zmc2V0SW5EYXRhYmluKFxyXG4gICAgICAgICAgICAgICAgZGF0YWJpbiwgakdsb2JhbHMuajJrTWFya2Vycy5Db2RpbmdTdHlsZURlZmF1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBnZXRCeXRlcyhkYXRhYmluLCBudW1CeXRlcywgZGF0YWJpblN0YXJ0T2Zmc2V0LCBhbGxvd0VuZE9mUmFuZ2UpIHtcclxuICAgICAgICB2YXIgYnl0ZXMgPSBbXTtcclxuXHJcbiAgICAgICAgdmFyIHJhbmdlT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgZm9yY2VDb3B5QWxsUmFuZ2U6IHRydWUsXHJcbiAgICAgICAgICAgIG1heExlbmd0aFRvQ29weTogbnVtQnl0ZXMsXHJcbiAgICAgICAgICAgIGRhdGFiaW5TdGFydE9mZnNldDogZGF0YWJpblN0YXJ0T2Zmc2V0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGJ5dGVzQ29waWVkID0gZGF0YWJpbi5jb3B5Qnl0ZXMoYnl0ZXMsIC8qc3RhcnRPZmZzZXQ9Ki8wLCByYW5nZU9wdGlvbnMpO1xyXG4gICAgICAgIGlmIChieXRlc0NvcGllZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICdIZWFkZXIgZGF0YS1iaW4gaGFzIG5vdCB5ZXQgcmVjaWV2ZWQgJyArIG51bUJ5dGVzICtcclxuICAgICAgICAgICAgICAgICcgYnl0ZXMgc3RhcnRpbmcgZnJvbSBvZmZzZXQgJyArIGRhdGFiaW5TdGFydE9mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBieXRlcztcclxuICAgIH1cclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgakdsb2JhbHMgPSByZXF1aXJlKCdqMmstanBpcC1nbG9iYWxzLmpzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5KcGlwU3RydWN0dXJlUGFyc2VyID0gZnVuY3Rpb24gSnBpcFN0cnVjdHVyZVBhcnNlcihcclxuICAgIGRhdGFiaW5zU2F2ZXIsIG1hcmtlcnNQYXJzZXIsIG1lc3NhZ2VIZWFkZXJQYXJzZXIsIG9mZnNldHNDYWxjdWxhdG9yKSB7XHJcbiAgICBcclxuICAgIHRoaXMucGFyc2VDb2Rlc3RyZWFtU3RydWN0dXJlID0gZnVuY3Rpb24gcGFyc2VDb2Rlc3RyZWFtU3RydWN0dXJlKCkge1xyXG4gICAgICAgIC8vIEEuNS4xIChJbWFnZSBhbmQgVGlsZSBTaXplKVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBtYWluSGVhZGVyRGF0YWJpbiA9IGRhdGFiaW5zU2F2ZXIuZ2V0TWFpbkhlYWRlckRhdGFiaW4oKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgc2l6TWFya2VyT2Zmc2V0ID0gb2Zmc2V0c0NhbGN1bGF0b3IuZ2V0SW1hZ2VBbmRUaWxlU2l6ZU9mZnNldCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBieXRlcyA9IGdldEJ5dGVzKFxyXG4gICAgICAgICAgICBtYWluSGVhZGVyRGF0YWJpbixcclxuICAgICAgICAgICAgLypudW1CeXRlcz0qLzM4LFxyXG4gICAgICAgICAgICBzaXpNYXJrZXJPZmZzZXQgKyBqR2xvYmFscy5qMmtPZmZzZXRzLk1BUktFUl9TSVpFICsgakdsb2JhbHMuajJrT2Zmc2V0cy5MRU5HVEhfRklFTERfU0laRSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlZmVyZW5jZUdyaWRTaXplT2Zmc2V0ID1cclxuICAgICAgICAgICAgakdsb2JhbHMuajJrT2Zmc2V0cy5SRUZFUkVOQ0VfR1JJRF9TSVpFX09GRlNFVF9BRlRFUl9TSVpfTUFSS0VSIC1cclxuICAgICAgICAgICAgKGpHbG9iYWxzLmoya09mZnNldHMuTUFSS0VSX1NJWkUgKyBqR2xvYmFscy5qMmtPZmZzZXRzLkxFTkdUSF9GSUVMRF9TSVpFKTtcclxuICAgICAgICB2YXIgbnVtQ29tcG9uZW50c09mZnNldCA9XHJcbiAgICAgICAgICAgIGpHbG9iYWxzLmoya09mZnNldHMuTlVNX0NPTVBPTkVOVFNfT0ZGU0VUX0FGVEVSX1NJWl9NQVJLRVIgLVxyXG4gICAgICAgICAgICAoakdsb2JhbHMuajJrT2Zmc2V0cy5NQVJLRVJfU0laRSArIGpHbG9iYWxzLmoya09mZnNldHMuTEVOR1RIX0ZJRUxEX1NJWkUpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB2YXIgcmVmZXJlbmNlR3JpZFNpemVYID0gbWVzc2FnZUhlYWRlclBhcnNlci5nZXRJbnQzMihcclxuICAgICAgICAgICAgYnl0ZXMsIHJlZmVyZW5jZUdyaWRTaXplT2Zmc2V0KTsgLy8gWFNpelxyXG4gICAgICAgIHZhciByZWZlcmVuY2VHcmlkU2l6ZVkgPSBtZXNzYWdlSGVhZGVyUGFyc2VyLmdldEludDMyKFxyXG4gICAgICAgICAgICBieXRlcywgcmVmZXJlbmNlR3JpZFNpemVPZmZzZXQgKyA0KTsgLy8gWVNpelxyXG4gICAgICAgICAgICBcclxuICAgICAgICB2YXIgaW1hZ2VPZmZzZXRYID0gbWVzc2FnZUhlYWRlclBhcnNlci5nZXRJbnQzMihieXRlcywgMTApOyAvLyBYT1NpelxyXG4gICAgICAgIHZhciBpbWFnZU9mZnNldFkgPSBtZXNzYWdlSGVhZGVyUGFyc2VyLmdldEludDMyKGJ5dGVzLCAxNCk7IC8vIFlPU2l6XHJcbiAgICAgICAgdmFyIHRpbGVTaXplWCA9IG1lc3NhZ2VIZWFkZXJQYXJzZXIuZ2V0SW50MzIoYnl0ZXMsIDE4KTsgLy8gWFRTaXpcclxuICAgICAgICB2YXIgdGlsZVNpemVZID0gbWVzc2FnZUhlYWRlclBhcnNlci5nZXRJbnQzMihieXRlcywgMjIpOyAvLyBZVFNpelxyXG4gICAgICAgIHZhciBmaXJzdFRpbGVPZmZzZXRYID0gbWVzc2FnZUhlYWRlclBhcnNlci5nZXRJbnQzMihieXRlcywgMjYpOyAvLyBYVE9TaXpcclxuICAgICAgICB2YXIgZmlyc3RUaWxlT2Zmc2V0WSA9IG1lc3NhZ2VIZWFkZXJQYXJzZXIuZ2V0SW50MzIoYnl0ZXMsIDMwKTsgLy8gWVRPU2l6XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIG51bUNvbXBvbmVudHMgPSBtZXNzYWdlSGVhZGVyUGFyc2VyLmdldEludDE2KGJ5dGVzLCBudW1Db21wb25lbnRzT2Zmc2V0KTsgLy8gQ1NpelxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBjb21wb25lbnRzRGF0YU9mZnNldCA9XHJcbiAgICAgICAgICAgIHNpek1hcmtlck9mZnNldCArIGpHbG9iYWxzLmoya09mZnNldHMuTlVNX0NPTVBPTkVOVFNfT0ZGU0VUX0FGVEVSX1NJWl9NQVJLRVIgKyAyO1xyXG4gICAgICAgIHZhciBjb21wb25lbnRzRGF0YUxlbmd0aCA9IG51bUNvbXBvbmVudHMgKiAzO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBjb21wb25lbnRzRGF0YUJ5dGVzID0gZ2V0Qnl0ZXMoXHJcbiAgICAgICAgICAgIG1haW5IZWFkZXJEYXRhYmluLCBjb21wb25lbnRzRGF0YUxlbmd0aCwgY29tcG9uZW50c0RhdGFPZmZzZXQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBjb21wb25lbnRzU2NhbGVYID0gbmV3IEFycmF5KG51bUNvbXBvbmVudHMpO1xyXG4gICAgICAgIHZhciBjb21wb25lbnRzU2NhbGVZID0gbmV3IEFycmF5KG51bUNvbXBvbmVudHMpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ29tcG9uZW50czsgKytpKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudHNTY2FsZVhbaV0gPSBjb21wb25lbnRzRGF0YUJ5dGVzW2kgKiAzICsgMV07XHJcbiAgICAgICAgICAgIGNvbXBvbmVudHNTY2FsZVlbaV0gPSBjb21wb25lbnRzRGF0YUJ5dGVzW2kgKiAzICsgMl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgIG51bUNvbXBvbmVudHM6IG51bUNvbXBvbmVudHMsXHJcbiAgICAgICAgICAgIGNvbXBvbmVudHNTY2FsZVg6IGNvbXBvbmVudHNTY2FsZVgsXHJcbiAgICAgICAgICAgIGNvbXBvbmVudHNTY2FsZVk6IGNvbXBvbmVudHNTY2FsZVksXHJcbiAgICAgICAgICAgIGltYWdlV2lkdGg6IHJlZmVyZW5jZUdyaWRTaXplWCAtIGZpcnN0VGlsZU9mZnNldFgsXHJcbiAgICAgICAgICAgIGltYWdlSGVpZ2h0OiByZWZlcmVuY2VHcmlkU2l6ZVkgLSBmaXJzdFRpbGVPZmZzZXRZLFxyXG4gICAgICAgICAgICB0aWxlV2lkdGg6IHRpbGVTaXplWCxcclxuICAgICAgICAgICAgdGlsZUhlaWdodDogdGlsZVNpemVZLFxyXG4gICAgICAgICAgICBmaXJzdFRpbGVPZmZzZXRYOiBmaXJzdFRpbGVPZmZzZXRYLFxyXG4gICAgICAgICAgICBmaXJzdFRpbGVPZmZzZXRZOiBmaXJzdFRpbGVPZmZzZXRZXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5wYXJzZURlZmF1bHRUaWxlUGFyYW1zID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIG1haW5IZWFkZXJEYXRhYmluID0gZGF0YWJpbnNTYXZlci5nZXRNYWluSGVhZGVyRGF0YWJpbigpO1xyXG5cclxuICAgICAgICB2YXIgdGlsZVBhcmFtcyA9IHBhcnNlQ29kaW5nU3R5bGUobWFpbkhlYWRlckRhdGFiaW4sIC8qaXNNYW5kYXRvcnk9Ki90cnVlKTtcclxuICAgICAgICByZXR1cm4gdGlsZVBhcmFtcztcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMucGFyc2VPdmVycmlkZW5UaWxlUGFyYW1zID0gZnVuY3Rpb24odGlsZUluZGV4KSB7XHJcbiAgICAgICAgdmFyIHRpbGVIZWFkZXJEYXRhYmluID0gZGF0YWJpbnNTYXZlci5nZXRUaWxlSGVhZGVyRGF0YWJpbih0aWxlSW5kZXgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEEuNC4yIChTdGFydCBPZiBUaWxlLXBhcnQpXHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHRpbGVQYXJhbXMgPSBwYXJzZUNvZGluZ1N0eWxlKHRpbGVIZWFkZXJEYXRhYmluLCAvKmlzTWFuZGF0b3J5PSovZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiB0aWxlUGFyYW1zO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZUNvZGluZ1N0eWxlKGRhdGFiaW4sIGlzTWFuZGF0b3J5KSB7XHJcbiAgICAgICAgLy8gQS41LjEgKEltYWdlIGFuZCBUaWxlIFNpemUpXHJcblxyXG4gICAgICAgIHZhciBiYXNlUGFyYW1zID0gb2Zmc2V0c0NhbGN1bGF0b3IuZ2V0Q29kaW5nU3R5bGVCYXNlUGFyYW1zKFxyXG4gICAgICAgICAgICBkYXRhYmluLCBpc01hbmRhdG9yeSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGJhc2VQYXJhbXMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbWFpbkhlYWRlckRhdGFiaW4gPSBkYXRhYmluc1NhdmVyLmdldE1haW5IZWFkZXJEYXRhYmluKCk7XHJcblxyXG4gICAgICAgIHZhciBzaXpNYXJrZXJPZmZzZXQgPSBvZmZzZXRzQ2FsY3VsYXRvci5nZXRJbWFnZUFuZFRpbGVTaXplT2Zmc2V0KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIG51bUNvbXBvbmVudHNPZmZzZXQgPVxyXG4gICAgICAgICAgICBzaXpNYXJrZXJPZmZzZXQgKyBqR2xvYmFscy5qMmtPZmZzZXRzLk5VTV9DT01QT05FTlRTX09GRlNFVF9BRlRFUl9TSVpfTUFSS0VSO1xyXG5cclxuICAgICAgICB2YXIgbnVtQ29tcG9uZW50c0J5dGVzID0gZ2V0Qnl0ZXMoXHJcbiAgICAgICAgICAgIG1haW5IZWFkZXJEYXRhYmluLFxyXG4gICAgICAgICAgICAvKm51bUJ5dGVzPSovMixcclxuICAgICAgICAgICAgLypzdGFydE9mZnNldD0qL251bUNvbXBvbmVudHNPZmZzZXQpO1xyXG4gICAgICAgIHZhciBudW1Db21wb25lbnRzID0gbWVzc2FnZUhlYWRlclBhcnNlci5nZXRJbnQxNihudW1Db21wb25lbnRzQnl0ZXMsIDApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBwYWNrZWRQYWNrZXRIZWFkZXJzTWFya2VySW5UaWxlSGVhZGVyID1cclxuICAgICAgICAgICAgbWFya2Vyc1BhcnNlci5nZXRNYXJrZXJPZmZzZXRJbkRhdGFiaW4oXHJcbiAgICAgICAgICAgICAgICBkYXRhYmluLCBqR2xvYmFscy5qMmtNYXJrZXJzLlBhY2tlZFBhY2tldEhlYWRlcnNJblRpbGVIZWFkZXIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBwYWNrZWRQYWNrZXRIZWFkZXJzTWFya2VySW5NYWluSGVhZGVyID1cclxuICAgICAgICAgICAgbWFya2Vyc1BhcnNlci5nZXRNYXJrZXJPZmZzZXRJbkRhdGFiaW4oXHJcbiAgICAgICAgICAgICAgICBtYWluSGVhZGVyRGF0YWJpbiwgakdsb2JhbHMuajJrTWFya2Vycy5QYWNrZWRQYWNrZXRIZWFkZXJzSW5NYWluSGVhZGVyKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgaXNQYWNrZXRIZWFkZXJzTmVhckRhdGEgPVxyXG4gICAgICAgICAgICBwYWNrZWRQYWNrZXRIZWFkZXJzTWFya2VySW5UaWxlSGVhZGVyID09PSBudWxsICYmXHJcbiAgICAgICAgICAgIHBhY2tlZFBhY2tldEhlYWRlcnNNYXJrZXJJbk1haW5IZWFkZXIgPT09IG51bGw7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGNvZGluZ1N0eWxlTW9yZURhdGFPZmZzZXQgPSBiYXNlUGFyYW1zLmNvZGluZ1N0eWxlRGVmYXVsdE9mZnNldCArIDY7XHJcbiAgICAgICAgdmFyIGNvZGluZ1N0eWxlTW9yZURhdGFCeXRlcyA9IGdldEJ5dGVzKFxyXG4gICAgICAgICAgICBkYXRhYmluLFxyXG4gICAgICAgICAgICAvKm51bUJ5dGVzPSovNixcclxuICAgICAgICAgICAgLypzdGFydE9mZnNldD0qL2NvZGluZ1N0eWxlTW9yZURhdGFPZmZzZXQpO1xyXG4gICAgICAgIHZhciBudW1RdWFsaXR5TGF5ZXJzID0gbWVzc2FnZUhlYWRlclBhcnNlci5nZXRJbnQxNihcclxuICAgICAgICAgICAgY29kaW5nU3R5bGVNb3JlRGF0YUJ5dGVzLCAwKTtcclxuXHJcbiAgICAgICAgdmFyIGNvZGVibG9ja1dpZHRoID0gcGFyc2VDb2RlYmxvY2tTaXplKFxyXG4gICAgICAgICAgICBjb2RpbmdTdHlsZU1vcmVEYXRhQnl0ZXMsIDQpO1xyXG4gICAgICAgIHZhciBjb2RlYmxvY2tIZWlnaHQgPSBwYXJzZUNvZGVibG9ja1NpemUoXHJcbiAgICAgICAgICAgIGNvZGluZ1N0eWxlTW9yZURhdGFCeXRlcywgNSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHByZWNpbmN0V2lkdGhzID0gbmV3IEFycmF5KGJhc2VQYXJhbXMubnVtUmVzb2x1dGlvbkxldmVscyk7XHJcbiAgICAgICAgdmFyIHByZWNpbmN0SGVpZ2h0cyA9IG5ldyBBcnJheShiYXNlUGFyYW1zLm51bVJlc29sdXRpb25MZXZlbHMpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBwcmVjaW5jdFNpemVzQnl0ZXMgPSBudWxsO1xyXG4gICAgICAgIGlmICghYmFzZVBhcmFtcy5pc0RlZmF1bHRQcmVjaW5jdFNpemUpIHtcclxuICAgICAgICAgICAgdmFyIHByZWNpbmN0U2l6ZXNCeXRlc05lZWRlZCA9IGJhc2VQYXJhbXMubnVtUmVzb2x1dGlvbkxldmVscztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHByZWNpbmN0U2l6ZXNCeXRlcyA9IGdldEJ5dGVzKFxyXG4gICAgICAgICAgICAgICAgZGF0YWJpbixcclxuICAgICAgICAgICAgICAgIHByZWNpbmN0U2l6ZXNCeXRlc05lZWRlZCxcclxuICAgICAgICAgICAgICAgIGJhc2VQYXJhbXMucHJlY2luY3RTaXplc09mZnNldCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZGVmYXVsdFNpemUgPSAxIDw8IDE1O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZVBhcmFtcy5udW1SZXNvbHV0aW9uTGV2ZWxzOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKGJhc2VQYXJhbXMuaXNEZWZhdWx0UHJlY2luY3RTaXplKSB7XHJcbiAgICAgICAgICAgICAgICBwcmVjaW5jdFdpZHRoc1tpXSA9IGRlZmF1bHRTaXplO1xyXG4gICAgICAgICAgICAgICAgcHJlY2luY3RIZWlnaHRzW2ldID0gZGVmYXVsdFNpemU7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHByZWNpbmN0U2l6ZU9mZnNldCA9IGk7XHJcbiAgICAgICAgICAgIHZhciBzaXplRXhwb25lbnRzID0gcHJlY2luY3RTaXplc0J5dGVzW3ByZWNpbmN0U2l6ZU9mZnNldF07XHJcbiAgICAgICAgICAgIHZhciBwcHggPSBzaXplRXhwb25lbnRzICYgMHgwRjtcclxuICAgICAgICAgICAgdmFyIHBweSA9IHNpemVFeHBvbmVudHMgPj4+IDQ7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBwcmVjaW5jdFdpZHRoc1tpXSA9IDEgKiBNYXRoLnBvdygyLCBwcHgpOyAvLyBBdm9pZCBuZWdhdGl2ZSByZXN1bHQgZHVlIHRvIHNpZ25lZCBjYWxjdWxhdGlvblxyXG4gICAgICAgICAgICBwcmVjaW5jdEhlaWdodHNbaV0gPSAxICogTWF0aC5wb3coMiwgcHB5KTsgLy8gQXZvaWQgbmVnYXRpdmUgcmVzdWx0IGR1ZSB0byBzaWduZWQgY2FsY3VsYXRpb25cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHBhcmFtc1BlckNvbXBvbmVudCA9IG5ldyBBcnJheShudW1Db21wb25lbnRzKTtcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bUNvbXBvbmVudHM7ICsraikge1xyXG4gICAgICAgICAgICBwYXJhbXNQZXJDb21wb25lbnRbal0gPSB7XHJcbiAgICAgICAgICAgICAgICBtYXhDb2RlYmxvY2tXaWR0aDogY29kZWJsb2NrV2lkdGgsXHJcbiAgICAgICAgICAgICAgICBtYXhDb2RlYmxvY2tIZWlnaHQ6IGNvZGVibG9ja0hlaWdodCxcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgbnVtUmVzb2x1dGlvbkxldmVsczogYmFzZVBhcmFtcy5udW1SZXNvbHV0aW9uTGV2ZWxzLFxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBwcmVjaW5jdFdpZHRoUGVyTGV2ZWw6IHByZWNpbmN0V2lkdGhzLFxyXG4gICAgICAgICAgICAgICAgcHJlY2luY3RIZWlnaHRQZXJMZXZlbDogcHJlY2luY3RIZWlnaHRzXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBkZWZhdWx0Q29tcG9uZW50UGFyYW1zID0ge1xyXG4gICAgICAgICAgICBtYXhDb2RlYmxvY2tXaWR0aDogY29kZWJsb2NrV2lkdGgsXHJcbiAgICAgICAgICAgIG1heENvZGVibG9ja0hlaWdodDogY29kZWJsb2NrSGVpZ2h0LFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbnVtUmVzb2x1dGlvbkxldmVsczogYmFzZVBhcmFtcy5udW1SZXNvbHV0aW9uTGV2ZWxzLFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcHJlY2luY3RXaWR0aFBlckxldmVsOiBwcmVjaW5jdFdpZHRocyxcclxuICAgICAgICAgICAgcHJlY2luY3RIZWlnaHRQZXJMZXZlbDogcHJlY2luY3RIZWlnaHRzXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHRpbGVQYXJhbXMgPSB7XHJcbiAgICAgICAgICAgIG51bVF1YWxpdHlMYXllcnM6IG51bVF1YWxpdHlMYXllcnMsXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpc1BhY2tldEhlYWRlcnNOZWFyRGF0YTogaXNQYWNrZXRIZWFkZXJzTmVhckRhdGEsXHJcbiAgICAgICAgICAgIGlzU3RhcnRPZlBhY2tldE1hcmtlckFsbG93ZWQ6IGJhc2VQYXJhbXMuaXNTdGFydE9mUGFja2V0TWFya2VyQWxsb3dlZCxcclxuICAgICAgICAgICAgaXNFbmRQYWNrZXRIZWFkZXJNYXJrZXJBbGxvd2VkOiBiYXNlUGFyYW1zLmlzRW5kUGFja2V0SGVhZGVyTWFya2VyQWxsb3dlZCxcclxuXHJcbiAgICAgICAgICAgIHBhcmFtc1BlckNvbXBvbmVudDogcGFyYW1zUGVyQ29tcG9uZW50LFxyXG4gICAgICAgICAgICBkZWZhdWx0Q29tcG9uZW50UGFyYW1zOiBkZWZhdWx0Q29tcG9uZW50UGFyYW1zXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHRpbGVQYXJhbXM7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHBhcnNlQ29kZWJsb2NrU2l6ZShieXRlcywgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIGNvZGVibG9ja1NpemVFeHBvbmVudE1pbnVzMiA9IGJ5dGVzW29mZnNldF07XHJcbiAgICAgICAgdmFyIGNvZGVibG9ja1NpemVFeHBvbmVudCA9IDIgKyAoY29kZWJsb2NrU2l6ZUV4cG9uZW50TWludXMyICYgMHgwRik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGNvZGVibG9ja1NpemVFeHBvbmVudCA+IDEwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qMmtFeGNlcHRpb25zLklsbGVnYWxEYXRhRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgJ0lsbGVnYWwgY29kZWJsb2NrIHdpZHRoIGV4cG9uZW50ICcgKyBjb2RlYmxvY2tTaXplRXhwb25lbnQsXHJcbiAgICAgICAgICAgICAgICAnQS42LjEsIFRhYmxlIEEuMTgnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHNpemUgPSAxIDw8IGNvZGVibG9ja1NpemVFeHBvbmVudDtcclxuICAgICAgICByZXR1cm4gc2l6ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gZ2V0Qnl0ZXMoZGF0YWJpbiwgbnVtQnl0ZXMsIGRhdGFiaW5TdGFydE9mZnNldCwgYWxsb3dFbmRPZlJhbmdlKSB7XHJcbiAgICAgICAgdmFyIGJ5dGVzID0gW107XHJcblxyXG4gICAgICAgIHZhciByYW5nZU9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGZvcmNlQ29weUFsbFJhbmdlOiB0cnVlLFxyXG4gICAgICAgICAgICBtYXhMZW5ndGhUb0NvcHk6IG51bUJ5dGVzLFxyXG4gICAgICAgICAgICBkYXRhYmluU3RhcnRPZmZzZXQ6IGRhdGFiaW5TdGFydE9mZnNldFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBieXRlc0NvcGllZCA9IGRhdGFiaW4uY29weUJ5dGVzKGJ5dGVzLCAvKnN0YXJ0T2Zmc2V0PSovMCwgcmFuZ2VPcHRpb25zKTtcclxuICAgICAgICBpZiAoYnl0ZXNDb3BpZWQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAnSGVhZGVyIGRhdGEtYmluIGhhcyBub3QgeWV0IHJlY2lldmVkICcgKyBudW1CeXRlcyArXHJcbiAgICAgICAgICAgICAgICAnIGJ5dGVzIHN0YXJ0aW5nIGZyb20gb2Zmc2V0ICcgKyBkYXRhYmluU3RhcnRPZmZzZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gYnl0ZXM7XHJcbiAgICB9XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGpHbG9iYWxzID0gcmVxdWlyZSgnajJrLWpwaXAtZ2xvYmFscy5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuSnBpcENoYW5uZWwgPSBmdW5jdGlvbiBKcGlwQ2hhbm5lbChcclxuICAgIG1heFJlcXVlc3RzV2FpdGluZ0ZvclJlc3BvbnNlSW5DaGFubmVsLCBzZXNzaW9uSGVscGVyLCBqcGlwRmFjdG9yeSkge1xyXG4gICAgXHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB2YXIgY2hhbm5lbElkID0gbnVsbDtcclxuICAgIHZhciByZXF1ZXN0SWQgPSAwO1xyXG4gICAgdmFyIHJlcXVlc3RzV2FpdGluZ0ZvckNoYW5uZWxDcmVhdGlvbiA9IFtdO1xyXG4gICAgdmFyIHJlcXVlc3RzV2FpdGluZ0ZvclJlc3BvbnNlID0gW107XHJcbiAgICB2YXIgaXNEZWRpY2F0ZWRGb3JNb3ZhYmxlUmVxdWVzdCA9IGZhbHNlO1xyXG4gICAgXHJcbiAgICB0aGlzLnJlcXVlc3REYXRhID0gZnVuY3Rpb24gcmVxdWVzdERhdGEoXHJcbiAgICAgICAgY29kZXN0cmVhbVBhcnRQYXJhbXMsXHJcbiAgICAgICAgY2FsbGJhY2ssXHJcbiAgICAgICAgZmFpbHVyZUNhbGxiYWNrLFxyXG4gICAgICAgIG51bVF1YWxpdHlMYXllcnMpIHtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoIWlzRGVkaWNhdGVkRm9yTW92YWJsZVJlcXVlc3QpIHtcclxuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgY29uY3VycmVudCByZXF1ZXN0c1xyXG4gICAgICAgICAgICAvLyBpZiBjaGFubmVsIHdhcyBkZWRpY2F0ZWQgZm9yIG1vdmFibGUgcmVxdWVzdC4gVGhlIHJlYXNvbiBpc1xyXG4gICAgICAgICAgICAvLyB0aGF0IGFueSByZXF1ZXN0IGluIGRlZGljYXRlZCBjaGFubmVsIGNhbmNlbCB0aGUgcHJldmlvdXMgb25lLlxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGFsbFdhaXRpbmdSZXF1ZXN0cyA9IGdldEFsbFF1ZXVlZFJlcXVlc3RDb3VudCgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGFsbFdhaXRpbmdSZXF1ZXN0cyA+PSBtYXhSZXF1ZXN0c1dhaXRpbmdGb3JSZXNwb25zZUluQ2hhbm5lbCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgJ0NoYW5uZWwgaGFzIHRvbyBtYW55IHJlcXVlc3RzIG5vdCByZXNwb25kZWQgeWV0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB1cmwgPSBjcmVhdGVSZXF1ZXN0VXJsKGNvZGVzdHJlYW1QYXJ0UGFyYW1zLCBudW1RdWFsaXR5TGF5ZXJzKTtcclxuICAgICAgICB2YXIgcmVxdWVzdCA9IGpwaXBGYWN0b3J5LmNyZWF0ZVJlcXVlc3QoXHJcbiAgICAgICAgICAgIHNlc3Npb25IZWxwZXIsXHJcbiAgICAgICAgICAgIHNlbGYsXHJcbiAgICAgICAgICAgIHVybCxcclxuICAgICAgICAgICAgY2FsbGJhY2ssXHJcbiAgICAgICAgICAgIGZhaWx1cmVDYWxsYmFjayk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGNoYW5uZWxJZCAhPT0gbnVsbCB8fCByZXF1ZXN0c1dhaXRpbmdGb3JSZXNwb25zZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmVxdWVzdHNXYWl0aW5nRm9yUmVzcG9uc2UucHVzaChyZXF1ZXN0KTtcclxuICAgICAgICAgICAgcmVxdWVzdC5zdGFydFJlcXVlc3QoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzRGVkaWNhdGVkRm9yTW92YWJsZVJlcXVlc3QpIHtcclxuICAgICAgICAgICAgLy8gVGhvc2UgcmVxdWVzdHMgY2FuY2VsIGFsbCBwcmV2aW91cyByZXF1ZXN0cyBpbiBjaGFubmVsLCBzbyBub1xyXG4gICAgICAgICAgICAvLyBuZWVkIHRvIGxvZyBvbGQgcmVxdWVzdHNcclxuICAgICAgICAgICAgcmVxdWVzdHNXYWl0aW5nRm9yQ2hhbm5lbENyZWF0aW9uID0gW3JlcXVlc3RdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RzV2FpdGluZ0ZvckNoYW5uZWxDcmVhdGlvbi5wdXNoKHJlcXVlc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuc2VuZE1pbmltYWxSZXF1ZXN0ID0gZnVuY3Rpb24gc2VuZE1pbmltYWxSZXF1ZXN0KGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKGNoYW5uZWxJZCA9PT0gbnVsbCAmJiByZXF1ZXN0c1dhaXRpbmdGb3JSZXNwb25zZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbnRlcm5hbEVycm9yRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgJ01pbmltYWwgcmVxdWVzdHMgc2hvdWxkIGJlIHVzZWQgZm9yIGZpcnN0IHJlcXVlc3Qgb3Iga2VlcCAnICtcclxuICAgICAgICAgICAgICAgICdhbGl2ZSBtZXNzYWdlLiBLZWVwIGFsaXZlIHJlcXVpcmVzIGFuIGFscmVhZHkgaW5pdGlhbGl6ZWQgJyArXHJcbiAgICAgICAgICAgICAgICAnY2hhbm5lbCwgYW5kIGZpcnN0IHJlcXVlc3QgcmVxdWlyZXMgdG8gbm90IGhhdmUgYW55ICcgK1xyXG4gICAgICAgICAgICAgICAgJ3ByZXZpb3VzIHJlcXVlc3QnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHVybCA9IGNyZWF0ZU1pbmltYWxSZXF1ZXN0VXJsKCk7XHJcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBqcGlwRmFjdG9yeS5jcmVhdGVSZXF1ZXN0KFxyXG4gICAgICAgICAgICBzZXNzaW9uSGVscGVyLCBzZWxmLCB1cmwsIGNhbGxiYWNrKTtcclxuICAgICAgICBcclxuICAgICAgICByZXF1ZXN0c1dhaXRpbmdGb3JSZXNwb25zZS5wdXNoKHJlcXVlc3QpO1xyXG4gICAgICAgIHJlcXVlc3Quc3RhcnRSZXF1ZXN0KCk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldElzRGVkaWNhdGVkRm9yTW92YWJsZVJlcXVlc3QgPVxyXG4gICAgICAgIGZ1bmN0aW9uIGdldElzRGVkaWNhdGVkRm9yTW92YWJsZVJlcXVlc3QoKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGlzRGVkaWNhdGVkRm9yTW92YWJsZVJlcXVlc3Q7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmRlZGljYXRlRm9yTW92YWJsZVJlcXVlc3QgPSBmdW5jdGlvbiBkZWRpY2F0ZUZvck1vdmFibGVSZXF1ZXN0KCkge1xyXG4gICAgICAgIGlmIChpc0RlZGljYXRlZEZvck1vdmFibGVSZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbnRlcm5hbEVycm9yRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgJ0NoYW5uZWwgYWxyZWFkeSBkZWRpY2F0ZWQgZm9yIG1vdmFibGUgcmVxdWVzdCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpc0RlZGljYXRlZEZvck1vdmFibGVSZXF1ZXN0ID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0Q2hhbm5lbElkID0gZnVuY3Rpb24gZ2V0Q2hhbm5lbElkKCkge1xyXG4gICAgICAgIHJldHVybiBjaGFubmVsSWQ7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLnNldENoYW5uZWxJZCA9IGZ1bmN0aW9uIHNldENoYW5uZWxJZChuZXdDaGFubmVsSWQpIHtcclxuICAgICAgICBpZiAobmV3Q2hhbm5lbElkID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2hhbm5lbElkID0gbmV3Q2hhbm5lbElkO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciByZXF1ZXN0c1RvU2VuZCA9IHJlcXVlc3RzV2FpdGluZ0ZvckNoYW5uZWxDcmVhdGlvbjtcclxuICAgICAgICByZXF1ZXN0c1dhaXRpbmdGb3JDaGFubmVsQ3JlYXRpb24gPSBbXTtcclxuICAgICAgICBcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcXVlc3RzVG9TZW5kLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RzV2FpdGluZ0ZvclJlc3BvbnNlLnB1c2gocmVxdWVzdHNUb1NlbmRbaV0pO1xyXG4gICAgICAgICAgICByZXF1ZXN0c1RvU2VuZFtpXS5zdGFydFJlcXVlc3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLm5leHRSZXF1ZXN0SWQgPSBmdW5jdGlvbiBuZXh0UmVxdWVzdElkKCkge1xyXG4gICAgICAgIHJldHVybiArK3JlcXVlc3RJZDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0UmVxdWVzdHNXYWl0aW5nRm9yUmVzcG9uc2UgPVxyXG4gICAgICAgIGZ1bmN0aW9uIGdldFJlcXVlc3RzV2FpdGluZ0ZvclJlc3BvbnNlKCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiByZXF1ZXN0c1dhaXRpbmdGb3JSZXNwb25zZTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0QWxsUXVldWVkUmVxdWVzdENvdW50ID0gZ2V0QWxsUXVldWVkUmVxdWVzdENvdW50O1xyXG4gICAgXHJcbiAgICB0aGlzLnJlcXVlc3RFbmRlZCA9IGZ1bmN0aW9uIHJlcXVlc3RFbmRlZChhamF4UmVzcG9uc2UsIHJlcXVlc3QpIHtcclxuICAgICAgICB2YXIgcmVxdWVzdHMgPSByZXF1ZXN0c1dhaXRpbmdGb3JSZXNwb25zZTtcclxuICAgICAgICB2YXIgaXNGb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVxdWVzdHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKHJlcXVlc3RzW2ldID09PSByZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0c1tpXSA9IHJlcXVlc3RzW3JlcXVlc3RzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdHMubGVuZ3RoIC09IDE7XHJcbiAgICAgICAgICAgICAgICBpc0ZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICghaXNGb3VuZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICdjaGFubmVsLnJlcXVlc3RzV2FpdGluZ0ZvclJlc3BvbnNlIGluY29uc2lzdGVuY3knKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgc2Vzc2lvbkhlbHBlci5yZXF1ZXN0RW5kZWQoYWpheFJlc3BvbnNlLCBzZWxmKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoY2hhbm5lbElkID09PSBudWxsICYmIHJlcXVlc3RzV2FpdGluZ0ZvckNoYW5uZWxDcmVhdGlvbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIElmIG5vdCBzdWNjZWVkZWQgdG8gY3JlYXRlIGEgY2hhbm5lbCBJRCB5ZXQsXHJcbiAgICAgICAgICAgIC8vIHBlcmZvcm0gYW4gYWRkaXRpb25hbCByZXF1ZXN0XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgbmV4dFJlcXVlc3QgPSByZXF1ZXN0c1dhaXRpbmdGb3JDaGFubmVsQ3JlYXRpb24uc2hpZnQoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJlcXVlc3RzV2FpdGluZ0ZvclJlc3BvbnNlLnB1c2gobmV4dFJlcXVlc3QpO1xyXG4gICAgICAgICAgICBuZXh0UmVxdWVzdC5zdGFydFJlcXVlc3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmlzQWxsT2xkUmVxdWVzdHNFbmRlZCA9IGZ1bmN0aW9uIGlzQWxsT2xkUmVxdWVzdHNFbmRlZChwcmlvclRvSWQpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcXVlc3RzV2FpdGluZ0ZvclJlc3BvbnNlLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0c1dhaXRpbmdGb3JSZXNwb25zZVtpXS5sYXN0UmVxdWVzdElkIDw9IHByaW9yVG9JZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZnVuY3Rpb24gZ2V0QWxsUXVldWVkUmVxdWVzdENvdW50KCkge1xyXG4gICAgICAgIHZhciBhbGxXYWl0aW5nUmVxdWVzdHMgPVxyXG4gICAgICAgICAgICByZXF1ZXN0c1dhaXRpbmdGb3JSZXNwb25zZS5sZW5ndGggK1xyXG4gICAgICAgICAgICByZXF1ZXN0c1dhaXRpbmdGb3JDaGFubmVsQ3JlYXRpb24ubGVuZ3RoO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBhbGxXYWl0aW5nUmVxdWVzdHM7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1pbmltYWxSZXF1ZXN0VXJsKGFsbG93U3RvcFByZXZpb3VzUmVxdWVzdHNJbkNoYW5uZWwpIHtcclxuICAgICAgICB2YXIgcmVxdWVzdFVybCA9IHNlc3Npb25IZWxwZXIuZ2V0RGF0YVJlcXVlc3RVcmwoKTtcclxuICAgICAgICB2YXIgdGFyZ2V0SWQgPSBzZXNzaW9uSGVscGVyLmdldFRhcmdldElkKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHRhcmdldElkICE9PSAnMCcpIHtcclxuICAgICAgICAgICAgcmVxdWVzdFVybCArPSAnJnRpZD0nICsgdGFyZ2V0SWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBhbHJlYWR5U2VudE1lc3NhZ2VzT25DaGFubmVsID0gY2hhbm5lbElkICE9PSBudWxsO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChhbHJlYWR5U2VudE1lc3NhZ2VzT25DaGFubmVsKSB7XHJcbiAgICAgICAgICAgIHZhciBpc1N0b3BQcmV2aW91cyA9XHJcbiAgICAgICAgICAgICAgICBpc0RlZGljYXRlZEZvck1vdmFibGVSZXF1ZXN0ICYmXHJcbiAgICAgICAgICAgICAgICBhbGxvd1N0b3BQcmV2aW91c1JlcXVlc3RzSW5DaGFubmVsO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGlzU3RvcFByZXZpb3VzKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0VXJsICs9ICcmd2FpdD1ubyc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0VXJsICs9ICcmd2FpdD15ZXMnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiByZXF1ZXN0VXJsO1xyXG4gICAgfVxyXG4gICAgICAgIFxyXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVxdWVzdFVybChjb2Rlc3RyZWFtUGFydFBhcmFtcywgbnVtUXVhbGl0eUxheWVycykge1xyXG4gICAgICAgIHZhciByZXF1ZXN0VXJsID0gY3JlYXRlTWluaW1hbFJlcXVlc3RVcmwoXHJcbiAgICAgICAgICAgIC8qYWxsb3dTdG9wUHJldmlvdXNSZXF1ZXN0c0luQ2hhbm5lbD0qL3RydWUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBjb2Rlc3RyZWFtU3RydWN0dXJlID0gc2Vzc2lvbkhlbHBlci5nZXRDb2Rlc3RyZWFtU3RydWN0dXJlKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGZyYW1lV2lkdGggPSBjb2Rlc3RyZWFtU3RydWN0dXJlLmdldExldmVsV2lkdGgoXHJcbiAgICAgICAgICAgIGNvZGVzdHJlYW1QYXJ0UGFyYW1zLm51bVJlc29sdXRpb25MZXZlbHNUb0N1dCk7XHJcbiAgICAgICAgdmFyIGZyYW1lSGVpZ2h0ID0gY29kZXN0cmVhbVN0cnVjdHVyZS5nZXRMZXZlbEhlaWdodChcclxuICAgICAgICAgICAgY29kZXN0cmVhbVBhcnRQYXJhbXMubnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0KTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgcmVnaW9uV2lkdGggPVxyXG4gICAgICAgICAgICBjb2Rlc3RyZWFtUGFydFBhcmFtcy5tYXhYRXhjbHVzaXZlIC0gY29kZXN0cmVhbVBhcnRQYXJhbXMubWluWDtcclxuICAgICAgICB2YXIgcmVnaW9uSGVpZ2h0ID1cclxuICAgICAgICAgICAgY29kZXN0cmVhbVBhcnRQYXJhbXMubWF4WUV4Y2x1c2l2ZSAtIGNvZGVzdHJlYW1QYXJ0UGFyYW1zLm1pblk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmVxdWVzdFVybCArPVxyXG4gICAgICAgICAgICAnJmZzaXo9JyArIGZyYW1lV2lkdGggKyAnLCcgKyBmcmFtZUhlaWdodCArICcsY2xvc2VzdCcgK1xyXG4gICAgICAgICAgICAnJnJzaXo9JyArIHJlZ2lvbldpZHRoICsgJywnICsgcmVnaW9uSGVpZ2h0ICtcclxuICAgICAgICAgICAgJyZyb2ZmPScgKyBjb2Rlc3RyZWFtUGFydFBhcmFtcy5taW5YICsgJywnICsgY29kZXN0cmVhbVBhcnRQYXJhbXMubWluWTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgaWYgKG51bVF1YWxpdHlMYXllcnMgIT09ICdtYXgnKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RVcmwgKz0gJyZsYXllcnM9JyArIG51bVF1YWxpdHlMYXllcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiByZXF1ZXN0VXJsO1xyXG4gICAgfVxyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBqR2xvYmFscyA9IHJlcXVpcmUoJ2oyay1qcGlwLWdsb2JhbHMuanMnKTtcclxuXHJcbnZhciBqcGlwTWVzc2FnZUhlYWRlclBhcnNlciA9IHtcclxuICAgICAgICBcclxuICAgIExTQl9NQVNLOiAweDEsXHJcbiAgICBCSVRfNF9NQVNLOiAweDEwLFxyXG4gICAgQklUU181Nl9NQVNLOiAweDYwLFxyXG4gICAgTVNCX01BU0s6IDB4ODAsXHJcblxyXG4gICAgTFNCXzdfTUFTSzogMHg3RixcclxuXHJcbiAgICAvLyBBLjIuMVxyXG4gICAgcGFyc2VOdW1iZXJJblZiYXM6IGZ1bmN0aW9uIHBhcnNlTnVtYmVySW5WYmFzQ2xvc3VyZShcclxuICAgICAgICBtZXNzYWdlLCBzdGFydE9mZnNldCwgYml0c1RvVGFrZUluRmlyc3RCeXRlKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHNlbGYgPSBqcGlwTWVzc2FnZUhlYWRlclBhcnNlcjtcclxuICAgICAgICB2YXIgY3VycmVudE9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgaWYgKGJpdHNUb1Rha2VJbkZpcnN0Qnl0ZSkge1xyXG4gICAgICAgICAgICB2YXIgbWFza0ZpcnN0Qnl0ZSA9ICgxIDw8IGJpdHNUb1Rha2VJbkZpcnN0Qnl0ZSkgLSAxO1xyXG4gICAgICAgICAgICByZXN1bHQgPSBtZXNzYWdlW2N1cnJlbnRPZmZzZXRdICYgbWFza0ZpcnN0Qnl0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG1lc3NhZ2VbY3VycmVudE9mZnNldF0gJiBzZWxmLkxTQl83X01BU0s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHdoaWxlICggISEobWVzc2FnZVtjdXJyZW50T2Zmc2V0XSAmIHNlbGYuTVNCX01BU0spICkge1xyXG4gICAgICAgICAgICArK2N1cnJlbnRPZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICByZXN1bHQgPDw9IDc7XHJcbiAgICAgICAgICAgIHJlc3VsdCB8PSBtZXNzYWdlW2N1cnJlbnRPZmZzZXRdICYgc2VsZi5MU0JfN19NQVNLO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBlbmRPZmZzZXQ6IGN1cnJlbnRPZmZzZXQgKyAxLFxyXG4gICAgICAgICAgICBudW1iZXI6IHJlc3VsdFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICAvLyBBLjJcclxuICAgIHBhcnNlTWVzc2FnZUhlYWRlcjogZnVuY3Rpb24gcGFyc2VNZXNzYWdlSGVhZGVyQ2xvc3VyZShcclxuICAgICAgICBtZXNzYWdlLCBzdGFydE9mZnNldCwgcHJldmlvdXNNZXNzYWdlSGVhZGVyKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHNlbGYgPSBqcGlwTWVzc2FnZUhlYWRlclBhcnNlcjtcclxuICAgICAgICBcclxuICAgICAgICAvLyBBLjIuMVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEZpcnN0IFZiYXM6IEJpbi1JRFxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBjbGFzc0FuZENzblByZWNlbnNlID0gKG1lc3NhZ2Vbc3RhcnRPZmZzZXRdICYgc2VsZi5CSVRTXzU2X01BU0spID4+PiA1O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChjbGFzc0FuZENzblByZWNlbnNlID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5QYXJzZUV4Y2VwdGlvbignRmFpbGVkIHBhcnNpbmcgbWVzc2FnZSBoZWFkZXIgJyArXHJcbiAgICAgICAgICAgICAgICAnKEEuMi4xKTogcHJvaGliaXRlZCBleGlzdGFuY2UgY2xhc3MgYW5kIGNzbiBiaXRzIDAwJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBoYXNDbGFzc1ZiYXMgPSAhIShjbGFzc0FuZENzblByZWNlbnNlICYgMHgyKTtcclxuICAgICAgICB2YXIgaGFzQ29kZVN0cmVhbUluZGV4VmJhcyA9IGNsYXNzQW5kQ3NuUHJlY2Vuc2UgPT09IDM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGlzTGFzdEJ5dGVJbkRhdGFiaW4gPSAhIShtZXNzYWdlW3N0YXJ0T2Zmc2V0XSAmIHNlbGYuQklUXzRfTUFTSyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQS4yLjNcclxuICAgICAgICB2YXIgcGFyc2VkSW5DbGFzc0lkID0gc2VsZi5wYXJzZU51bWJlckluVmJhcyhcclxuICAgICAgICAgICAgbWVzc2FnZSwgc3RhcnRPZmZzZXQsIC8qYml0c1RvVGFrZUluRmlyc3RCeXRlPSovNCk7XHJcbiAgICAgICAgdmFyIGluQ2xhc3NJZCA9IHBhcnNlZEluQ2xhc3NJZC5udW1iZXI7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRPZmZzZXQgPSBwYXJzZWRJbkNsYXNzSWQuZW5kT2Zmc2V0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFNlY29uZCBvcHRpb25hbCBWYmFzOiBDbGFzcyBJRFxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBjbGFzc0lkID0gMDtcclxuICAgICAgICBpZiAoaGFzQ2xhc3NWYmFzKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJzZWRDbGFzc0lkID0gc2VsZi5wYXJzZU51bWJlckluVmJhcyhtZXNzYWdlLCBjdXJyZW50T2Zmc2V0KTtcclxuICAgICAgICAgICAgY2xhc3NJZCA9IHBhcnNlZENsYXNzSWQubnVtYmVyO1xyXG4gICAgICAgICAgICBjdXJyZW50T2Zmc2V0ID0gcGFyc2VkQ2xhc3NJZC5lbmRPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHByZXZpb3VzTWVzc2FnZUhlYWRlcikge1xyXG4gICAgICAgICAgICBjbGFzc0lkID0gcHJldmlvdXNNZXNzYWdlSGVhZGVyLmNsYXNzSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFRoaXJkIG9wdGlvbmFsIFZiYXM6IENvZGUgU3RyZWFtIEluZGV4IChDc24pXHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGNvZGVzdHJlYW1JbmRleCA9IDA7XHJcbiAgICAgICAgaWYgKGhhc0NvZGVTdHJlYW1JbmRleFZiYXMpIHtcclxuICAgICAgICAgICAgdmFyIHBhcnNlZENzbiA9IHNlbGYucGFyc2VOdW1iZXJJblZiYXMobWVzc2FnZSwgY3VycmVudE9mZnNldCk7XHJcbiAgICAgICAgICAgIGNvZGVzdHJlYW1JbmRleCA9IHBhcnNlZENzbi5udW1iZXI7XHJcbiAgICAgICAgICAgIGN1cnJlbnRPZmZzZXQgPSBwYXJzZWRDc24uZW5kT2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwcmV2aW91c01lc3NhZ2VIZWFkZXIpIHtcclxuICAgICAgICAgICAgY29kZXN0cmVhbUluZGV4ID0gcHJldmlvdXNNZXNzYWdlSGVhZGVyLmNvZGVzdHJlYW1JbmRleDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gNHRoIFZiYXM6IE1lc3NhZ2Ugb2Zmc2V0XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHBhcnNlZE9mZnNldCA9IHNlbGYucGFyc2VOdW1iZXJJblZiYXMobWVzc2FnZSwgY3VycmVudE9mZnNldCk7XHJcbiAgICAgICAgdmFyIG1lc3NhZ2VPZmZzZXRGcm9tRGF0YWJpblN0YXJ0ID0gcGFyc2VkT2Zmc2V0Lm51bWJlcjtcclxuICAgICAgICBjdXJyZW50T2Zmc2V0ID0gcGFyc2VkT2Zmc2V0LmVuZE9mZnNldDtcclxuICAgICAgICBcclxuICAgICAgICAvLyA1dGggVmJhczogTWVzc2FnZSBsZW5ndGhcclxuXHJcbiAgICAgICAgdmFyIHBhcnNlZExlbmd0aCA9IHNlbGYucGFyc2VOdW1iZXJJblZiYXMobWVzc2FnZSwgY3VycmVudE9mZnNldCk7XHJcbiAgICAgICAgdmFyIG1lc3NhZ2VCb2R5TGVuZ3RoID0gcGFyc2VkTGVuZ3RoLm51bWJlcjtcclxuICAgICAgICBjdXJyZW50T2Zmc2V0ID0gcGFyc2VkTGVuZ3RoLmVuZE9mZnNldDtcclxuICAgICAgICBcclxuICAgICAgICAvLyA2dGggb3B0aW9uYWwgVmJhczogQXV4XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQS4yLjJcclxuICAgICAgICB2YXIgaGFzQXV4VmJhcyA9ICEhKGNsYXNzSWQgJiBzZWxmLkxTQl9NQVNLKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgYXV4O1xyXG4gICAgICAgIGlmIChoYXNBdXhWYmFzKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJzZWRBdXggPSBzZWxmLnBhcnNlTnVtYmVySW5WYmFzKG1lc3NhZ2UsIGN1cnJlbnRPZmZzZXQpO1xyXG4gICAgICAgICAgICBhdXggPSBwYXJzZWRBdXgubnVtYmVyO1xyXG4gICAgICAgICAgICBjdXJyZW50T2Zmc2V0ID0gcGFyc2VkQXV4LmVuZE9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUmV0dXJuXHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgaXNMYXN0Qnl0ZUluRGF0YWJpbjogaXNMYXN0Qnl0ZUluRGF0YWJpbixcclxuICAgICAgICAgICAgaW5DbGFzc0lkOiBpbkNsYXNzSWQsXHJcbiAgICAgICAgICAgIGJvZHlTdGFydDogY3VycmVudE9mZnNldCxcclxuICAgICAgICAgICAgY2xhc3NJZDogY2xhc3NJZCxcclxuICAgICAgICAgICAgY29kZXN0cmVhbUluZGV4OiBjb2Rlc3RyZWFtSW5kZXgsXHJcbiAgICAgICAgICAgIG1lc3NhZ2VPZmZzZXRGcm9tRGF0YWJpblN0YXJ0OiBtZXNzYWdlT2Zmc2V0RnJvbURhdGFiaW5TdGFydCxcclxuICAgICAgICAgICAgbWVzc2FnZUJvZHlMZW5ndGg6IG1lc3NhZ2VCb2R5TGVuZ3RoXHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoaGFzQXV4VmJhcykge1xyXG4gICAgICAgICAgICByZXN1bHQuYXV4ID0gYXV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxuICAgIFxyXG4gICAgZ2V0SW50MzI6IGZ1bmN0aW9uIGdldEludDMyQ2xvc3VyZShkYXRhLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgbXNiID0gZGF0YVtvZmZzZXRdICogTWF0aC5wb3coMiwgMjQpOyAvLyBBdm9pZCBuZWdhdGl2ZSByZXN1bHQgZHVlIHRvIHNpZ25lZCBjYWxjdWxhdGlvblxyXG4gICAgICAgIHZhciBieXRlMiA9IGRhdGFbb2Zmc2V0ICsgMV0gPDwgMTY7XHJcbiAgICAgICAgdmFyIGJ5dGUxID0gZGF0YVtvZmZzZXQgKyAyXSA8PCA4O1xyXG4gICAgICAgIHZhciBsc2IgPSBkYXRhW29mZnNldCArIDNdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciByZXN1bHQgPSBtc2IgKyBieXRlMiArIGJ5dGUxICsgbHNiO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBnZXRJbnQxNjogZnVuY3Rpb24gZ2V0SW50MTZDbG9zdXJlKGRhdGEsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciBtc2IgPSBkYXRhW29mZnNldF0gPDwgODtcclxuICAgICAgICB2YXIgbHNiID0gZGF0YVtvZmZzZXQgKyAxXTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbXNiICsgbHNiO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5qcGlwTWVzc2FnZUhlYWRlclBhcnNlciA9IGpwaXBNZXNzYWdlSGVhZGVyUGFyc2VyOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBqR2xvYmFscyA9IHJlcXVpcmUoJ2oyay1qcGlwLWdsb2JhbHMuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLkpwaXBSZWNvbm5lY3RhYmxlUmVxdWVzdGVyID0gZnVuY3Rpb24gSnBpcFJlY29ubmVjdGFibGVSZXF1ZXN0ZXIoXHJcbiAgICBtYXhDaGFubmVsc0luU2Vzc2lvbixcclxuICAgIG1heFJlcXVlc3RzV2FpdGluZ0ZvclJlc3BvbnNlSW5DaGFubmVsLCBcclxuICAgIGNvZGVzdHJlYW1TdHJ1Y3R1cmUsXHJcbiAgICBkYXRhYmluc1NhdmVyLFxyXG4gICAganBpcEZhY3RvcnksXHJcbiAgICAvLyBOT1RFOiBNb3ZlIHBhcmFtZXRlciB0byBiZWdpbm5pbmcgYW5kIGV4cG9zZSBpbiBDb2Rlc3RyZWFtQ2xpZW50XHJcbiAgICBtYXhKcGlwQ2FjaGVTaXplQ29uZmlnKSB7XHJcbiAgICBcclxuICAgIHZhciBNQiA9IDEwNDg1NzY7XHJcbiAgICB2YXIgbWF4SnBpcENhY2hlU2l6ZSA9IG1heEpwaXBDYWNoZVNpemVDb25maWcgfHwgKDEwICogTUIpO1xyXG4gICAgXHJcbiAgICB2YXIgc2Vzc2lvbldhaXRpbmdGb3JSZWFkeTtcclxuICAgIHZhciBhY3RpdmVTZXNzaW9uID0gbnVsbDtcclxuICAgIHZhciBzZXNzaW9uV2FpdGluZ0ZvckRpc2Nvbm5lY3QgPSBudWxsO1xyXG4gICAgXHJcbiAgICB2YXIgdXJsID0gbnVsbDtcclxuICAgIHZhciB3YWl0aW5nRm9yQ2xvc2VTZXNzaW9ucyA9IDA7XHJcbiAgICBcclxuICAgIHZhciBub25EZWRpY2F0ZWRSZXF1ZXN0c1dhaXRpbmdGb3JTZW5kID0gW107XHJcbiAgICB2YXIgZGVkaWNhdGVkQ2hhbm5lbHMgPSBbXTtcclxuICAgIFxyXG4gICAgdmFyIHN0YXR1c0NhbGxiYWNrID0gbnVsbDtcclxuICAgIHZhciBsYXN0Q2xvc2VkQ2FsbGJhY2sgPSBudWxsO1xyXG4gICAgXHJcbiAgICB0aGlzLmdldElzUmVhZHkgPSBmdW5jdGlvbiBnZXRJc1JlYWR5KCkge1xyXG4gICAgICAgIHJldHVybiBhY3RpdmVTZXNzaW9uICE9PSBudWxsICYmIGFjdGl2ZVNlc3Npb24uZ2V0SXNSZWFkeSgpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5vcGVuID0gZnVuY3Rpb24gb3BlbihiYXNlVXJsKSB7XHJcbiAgICAgICAgaWYgKGJhc2VVcmwgPT09IHVuZGVmaW5lZCB8fCBiYXNlVXJsID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5Bcmd1bWVudEV4Y2VwdGlvbignYmFzZVVybCcsIGJhc2VVcmwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAodXJsICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbGxlZ2FsT3BlcmF0aW9uRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgJ0ltYWdlIHdhcyBhbHJlYWR5IG9wZW5lZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB1cmwgPSBiYXNlVXJsO1xyXG4gICAgICAgIGNyZWF0ZUludGVybmFsU2Vzc2lvbigpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKGNsb3NlZENhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKGxhc3RDbG9zZWRDYWxsYmFjayAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSWxsZWdhbE9wZXJhdGlvbkV4Y2VwdGlvbignY2xvc2VkIHR3aWNlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGxhc3RDbG9zZWRDYWxsYmFjayA9IGNsb3NlZENhbGxiYWNrO1xyXG4gICAgICAgIHdhaXRpbmdGb3JDbG9zZVNlc3Npb25zID0gMTtcclxuICAgICAgICBcclxuICAgICAgICBjbG9zZUludGVybmFsU2Vzc2lvbihhY3RpdmVTZXNzaW9uKTtcclxuICAgICAgICBjbG9zZUludGVybmFsU2Vzc2lvbihzZXNzaW9uV2FpdGluZ0ZvclJlYWR5KTtcclxuICAgICAgICBjbG9zZUludGVybmFsU2Vzc2lvbihzZXNzaW9uV2FpdGluZ0ZvckRpc2Nvbm5lY3QpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNoZWNrSWZBbGxTZXNzaW9uc0Nsb3NlZEFmdGVyU2Vzc2lvbkNsb3NlZCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnNldFN0YXR1c0NhbGxiYWNrID0gZnVuY3Rpb24gc2V0U3RhdHVzQ2FsbGJhY2sobmV3U3RhdHVzQ2FsbGJhY2spIHtcclxuICAgICAgICBzdGF0dXNDYWxsYmFjayA9IG5ld1N0YXR1c0NhbGxiYWNrO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChhY3RpdmVTZXNzaW9uICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGFjdGl2ZVNlc3Npb24uc2V0U3RhdHVzQ2FsbGJhY2sobmV3U3RhdHVzQ2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZGVkaWNhdGVDaGFubmVsRm9yTW92YWJsZVJlcXVlc3QgPVxyXG4gICAgICAgIGZ1bmN0aW9uIGRlZGljYXRlQ2hhbm5lbEZvck1vdmFibGVSZXF1ZXN0KCkge1xyXG5cclxuICAgICAgICBjaGVja1JlYWR5KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGRlZGljYXRlZENoYW5uZWxIYW5kbGUgPSB7IGludGVybmFsRGVkaWNhdGVkQ2hhbm5lbDogbnVsbCB9O1xyXG4gICAgICAgIGRlZGljYXRlZENoYW5uZWxzLnB1c2goZGVkaWNhdGVkQ2hhbm5lbEhhbmRsZSk7XHJcbiAgICAgICAgY3JlYXRlSW50ZXJuYWxEZWRpY2F0ZWRDaGFubmVsKGRlZGljYXRlZENoYW5uZWxIYW5kbGUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBkZWRpY2F0ZWRDaGFubmVsSGFuZGxlO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5yZXF1ZXN0RGF0YSA9IGZ1bmN0aW9uIHJlcXVlc3REYXRhKFxyXG4gICAgICAgIGNvZGVzdHJlYW1QYXJ0UGFyYW1zLFxyXG4gICAgICAgIGNhbGxiYWNrLFxyXG4gICAgICAgIGZhaWx1cmVDYWxsYmFjayxcclxuICAgICAgICBudW1RdWFsaXR5TGF5ZXJzLFxyXG4gICAgICAgIGRlZGljYXRlZENoYW5uZWxIYW5kbGVUb01vdmUpIHtcclxuXHJcbiAgICAgICAgY2hlY2tSZWFkeSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICBpc0VuZGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgaW50ZXJuYWxSZXF1ZXN0OiBudWxsLFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29kZXN0cmVhbVBhcnRQYXJhbXM6IGNvZGVzdHJlYW1QYXJ0UGFyYW1zLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXHJcbiAgICAgICAgICAgIGZhaWx1cmVDYWxsYmFjazogZmFpbHVyZUNhbGxiYWNrLFxyXG4gICAgICAgICAgICBudW1RdWFsaXR5TGF5ZXJzOiBudW1RdWFsaXR5TGF5ZXJzXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGNoYW5uZWw7XHJcbiAgICAgICAgdmFyIG1vdmVEZWRpY2F0ZWRDaGFubmVsID0gZGVkaWNhdGVkQ2hhbm5lbEhhbmRsZVRvTW92ZSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChtb3ZlRGVkaWNhdGVkQ2hhbm5lbCkge1xyXG4gICAgICAgICAgICBjaGFubmVsID0gZGVkaWNhdGVkQ2hhbm5lbEhhbmRsZVRvTW92ZS5pbnRlcm5hbERlZGljYXRlZENoYW5uZWw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2hhbm5lbCA9IGFjdGl2ZVNlc3Npb24udHJ5R2V0Q2hhbm5lbCgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGNoYW5uZWwgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIG5vbkRlZGljYXRlZFJlcXVlc3RzV2FpdGluZ0ZvclNlbmQucHVzaChyZXF1ZXN0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5uZWwuZ2V0SXNEZWRpY2F0ZWRGb3JNb3ZhYmxlUmVxdWVzdCgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAnRXhwZWN0ZWQgbm9uLW1vdmFibGUgY2hhbm5lbCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChjaGFubmVsLmdldElzRGVkaWNhdGVkRm9yTW92YWJsZVJlcXVlc3QoKSAhPT0gbW92ZURlZGljYXRlZENoYW5uZWwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAnZ2V0SXNEZWRpY2F0ZWRGb3JNb3ZhYmxlUmVxdWVzdCBpbmNvbnNpc3RlbmN5Jyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXF1ZXN0LmludGVybmFsUmVxdWVzdCA9IGNoYW5uZWwucmVxdWVzdERhdGEoXHJcbiAgICAgICAgICAgIGNvZGVzdHJlYW1QYXJ0UGFyYW1zLFxyXG4gICAgICAgICAgICBjYWxsYmFjayxcclxuICAgICAgICAgICAgZmFpbHVyZUNhbGxiYWNrLFxyXG4gICAgICAgICAgICBudW1RdWFsaXR5TGF5ZXJzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLnN0b3BSZXF1ZXN0QXN5bmMgPSBmdW5jdGlvbiBzdG9wUmVxdWVzdEFzeW5jKHJlcXVlc3QpIHtcclxuICAgICAgICByZXF1ZXN0LmlzRW5kZWQgPSB0cnVlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChyZXF1ZXN0LmludGVybmFsUmVxdWVzdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXF1ZXN0LmludGVybmFsUmVxdWVzdC5zdG9wUmVxdWVzdEFzeW5jKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5yZWNvbm5lY3QgPSByZWNvbm5lY3Q7XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHJlY29ubmVjdCgpIHtcclxuICAgICAgICBpZiAoc2Vzc2lvbldhaXRpbmdGb3JSZWFkeSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSWxsZWdhbE9wZXJhdGlvbkV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICdQcmV2aW91cyBzZXNzaW9uIHN0aWxsIG5vdCBlc3RhYmxpc2hlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoc2Vzc2lvbldhaXRpbmdGb3JEaXNjb25uZWN0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0dXNDYWxsYmFjayAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzQ2FsbGJhY2soe1xyXG4gICAgICAgICAgICAgICAgICAgIGlzUmVhZHk6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZXhjZXB0aW9uOiAvL2pwaXBFeGNlcHRpb25zLkludmFsaWRPcGVyYXRpb25FeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdQcmV2aW91cyBzZXNzaW9uIHRoYXQgc2hvdWxkIGJlIGNsb3NlZCBzdGlsbCBhbGl2ZS4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ01heWJlIG9sZCByZXF1ZXN0Q29udGV4dHMgaGF2ZSBub3QgYmVlZCBjbG9zZWQuICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnUmVjb25uZWN0IHdpbGwgbm90IGJlIGRvbmUnIC8vKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBkYXRhYmluc1NhdmVyLmNsZWFudXBVbnJlZ2lzdGVyZWREYXRhYmlucygpO1xyXG4gICAgICAgIGNyZWF0ZUludGVybmFsU2Vzc2lvbigpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVJbnRlcm5hbFNlc3Npb24oKSB7XHJcbiAgICAgICAgdmFyIHRhcmdldElkO1xyXG4gICAgICAgIGlmIChhY3RpdmVTZXNzaW9uICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRhcmdldElkID0gYWN0aXZlU2Vzc2lvbi5nZXRUYXJnZXRJZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBzZXNzaW9uV2FpdGluZ0ZvclJlYWR5ID0ganBpcEZhY3RvcnkuY3JlYXRlU2Vzc2lvbihcclxuICAgICAgICAgICAgbWF4Q2hhbm5lbHNJblNlc3Npb24sXHJcbiAgICAgICAgICAgIG1heFJlcXVlc3RzV2FpdGluZ0ZvclJlc3BvbnNlSW5DaGFubmVsLFxyXG4gICAgICAgICAgICB0YXJnZXRJZCxcclxuICAgICAgICAgICAgY29kZXN0cmVhbVN0cnVjdHVyZSxcclxuICAgICAgICAgICAgZGF0YWJpbnNTYXZlcik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIHNlc3Npb25XYWl0aW5nRm9yUmVhZHkuc2V0U3RhdHVzQ2FsbGJhY2sod2FpdGluZ0ZvclJlYWR5Q2FsbGJhY2spO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHNlc3Npb25XYWl0aW5nRm9yUmVhZHkub3Blbih1cmwpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVJbnRlcm5hbERlZGljYXRlZENoYW5uZWwoZGVkaWNhdGVkQ2hhbm5lbEhhbmRsZSkge1xyXG4gICAgICAgIHZhciBjaGFubmVsID0gYWN0aXZlU2Vzc2lvbi50cnlHZXRDaGFubmVsKFxyXG4gICAgICAgICAgICAvKmRlZGljYXRlRm9yTW92YWJsZVJlcXVlc3Q9Ki90cnVlKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoY2hhbm5lbCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW52YWxpZE9wZXJhdGlvbkV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICdUb28gbWFueSBjb25jdXJyZW50IHJlcXVlc3RzLiBMaW1pdCB0aGUgdXNlIG9mIGRlZGljYXRlZCAnICtcclxuICAgICAgICAgICAgICAgICcobW92YWJsZSkgcmVxdWVzdHMsIGVubGFyZ2UgbWF4Q2hhbm5lbHNJblNlc3Npb24gb3Igd2FpdCAnICtcclxuICAgICAgICAgICAgICAgICdmb3IgcmVxdWVzdHMgdG8gZmluaXNoIGFuZCBhdm9pZCBjcmVhdGUgbmV3IG9uZXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKCFjaGFubmVsLmdldElzRGVkaWNhdGVkRm9yTW92YWJsZVJlcXVlc3QoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICdnZXRJc0RlZGljYXRlZEZvck1vdmFibGVSZXF1ZXN0IGluY29uc2lzdGVuY3knKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRlZGljYXRlZENoYW5uZWxIYW5kbGUuaW50ZXJuYWxEZWRpY2F0ZWRDaGFubmVsID0gY2hhbm5lbDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gd2FpdGluZ0ZvclJlYWR5Q2FsbGJhY2soc3RhdHVzKSB7XHJcbiAgICAgICAgaWYgKHNlc3Npb25XYWl0aW5nRm9yUmVhZHkgPT09IG51bGwgfHxcclxuICAgICAgICAgICAgc3RhdHVzLmlzUmVhZHkgIT09IHNlc3Npb25XYWl0aW5nRm9yUmVhZHkuZ2V0SXNSZWFkeSgpKSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbignVW5leHBlY3RlZCAnICtcclxuICAgICAgICAgICAgICAgICdzdGF0dXNDYWxsYmFjayB3aGVuIG5vdCByZWdpc3RlcmVkIHRvIHNlc3Npb24gb3IgJyArXHJcbiAgICAgICAgICAgICAgICAnaW5jb25zaXN0ZW50IGlzUmVhZHknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHN0YXR1cy5pc1JlYWR5KSB7XHJcbiAgICAgICAgICAgIGlmIChzZXNzaW9uV2FpdGluZ0ZvckRpc2Nvbm5lY3QgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbnRlcm5hbEVycm9yRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICdzZXNzaW9uV2FpdGluZ0ZvckRpc2Nvbm5lY3Qgc2hvdWxkIGJlIG51bGwnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgc2Vzc2lvbldhaXRpbmdGb3JEaXNjb25uZWN0ID0gYWN0aXZlU2Vzc2lvbjtcclxuICAgICAgICAgICAgYWN0aXZlU2Vzc2lvbiA9IHNlc3Npb25XYWl0aW5nRm9yUmVhZHk7XHJcbiAgICAgICAgICAgIHNlc3Npb25XYWl0aW5nRm9yUmVhZHkgPSBudWxsO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHNlc3Npb25XYWl0aW5nRm9yRGlzY29ubmVjdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc2Vzc2lvbldhaXRpbmdGb3JEaXNjb25uZWN0LnNldFN0YXR1c0NhbGxiYWNrKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0cnlEaXNjb25uZWN0V2FpdGluZ1Nlc3Npb24oKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25XYWl0aW5nRm9yRGlzY29ubmVjdC5zZXRSZXF1ZXN0RW5kZWRDYWxsYmFjayhcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5RGlzY29ubmVjdFdhaXRpbmdTZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgYWN0aXZlU2Vzc2lvbi5zZXRTdGF0dXNDYWxsYmFjayhzdGF0dXNDYWxsYmFjayk7XHJcbiAgICAgICAgICAgIGFjdGl2ZVNlc3Npb24uc2V0UmVxdWVzdEVuZGVkQ2FsbGJhY2soYWN0aXZlU2Vzc2lvblJlcXVlc3RFbmRlZENhbGxiYWNrKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVkaWNhdGVkQ2hhbm5lbHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZUludGVybmFsRGVkaWNhdGVkQ2hhbm5lbChkZWRpY2F0ZWRDaGFubmVsc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHN0YXR1c0NhbGxiYWNrICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0YXR1c0NhbGxiYWNrKHN0YXR1cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBjbG9zZUludGVybmFsU2Vzc2lvbihzZXNzaW9uKSB7XHJcbiAgICAgICAgaWYgKHNlc3Npb24gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgKyt3YWl0aW5nRm9yQ2xvc2VTZXNzaW9ucztcclxuICAgICAgICAgICAgc2Vzc2lvbi5jbG9zZShjaGVja0lmQWxsU2Vzc2lvbnNDbG9zZWRBZnRlclNlc3Npb25DbG9zZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gY2hlY2tJZkFsbFNlc3Npb25zQ2xvc2VkQWZ0ZXJTZXNzaW9uQ2xvc2VkKCkge1xyXG4gICAgICAgIC0td2FpdGluZ0ZvckNsb3NlU2Vzc2lvbnM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHdhaXRpbmdGb3JDbG9zZVNlc3Npb25zID09PSAwICYmIGxhc3RDbG9zZWRDYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxhc3RDbG9zZWRDYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gY2hlY2tSZWFkeSgpIHtcclxuICAgICAgICBpZiAoYWN0aXZlU2Vzc2lvbiA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbignVGhpcyBvcGVyYXRpb24gJyArXHJcbiAgICAgICAgICAgICAgICAnaXMgZm9yYmlkZGVuIHdoZW4gc2Vzc2lvbiBpcyBub3QgcmVhZHknKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGFjdGl2ZVNlc3Npb25SZXF1ZXN0RW5kZWRDYWxsYmFjayhjaGFubmVsRnJlZWQpIHtcclxuICAgICAgICB2YXIgcmVxdWVzdCA9IG51bGw7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGRhdGFiaW5zU2F2ZXIuZ2V0TG9hZGVkQnl0ZXMoKSA+IG1heEpwaXBDYWNoZVNpemUpIHtcclxuICAgICAgICAgICAgcmVjb25uZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChjaGFubmVsRnJlZWQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoY2hhbm5lbEZyZWVkLmdldElzRGVkaWNhdGVkRm9yTW92YWJsZVJlcXVlc3QoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICdFeHBlY3RlZCBub24tbW92YWJsZSBjaGFubmVsIGFzIGNoYW5uZWxGcmVlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGlmIChub25EZWRpY2F0ZWRSZXF1ZXN0c1dhaXRpbmdGb3JTZW5kLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmVxdWVzdCA9IG5vbkRlZGljYXRlZFJlcXVlc3RzV2FpdGluZ0ZvclNlbmQuc2hpZnQoKTtcclxuICAgICAgICAgICAgaWYgKHJlcXVlc3QuaW50ZXJuYWxSZXF1ZXN0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbignUmVxdWVzdCB3YXMgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2FscmVhZHkgc2VudCBidXQgc3RpbGwgaW4gcXVldWUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKHJlcXVlc3QuaXNFbmRlZCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHJlcXVlc3QgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmVxdWVzdC5pbnRlcm5hbFJlcXVlc3QgPSBjaGFubmVsRnJlZWQucmVxdWVzdERhdGEoXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmNvZGVzdHJlYW1QYXJ0UGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5jYWxsYmFjayxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QuZmFpbHVyZUNhbGxiYWNrLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5udW1RdWFsaXR5TGF5ZXJzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHRyeURpc2Nvbm5lY3RXYWl0aW5nU2Vzc2lvbigpIHtcclxuICAgICAgICB2YXIgY2FuQ2xvc2VTZXNzaW9uID0gIXNlc3Npb25XYWl0aW5nRm9yRGlzY29ubmVjdC5oYXNBY3RpdmVSZXF1ZXN0cygpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChjYW5DbG9zZVNlc3Npb24pIHtcclxuICAgICAgICAgICAgc2Vzc2lvbldhaXRpbmdGb3JEaXNjb25uZWN0LmNsb3NlKCk7XHJcbiAgICAgICAgICAgIHNlc3Npb25XYWl0aW5nRm9yRGlzY29ubmVjdCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBjYW5DbG9zZVNlc3Npb247XHJcbiAgICB9XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGpHbG9iYWxzID0gcmVxdWlyZSgnajJrLWpwaXAtZ2xvYmFscy5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuSnBpcFJlcXVlc3QgPSBmdW5jdGlvbiBKcGlwUmVxdWVzdChcclxuICAgIHNlc3Npb25IZWxwZXIsXHJcbiAgICBtZXNzYWdlSGVhZGVyUGFyc2VyLFxyXG4gICAgY2hhbm5lbCxcclxuICAgIHJlcXVlc3RVcmwsXHJcbiAgICBjYWxsYmFjayxcclxuICAgIGZhaWx1cmVDYWxsYmFjaykge1xyXG4gICAgXHJcbiAgICB2YXIgS0IgPSAxMDI0O1xyXG4gICAgdmFyIFBST0dSRVNTSVZFTkVTU19NSU5fTEVOR1RIX0JZVEVTID0gMTAgKiBLQjtcclxuXHJcbiAgICB2YXIgUkVTUE9OU0VfRU5ERURfU1VDQ0VTUyA9IDE7XHJcbiAgICB2YXIgUkVTUE9OU0VfRU5ERURfQUJPUlRFRCA9IDI7XHJcbiAgICB2YXIgUkVTUE9OU0VfRU5ERURfU0VOVF9BTk9USEVSX01FU1NBR0UgPSAzO1xyXG4gICAgXHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB2YXIgaXNBY3RpdmUgPSBmYWxzZTtcclxuICAgIHZhciBlbmRlZEJ5VXNlciA9IGZhbHNlO1xyXG4gICAgdmFyIGxhc3RSZXF1ZXN0SWQ7XHJcbiAgICB2YXIgcmVzcG9uc2VMZW5ndGggPSBQUk9HUkVTU0lWRU5FU1NfTUlOX0xFTkdUSF9CWVRFUztcclxuICAgIFxyXG4gICAgdGhpcy5zdGFydFJlcXVlc3QgPSBmdW5jdGlvbiBzdGFydFJlcXVlc3QoKSB7XHJcbiAgICAgICAgaWYgKGlzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbnRlcm5hbEVycm9yRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgJ3N0YXJ0UmVxdWVzdCBjYWxsZWQgdHdpY2UnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGVuZGVkQnlVc2VyKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbnRlcm5hbEVycm9yRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgJ3JlcXVlc3Qgd2FzIGFscmVhZHkgc3RvcHBlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpc0FjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgc2Vzc2lvbkhlbHBlci5yZXF1ZXN0U3RhcnRlZCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHNlbmRNZXNzYWdlT2ZEYXRhUmVxdWVzdCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLnN0b3BSZXF1ZXN0QXN5bmMgPSBmdW5jdGlvbiBzdG9wUmVxdWVzdEFzeW5jKHJlcXVlc3QpIHtcclxuICAgICAgICBlbmRlZEJ5VXNlciA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldExhc3RSZXF1ZXN0SWQgPSBmdW5jdGlvbiBnZXRMYXN0UmVxdWVzdElkKCkge1xyXG4gICAgICAgIGlmICghaXNBY3RpdmUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAnVW5leHBlY3RlZCBjYWxsIHRvIGdldExhc3RSZXF1ZXN0SWQgb24gaW5hY3RpdmUgcmVxdWVzdCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gbGFzdFJlcXVlc3RJZDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuY2FsbENhbGxiYWNrQWZ0ZXJDb25jdXJyZW50UmVxdWVzdHNGaW5pc2hlZCA9XHJcbiAgICAgICAgZnVuY3Rpb24gY2FsbENhbGxiYWNrQWZ0ZXJDb25jdXJyZW50UmVxdWVzdHNGaW5pc2hlZCgpIHtcclxuICAgICAgICBcclxuICAgICAgICBjYWxsYmFjayhzZWxmLCAvKmlzUmVzcG9uc2VEb25lPSovdHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBpbnRlcm5hbFN1Y2Nlc3NDYWxsYmFjayhhamF4UmVzcG9uc2UsIGlzUmVzcG9uc2VEb25lKSB7XHJcbiAgICAgICAgdmFyIGZhaWxlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgZW5kZWRSZWFzb24gPSBwcm9jZXNzQWpheFJlc3BvbnNlKGFqYXhSZXNwb25zZSwgaXNSZXNwb25zZURvbmUpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGVuZGVkUmVhc29uID09PSBSRVNQT05TRV9FTkRFRF9TRU5UX0FOT1RIRVJfTUVTU0FHRSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBmYWlsZWQgPSBlbmRlZFJlYXNvbiA9PT0gUkVTUE9OU0VfRU5ERURfQUJPUlRFRDtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGZhaWxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHNlc3Npb25IZWxwZXIub25FeGNlcHRpb24oZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmICghZmFpbGVkKSB7XHJcbiAgICAgICAgICAgICAgICBzZXNzaW9uSGVscGVyLndhaXRGb3JDb25jdXJyZW50UmVxdWVzdHNUb0VuZChzZWxmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY2hhbm5lbC5yZXF1ZXN0RW5kZWQoYWpheFJlc3BvbnNlLCBzZWxmKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChmYWlsZWQgJiYgIWVuZGVkQnlVc2VyICYmIGZhaWx1cmVDYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBmYWlsdXJlQ2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgc2Vzc2lvbkhlbHBlci5jaGVja0NvbmN1cnJlbnRSZXF1ZXN0c0ZpbmlzaGVkKCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBzZXNzaW9uSGVscGVyLm9uRXhjZXB0aW9uKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gaW50ZXJuYWxGYWlsdXJlQ2FsbGJhY2soYWpheFJlc3BvbnNlKSB7XHJcbiAgICAgICAgY2hhbm5lbC5yZXF1ZXN0RW5kZWQoYWpheFJlc3BvbnNlLCBzZWxmKTtcclxuICAgICAgICBzZXNzaW9uSGVscGVyLmNoZWNrQ29uY3VycmVudFJlcXVlc3RzRmluaXNoZWQoKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoZmFpbHVyZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZmFpbHVyZUNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzQWpheFJlc3BvbnNlKGFqYXhSZXNwb25zZSwgaXNSZXNwb25zZURvbmUpIHtcclxuICAgICAgICBpZiAoIWlzUmVzcG9uc2VEb25lKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbnRlcm5hbEVycm9yRXhjZXB0aW9uKCdBSkFYICcgK1xyXG4gICAgICAgICAgICAgICAgJ2NhbGxiYWNrIGNhbGxlZCBhbHRob3VnaCByZXNwb25zZSBpcyBub3QgZG9uZSB5ZXQgJyArXHJcbiAgICAgICAgICAgICAgICAnYW5kIGNodW5rZWQgZW5jb2RpbmcgaXMgbm90IGVuYWJsZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICB2YXIgY3JlYXRlZENoYW5uZWwgPSBzZXNzaW9uSGVscGVyLmdldENyZWF0ZWRDaGFubmVsSWQoXHJcbiAgICAgICAgICAgIGFqYXhSZXNwb25zZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGNyZWF0ZWRDaGFubmVsICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFubmVsLmdldENoYW5uZWxJZCgpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzZXNzaW9uSGVscGVyLm9uRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbGxlZ2FsRGF0YUV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NoYW5uZWwgY3JlYXRlZCBhbHRob3VnaCB3YXMgbm90IHJlcXVlc3RlZCcsICdELjIuMycpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNoYW5uZWwuc2V0Q2hhbm5lbElkKGNyZWF0ZWRDaGFubmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbC5nZXRDaGFubmVsSWQoKSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXNzaW9uSGVscGVyLm9uRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLklsbGVnYWxEYXRhRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICdDYW5ub3QgZXh0cmFjdCBjaWQgZnJvbSBjbmV3IHJlc3BvbnNlJywgJ0QuMi4zJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgZW5kT2Zmc2V0ID0gc2F2ZVRvRGF0YWJpbnNGcm9tT2Zmc2V0KGFqYXhSZXNwb25zZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGVuZE9mZnNldCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUkVTUE9OU0VfRU5ERURfQUJPUlRFRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGVuZGVkUmVhc29uID0gcGFyc2VFbmRPZlJlc3BvbnNlKGFqYXhSZXNwb25zZSwgZW5kT2Zmc2V0KTtcclxuICAgICAgICByZXR1cm4gZW5kZWRSZWFzb247XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHNlbmRNZXNzYWdlT2ZEYXRhUmVxdWVzdCgpIHtcclxuICAgICAgICBsYXN0UmVxdWVzdElkID0gY2hhbm5lbC5uZXh0UmVxdWVzdElkKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHVybCA9IHJlcXVlc3RVcmwgK1xyXG4gICAgICAgICAgICAnJmxlbj0nICsgcmVzcG9uc2VMZW5ndGggK1xyXG4gICAgICAgICAgICAnJnFpZD0nICsgbGFzdFJlcXVlc3RJZDtcclxuICAgICAgICBcclxuICAgICAgICByZXNwb25zZUxlbmd0aCAqPSAyO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBzaG91bGRDcmVhdGVDaGFubmVsID0gY2hhbm5lbC5nZXRDaGFubmVsSWQoKSA9PT0gbnVsbDtcclxuICAgICAgICBpZiAoc2hvdWxkQ3JlYXRlQ2hhbm5lbCkge1xyXG4gICAgICAgICAgICB1cmwgKz0gJyZjbmV3PWh0dHAnO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGV4aXN0Q2hhbm5lbEluU2Vzc2lvbiA9IHNlc3Npb25IZWxwZXIuZ2V0Rmlyc3RDaGFubmVsKCk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGV4aXN0Q2hhbm5lbEluU2Vzc2lvbiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdXJsICs9ICcmY2lkPScgKyBleGlzdENoYW5uZWxJblNlc3Npb24uZ2V0Q2hhbm5lbElkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIE5PVEU6IElmIGV4aXN0Q2hhbm5lbEluU2Vzc2lvbiwgbWF5YmUgc2hvdWxkIHJlbW92ZSBcIiZzdHJlYW09MFwiXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdXJsICs9ICcmY2lkPScgKyBjaGFubmVsLmdldENoYW5uZWxJZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBzZXNzaW9uSGVscGVyLnNlbmRBamF4KFxyXG4gICAgICAgICAgICB1cmwsXHJcbiAgICAgICAgICAgIGludGVybmFsU3VjY2Vzc0NhbGxiYWNrLFxyXG4gICAgICAgICAgICBpbnRlcm5hbEZhaWx1cmVDYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHBhcnNlRW5kT2ZSZXNwb25zZShhamF4UmVzcG9uc2UsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciBlbmRSZXNwb25zZVJlc3VsdCA9IFJFU1BPTlNFX0VOREVEX0FCT1JURUQ7XHJcbiAgICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYWpheFJlc3BvbnNlLnJlc3BvbnNlKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAob2Zmc2V0ID4gYnl0ZXMubGVuZ3RoIC0gMiB8fFxyXG4gICAgICAgICAgICBieXRlc1tvZmZzZXRdICE9PSAwKSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSWxsZWdhbERhdGFFeGNlcHRpb24oJ0NvdWxkIG5vdCBmaW5kICcgK1xyXG4gICAgICAgICAgICAgICAgJ0VuZCBPZiBSZXNwb25zZSAoRU9SKSBjb2RlIGF0IHRoZSBlbmQgb2YgcmVzcG9uc2UnLCAnRC4zJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHN3aXRjaCAoYnl0ZXNbb2Zmc2V0ICsgMV0pIHtcclxuICAgICAgICAgICAgY2FzZSBqR2xvYmFscy5qcGlwRW5kT2ZSZXNwb25zZVJlYXNvbnMuSU1BR0VfRE9ORTpcclxuICAgICAgICAgICAgY2FzZSBqR2xvYmFscy5qcGlwRW5kT2ZSZXNwb25zZVJlYXNvbnMuV0lORE9XX0RPTkU6XHJcbiAgICAgICAgICAgIGNhc2Ugakdsb2JhbHMuanBpcEVuZE9mUmVzcG9uc2VSZWFzb25zLlFVQUxJVFlfTElNSVQ6XHJcbiAgICAgICAgICAgICAgICBlbmRSZXNwb25zZVJlc3VsdCA9IFJFU1BPTlNFX0VOREVEX1NVQ0NFU1M7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhc2Ugakdsb2JhbHMuanBpcEVuZE9mUmVzcG9uc2VSZWFzb25zLldJTkRPV19DSEFOR0U6XHJcbiAgICAgICAgICAgICAgICBpZiAoIWVuZGVkQnlVc2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLklsbGVnYWxPcGVyYXRpb25FeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZXJ2ZXIgcmVzcG9uc2Ugd2FzIHRlcm1pbmF0ZWQgZHVlIHRvIG5ld2VyICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVxdWVzdCBpc3N1ZWQgb24gc2FtZSBjaGFubmVsLiBUaGF0IG1heSBiZSBhbiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ludGVybmFsIHdlYmpwaXAuanMgZXJyb3IgLSBDaGVjayB0aGF0IG1vdmFibGUgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZXF1ZXN0cyBhcmUgd2VsbCBtYWludGFpbmVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhc2Ugakdsb2JhbHMuanBpcEVuZE9mUmVzcG9uc2VSZWFzb25zLkJZVEVfTElNSVQ6XHJcbiAgICAgICAgICAgIGNhc2Ugakdsb2JhbHMuanBpcEVuZE9mUmVzcG9uc2VSZWFzb25zLlJFU1BPTlNFX0xJTUlUOlxyXG4gICAgICAgICAgICAgICAgaWYgKCFlbmRlZEJ5VXNlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlT2ZEYXRhUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZFJlc3BvbnNlUmVzdWx0ID0gUkVTUE9OU0VfRU5ERURfU0VOVF9BTk9USEVSX01FU1NBR0U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY2FzZSBqR2xvYmFscy5qcGlwRW5kT2ZSZXNwb25zZVJlYXNvbnMuU0VTU0lPTl9MSU1JVDpcclxuICAgICAgICAgICAgICAgIHNlc3Npb25IZWxwZXIub25FeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLklsbGVnYWxPcGVyYXRpb25FeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZXJ2ZXIgcmVzb3VyY2VzIGFzc29jaWF0ZWQgd2l0aCB0aGUgc2Vzc2lvbiBpcyAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpbWl0dGVkLCBubyBmdXJ0aGVyIHJlcXVlc3RzIHNob3VsZCBiZSBpc3N1ZWQgdG8gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aGlzIHNlc3Npb24nKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhc2Ugakdsb2JhbHMuanBpcEVuZE9mUmVzcG9uc2VSZWFzb25zLk5PTl9TUEVDSUZJRUQ6XHJcbiAgICAgICAgICAgICAgICBzZXNzaW9uSGVscGVyLm9uRXhjZXB0aW9uKG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbGxlZ2FsT3BlcmF0aW9uRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICdTZXJ2ZXIgZXJyb3IgdGVybWluYXRlZCByZXNwb25zZSB3aXRoIG5vIHJlYXNvbiBzcGVjaWZpZWQnKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHNlc3Npb25IZWxwZXIub25FeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLklsbGVnYWxEYXRhRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnU2VydmVyIHJlc3BvbmRlZCB3aXRoIGlsbGVnYWwgRW5kIE9mIFJlc3BvbnNlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnKEVPUikgY29kZTogJyArIGJ5dGVzW29mZnNldCArIDFdKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGVuZFJlc3BvbnNlUmVzdWx0O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBzYXZlVG9EYXRhYmluc0Zyb21PZmZzZXQoYWpheFJlc3BvbnNlKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYWpheFJlc3BvbnNlLnJlc3BvbnNlKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICB2YXIgcHJldmlvdXNIZWFkZXI7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgYnl0ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZXNbb2Zmc2V0XSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuZCBPZiBSZXNwb25zZSAoRU9SKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gbWVzc2FnZUhlYWRlclBhcnNlci5wYXJzZU1lc3NhZ2VIZWFkZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMsIG9mZnNldCwgcHJldmlvdXNIZWFkZXIpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyLmJvZHlTdGFydCArIGhlYWRlci5tZXNzYWdlQm9keUxlbmd0aCA+IGJ5dGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHNlc3Npb25IZWxwZXIuZ2V0RGF0YWJpbnNTYXZlcigpLnNhdmVEYXRhKGhlYWRlciwgYnl0ZXMpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBoZWFkZXIuYm9keVN0YXJ0ICsgaGVhZGVyLm1lc3NhZ2VCb2R5TGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgcHJldmlvdXNIZWFkZXIgPSBoZWFkZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiBvZmZzZXQ7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBzZXNzaW9uSGVscGVyLm9uRXhjZXB0aW9uKGUpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBqR2xvYmFscyA9IHJlcXVpcmUoJ2oyay1qcGlwLWdsb2JhbHMuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLkpwaXBTZXNzaW9uSGVscGVyID0gZnVuY3Rpb24gSnBpcFNlc3Npb25IZWxwZXIoXHJcbiAgICBkYXRhUmVxdWVzdFVybCxcclxuICAgIGtub3duVGFyZ2V0SWQsXHJcbiAgICBjb2Rlc3RyZWFtU3RydWN0dXJlLFxyXG4gICAgZGF0YWJpbnNTYXZlcixcclxuICAgIGFqYXhIZWxwZXIpIHtcclxuICAgIFxyXG4gICAgdmFyIHN0YXR1c0NhbGxiYWNrID0gbnVsbDtcclxuICAgIHZhciByZXF1ZXN0RW5kZWRDYWxsYmFjayA9IG51bGw7XHJcbiAgICBcclxuICAgIHZhciBjaGFubmVscyA9IFtdO1xyXG4gICAgdmFyIGZpcnN0Q2hhbm5lbCA9IG51bGw7XHJcblxyXG4gICAgdmFyIGFjdGl2ZVJlcXVlc3RzID0gMDtcclxuICAgIHZhciB3YWl0aW5nRm9yQ29uY3VycmVudFJlcXVlc3RzID0gW107XHJcblxyXG4gICAgdmFyIGlzUmVhZHkgPSBmYWxzZTtcclxuICAgIHZhciB0YXJnZXRJZCA9IGtub3duVGFyZ2V0SWQgfHwgJzAnO1xyXG4gICAgXHJcbiAgICB0aGlzLm9uRXhjZXB0aW9uID0gZnVuY3Rpb24gb25FeGNlcHRpb24oZXhjZXB0aW9uKSB7XHJcbiAgICAgICAgb25TdGF0dXNDaGFuZ2UoZXhjZXB0aW9uKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0SXNSZWFkeSA9IGZ1bmN0aW9uIGdldElzUmVhZHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzUmVhZHk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLnNldElzUmVhZHkgPSBmdW5jdGlvbiBzZXRJc1JlYWR5KGlzUmVhZHlfKSB7XHJcbiAgICAgICAgaXNSZWFkeSA9IGlzUmVhZHlfO1xyXG4gICAgICAgIG9uU3RhdHVzQ2hhbmdlKCk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldENvZGVzdHJlYW1TdHJ1Y3R1cmUgPSBmdW5jdGlvbiBnZXRDb2Rlc3RyZWFtU3RydWN0dXJlKCkge1xyXG4gICAgICAgIHJldHVybiBjb2Rlc3RyZWFtU3RydWN0dXJlO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXREYXRhYmluc1NhdmVyID0gZnVuY3Rpb24gZ2V0RGF0YWJpbnNTYXZlcigpIHtcclxuICAgICAgICByZXR1cm4gZGF0YWJpbnNTYXZlcjtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0RGF0YVJlcXVlc3RVcmwgPSBmdW5jdGlvbiBnZXREYXRhUmVxdWVzdFVybCgpIHtcclxuICAgICAgICByZXR1cm4gZGF0YVJlcXVlc3RVcmw7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldFRhcmdldElkID0gZnVuY3Rpb24gZ2V0VGFyZ2V0SWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldElkO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRGaXJzdENoYW5uZWwgPSBmdW5jdGlvbiBnZXRGaXJzdENoYW5uZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpcnN0Q2hhbm5lbDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuc2V0U3RhdHVzQ2FsbGJhY2sgPSBmdW5jdGlvbiBzZXRTdGF0dXNDYWxsYmFjayhzdGF0dXNDYWxsYmFja18pIHtcclxuICAgICAgICBzdGF0dXNDYWxsYmFjayA9IHN0YXR1c0NhbGxiYWNrXztcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuc2V0UmVxdWVzdEVuZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiBzZXRSZXF1ZXN0RW5kZWRDYWxsYmFjayhcclxuICAgICAgICByZXF1ZXN0RW5kZWRDYWxsYmFja18pIHtcclxuICAgICAgICBcclxuICAgICAgICByZXF1ZXN0RW5kZWRDYWxsYmFjayA9IHJlcXVlc3RFbmRlZENhbGxiYWNrXztcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMucmVxdWVzdFN0YXJ0ZWQgPSBmdW5jdGlvbiByZXF1ZXN0U3RhcnRlZCgpIHtcclxuICAgICAgICArK2FjdGl2ZVJlcXVlc3RzO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5yZXF1ZXN0RW5kZWQgPSBmdW5jdGlvbiByZXF1ZXN0RW5kZWQoYWpheFJlc3BvbnNlLCBjaGFubmVsKSB7XHJcbiAgICAgICAgLS1hY3RpdmVSZXF1ZXN0cztcclxuICAgICAgICBcclxuICAgICAgICB2YXIgdGFyZ2V0SWRGcm9tU2VydmVyID0gYWpheFJlc3BvbnNlLmdldFJlc3BvbnNlSGVhZGVyKCdKUElQLXRpZCcpO1xyXG4gICAgICAgIGlmICh0YXJnZXRJZEZyb21TZXJ2ZXIgIT09ICcnICYmIHRhcmdldElkRnJvbVNlcnZlciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0SWQgPT09ICcwJykge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0SWQgPSB0YXJnZXRJZEZyb21TZXJ2ZXI7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0SWQgIT09IHRhcmdldElkRnJvbVNlcnZlcikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLklsbGVnYWxEYXRhRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICdTZXJ2ZXIgcmV0dXJuZWQgdW5tYXRjaGVkIHRhcmdldCBJRCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChmaXJzdENoYW5uZWwgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgZmlyc3RDaGFubmVsID0gY2hhbm5lbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGNoYW5uZWxGcmVlZCA9IGNoYW5uZWwuZ2V0SXNEZWRpY2F0ZWRGb3JNb3ZhYmxlUmVxdWVzdCgpID9cclxuICAgICAgICAgICAgbnVsbCA6IGNoYW5uZWw7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHJlcXVlc3RFbmRlZENhbGxiYWNrICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RFbmRlZENhbGxiYWNrKGNoYW5uZWxGcmVlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRBY3RpdmVSZXF1ZXN0c0NvdW50ID0gZnVuY3Rpb24gZ2V0QWN0aXZlUmVxdWVzdHNDb3VudCgpIHtcclxuICAgICAgICByZXR1cm4gYWN0aXZlUmVxdWVzdHM7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmNoYW5uZWxDcmVhdGVkID0gZnVuY3Rpb24gY2hhbm5lbENyZWF0ZWQoY2hhbm5lbCkge1xyXG4gICAgICAgIGNoYW5uZWxzLnB1c2goY2hhbm5lbCk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldENyZWF0ZWRDaGFubmVsSWQgPSBmdW5jdGlvbiBnZXRDcmVhdGVkQ2hhbm5lbElkKGFqYXhSZXNwb25zZSkge1xyXG4gICAgICAgIHZhciBjbmV3UmVzcG9uc2UgPSBhamF4UmVzcG9uc2UuZ2V0UmVzcG9uc2VIZWFkZXIoJ0pQSVAtY25ldycpO1xyXG4gICAgICAgIGlmICghY25ld1Jlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIga2V5VmFsdWVQYWlyc0luUmVzcG9uc2UgPSBjbmV3UmVzcG9uc2Uuc3BsaXQoJywnKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlWYWx1ZVBhaXJzSW5SZXNwb25zZS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIga2V5QW5kVmFsdWUgPSBrZXlWYWx1ZVBhaXJzSW5SZXNwb25zZVtpXS5zcGxpdCgnPScpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGtleUFuZFZhbHVlWzBdID09PSAnY2lkJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleUFuZFZhbHVlWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy53YWl0Rm9yQ29uY3VycmVudFJlcXVlc3RzVG9FbmQgPVxyXG4gICAgICAgIGZ1bmN0aW9uIHdhaXRGb3JDb25jdXJyZW50UmVxdWVzdHNUb0VuZChyZXF1ZXN0KSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGNvbmN1cnJlbnRSZXF1ZXN0cyA9IFtdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbm5lbHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHJlcXVlc3RzID0gY2hhbm5lbHNbaV0uZ2V0UmVxdWVzdHNXYWl0aW5nRm9yUmVzcG9uc2UoKTtcclxuICAgICAgICAgICAgdmFyIG51bVJlcXVlc3RzID0gcmVxdWVzdHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAobnVtUmVxdWVzdHMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgbGFzdFJlcXVlc3RJZCA9IHJlcXVlc3RzWzBdLmdldExhc3RSZXF1ZXN0SWQoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCByZXF1ZXN0cy5sZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgICAgICAgbGFzdFJlcXVlc3RJZCA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RSZXF1ZXN0SWQsIHJlcXVlc3RzW2pdLmdldExhc3RSZXF1ZXN0SWQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbmN1cnJlbnRSZXF1ZXN0cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGNoYW5uZWw6IGNoYW5uZWxzW2ldLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdElkOiBsYXN0UmVxdWVzdElkXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgd2FpdGluZ0ZvckNvbmN1cnJlbnRSZXF1ZXN0cy5wdXNoKHtcclxuICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcclxuICAgICAgICAgICAgY29uY3VycmVudFJlcXVlc3RzOiBjb25jdXJyZW50UmVxdWVzdHNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuY2hlY2tDb25jdXJyZW50UmVxdWVzdHNGaW5pc2hlZCA9XHJcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tDb25jdXJyZW50UmVxdWVzdHNGaW5pc2hlZCgpIHtcclxuICAgICAgICBcclxuICAgICAgICBmb3IgKHZhciBpID0gd2FpdGluZ0ZvckNvbmN1cnJlbnRSZXF1ZXN0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICB2YXIgaXNBbGxDb25jdXJyZW50UmVxdWVzdHNGaW5pc2hlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgY29uY3VycmVudFJlcXVlc3RzID1cclxuICAgICAgICAgICAgICAgIHdhaXRpbmdGb3JDb25jdXJyZW50UmVxdWVzdHNbaV0uY29uY3VycmVudFJlcXVlc3RzO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGNvbmN1cnJlbnRSZXF1ZXN0cy5sZW5ndGggLSAxOyBqID49IDA7IC0taikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHdhaXRpbmcgPSBjb25jdXJyZW50UmVxdWVzdHNbal07XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmICh3YWl0aW5nLmNoYW5uZWwuaXNBbGxPbGRSZXF1ZXN0c0VuZGVkKHdhaXRpbmcucmVxdWVzdElkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbmN1cnJlbnRSZXF1ZXN0c1tqXSA9IGNvbmN1cnJlbnRSZXF1ZXN0c1tcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uY3VycmVudFJlcXVlc3RzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbmN1cnJlbnRSZXF1ZXN0cy5sZW5ndGggLT0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGNvbmN1cnJlbnRSZXF1ZXN0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSB3YWl0aW5nRm9yQ29uY3VycmVudFJlcXVlc3RzW2ldLnJlcXVlc3Q7XHJcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IHJlcXVlc3QuY2FsbGJhY2s7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB3YWl0aW5nRm9yQ29uY3VycmVudFJlcXVlc3RzW2ldID0gd2FpdGluZ0ZvckNvbmN1cnJlbnRSZXF1ZXN0c1tcclxuICAgICAgICAgICAgICAgIHdhaXRpbmdGb3JDb25jdXJyZW50UmVxdWVzdHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIHdhaXRpbmdGb3JDb25jdXJyZW50UmVxdWVzdHMubGVuZ3RoIC09IDE7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXF1ZXN0LmNhbGxDYWxsYmFja0FmdGVyQ29uY3VycmVudFJlcXVlc3RzRmluaXNoZWQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLnNlbmRBamF4ID0gZnVuY3Rpb24gc2VuZEFqYXgoXHJcbiAgICAgICAgdXJsLFxyXG4gICAgICAgIGNhbGxiYWNrLFxyXG4gICAgICAgIGZhaWx1cmVDYWxsYmFjaykge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBmb3JrZWRGYWlsdXJlQ2FsbGJhY2s7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGZhaWx1cmVDYWxsYmFjaykge1xyXG4gICAgICAgICAgICBmb3JrZWRGYWlsdXJlQ2FsbGJhY2sgPSBmdW5jdGlvbiBmb3JrRmFpbHVyZUNhbGxiYWNrKGFqYXhSZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgZ2VuZXJhbEZhaWx1cmVDYWxsYmFjayhhamF4UmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgZmFpbHVyZUNhbGxiYWNrKGFqYXhSZXNwb25zZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9ya2VkRmFpbHVyZUNhbGxiYWNrID0gZ2VuZXJhbEZhaWx1cmVDYWxsYmFjaztcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgYWpheEhlbHBlci5yZXF1ZXN0KHVybCwgY2FsbGJhY2ssIGZvcmtlZEZhaWx1cmVDYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBnZW5lcmFsRmFpbHVyZUNhbGxiYWNrKGFqYXhSZXNwb25zZSkge1xyXG4gICAgICAgIHZhciBleGNlcHRpb24gPSBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgJ0JhZCBqcGlwIHNlcnZlciByZXNwb25zZSAoc3RhdHVzID0gJyArIGFqYXhSZXNwb25zZS5zdGF0dXMgKyAnKScpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICBvblN0YXR1c0NoYW5nZShleGNlcHRpb24pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBvblN0YXR1c0NoYW5nZShleGNlcHRpb24pIHtcclxuICAgICAgICBpZiAoZXhjZXB0aW9uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZXhjZXB0aW9uID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHN0YXR1c0NhbGxiYWNrICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0YXR1c0NhbGxiYWNrKHtcclxuICAgICAgICAgICAgICAgIGlzUmVhZHk6IGlzUmVhZHksXHJcbiAgICAgICAgICAgICAgICBleGNlcHRpb246IGV4Y2VwdGlvblxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGpHbG9iYWxzID0gcmVxdWlyZSgnajJrLWpwaXAtZ2xvYmFscy5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuSnBpcFNlc3Npb24gPSBmdW5jdGlvbiBKcGlwU2Vzc2lvbihcclxuICAgIG1heENoYW5uZWxzSW5TZXNzaW9uLFxyXG4gICAgbWF4UmVxdWVzdHNXYWl0aW5nRm9yUmVzcG9uc2VJbkNoYW5uZWwsXHJcbiAgICBrbm93blRhcmdldElkLFxyXG4gICAgY29kZXN0cmVhbVN0cnVjdHVyZSxcclxuICAgIGRhdGFiaW5zU2F2ZXIsXHJcbiAgICBzZXRJbnRlcnZhbEZ1bmN0aW9uLFxyXG4gICAgY2xlYXJJbnRlcnZhbEZ1bmN0aW9uLFxyXG4gICAganBpcEZhY3RvcnkpIHtcclxuXHJcbiAgICB2YXIgU0VDT05EID0gMTAwMDtcclxuICAgIHZhciBLRUVQX0FMSVZFX0lOVEVSVkFMID0gMzAgKiBTRUNPTkQ7XHJcbiAgICBcclxuICAgIHZhciBjaGFubmVsTWFuYWdlbWVudFVybDtcclxuICAgIHZhciBkYXRhUmVxdWVzdFVybDtcclxuICAgIHZhciBjbG9zZVNlc3Npb25Vcmw7XHJcbiAgICBcclxuICAgIHZhciBpc0Nsb3NlQ2FsbGVkID0gZmFsc2U7XHJcbiAgICB2YXIgY2xvc2VDYWxsYmFja1BlbmRpbmcgPSBudWxsO1xyXG5cclxuICAgIHZhciBzZXNzaW9uSGVscGVyID0gbnVsbDtcclxuICAgIHZhciBzdGF0dXNDYWxsYmFjayA9IG51bGw7XHJcbiAgICB2YXIgcmVxdWVzdEVuZGVkQ2FsbGJhY2sgPSBudWxsO1xyXG5cclxuICAgIHZhciBub25EZWRpY2F0ZWRDaGFubmVscyA9IFtdO1xyXG4gICAgdmFyIGNoYW5uZWxzQ3JlYXRlZCA9IDA7XHJcbiAgICB2YXIga2VlcEFsaXZlSW50ZXJ2YWxIYW5kbGUgPSBudWxsO1xyXG4gICAgXHJcbiAgICB0aGlzLm9wZW4gPSBmdW5jdGlvbiBvcGVuKGJhc2VVcmwpIHtcclxuICAgICAgICBpZiAoc2Vzc2lvbkhlbHBlciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICdzZXNzaW9uLm9wZW4oKSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgcXVlcnlQYXJhbXNEZWxpbWl0ZXIgPSBiYXNlVXJsLmluZGV4T2YoJz8nKSA8IDAgPyAnPycgOiAnJic7XHJcbiAgICAgICAgY2hhbm5lbE1hbmFnZW1lbnRVcmwgPSBiYXNlVXJsICsgcXVlcnlQYXJhbXNEZWxpbWl0ZXIgKyAndHlwZT0nICsgXHJcbiAgICAgICAgICAgIChkYXRhYmluc1NhdmVyLmdldElzSnBpcFRpbGVQYXJ0U3RyZWFtKCkgPyAnanB0LXN0cmVhbScgOiAnanBwLXN0cmVhbScpO1xyXG4gICAgICAgIGRhdGFSZXF1ZXN0VXJsID0gY2hhbm5lbE1hbmFnZW1lbnRVcmwgKyAnJnN0cmVhbT0wJztcclxuICAgICAgICBcclxuICAgICAgICBzZXNzaW9uSGVscGVyID0ganBpcEZhY3RvcnkuY3JlYXRlU2Vzc2lvbkhlbHBlcihcclxuICAgICAgICAgICAgZGF0YVJlcXVlc3RVcmwsIGtub3duVGFyZ2V0SWQsIGNvZGVzdHJlYW1TdHJ1Y3R1cmUsIGRhdGFiaW5zU2F2ZXIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChzdGF0dXNDYWxsYmFjayAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXNzaW9uSGVscGVyLnNldFN0YXR1c0NhbGxiYWNrKHN0YXR1c0NhbGxiYWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHJlcXVlc3RFbmRlZENhbGxiYWNrICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNlc3Npb25IZWxwZXIuc2V0UmVxdWVzdEVuZGVkQ2FsbGJhY2socmVxdWVzdEVuZGVkQ2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgY2hhbm5lbCA9IGNyZWF0ZUNoYW5uZWwoKTtcclxuICAgICAgICBcclxuICAgICAgICBjaGFubmVsLnNlbmRNaW5pbWFsUmVxdWVzdChzZXNzaW9uUmVhZHlDYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldFRhcmdldElkID0gZnVuY3Rpb24gZ2V0VGFyZ2V0SWQoKSB7XHJcbiAgICAgICAgZW5zdXJlUmVhZHkoKTtcclxuICAgICAgICByZXR1cm4gc2Vzc2lvbkhlbHBlci5nZXRUYXJnZXRJZCgpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRJc1JlYWR5ID0gZnVuY3Rpb24gZ2V0SXNSZWFkeSgpIHtcclxuICAgICAgICB2YXIgaXNSZWFkeSA9IHNlc3Npb25IZWxwZXIgIT09IG51bGwgJiYgc2Vzc2lvbkhlbHBlci5nZXRJc1JlYWR5KCk7XHJcbiAgICAgICAgcmV0dXJuIGlzUmVhZHk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLnNldFN0YXR1c0NhbGxiYWNrID0gZnVuY3Rpb24gc2V0U3RhdHVzQ2FsbGJhY2soc3RhdHVzQ2FsbGJhY2tfKSB7XHJcbiAgICAgICAgc3RhdHVzQ2FsbGJhY2sgPSBzdGF0dXNDYWxsYmFja187XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHNlc3Npb25IZWxwZXIgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgc2Vzc2lvbkhlbHBlci5zZXRTdGF0dXNDYWxsYmFjayhzdGF0dXNDYWxsYmFja18pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuc2V0UmVxdWVzdEVuZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiBzZXRSZXF1ZXN0RW5kZWRDYWxsYmFjayhcclxuICAgICAgICByZXF1ZXN0RW5kZWRDYWxsYmFja18pIHtcclxuICAgICAgICBcclxuICAgICAgICByZXF1ZXN0RW5kZWRDYWxsYmFjayA9IHJlcXVlc3RFbmRlZENhbGxiYWNrXztcclxuICAgICAgICBcclxuICAgICAgICBpZiAoc2Vzc2lvbkhlbHBlciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXNzaW9uSGVscGVyLnNldFJlcXVlc3RFbmRlZENhbGxiYWNrKHJlcXVlc3RFbmRlZENhbGxiYWNrXyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5oYXNBY3RpdmVSZXF1ZXN0cyA9IGZ1bmN0aW9uIGhhc0FjdGl2ZVJlcXVlc3RzKCkge1xyXG4gICAgICAgIGVuc3VyZVJlYWR5KCk7XHJcblxyXG4gICAgICAgIHZhciBpc0FjdGl2ZVJlcXVlc3RzID0gc2Vzc2lvbkhlbHBlci5nZXRBY3RpdmVSZXF1ZXN0c0NvdW50KCkgPiAwO1xyXG4gICAgICAgIHJldHVybiBpc0FjdGl2ZVJlcXVlc3RzO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy50cnlHZXRDaGFubmVsID0gZnVuY3Rpb24gdHJ5R2V0Q2hhbm5lbChkZWRpY2F0ZUZvck1vdmFibGVSZXF1ZXN0KSB7XHJcbiAgICAgICAgZW5zdXJlUmVhZHkoKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgY2FuQ3JlYXRlTmV3Q2hhbm5lbCA9IGNoYW5uZWxzQ3JlYXRlZCA8IG1heENoYW5uZWxzSW5TZXNzaW9uO1xyXG4gICAgICAgIHZhciBzZWFyY2hPbmx5Q2hhbm5lbFdpdGhFbXB0eVF1ZXVlID1cclxuICAgICAgICAgICAgY2FuQ3JlYXRlTmV3Q2hhbm5lbCB8fCBkZWRpY2F0ZUZvck1vdmFibGVSZXF1ZXN0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBtYXhSZXF1ZXN0c0luQ2hhbm5lbCA9IHNlYXJjaE9ubHlDaGFubmVsV2l0aEVtcHR5UXVldWUgP1xyXG4gICAgICAgICAgICAwIDogbWF4UmVxdWVzdHNXYWl0aW5nRm9yUmVzcG9uc2VJbkNoYW5uZWwgLSAxO1xyXG5cclxuICAgICAgICB2YXIgY2hhbm5lbCA9IGdldENoYW5uZWxXaXRoTWluaW1hbFdhaXRpbmdSZXF1ZXN0cyhcclxuICAgICAgICAgICAgbWF4UmVxdWVzdHNJbkNoYW5uZWwsXHJcbiAgICAgICAgICAgIC8qaXNFeHRyYWN0RnJvbU5vbkRlZGljYXRlZExpc3Q9Ki9kZWRpY2F0ZUZvck1vdmFibGVSZXF1ZXN0KTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoY2hhbm5lbCA9PT0gbnVsbCAmJiBjYW5DcmVhdGVOZXdDaGFubmVsKSB7XHJcbiAgICAgICAgICAgIGNoYW5uZWwgPSBjcmVhdGVDaGFubmVsKGRlZGljYXRlRm9yTW92YWJsZVJlcXVlc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoZGVkaWNhdGVGb3JNb3ZhYmxlUmVxdWVzdCAmJiBjaGFubmVsICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNoYW5uZWwuZGVkaWNhdGVGb3JNb3ZhYmxlUmVxdWVzdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gY2hhbm5lbDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuY2xvc2UgPSBmdW5jdGlvbiBjbG9zZShjbG9zZWRDYWxsYmFjaykge1xyXG4gICAgICAgIGlmIChjaGFubmVsc0NyZWF0ZWQgPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAnQ2Fubm90IGNsb3NlIHNlc3Npb24gYmVmb3JlIG9wZW4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc0Nsb3NlQ2FsbGVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbnRlcm5hbEVycm9yRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgJ0Nhbm5vdCBjbG9zZSBzZXNzaW9uIHR3aWNlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlzQ2xvc2VDYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgIGNsb3NlQ2FsbGJhY2tQZW5kaW5nID0gY2xvc2VkQ2FsbGJhY2s7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGNsb3NlU2Vzc2lvblVybCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNsb3NlSW50ZXJuYWwoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBjbG9zZUludGVybmFsKCkge1xyXG4gICAgICAgIGlmIChrZWVwQWxpdmVJbnRlcnZhbEhhbmRsZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjbGVhckludGVydmFsRnVuY3Rpb24oa2VlcEFsaXZlSW50ZXJ2YWxIYW5kbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBzZXNzaW9uSGVscGVyLnNldElzUmVhZHkoZmFsc2UpO1xyXG4gICAgICAgIHNlc3Npb25IZWxwZXIuc2VuZEFqYXgoY2xvc2VTZXNzaW9uVXJsLCBjbG9zZUNhbGxiYWNrUGVuZGluZyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNoYW5uZWwoaXNEZWRpY2F0ZWRGb3JNb3ZhYmxlUmVxdWVzdCkge1xyXG4gICAgICAgICsrY2hhbm5lbHNDcmVhdGVkO1xyXG4gICAgICAgIHZhciBjaGFubmVsID0ganBpcEZhY3RvcnkuY3JlYXRlQ2hhbm5lbChcclxuICAgICAgICAgICAgbWF4UmVxdWVzdHNXYWl0aW5nRm9yUmVzcG9uc2VJbkNoYW5uZWwsIHNlc3Npb25IZWxwZXIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHNlc3Npb25IZWxwZXIuY2hhbm5lbENyZWF0ZWQoY2hhbm5lbCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKCFpc0RlZGljYXRlZEZvck1vdmFibGVSZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIG5vbkRlZGljYXRlZENoYW5uZWxzLnB1c2goY2hhbm5lbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2hhbm5lbDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gZ2V0Q2hhbm5lbFdpdGhNaW5pbWFsV2FpdGluZ1JlcXVlc3RzKFxyXG4gICAgICAgIG1heFJlcXVlc3RzSW5DaGFubmVsLCBpc0V4dHJhY3RGcm9tTm9uRGVkaWNhdGVkTGlzdCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBjaGFubmVsID0gbnVsbDtcclxuICAgICAgICB2YXIgaW5kZXg7XHJcbiAgICAgICAgdmFyIG1pbmltYWxXYWl0aW5nUmVxdWVzdHMgPSBtYXhSZXF1ZXN0c0luQ2hhbm5lbCArIDE7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25EZWRpY2F0ZWRDaGFubmVscy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgd2FpdGluZ1JlcXVlc3RzID1cclxuICAgICAgICAgICAgICAgIG5vbkRlZGljYXRlZENoYW5uZWxzW2ldLmdldEFsbFF1ZXVlZFJlcXVlc3RDb3VudCgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHdhaXRpbmdSZXF1ZXN0cyA8IG1pbmltYWxXYWl0aW5nUmVxdWVzdHMpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5uZWwgPSBub25EZWRpY2F0ZWRDaGFubmVsc1tpXTtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIG1pbmltYWxXYWl0aW5nUmVxdWVzdHMgPSB3YWl0aW5nUmVxdWVzdHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICh3YWl0aW5nUmVxdWVzdHMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICghaXNFeHRyYWN0RnJvbU5vbkRlZGljYXRlZExpc3QgfHwgY2hhbm5lbCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2hhbm5lbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgbm9uRGVkaWNhdGVkQ2hhbm5lbHNbaW5kZXhdID1cclxuICAgICAgICAgICAgbm9uRGVkaWNhdGVkQ2hhbm5lbHNbbm9uRGVkaWNhdGVkQ2hhbm5lbHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgbm9uRGVkaWNhdGVkQ2hhbm5lbHMubGVuZ3RoIC09IDE7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGNoYW5uZWw7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHNlc3Npb25SZWFkeUNhbGxiYWNrKCkge1xyXG4gICAgICAgIHZhciBtYWluSGVhZGVyRGF0YWJpbiA9IGRhdGFiaW5zU2F2ZXIuZ2V0TWFpbkhlYWRlckRhdGFiaW4oKTtcclxuICAgICAgICBpZiAoIW1haW5IZWFkZXJEYXRhYmluLmlzQWxsRGF0YWJpbkxvYWRlZCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbGxlZ2FsRGF0YUV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICdNYWluIGhlYWRlciB3YXMgbm90IGxvYWRlZCBvbiBzZXNzaW9uIGNyZWF0aW9uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBhcmJpdHJhcnlDaGFubmVsID0gc2Vzc2lvbkhlbHBlci5nZXRGaXJzdENoYW5uZWwoKTtcclxuICAgICAgICB2YXIgYXJiaXRyYXJ5Q2hhbm5lbElkID0gYXJiaXRyYXJ5Q2hhbm5lbC5nZXRDaGFubmVsSWQoKTtcclxuICAgICAgICBjbG9zZVNlc3Npb25VcmwgPSBjaGFubmVsTWFuYWdlbWVudFVybCArXHJcbiAgICAgICAgICAgICcmY2Nsb3NlPSonICtcclxuICAgICAgICAgICAgJyZjaWQ9JyArIGFyYml0cmFyeUNoYW5uZWxJZDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgaWYgKGlzQ2xvc2VDYWxsZWQpIHtcclxuICAgICAgICAgICAgY2xvc2VJbnRlcm5hbCgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGtlZXBBbGl2ZUludGVydmFsSGFuZGxlID0gc2V0SW50ZXJ2YWxGdW5jdGlvbihcclxuICAgICAgICAgICAga2VlcEFsaXZlSGFuZGxlciwgS0VFUF9BTElWRV9JTlRFUlZBTCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgc2Vzc2lvbkhlbHBlci5zZXRJc1JlYWR5KHRydWUpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBrZWVwQWxpdmVIYW5kbGVyKCkge1xyXG4gICAgICAgIGlmIChzZXNzaW9uSGVscGVyLmdldEFjdGl2ZVJlcXVlc3RzQ291bnQoKSA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgYXJiaXRyYXJ5Q2hhbm5lbCA9IHNlc3Npb25IZWxwZXIuZ2V0Rmlyc3RDaGFubmVsKCk7XHJcbiAgICAgICAgYXJiaXRyYXJ5Q2hhbm5lbC5zZW5kTWluaW1hbFJlcXVlc3QoZnVuY3Rpb24gZHVtbXlDYWxsYmFjaygpIHt9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gZW5zdXJlUmVhZHkoKSB7XHJcbiAgICAgICAgaWYgKHNlc3Npb25IZWxwZXIgPT09IG51bGwgfHwgIXNlc3Npb25IZWxwZXIuZ2V0SXNSZWFkeSgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbnRlcm5hbEVycm9yRXhjZXB0aW9uKCdDYW5ub3QgcGVyZm9ybSAnICtcclxuICAgICAgICAgICAgICAgICd0aGlzIG9wZXJhdGlvbiB3aGVuIHRoZSBzZXNzaW9uIGlzIG5vdCByZWFkeScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgakdsb2JhbHMgPSByZXF1aXJlKCdqMmstanBpcC1nbG9iYWxzLmpzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5KcGlwQml0c3RyZWFtUmVhZGVyID0gKGZ1bmN0aW9uIEpwaXBCaXRzdHJlYW1SZWFkZXJDbG9zdXJlKCkge1xyXG4gICAgdmFyIHplcm9CaXRzVW50aWxGaXJzdE9uZUJpdE1hcCA9IGNyZWF0ZVplcm9CaXRzVW50aWxGaXJzdE9uZUJpdE1hcCgpO1xyXG5cclxuICAgIGZ1bmN0aW9uIEpwaXBCaXRzdHJlYW1SZWFkZXIoZGF0YWJpbiwgdHJhbnNhY3Rpb25IZWxwZXIpIHtcclxuICAgICAgICB2YXIgaW5pdGlhbFN0YXRlID0ge1xyXG4gICAgICAgICAgICBuZXh0T2Zmc2V0VG9QYXJzZTogMCxcclxuICAgICAgICAgICAgdmFsaWRCaXRzSW5DdXJyZW50Qnl0ZTogMCxcclxuICAgICAgICAgICAgb3JpZ2luYWxCeXRlV2l0aG91dFNoaWZ0OiBudWxsLFxyXG4gICAgICAgICAgICBjdXJyZW50Qnl0ZTogbnVsbCxcclxuICAgICAgICAgICAgaXNTa2lwTmV4dEJ5dGU6IGZhbHNlXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciBzdHJlYW1TdGF0ZSA9IHRyYW5zYWN0aW9uSGVscGVyLmNyZWF0ZVRyYW5zYWN0aW9uYWxPYmplY3QoaW5pdGlhbFN0YXRlKTtcclxuICAgICAgICB2YXIgYWN0aXZlVHJhbnNhY3Rpb24gPSBudWxsO1xyXG4gICAgICAgIFxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYWN0aXZlVHJhbnNhY3Rpb24nLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0QWN0aXZlVHJhbnNhY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlVHJhbnNhY3Rpb24gPT09IG51bGwgfHxcclxuICAgICAgICAgICAgICAgICAgICAhYWN0aXZlVHJhbnNhY3Rpb24uaXNBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ05vIGFjdGl2ZSB0cmFuc2FjdGlvbiBpbiBiaXRzdHJlYW1SZWFkZXInKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZVRyYW5zYWN0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdiaXRzQ291bnRlcicsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXRCaXRzQ291bnRlcigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN0cmVhbVN0YXRlLmdldFZhbHVlKGFjdGl2ZVRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdHJ5VmFsaWRhdGVDdXJyZW50Qnl0ZShkYXRhYmluLCBzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaXNTa2lwTmV4dEJ5dGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1VuZXhwZWN0ZWQgc3RhdGUgb2YgYml0c3RyZWFtUmVhZGVyOiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1doZW4gMHhGRiBlbmNvdW50ZXJlZCwgdHJ5VmFsaWRhdGVDdXJyZW50Qnl0ZSAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Nob3VsZCBza2lwIHRoZSB3aG9sZSBieXRlICBhZnRlciAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ3NoaWZ0UmVtYWluaW5nQml0c0luQnl0ZSBhbmQgY2xlYXIgaXNTa2lwTmV4dEJ5dGUuICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnSG93ZXZlciB0aGUgZmxhZyBpcyBzdGlsbCBzZXQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHN0YXRlLm5leHRPZmZzZXRUb1BhcnNlICogOCAtIHN0YXRlLnZhbGlkQml0c0luQ3VycmVudEJ5dGU7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2RhdGFiaW5PZmZzZXQnLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0RGF0YWJpbk9mZnNldCgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN0cmVhbVN0YXRlLmdldFZhbHVlKGFjdGl2ZVRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmlzU2tpcE5leHRCeXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLm5leHRPZmZzZXRUb1BhcnNlICsgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnZhbGlkQml0c0luQ3VycmVudEJ5dGUgJSA4ICE9PSAwIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUub3JpZ2luYWxCeXRlV2l0aG91dFNoaWZ0ID09PSAweEZGKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdDYW5ub3QgY2FsY3VsYXRlIGRhdGFiaW4gb2Zmc2V0IHdoZW4gYml0c3RyZWFtUmVhZGVyICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnIGlzIGluIHRoZSBtaWRkbGUgb2YgdGhlIGJ5dGUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLm5leHRPZmZzZXRUb1BhcnNlIC0gc3RhdGUudmFsaWRCaXRzSW5DdXJyZW50Qnl0ZSAvIDg7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldERhdGFiaW5PZmZzZXQob2Zmc2V0SW5CeXRlcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gc3RyZWFtU3RhdGUuZ2V0VmFsdWUoYWN0aXZlVHJhbnNhY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgc3RhdGUudmFsaWRCaXRzSW5DdXJyZW50Qnl0ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc1NraXBOZXh0Qnl0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgc3RhdGUub3JpZ2luYWxCeXRlV2l0aG91dFNoaWZ0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHN0YXRlLm5leHRPZmZzZXRUb1BhcnNlID0gb2Zmc2V0SW5CeXRlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuc3RhcnROZXdUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uIHN0YXJ0TmV3VHJhbnNhY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmIChhY3RpdmVUcmFuc2FjdGlvbiAhPT0gbnVsbCAmJiBhY3RpdmVUcmFuc2FjdGlvbi5pc0FjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgJ0Nhbm5vdCBzdGFydCBuZXcgdHJhbnNhY3Rpb24gaW4gYml0c3RyZWFtUmVhZGVyICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICd3aGlsZSBhbm90aGVyIHRyYW5zYWN0aW9uIGlzIGFjdGl2ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBhY3RpdmVUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uSGVscGVyLmNyZWF0ZVRyYW5zYWN0aW9uKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnNoaWZ0UmVtYWluaW5nQml0c0luQnl0ZSA9IGZ1bmN0aW9uIHNoaWZ0UmVtYWluaW5nQml0c0luQnl0ZSgpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXRlID0gc3RyZWFtU3RhdGUuZ2V0VmFsdWUoYWN0aXZlVHJhbnNhY3Rpb24pO1xyXG5cclxuICAgICAgICAgICAgc3RhdGUuaXNTa2lwTmV4dEJ5dGUgPSBzdGF0ZS5vcmlnaW5hbEJ5dGVXaXRob3V0U2hpZnQgPT09IDB4RkY7XHJcbiAgICAgICAgICAgIHN0YXRlLnZhbGlkQml0c0luQ3VycmVudEJ5dGUgPSBNYXRoLmZsb29yKFxyXG4gICAgICAgICAgICAgICAgc3RhdGUudmFsaWRCaXRzSW5DdXJyZW50Qnl0ZSAvIDgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5zaGlmdEJpdCA9IGZ1bmN0aW9uIHNoaWZ0Qml0KCkge1xyXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBzdHJlYW1TdGF0ZS5nZXRWYWx1ZShhY3RpdmVUcmFuc2FjdGlvbik7XHJcbiAgICAgICAgICAgIGlmICghdHJ5VmFsaWRhdGVDdXJyZW50Qnl0ZShkYXRhYmluLCBzdGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgb25lc0NvdW50ID0gY291bnRBbmRTaGlmdEJpdHMoXHJcbiAgICAgICAgICAgICAgICBkYXRhYmluLFxyXG4gICAgICAgICAgICAgICAgc3RhdGUsXHJcbiAgICAgICAgICAgICAgICAvKmlzVW50aWxaZXJvQml0PSovdHJ1ZSxcclxuICAgICAgICAgICAgICAgIC8qbWF4Qml0c1RvU2hpZnQ9Ki8xKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiBvbmVzQ291bnQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmNvdW50WmVyb3NBbmRTaGlmdFVudGlsRmlyc3RPbmVCaXQgPVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBjb3VudFplcm9zQW5kU2hpZnRVbnRpbEZpcnN0T25lQml0KG1heEJpdHNUb1NoaWZ0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBzdHJlYW1TdGF0ZS5nZXRWYWx1ZShhY3RpdmVUcmFuc2FjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY291bnRBbmRTaGlmdEJpdHMoXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YWJpbiwgc3RhdGUsIC8qaXNVbnRpbFplcm9CaXQ9Ki9mYWxzZSwgbWF4Qml0c1RvU2hpZnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuY291bnRPbmVzQW5kU2hpZnRVbnRpbEZpcnN0WmVyb0JpdCA9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvdW50T25lc0FuZFNoaWZ0VW50aWxGaXJzdFplcm9CaXQobWF4Qml0c1RvU2hpZnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN0cmVhbVN0YXRlLmdldFZhbHVlKGFjdGl2ZVRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBjb3VudEFuZFNoaWZ0Qml0cyhcclxuICAgICAgICAgICAgICAgICAgICBkYXRhYmluLCBzdGF0ZSwgLyppc1VudGlsWmVyb0JpdD0qL3RydWUsIG1heEJpdHNUb1NoaWZ0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnNoaWZ0Qml0cyA9IGZ1bmN0aW9uIHNoaWZ0Qml0cyhiaXRzQ291bnQpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHN0cmVhbVN0YXRlLmdldFZhbHVlKGFjdGl2ZVRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgdmFyIHJlbWFpbmluZ0JpdHMgPSBiaXRzQ291bnQ7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB3aGlsZSAocmVtYWluaW5nQml0cyA+IDApIHtcclxuICAgICAgICAgICAgICAgIGlmICghdHJ5VmFsaWRhdGVDdXJyZW50Qnl0ZShkYXRhYmluLCBzdGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIGJpdHNUb1Rha2UgPSBNYXRoLm1pbihcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWxpZEJpdHNJbkN1cnJlbnRCeXRlLCByZW1haW5pbmdCaXRzKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIGFkZFRvUmVzdWx0ID0gc3RhdGUuY3VycmVudEJ5dGUgPj4gKDggLSBiaXRzVG9UYWtlKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChyZXN1bHQgPDwgYml0c1RvVGFrZSkgKyBhZGRUb1Jlc3VsdDtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlQml0c0Zyb21CeXRlKHN0YXRlLCBiaXRzVG9UYWtlKTtcclxuICAgICAgICAgICAgICAgIHJlbWFpbmluZ0JpdHMgLT0gYml0c1RvVGFrZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBjb3VudEFuZFNoaWZ0Qml0cyhkYXRhYmluLCBzdGF0ZSwgaXNVbnRpbFplcm9CaXQsIG1heEJpdHNUb1NoaWZ0KSB7XHJcbiAgICAgICAgdmFyIGNvdW50ZWRCaXRzID0gMDtcclxuICAgICAgICB2YXIgZm91bmRUZXJtaW5hdGluZ0JpdDtcclxuICAgICAgICB2YXIgcmVtYWluaW5nQml0cyA9IG1heEJpdHNUb1NoaWZ0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgaWYgKCF0cnlWYWxpZGF0ZUN1cnJlbnRCeXRlKGRhdGFiaW4sIHN0YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBieXRlVmFsdWUgPSBpc1VudGlsWmVyb0JpdCA/IH5zdGF0ZS5jdXJyZW50Qnl0ZSA6IHN0YXRlLmN1cnJlbnRCeXRlO1xyXG4gICAgICAgICAgICB2YXIgYml0c0NvdW50SW5jbHVkaW5nVGVybWluYXRpbmdCaXQgPSBNYXRoLm1pbihcclxuICAgICAgICAgICAgICAgIHplcm9CaXRzVW50aWxGaXJzdE9uZUJpdE1hcFtieXRlVmFsdWVdLFxyXG4gICAgICAgICAgICAgICAgc3RhdGUudmFsaWRCaXRzSW5DdXJyZW50Qnl0ZSArIDEpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGJpdHNDb3VudE5vdEluY2x1ZGluZ1Rlcm1pbmF0aW5nQml0ID1cclxuICAgICAgICAgICAgICAgIGJpdHNDb3VudEluY2x1ZGluZ1Rlcm1pbmF0aW5nQml0IC0gMTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmdCaXRzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChiaXRzQ291bnRJbmNsdWRpbmdUZXJtaW5hdGluZ0JpdCA+IHJlbWFpbmluZ0JpdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVCaXRzRnJvbUJ5dGUoc3RhdGUsIHJlbWFpbmluZ0JpdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZWRCaXRzICs9IHJlbWFpbmluZ0JpdHM7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHJlbWFpbmluZ0JpdHMgLT0gYml0c0NvdW50Tm90SW5jbHVkaW5nVGVybWluYXRpbmdCaXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvdW50ZWRCaXRzICs9IGJpdHNDb3VudE5vdEluY2x1ZGluZ1Rlcm1pbmF0aW5nQml0O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZm91bmRUZXJtaW5hdGluZ0JpdCA9XHJcbiAgICAgICAgICAgICAgICBiaXRzQ291bnRJbmNsdWRpbmdUZXJtaW5hdGluZ0JpdCA8PSBzdGF0ZS52YWxpZEJpdHNJbkN1cnJlbnRCeXRlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZvdW5kVGVybWluYXRpbmdCaXQpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUJpdHNGcm9tQnl0ZShzdGF0ZSwgYml0c0NvdW50SW5jbHVkaW5nVGVybWluYXRpbmdCaXQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUudmFsaWRCaXRzSW5DdXJyZW50Qnl0ZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlICghZm91bmRUZXJtaW5hdGluZ0JpdCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGNvdW50ZWRCaXRzO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiByZW1vdmVCaXRzRnJvbUJ5dGUoc3RhdGUsIGJpdHNDb3VudCkge1xyXG4gICAgICAgIHN0YXRlLnZhbGlkQml0c0luQ3VycmVudEJ5dGUgLT0gYml0c0NvdW50O1xyXG4gICAgICAgIGlmIChzdGF0ZS52YWxpZEJpdHNJbkN1cnJlbnRCeXRlID4gMCkge1xyXG4gICAgICAgICAgICBzdGF0ZS5jdXJyZW50Qnl0ZSA9IChzdGF0ZS5jdXJyZW50Qnl0ZSA8PCBiaXRzQ291bnQpICYgMHhGRjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdHJ5VmFsaWRhdGVDdXJyZW50Qnl0ZShkYXRhYmluLCBzdGF0ZSkge1xyXG4gICAgICAgIGlmIChzdGF0ZS52YWxpZEJpdHNJbkN1cnJlbnRCeXRlID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGJ5dGVzTmVlZGVkID0gc3RhdGUuaXNTa2lwTmV4dEJ5dGUgPyAyIDogMTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgcmVzdWx0QXJyYXkgPSBbXTtcclxuICAgICAgICB2YXIgYnl0ZXNDb3BpZWQgPSBkYXRhYmluLmNvcHlCeXRlcyhyZXN1bHRBcnJheSwgLypyZXN1bHRTdGFydE9mZnNldD0qLzAsIHtcclxuICAgICAgICAgICAgZm9yY2VDb3B5QWxsUmFuZ2U6IHRydWUsXHJcbiAgICAgICAgICAgIGRhdGFiaW5TdGFydE9mZnNldDogc3RhdGUubmV4dE9mZnNldFRvUGFyc2UsXHJcbiAgICAgICAgICAgIG1heExlbmd0aFRvQ29weTogYnl0ZXNOZWVkZWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGJ5dGVzQ29waWVkICE9PSBieXRlc05lZWRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcHJldkJ5dGUgPSBzdGF0ZS5vcmlnaW5hbEJ5dGVXaXRob3V0U2hpZnQ7XHJcblxyXG4gICAgICAgIHN0YXRlLmN1cnJlbnRCeXRlID0gcmVzdWx0QXJyYXlbYnl0ZXNOZWVkZWQgLSAxXTtcclxuICAgICAgICBzdGF0ZS52YWxpZEJpdHNJbkN1cnJlbnRCeXRlID0gODtcclxuICAgICAgICBzdGF0ZS5vcmlnaW5hbEJ5dGVXaXRob3V0U2hpZnQgPSBzdGF0ZS5jdXJyZW50Qnl0ZTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAocHJldkJ5dGUgPT09IDB4RkYpIHtcclxuICAgICAgICAgICAgaWYgKChyZXN1bHRBcnJheVswXSAmIDB4ODApICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuajJrRXhjZXB0aW9ucy5JbGxlZ2FsRGF0YUV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAnRXhwZWN0ZWQgMCBiaXQgYWZ0ZXIgMHhGRiBieXRlJywgJ0IuMTAuMScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIHNraXAgYW5vdGhlciBiaXQgaWYgYWxyZWFkeSBza2lwIHRoZSB3aG9sZSBieXRlXHJcbiAgICAgICAgICAgIGlmICghc3RhdGUuaXNTa2lwTmV4dEJ5dGUpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnRCeXRlIDw8PSAxO1xyXG4gICAgICAgICAgICAgICAgc3RhdGUudmFsaWRCaXRzSW5DdXJyZW50Qnl0ZSA9IDc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgc3RhdGUuaXNTa2lwTmV4dEJ5dGUgPSBmYWxzZTtcclxuICAgICAgICBzdGF0ZS5uZXh0T2Zmc2V0VG9QYXJzZSArPSBieXRlc05lZWRlZDtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVaZXJvQml0c1VudGlsRmlyc3RPbmVCaXRNYXAoKSB7XHJcbiAgICAgICAgdmFyIGFycmF5TWFwID0gbmV3IEFycmF5KDI1NSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgYXJyYXlNYXBbMHgwMF0gPSA5O1xyXG4gICAgICAgIGFycmF5TWFwWzB4MDFdID0gODtcclxuICAgICAgICBhcnJheU1hcFsweDAyXSA9IDc7XHJcbiAgICAgICAgYXJyYXlNYXBbMHgwM10gPSA3O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAoaSA9IDB4MDQ7IGkgPD0gMHgwNzsgKytpKSB7XHJcbiAgICAgICAgICAgIGFycmF5TWFwW2ldID0gNjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yIChpID0gMHgwODsgaSA8PSAweDBGOyArK2kpIHtcclxuICAgICAgICAgICAgYXJyYXlNYXBbaV0gPSA1O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChpID0gMHgxMDsgaSA8PSAweDFGOyArK2kpIHtcclxuICAgICAgICAgICAgYXJyYXlNYXBbaV0gPSA0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChpID0gMHgyMDsgaSA8PSAweDNGOyArK2kpIHtcclxuICAgICAgICAgICAgYXJyYXlNYXBbaV0gPSAzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBmb3IgKGkgPSAweDQwOyBpIDw9IDB4N0Y7ICsraSkge1xyXG4gICAgICAgICAgICBhcnJheU1hcFtpXSA9IDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAoaSA9IDB4ODA7IGkgPD0gMHhGRjsgKytpKSB7XHJcbiAgICAgICAgICAgIGFycmF5TWFwW2ldID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQXZvaWQgdHdvJ3MgY29tcGxlbWVudCBwcm9ibGVtc1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPD0gMHhGRjsgKytpKSB7XHJcbiAgICAgICAgICAgIGFycmF5TWFwW2kgLSAweDEwMF0gPSBhcnJheU1hcFtpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGFycmF5TWFwO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gSnBpcEJpdHN0cmVhbVJlYWRlcjtcclxufSkoKTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgakdsb2JhbHMgPSByZXF1aXJlKCdqMmstanBpcC1nbG9iYWxzLmpzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5KcGlwQ29kZWJsb2NrTGVuZ3RoUGFyc2VyID0gKGZ1bmN0aW9uIEpwaXBDb2RlYmxvY2tMZW5ndGhQYXJzZXJDbG9zdXJlKCkge1xyXG4gICAgLy8gQi4xMC43LlxyXG4gICAgXHJcbiAgICB2YXIgZXhhY3RMb2cyVGFibGUgPSBjcmVhdGVFeGFjdExvZzJUYWJsZSgpO1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBKcGlwQ29kZWJsb2NrTGVuZ3RoUGFyc2VyKGJpdHN0cmVhbVJlYWRlciwgdHJhbnNhY3Rpb25IZWxwZXIpIHtcclxuICAgICAgICB2YXIgbEJsb2NrID0gdHJhbnNhY3Rpb25IZWxwZXIuY3JlYXRlVHJhbnNhY3Rpb25hbE9iamVjdCh7XHJcbiAgICAgICAgICAgIGxCbG9ja1ZhbHVlOiAzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShjb2RpbmdQYXNzZXMpIHtcclxuICAgICAgICAgICAgdmFyIGFkZFRvTEJsb2NrID0gYml0c3RyZWFtUmVhZGVyLmNvdW50T25lc0FuZFNoaWZ0VW50aWxGaXJzdFplcm9CaXQoKTtcclxuICAgICAgICAgICAgaWYgKGFkZFRvTEJsb2NrID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGxCbG9ja1N0YXRlID0gbEJsb2NrLmdldFZhbHVlKGJpdHN0cmVhbVJlYWRlci5hY3RpdmVUcmFuc2FjdGlvbik7XHJcbiAgICAgICAgICAgIGxCbG9ja1N0YXRlLmxCbG9ja1ZhbHVlICs9IGFkZFRvTEJsb2NrO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGNvZGluZ1Bhc3Nlc0xvZzIgPSBleGFjdExvZzJUYWJsZVtjb2RpbmdQYXNzZXNdO1xyXG4gICAgICAgICAgICBpZiAoY29kaW5nUGFzc2VzTG9nMiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAnVW5leHBlY3RlZCB2YWx1ZSBvZiBjb2RpbmcgcGFzc2VzICcgKyBjb2RpbmdQYXNzZXMgK1xyXG4gICAgICAgICAgICAgICAgICAgICcuIEV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXIgPD0gMTY0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBiaXRzQ291bnQgPSBsQmxvY2tTdGF0ZS5sQmxvY2tWYWx1ZSArIGNvZGluZ1Bhc3Nlc0xvZzI7XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBiaXRzdHJlYW1SZWFkZXIuc2hpZnRCaXRzKGJpdHNDb3VudCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV4YWN0TG9nMlRhYmxlKCkge1xyXG4gICAgICAgIHZhciBtYXhDb2RpbmdQYXNzZXNQb3NzaWJsZSA9IDE2NDtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KG1heENvZGluZ1Bhc3Nlc1Bvc3NpYmxlKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgaW5wdXRWYWx1ZUxvd2VyQm91bmQgPSAxO1xyXG4gICAgICAgIHZhciBpbnB1dFZhbHVlVXBwZXJCb3VuZCA9IDI7XHJcbiAgICAgICAgdmFyIGxvZzJSZXN1bHQgPSAwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHdoaWxlIChpbnB1dFZhbHVlTG93ZXJCb3VuZCA8PSBtYXhDb2RpbmdQYXNzZXNQb3NzaWJsZSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gaW5wdXRWYWx1ZUxvd2VyQm91bmQ7IGkgPCBpbnB1dFZhbHVlVXBwZXJCb3VuZDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBsb2cyUmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpbnB1dFZhbHVlTG93ZXJCb3VuZCAqPSAyO1xyXG4gICAgICAgICAgICBpbnB1dFZhbHVlVXBwZXJCb3VuZCAqPSAyO1xyXG4gICAgICAgICAgICArK2xvZzJSZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBKcGlwQ29kZWJsb2NrTGVuZ3RoUGFyc2VyO1xyXG59KSgpOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzLkpwaXBDb2RpbmdQYXNzZXNOdW1iZXJQYXJzZXIgPSAoZnVuY3Rpb24gSnBpcENvZGluZ1Bhc3Nlc051bWJlclBhcnNlckNsb3N1cmUoKSB7XHJcbiAgICAvLyBUYWJsZSBCLjQgaW4gcGFydCAxIG9mIHRoZSBKcGVnMjAwMCBzdGFuZGFyZCBzaG93cyA3IGNhc2VzXHJcbiAgICAvLyBvZiB2YWx1ZXMuIFRoZSBhbGdvcml0aG0gc2hvd24gaGVyZSBzZXBhcmF0ZXMgdGhvc2UgY2FzZXNcclxuICAgIC8vIGludG8gMTYgY2FzZXMsIGRlcGVuZHMgb24gdGhlIG51bWJlciBvZiBvbmVzIGluIHRoZSBwcmVmaXhcclxuICAgIC8vIG9mIHRoZSBjb2RlZCBudW1iZXIgdW50aWwgdGhlIGZpcnN0IHplcm8uXHJcbiAgICAvLyBUaGUgcGFyc2luZyBpcyBkb25lIGluIHR3byBzdGFnZXM6IGZpcnN0IHdlIGNvdW50IHRoZSBvbmVzIHVudGlsXHJcbiAgICAvLyB0aGUgZmlyc3QgemVybywgbGF0ZXIgd2UgcGFyc2UgdGhlIG90aGVyIGJpdHMuXHJcbiAgICBcclxuICAgIC8vIEZvciBleGFtcGxlLCB0aGUgY2FzZSBvZiAxMTAxICh3aGljaCByZXByZXNlbnRzIDQgYWNjb3JkaW5nIHRvXHJcbiAgICAvLyB0YWJsZSBCLjQpIGlzIHBhcnNlZCBpbiB0d28gc3RhZ2VzLiBGaXJzdCB3ZSBjb3VudCB0aGUgb25lcyBpblxyXG4gICAgLy8gdGhlIGJlZ2lubmluZyB1bnRpbCB0aGUgZmlyc3QgemVybywgdGhlIHJlc3VsdCBpcyAyICgnMTEwJykuIFRoZW4gd2VcclxuICAgIC8vIHBhcnNlIHRoZSBvdGhlciBiaXRzICgnMScpLlxyXG4gICAgXHJcbiAgICAvLyBBZnRlciB0aGUgZmlyc3QgcGFyc2luZyBzdGFnZSAoY291bnQgb2Ygb25lcyksIHdlIGtub3cgdHdvIHRoaW5nczpcclxuICAgIC8vIC0gSG93IG1hbnkgYml0cyB3ZSBuZWVkIHRvIHRha2UgYWZ0ZXIgdGhlIGZpcnN0IHplcm8gKHNpbmdsZSBiaXQgaW5cclxuICAgIC8vICAgdGhlIGFib3ZlIGNhc2Ugb2YgJzExMCcgcHJlZml4KS5cclxuICAgIC8vIC0gSG93IG11Y2ggd2UgbmVlZCB0byBhZGQgdG8gdGhlIHJlc3VsdCBvZiBwYXJzaW5nIHRoZSBvdGhlciBiaXRzICgzXHJcbiAgICAvLyAgICAgaW4gdGhlIGFib3ZlIGNhc2Ugb2YgJzExMCcgcHJlZml4KS5cclxuICAgIFxyXG4gICAgLy8gQWN0dWFsbHkgdGhlIDE2IGNhc2VzIHdlcmUgZXh0cmFjdGVkIGZyb20gdGhlIHRhYmxlIHdpdGhvdXQgYW55IGZvcm11bGEsXHJcbiAgICAvLyBzbyB3ZSBjYW4gcmVmZXIgdGhlIG51bWJlciBvZiBvbmVzIGFzICdrZXl3b3Jkcycgb25seS5cclxuXHJcbiAgICB2YXIgYml0c05lZWRlZEFmdGVyQ291bnRPZk9uZXMgPSBjcmVhdGVCaXRzTmVlZGVkQWZ0ZXJDb3VudE9mT25lc01hcCgpO1xyXG4gICAgdmFyIGFkZFRvUmVzdWx0QWZ0ZXJDb3VudE9mT25lcyA9IGNyZWF0ZUFkZFRvUmVzdWx0QWZ0ZXJDb3VudE9mT25lc01hcCgpO1xyXG5cclxuICAgIHZhciBqcGlwQ29kaW5nUGFzc2VzTnVtYmVyUGFyc2VyID0ge1xyXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShiaXRzdHJlYW1SZWFkZXIpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBvbmVzQ291bnQgPSBiaXRzdHJlYW1SZWFkZXIuY291bnRPbmVzQW5kU2hpZnRVbnRpbEZpcnN0WmVyb0JpdChcclxuICAgICAgICAgICAgICAgIC8qbWF4Qml0c1RvU2hpZnQ9Ki8xNik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAob25lc0NvdW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIG1vcmVCaXRzTmVlZGVkID0gYml0c05lZWRlZEFmdGVyQ291bnRPZk9uZXNbb25lc0NvdW50XTtcclxuICAgICAgICAgICAgdmFyIG1vcmVCaXRzID0gYml0c3RyZWFtUmVhZGVyLnNoaWZ0Qml0cyhtb3JlQml0c05lZWRlZCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAobW9yZUJpdHMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgYWRkVG9SZXN1bHQgPSBhZGRUb1Jlc3VsdEFmdGVyQ291bnRPZk9uZXNbb25lc0NvdW50XTtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1vcmVCaXRzICsgYWRkVG9SZXN1bHQ7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUJpdHNOZWVkZWRBZnRlckNvdW50T2ZPbmVzTWFwKCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoMTcpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFRoZSBjYXNlIG9mICcwJzogQWZ0ZXIgMCBvbmVzIGFuZCBzaW5nbGUgemVybywgbmVlZHMgbm8gbW9yZSBiaXRzXHJcbiAgICAgICAgcmVzdWx0WzBdID0gMDtcclxuXHJcbiAgICAgICAgLy8gVGhlIGNhc2Ugb2YgJzEwJzogQWZ0ZXIgMSBvbmVzIGFuZCBzaW5nbGUgemVybywgbmVlZHMgbm8gbW9yZSBiaXRzXHJcbiAgICAgICAgcmVzdWx0WzFdID0gMDtcclxuICAgICAgICBcclxuICAgICAgICAvLyBUaGUgY2FzZXMgb2YgJzExMHgnOiBBZnRlciAyIG9uZXMgYW5kIHNpbmdsZSB6ZXJvLCBuZWVkcyBhbm90aGVyIGJpdFxyXG4gICAgICAgIHJlc3VsdFsyXSA9IDE7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVGhlIGNhc2Ugb2YgJzExMTAnOiBBZnRlciAzIG9uZXMgYW5kIHNpbmdsZSB6ZXJvLCBuZWVkcyBubyBtb3JlIGJpdHNcclxuICAgICAgICByZXN1bHRbM10gPSAwO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFRoZSBjYXNlcyBvZiAnMTExMSAwMDAwIDAnIHRvICcxMTExIDExMTEgMCc6XHJcbiAgICAgICAgLy8gQWZ0ZXIgNCB0byA4IG9uZXMgYW5kIHNpbmdsZSB6ZXJvLCBuZWVkcyBiaXRzIHRvIGNvbXBsZXRlIHRvIDkgYml0c1xyXG4gICAgICAgIHJlc3VsdFs0XSA9IDQ7XHJcbiAgICAgICAgcmVzdWx0WzVdID0gMztcclxuICAgICAgICByZXN1bHRbNl0gPSAyO1xyXG4gICAgICAgIHJlc3VsdFs3XSA9IDE7XHJcbiAgICAgICAgcmVzdWx0WzhdID0gMDtcclxuICAgICAgICBcclxuICAgICAgICAvLyBUaGUgY2FzZXMgb2YgJzExMTEgMTExMTEgLi4uJ1xyXG4gICAgICAgIC8vIEFmdGVyIGF0IGxlYXN0IDkgb25lcyBhbmQgc2luZ2xlIHplcm8sIG5lZWRzIGJpdHMgdG8gY29tcGxldGUgdG8gMTYgYml0c1xyXG4gICAgICAgIHJlc3VsdFs5XSA9IDY7XHJcbiAgICAgICAgcmVzdWx0WzEwXSA9IDU7XHJcbiAgICAgICAgcmVzdWx0WzExXSA9IDQ7XHJcbiAgICAgICAgcmVzdWx0WzEyXSA9IDM7XHJcbiAgICAgICAgcmVzdWx0WzEzXSA9IDI7XHJcbiAgICAgICAgcmVzdWx0WzE0XSA9IDE7XHJcbiAgICAgICAgcmVzdWx0WzE1XSA9IDA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVGhlIGNhc2Ugb2YgJzExMTEgMTExMTEgMTExMSAxMTEnXHJcbiAgICAgICAgcmVzdWx0WzE2XSA9IDA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gY3JlYXRlQWRkVG9SZXN1bHRBZnRlckNvdW50T2ZPbmVzTWFwKCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoMTcpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFRoZSBjYXNlIG9mICcwJyAoY29kZXdvcmQgZm9yIDEpOlxyXG4gICAgICAgIC8vIEFmdGVyIDAgb25lcyBhbmQgc2luZ2xlIHplcm8sIGFkZCAxIHRvIG90aGVyIDAgYml0cyB2YWx1ZVxyXG4gICAgICAgIHJlc3VsdFswXSA9IDE7XHJcblxyXG4gICAgICAgIC8vIFRoZSBjYXNlIG9mICcxMCcgKGNvZGV3b3JkIGZvciAyKTpcclxuICAgICAgICAvLyBBZnRlciAxIG9uZXMgYW5kIHNpbmdsZSB6ZXJvLCBhZGQgMiB0byBvdGhlciAwIGJpdHMgdmFsdWVcclxuICAgICAgICByZXN1bHRbMV0gPSAyO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFRoZSBjYXNlcyBvZiAnMTEweCcgKGNvZGV3b3JkcyBmb3IgMyBhbmQgNCk6XHJcbiAgICAgICAgLy8gQWZ0ZXIgMiBvbmVzIGFuZCBzaW5nbGUgemVybywgYWRkIDMgdG8gb3RoZXIgc2luZ2xlIGJpdCB2YWx1ZVxyXG4gICAgICAgIHJlc3VsdFsyXSA9IDM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVGhlIGNhc2Ugb2YgJzExMTAnIChjb2Rld29yZCBmb3IgNSk6XHJcbiAgICAgICAgLy8gQWZ0ZXIgMyBvbmVzIGFuZCBzaW5nbGUgemVybywgYWRkIDUgdG8gb3RoZXIgMCBiaXRzIHZhbHVlXHJcbiAgICAgICAgcmVzdWx0WzNdID0gNTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBUaGUgY2FzZXMgb2YgJzExMTEgMDAwMCAwJyB0byAnMTExMSAxMTExIDAnIChjb2Rld29yZHMgZm9yIDYgdG8gMzYpOlxyXG4gICAgICAgIC8vIEFmdGVyIDQgb25lcyBhbmQgc2luZ2xlIHplcm8sIGFkZCA2IHRvIG90aGVyIDAvMS8yLzMvNCBiaXRzIHZhbHVlXHJcbiAgICAgICAgcmVzdWx0WzRdID0gNiArIDB4MDA7IC8vIGIwMDAwMFxyXG4gICAgICAgIHJlc3VsdFs1XSA9IDYgKyAweDEwOyAvLyBiMTAwMDBcclxuICAgICAgICByZXN1bHRbNl0gPSA2ICsgMHgxODsgLy8gYjExMDAwXHJcbiAgICAgICAgcmVzdWx0WzddID0gNiArIDB4MUM7IC8vIGIxMTEwMFxyXG4gICAgICAgIHJlc3VsdFs4XSA9IDYgKyAweDFFOyAvLyBiMTExMTBcclxuICAgICAgICBcclxuICAgICAgICAvLyBUaGUgY2FzZXMgb2YgJzExMTEgMTExMTEgLi4uJyAoY29kZXdvcmRzIGZvciAzNyB0byAxNjQpOlxyXG4gICAgICAgIC8vIEFmdGVyIDkgb25lcyBhbmQgc2luZ2xlIHplcm8sIGFkZCAzNyB0byBvdGhlciAwLzEvMi8zLzQvNS82IGJpdHMgdmFsdWVcclxuICAgICAgICByZXN1bHRbIDldID0gMzcgKyAweDAwOyAvLyBiMDAwMDAwXHJcbiAgICAgICAgcmVzdWx0WzEwXSA9IDM3ICsgMHg0MDsgLy8gYjEwMDAwMFxyXG4gICAgICAgIHJlc3VsdFsxMV0gPSAzNyArIDB4NjA7IC8vIGIxMTAwMDBcclxuICAgICAgICByZXN1bHRbMTJdID0gMzcgKyAweDcwOyAvLyBiMTExMDAwXHJcbiAgICAgICAgcmVzdWx0WzEzXSA9IDM3ICsgMHg3ODsgLy8gYjExMTEwMFxyXG4gICAgICAgIHJlc3VsdFsxNF0gPSAzNyArIDB4N0M7IC8vIGIxMTExMTBcclxuICAgICAgICByZXN1bHRbMTVdID0gMzcgKyAweDdFOyAvLyBiMTExMTExXHJcbiAgICAgICAgcmVzdWx0WzE2XSA9IDM3ICsgMHg3RjsgLy8gYjExMTExMVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBqcGlwQ29kaW5nUGFzc2VzTnVtYmVyUGFyc2VyO1xyXG59KSgpOyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBqR2xvYmFscyA9IHJlcXVpcmUoJ2oyay1qcGlwLWdsb2JhbHMuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLkpwaXBQYWNrZXRMZW5ndGhDYWxjdWxhdG9yID0gZnVuY3Rpb24gSnBpcFBhY2tldExlbmd0aENhbGN1bGF0b3IoXHJcbiAgICB0aWxlU3RydWN0dXJlLFxyXG4gICAgY29tcG9uZW50U3RydWN0dXJlLFxyXG4gICAgZGF0YWJpbixcclxuICAgIHN0YXJ0T2Zmc2V0SW5EYXRhYmluLFxyXG4gICAgcHJlY2luY3QsXHJcbiAgICBqcGlwRmFjdG9yeSkge1xyXG4gICAgXHJcbiAgICB2YXIgY2FsY3VsYXRlZExlbmd0aHMgPSBbXTtcclxuICAgIFxyXG4gICAgdmFyIGJpdHN0cmVhbVJlYWRlciA9IGpwaXBGYWN0b3J5LmNyZWF0ZUJpdHN0cmVhbVJlYWRlcihkYXRhYmluKTtcclxuICAgIFxyXG4gICAgdmFyIG51bUNvZGVibG9ja3NYID1cclxuICAgICAgICBjb21wb25lbnRTdHJ1Y3R1cmUuZ2V0TnVtQ29kZWJsb2Nrc1hJblByZWNpbmN0KHByZWNpbmN0KTtcclxuICAgIHZhciBudW1Db2RlYmxvY2tzWSA9XHJcbiAgICAgICAgY29tcG9uZW50U3RydWN0dXJlLmdldE51bUNvZGVibG9ja3NZSW5QcmVjaW5jdChwcmVjaW5jdCk7XHJcbiAgICAgICAgXHJcbiAgICB2YXIgbnVtUXVhbGl0eUxheWVyc0luVGlsZSA9IHRpbGVTdHJ1Y3R1cmUuZ2V0TnVtUXVhbGl0eUxheWVycygpO1xyXG4gICAgdmFyIGlzUGFja2V0SGVhZGVyTmVhckRhdGEgPSB0aWxlU3RydWN0dXJlLmdldElzUGFja2V0SGVhZGVyTmVhckRhdGEoKTtcclxuICAgIHZhciBpc1N0YXJ0T2ZQYWNrZXRNYXJrZXJBbGxvd2VkID0gdGlsZVN0cnVjdHVyZS5nZXRJc1N0YXJ0T2ZQYWNrZXRNYXJrZXJBbGxvd2VkKCk7XHJcbiAgICB2YXIgaXNFbmRQYWNrZXRIZWFkZXJNYXJrZXJBbGxvd2VkID1cclxuICAgICAgICB0aWxlU3RydWN0dXJlLmdldElzRW5kUGFja2V0SGVhZGVyTWFya2VyQWxsb3dlZCgpO1xyXG4gICAgXHJcbiAgICB2YXIgc3ViYmFuZFBhcnNlcnMgPSBpbml0U3ViYmFuZFBhcnNlcnMoKTtcclxuICAgIFxyXG4gICAgdGhpcy5jYWxjdWxhdGVFbmRPZmZzZXRPZkxhc3RGdWxsUGFja2V0ID1cclxuICAgICAgICBmdW5jdGlvbiBjYWxjdWxhdGVGdWxsUGFja2V0c0F2YWlsYWJsZU9mZnNldHMobWF4TnVtUXVhbGl0eUxheWVycykge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBpc0FsbG93ZWRGdWxsUXVhbGl0eSA9XHJcbiAgICAgICAgICAgIG1heE51bVF1YWxpdHlMYXllcnMgPT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICBtYXhOdW1RdWFsaXR5TGF5ZXJzID49IG51bVF1YWxpdHlMYXllcnNJblRpbGU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIG51bVF1YWxpdHlMYXllcnNUb1BhcnNlO1xyXG4gICAgICAgIGlmICghaXNBbGxvd2VkRnVsbFF1YWxpdHkpIHtcclxuICAgICAgICAgICAgbnVtUXVhbGl0eUxheWVyc1RvUGFyc2UgPSBtYXhOdW1RdWFsaXR5TGF5ZXJzO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIWRhdGFiaW4uaXNBbGxEYXRhYmluTG9hZGVkKCkpIHtcclxuICAgICAgICAgICAgbnVtUXVhbGl0eUxheWVyc1RvUGFyc2UgPSBudW1RdWFsaXR5TGF5ZXJzSW5UaWxlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBlbmRPZmZzZXQgPSBkYXRhYmluLmdldERhdGFiaW5MZW5ndGhJZktub3duKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZW5kT2Zmc2V0OiBlbmRPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBudW1RdWFsaXR5TGF5ZXJzOiBudW1RdWFsaXR5TGF5ZXJzSW5UaWxlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBjaGVja1N1cHBvcnRlZFN0cnVjdHVyZSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRyeVZhbGlkYXRlUGFja2V0cyhudW1RdWFsaXR5TGF5ZXJzVG9QYXJzZSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGdldEZ1bGxRdWFsaXR5TGF5ZXJzRW5kT2Zmc2V0KG51bVF1YWxpdHlMYXllcnNUb1BhcnNlKTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRQYWNrZXRPZmZzZXRzQnlDb2RlYmxvY2tJbmRleCA9IGZ1bmN0aW9uIGdldFBhY2tldE9mZnNldHNCeUNvZGVibG9ja0luZGV4KFxyXG4gICAgICAgIHF1YWxpdHlMYXllcikge1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNoZWNrU3VwcG9ydGVkU3RydWN0dXJlKCk7XHJcbiAgICAgICAgdHJ5VmFsaWRhdGVQYWNrZXRzKHF1YWxpdHlMYXllciArIDEpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChjYWxjdWxhdGVkTGVuZ3Rocy5sZW5ndGggPD0gcXVhbGl0eUxheWVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gY2FsY3VsYXRlZExlbmd0aHNbcXVhbGl0eUxheWVyXTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHRyeVZhbGlkYXRlUGFja2V0cyhxdWFsaXR5TGF5ZXJzKSB7XHJcbiAgICAgICAgd2hpbGUgKGNhbGN1bGF0ZWRMZW5ndGhzLmxlbmd0aCA8IHF1YWxpdHlMYXllcnMpIHtcclxuICAgICAgICAgICAgYml0c3RyZWFtUmVhZGVyLnN0YXJ0TmV3VHJhbnNhY3Rpb24oKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBuZXh0UGFja2V0ID0gdHJ5Q2FsY3VsYXRlTmV4dFBhY2tldExlbmd0aChcclxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRMZW5ndGhzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAobmV4dFBhY2tldCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgYml0c3RyZWFtUmVhZGVyLmFjdGl2ZVRyYW5zYWN0aW9uLmFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhbGN1bGF0ZWRMZW5ndGhzLnB1c2gobmV4dFBhY2tldCk7XHJcbiAgICAgICAgICAgIGJpdHN0cmVhbVJlYWRlci5hY3RpdmVUcmFuc2FjdGlvbi5jb21taXQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIHRyeUNhbGN1bGF0ZU5leHRQYWNrZXRMZW5ndGgocXVhbGl0eUxheWVyKSB7XHJcbiAgICAgICAgdmFyIGhlYWRlclN0YXJ0T2Zmc2V0O1xyXG4gICAgICAgIGlmIChxdWFsaXR5TGF5ZXIgPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBsYXN0ID0gY2FsY3VsYXRlZExlbmd0aHNbcXVhbGl0eUxheWVyIC0gMV07XHJcbiAgICAgICAgICAgIGhlYWRlclN0YXJ0T2Zmc2V0ID1cclxuICAgICAgICAgICAgICAgIGxhc3QuaGVhZGVyU3RhcnRPZmZzZXQgK1xyXG4gICAgICAgICAgICAgICAgbGFzdC5oZWFkZXJMZW5ndGggK1xyXG4gICAgICAgICAgICAgICAgbGFzdC5vdmVyYWxsQm9keUxlbmd0aEJ5dGVzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGhlYWRlclN0YXJ0T2Zmc2V0ID0gc3RhcnRPZmZzZXRJbkRhdGFiaW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICBiaXRzdHJlYW1SZWFkZXIuZGF0YWJpbk9mZnNldCA9IGhlYWRlclN0YXJ0T2Zmc2V0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChpc1BhY2tldEhlYWRlck5lYXJEYXRhICYmIGlzU3RhcnRPZlBhY2tldE1hcmtlckFsbG93ZWQpIHtcclxuICAgICAgICAgICAgdmFyIGlzTWFya2VyID0gaXNNYXJrZXJIZXJlKDB4OTEpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGlzTWFya2VyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc01hcmtlcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0T2ZQYWNrZXRTZWdtZW50TGVuZ3RoID0gNjtcclxuICAgICAgICAgICAgICAgIGJpdHN0cmVhbVJlYWRlci5kYXRhYmluT2Zmc2V0ICs9IHN0YXJ0T2ZQYWNrZXRTZWdtZW50TGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBpc1BhY2tldEV4aXN0SW5RdWFsaXR5TGF5ZXIgPSBiaXRzdHJlYW1SZWFkZXIuc2hpZnRCaXQoKTtcclxuICAgICAgICBpZiAoaXNQYWNrZXRFeGlzdEluUXVhbGl0eUxheWVyID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZiAoIWlzUGFja2V0RXhpc3RJblF1YWxpdHlMYXllcikge1xyXG4gICAgICAgICAgICBiaXRzdHJlYW1SZWFkZXIuc2hpZnRSZW1haW5pbmdCaXRzSW5CeXRlKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBoZWFkZXJTdGFydE9mZnNldDogaGVhZGVyU3RhcnRPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBoZWFkZXJMZW5ndGg6IDEsXHJcbiAgICAgICAgICAgICAgICBjb2RlYmxvY2tCb2R5TGVuZ3RoQnlJbmRleDogW10sXHJcbiAgICAgICAgICAgICAgICBvdmVyYWxsQm9keUxlbmd0aEJ5dGVzOiAwXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgYm9keUxlbmd0aCA9IGFjdHVhbENhbGN1bGF0ZVBhY2tldExlbmd0aEFmdGVyWmVyb0xlbmd0aEJpdChcclxuICAgICAgICAgICAgcXVhbGl0eUxheWVyKTtcclxuICAgICAgICBpZiAoYm9keUxlbmd0aCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGhlYWRlckVuZE9mZnNldCA9IGJpdHN0cmVhbVJlYWRlci5kYXRhYmluT2Zmc2V0O1xyXG4gICAgICAgIGJvZHlMZW5ndGguaGVhZGVyTGVuZ3RoID0gaGVhZGVyRW5kT2Zmc2V0IC0gaGVhZGVyU3RhcnRPZmZzZXQ7XHJcblxyXG4gICAgICAgIGJvZHlMZW5ndGguaGVhZGVyU3RhcnRPZmZzZXQgPSBoZWFkZXJTdGFydE9mZnNldDtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gYm9keUxlbmd0aDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gYWN0dWFsQ2FsY3VsYXRlUGFja2V0TGVuZ3RoQWZ0ZXJaZXJvTGVuZ3RoQml0KHF1YWxpdHlMYXllcikge1xyXG4gICAgICAgIHZhciBib2R5Qnl0ZXMgPSAwO1xyXG4gICAgICAgIHZhciBjb2RlYmxvY2tCb2R5TGVuZ3RoQnlJbmRleCA9IG51bGw7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yICh2YXIgc3ViYmFuZCA9IDA7IHN1YmJhbmQgPCBzdWJiYW5kUGFyc2Vycy5sZW5ndGg7ICsrc3ViYmFuZCkge1xyXG4gICAgICAgICAgICB2YXIgcGFyc2VyID0gc3ViYmFuZFBhcnNlcnNbc3ViYmFuZF07XHJcbiAgICAgICAgICAgIHZhciBzdWJiYW5kQm9keUxlbmd0aCA9IHBhcnNlci5jYWxjdWxhdGVTdWJiYW5kTGVuZ3RoKHF1YWxpdHlMYXllcik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoc3ViYmFuZEJvZHlMZW5ndGggPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoY29kZWJsb2NrQm9keUxlbmd0aEJ5SW5kZXggPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvZGVibG9ja0JvZHlMZW5ndGhCeUluZGV4ID1cclxuICAgICAgICAgICAgICAgICAgICBzdWJiYW5kQm9keUxlbmd0aC5jb2RlYmxvY2tCb2R5TGVuZ3RoQnlJbmRleDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvZGVibG9ja0JvZHlMZW5ndGhCeUluZGV4ID0gY29kZWJsb2NrQm9keUxlbmd0aEJ5SW5kZXguY29uY2F0KFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YmJhbmRCb2R5TGVuZ3RoLmNvZGVibG9ja0JvZHlMZW5ndGhCeUluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgYm9keUJ5dGVzICs9IHN1YmJhbmRCb2R5TGVuZ3RoLm92ZXJhbGxCb2R5TGVuZ3RoQnl0ZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBiaXRzdHJlYW1SZWFkZXIuc2hpZnRSZW1haW5pbmdCaXRzSW5CeXRlKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGlzRW5kUGFja2V0SGVhZGVyTWFya2VyQWxsb3dlZCkge1xyXG4gICAgICAgICAgICB2YXIgaXNNYXJrZXIgPSBpc01hcmtlckhlcmUoMHg5Mik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoaXNNYXJrZXIgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTWFya2VyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZW5kUGFja2V0SGVhZGVyTWFya2VyTGVuZ3RoID0gMjtcclxuICAgICAgICAgICAgICAgIGJpdHN0cmVhbVJlYWRlci5kYXRhYmluT2Zmc2V0ICs9IGVuZFBhY2tldEhlYWRlck1hcmtlckxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb2RlYmxvY2tCb2R5TGVuZ3RoQnlJbmRleDogY29kZWJsb2NrQm9keUxlbmd0aEJ5SW5kZXgsXHJcbiAgICAgICAgICAgIG92ZXJhbGxCb2R5TGVuZ3RoQnl0ZXM6IGJvZHlCeXRlc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBnZXRGdWxsUXVhbGl0eUxheWVyc0VuZE9mZnNldChtYXhOdW1RdWFsaXR5TGF5ZXJzKSB7XHJcbiAgICAgICAgdmFyIG51bVBhcnNlZFF1YWxpdHlMYXllciA9IE1hdGgubWluKFxyXG4gICAgICAgICAgICBtYXhOdW1RdWFsaXR5TGF5ZXJzLCBjYWxjdWxhdGVkTGVuZ3Rocy5sZW5ndGgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChudW1QYXJzZWRRdWFsaXR5TGF5ZXIgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGVuZE9mZnNldDogc3RhcnRPZmZzZXRJbkRhdGFiaW4sXHJcbiAgICAgICAgICAgICAgICBudW1RdWFsaXR5TGF5ZXJzOiAwXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgbGFzdFBhY2tldCA9IGNhbGN1bGF0ZWRMZW5ndGhzW251bVBhcnNlZFF1YWxpdHlMYXllciAtIDFdO1xyXG4gICAgICAgIHZhciBlbmRPZmZzZXQgPVxyXG4gICAgICAgICAgICBsYXN0UGFja2V0LmhlYWRlclN0YXJ0T2Zmc2V0ICtcclxuICAgICAgICAgICAgbGFzdFBhY2tldC5oZWFkZXJMZW5ndGggK1xyXG4gICAgICAgICAgICBsYXN0UGFja2V0Lm92ZXJhbGxCb2R5TGVuZ3RoQnl0ZXM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgZW5kT2Zmc2V0OiBlbmRPZmZzZXQsXHJcbiAgICAgICAgICAgIG51bVF1YWxpdHlMYXllcnM6IG51bVBhcnNlZFF1YWxpdHlMYXllclxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGluaXRTdWJiYW5kUGFyc2VycygpIHtcclxuICAgICAgICB2YXIgbnVtU3ViYmFuZHMgPSBwcmVjaW5jdC5yZXNvbHV0aW9uTGV2ZWwgPT09IDAgPyAxIDogMztcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TdWJiYW5kczsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBudW1Db2RlYmxvY2tzWEluU3ViYmFuZDtcclxuICAgICAgICAgICAgdmFyIG51bUNvZGVibG9ja3NZSW5TdWJiYW5kO1xyXG4gICAgICAgICAgICBpZiAocHJlY2luY3QucmVzb2x1dGlvbkxldmVsID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBudW1Db2RlYmxvY2tzWEluU3ViYmFuZCA9IG51bUNvZGVibG9ja3NYO1xyXG4gICAgICAgICAgICAgICAgbnVtQ29kZWJsb2Nrc1lJblN1YmJhbmQgPSBudW1Db2RlYmxvY2tzWTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRyZWF0IHRoZSBlZGdlIGNhc2Ugb2Ygc2luZ2xlIHJlZHVuZGFudCBwaXhlbHMgY29sdW1uXHJcbiAgICAgICAgICAgICAgICAvLyAoSW4gb3RoZXIgY2FzZXMsIG51bUNvZGVibG9ja3NYIGlzIGZ1bGwgZHVwbGljYXRpb24gb2YgMi5cclxuICAgICAgICAgICAgICAgIC8vIFNlZSBKcGlwQ29tcG9uZW50U3RydWN0dXJlIGltcGxlbWVudGF0aW9uKS5cclxuICAgICAgICAgICAgICAgIGlmIChpID09PSAxKSB7IC8vIExIXHJcbiAgICAgICAgICAgICAgICAgICAgbnVtQ29kZWJsb2Nrc1hJblN1YmJhbmQgPSBNYXRoLmNlaWwobnVtQ29kZWJsb2Nrc1ggLyAyKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIEhMIG9yIEhIXHJcbiAgICAgICAgICAgICAgICAgICAgbnVtQ29kZWJsb2Nrc1hJblN1YmJhbmQgPSBNYXRoLmZsb29yKG51bUNvZGVibG9ja3NYIC8gMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIC8vIFRyZWF0IHRoZSBlZGdlIGNhc2Ugb2Ygc2luZ2xlIHJlZHVuZGFudCBwaXhlbHMgcm93XHJcbiAgICAgICAgICAgICAgICAvLyAoSW4gb3RoZXIgY2FzZXMsIG51bUNvZGVibG9ja3NZIGlzIGZ1bGwgZHVwbGljYXRpb24gb2YgMi5cclxuICAgICAgICAgICAgICAgIC8vIFNlZSBKcGlwQ29tcG9uZW50U3RydWN0dXJlIGltcGxlbWVudGF0aW9uKS5cclxuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7IC8vIEhMXHJcbiAgICAgICAgICAgICAgICAgICAgbnVtQ29kZWJsb2Nrc1lJblN1YmJhbmQgPSBNYXRoLmNlaWwobnVtQ29kZWJsb2Nrc1kgLyAyKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIExIIG9yIEhIXHJcbiAgICAgICAgICAgICAgICAgICAgbnVtQ29kZWJsb2Nrc1lJblN1YmJhbmQgPSBNYXRoLmZsb29yKG51bUNvZGVibG9ja3NZIC8gMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChudW1Db2RlYmxvY2tzWEluU3ViYmFuZCA9PT0gMCB8fCBudW1Db2RlYmxvY2tzWUluU3ViYmFuZCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGpwaXBGYWN0b3J5LmNyZWF0ZVN1YmJhbmRMZW5ndGhJblBhY2tldEhlYWRlckNhbGN1bGF0b3IoXHJcbiAgICAgICAgICAgICAgICBiaXRzdHJlYW1SZWFkZXIsXHJcbiAgICAgICAgICAgICAgICBudW1Db2RlYmxvY2tzWEluU3ViYmFuZCxcclxuICAgICAgICAgICAgICAgIG51bUNvZGVibG9ja3NZSW5TdWJiYW5kKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGlzTWFya2VySGVyZShtYXJrZXJTZWNvbmRCeXRlKSB7XHJcbiAgICAgICAgdmFyIHBvc3NpYmxlTWFya2VyID0gbmV3IEFycmF5KDIpO1xyXG4gICAgICAgIHZhciBieXRlc0NvcGllZCA9IGRhdGFiaW4uY29weUJ5dGVzKFxyXG4gICAgICAgICAgICBwb3NzaWJsZU1hcmtlcixcclxuICAgICAgICAgICAgLypyZXN1bHRTdGFydE9mZnNldD0qLzAsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRhdGFiaW5TdGFydE9mZnNldDogYml0c3RyZWFtUmVhZGVyLmRhdGFiaW5PZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGhUb0NvcHk6IDIsXHJcbiAgICAgICAgICAgICAgICBmb3JjZUNvcHlBbGxSYW5nZTogZmFsc2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgc3dpdGNoIChieXRlc0NvcGllZCkge1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNNYXJrZXIgPVxyXG4gICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlTWFya2VyWzBdID09PSAweEZGICYmXHJcbiAgICAgICAgICAgICAgICAgICAgcG9zc2libGVNYXJrZXJbMV0gPT09IG1hcmtlclNlY29uZEJ5dGU7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc01hcmtlcjtcclxuXHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZU1hcmtlclswXSA9PT0gMHhGRikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBjaGVja1N1cHBvcnRlZFN0cnVjdHVyZSgpIHtcclxuICAgICAgICBpZiAoIWlzUGFja2V0SGVhZGVyTmVhckRhdGEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLlVuc3VwcG9ydGVkRmVhdHVyZUV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICdQUE0gb3IgUFBUJywgJ0EuNy40IGFuZCBBLjcuNScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgakdsb2JhbHMgPSByZXF1aXJlKCdqMmstanBpcC1nbG9iYWxzLmpzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5KcGlwUXVhbGl0eUxheWVyc0NhY2hlID0gZnVuY3Rpb24gSnBpcFF1YWxpdHlMYXllcnNDYWNoZShcclxuICAgIGNvZGVzdHJlYW1TdHJ1Y3R1cmUsIGpwaXBGYWN0b3J5KSB7XHJcbiAgICBcclxuICAgIHZhciBDQUNIRV9LRVkgPSAncGFja2V0TGVuZ3RoQ2FsY3VsYXRvcic7XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0UGFja2V0T2Zmc2V0c0J5Q29kZWJsb2NrSW5kZXggPVxyXG4gICAgICAgIGZ1bmN0aW9uIGdldFBhY2tldE9mZnNldHNCeUNvZGVibG9ja0luZGV4KFxyXG4gICAgICAgICAgICBwcmVjaW5jdERhdGFiaW4sIHF1YWxpdHlMYXllciwgcHJlY2luY3RQb3NpdGlvbikge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBwYWNrZXRMZW5ndGhDYWxjdWxhdG9yID0gZ2V0UGFja2V0UGFyc2VyKFxyXG4gICAgICAgICAgICBwcmVjaW5jdERhdGFiaW4sIHByZWNpbmN0UG9zaXRpb24pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB2YXIgcmVzdWx0ID0gcGFja2V0TGVuZ3RoQ2FsY3VsYXRvci5nZXRQYWNrZXRPZmZzZXRzQnlDb2RlYmxvY2tJbmRleChcclxuICAgICAgICAgICAgcXVhbGl0eUxheWVyKTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5nZXRRdWFsaXR5TGF5ZXJPZmZzZXQgPSBmdW5jdGlvbiBnZXRRdWFsaXR5TGF5ZXJPZmZzZXQoXHJcbiAgICAgICAgcHJlY2luY3REYXRhYmluLCBtYXhOdW1RdWFsaXR5TGF5ZXJzLCBwcmVjaW5jdFBvc2l0aW9uKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGxvYWRlZFJhbmdlcyA9IHByZWNpbmN0RGF0YWJpbi5nZXRFeGlzdGluZ1JhbmdlcygpO1xyXG4gICAgICAgIHZhciBlbmRPZmZzZXRMb2FkZWQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHBhY2tldExlbmd0aENhbGN1bGF0b3IgPSBnZXRQYWNrZXRQYXJzZXIoXHJcbiAgICAgICAgICAgIHByZWNpbmN0RGF0YWJpbiwgcHJlY2luY3RQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIGlmIChsb2FkZWRSYW5nZXMubGVuZ3RoIDwgMSB8fCBsb2FkZWRSYW5nZXNbMF0uc3RhcnQgPiAwKSB7XHJcbiAgICAgICAgICAgIGVuZE9mZnNldExvYWRlZCA9IDA7XHJcbiAgICAgICAgICAgIG1heE51bVF1YWxpdHlMYXllcnMgPSAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVuZE9mZnNldExvYWRlZCA9IGxvYWRlZFJhbmdlc1swXS5zdGFydCArIGxvYWRlZFJhbmdlc1swXS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBsYXllcnNJblByZWNpbmN0ID1cclxuICAgICAgICAgICAgcGFja2V0TGVuZ3RoQ2FsY3VsYXRvci5jYWxjdWxhdGVFbmRPZmZzZXRPZkxhc3RGdWxsUGFja2V0KFxyXG4gICAgICAgICAgICAgICAgbWF4TnVtUXVhbGl0eUxheWVycyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgd2hpbGUgKGVuZE9mZnNldExvYWRlZCA8IGxheWVyc0luUHJlY2luY3QuZW5kT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciByZWR1Y2VkTGF5ZXJzVG9TZWFyY2ggPSBsYXllcnNJblByZWNpbmN0Lm51bVF1YWxpdHlMYXllcnMgLSAxO1xyXG4gICAgICAgICAgICBsYXllcnNJblByZWNpbmN0ID0gcGFja2V0TGVuZ3RoQ2FsY3VsYXRvclxyXG4gICAgICAgICAgICAgICAgLmNhbGN1bGF0ZUVuZE9mZnNldE9mTGFzdEZ1bGxQYWNrZXQocmVkdWNlZExheWVyc1RvU2VhcmNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGxheWVyc0luUHJlY2luY3Q7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldFBhY2tldFBhcnNlcihwcmVjaW5jdERhdGFiaW4sIHByZWNpbmN0UG9zaXRpb24pIHtcclxuICAgICAgICB2YXIgcGFja2V0TGVuZ3RoQ2FsY3VsYXRvckNvbnRhaW5lciA9XHJcbiAgICAgICAgICAgIHByZWNpbmN0RGF0YWJpbi5nZXRDYWNoZWREYXRhKENBQ0hFX0tFWSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHBhY2tldExlbmd0aENhbGN1bGF0b3JDb250YWluZXIuY2FsY3VsYXRvciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYWNrZXRMZW5ndGhDYWxjdWxhdG9yQ29udGFpbmVyLmNhbGN1bGF0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChwcmVjaW5jdFBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24oJ3ByZWNpbmN0UG9zaXRpb24gJyArXHJcbiAgICAgICAgICAgICAgICAnc2hvdWxkIGJlIGdpdmVuIG9uIHRoZSBmaXJzdCB0aW1lIG9mIHVzaW5nIFF1YWxpdHlMYXllcnNDYWNoZSAnICtcclxuICAgICAgICAgICAgICAgICdvbiB0aGlzIHByZWNpbmN0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciB0aWxlU3RydWN0dXJlID0gY29kZXN0cmVhbVN0cnVjdHVyZS5nZXRUaWxlU3RydWN0dXJlKFxyXG4gICAgICAgICAgICBwcmVjaW5jdFBvc2l0aW9uLnRpbGVJbmRleCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGNvbXBvbmVudFN0cnVjdHVyZSA9IHRpbGVTdHJ1Y3R1cmUuZ2V0Q29tcG9uZW50U3RydWN0dXJlKFxyXG4gICAgICAgICAgICBwcmVjaW5jdFBvc2l0aW9uLmNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIHBhY2tldExlbmd0aENhbGN1bGF0b3JDb250YWluZXIuY2FsY3VsYXRvciA9XHJcbiAgICAgICAgICAgIGpwaXBGYWN0b3J5LmNyZWF0ZVBhY2tldExlbmd0aENhbGN1bGF0b3IoXHJcbiAgICAgICAgICAgICAgICB0aWxlU3RydWN0dXJlLFxyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50U3RydWN0dXJlLFxyXG4gICAgICAgICAgICAgICAgcHJlY2luY3REYXRhYmluLFxyXG4gICAgICAgICAgICAgICAgLypzdGFydE9mZnNldEluRGF0YWJpbj0qLzAsXHJcbiAgICAgICAgICAgICAgICBwcmVjaW5jdFBvc2l0aW9uKTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gcGFja2V0TGVuZ3RoQ2FsY3VsYXRvckNvbnRhaW5lci5jYWxjdWxhdG9yO1xyXG4gICAgfVxyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBqR2xvYmFscyA9IHJlcXVpcmUoJ2oyay1qcGlwLWdsb2JhbHMuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLkpwaXBTdWJiYW5kTGVuZ3RoSW5QYWNrZXRIZWFkZXJDYWxjdWxhdG9yID1cclxuICAgIGZ1bmN0aW9uIEpwaXBTdWJiYW5kTGVuZ3RoSW5QYWNrZXRIZWFkZXJDYWxjdWxhdG9yKFxyXG4gICAgICAgIGJpdHN0cmVhbVJlYWRlcixcclxuICAgICAgICBudW1Db2RlYmxvY2tzWCxcclxuICAgICAgICBudW1Db2RlYmxvY2tzWSxcclxuICAgICAgICBjb2RpbmdQYXNzZXNOdW1iZXJQYXJzZXIsXHJcbiAgICAgICAgdHJhbnNhY3Rpb25IZWxwZXIsXHJcbiAgICAgICAganBpcEZhY3RvcnkpIHtcclxuICAgIFxyXG4gICAgdmFyIGNvZGVibG9ja0xlbmd0aFBhcnNlcnMgPSBudWxsO1xyXG4gICAgdmFyIGlzQ29kZWJsb2Nrc0luY2x1ZGVkID0gbnVsbDtcclxuICAgIHZhciBwYXJzZWRRdWFsaXR5TGF5ZXJzID0gdHJhbnNhY3Rpb25IZWxwZXIuY3JlYXRlVHJhbnNhY3Rpb25hbE9iamVjdChcclxuICAgICAgICAwLCAvKmlzVmFsdWVUeXBlPSovdHJ1ZSk7XHJcbiAgICAgICAgXHJcbiAgICB2YXIgaW5jbHVzaW9uVHJlZSA9IGpwaXBGYWN0b3J5LmNyZWF0ZVRhZ1RyZWUoXHJcbiAgICAgICAgYml0c3RyZWFtUmVhZGVyLCBudW1Db2RlYmxvY2tzWCwgbnVtQ29kZWJsb2Nrc1kpO1xyXG4gICAgXHJcbiAgICB2YXIgemVyb0JpdFBsYW5lc1RyZWUgPSBqcGlwRmFjdG9yeS5jcmVhdGVUYWdUcmVlKFxyXG4gICAgICAgIGJpdHN0cmVhbVJlYWRlciwgbnVtQ29kZWJsb2Nrc1gsIG51bUNvZGVibG9ja3NZKTtcclxuICAgIFxyXG4gICAgdGhpcy5jYWxjdWxhdGVTdWJiYW5kTGVuZ3RoID0gZnVuY3Rpb24gY2FsY3VhbHRlU3ViYmFuZExlbmd0aChxdWFsaXR5TGF5ZXIpIHtcclxuICAgICAgICBlbnN1cmVRdWFsaXR5TGF5ZXJOb3RQYXJzZWRZZXQocXVhbGl0eUxheWVyKTtcclxuICAgICAgICBcclxuICAgICAgICBsYXp5SW5pdEFycmF5cygpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGluY2x1c2lvblRyZWUuc2V0TWluaW1hbFZhbHVlSWZOb3RSZWFkQml0cyhxdWFsaXR5TGF5ZXIpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBhY2N1bXVsYXRlZEJvZHlMZW5ndGhCeXRlcyA9IDA7XHJcbiAgICAgICAgdmFyIGNvZGVibG9ja0luZGV4ID0gMDtcclxuICAgICAgICB2YXIgY29kZWJsb2NrTGVuZ3RoQnlJbmRleCA9IG5ldyBBcnJheShudW1Db2RlYmxvY2tzWCAqIG51bUNvZGVibG9ja3NZKTtcclxuICAgICAgICBcclxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IG51bUNvZGVibG9ja3NZOyArK3kpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBudW1Db2RlYmxvY2tzWDsgKyt4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29kZWJsb2NrQm9keUxlbmd0aCA9IGdldE5leHRDb2RlYmxvY2tMZW5ndGgoeCwgeSwgcXVhbGl0eUxheWVyKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb2RlYmxvY2tCb2R5TGVuZ3RoID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGNvZGVibG9ja0xlbmd0aEJ5SW5kZXhbY29kZWJsb2NrSW5kZXgrK10gPSBjb2RlYmxvY2tCb2R5TGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZEJvZHlMZW5ndGhCeXRlcyArPVxyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVibG9ja0JvZHlMZW5ndGguY29kZWJsb2NrQm9keUxlbmd0aEJ5dGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHBhcnNlZFF1YWxpdHlMYXllcnMuc2V0VmFsdWUoXHJcbiAgICAgICAgICAgIGJpdHN0cmVhbVJlYWRlci5hY3RpdmVUcmFuc2FjdGlvbiwgcXVhbGl0eUxheWVyICsgMSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29kZWJsb2NrQm9keUxlbmd0aEJ5SW5kZXg6IGNvZGVibG9ja0xlbmd0aEJ5SW5kZXgsXHJcbiAgICAgICAgICAgIG92ZXJhbGxCb2R5TGVuZ3RoQnl0ZXM6IGFjY3VtdWxhdGVkQm9keUxlbmd0aEJ5dGVzXHJcbiAgICAgICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBlbnN1cmVRdWFsaXR5TGF5ZXJOb3RQYXJzZWRZZXQocXVhbGl0eUxheWVyKSB7XHJcbiAgICAgICAgdmFyIHBhcnNlZFF1YWxpdHlMYXllcnNWYWx1ZSA9IHBhcnNlZFF1YWxpdHlMYXllcnMuZ2V0VmFsdWUoXHJcbiAgICAgICAgICAgIGJpdHN0cmVhbVJlYWRlci5hY3RpdmVUcmFuc2FjdGlvbik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHBhcnNlZFF1YWxpdHlMYXllcnNWYWx1ZSA+PSBxdWFsaXR5TGF5ZXIgKyAxKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbnRlcm5hbEVycm9yRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgJ1VuZXhwZWN0ZWQgcXVhbGl0eSBsYXllciB0byBwYXJzZScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gbGF6eUluaXRBcnJheXMoKSB7XHJcbiAgICAgICAgaWYgKGNvZGVibG9ja0xlbmd0aFBhcnNlcnMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBjb2RlYmxvY2tMZW5ndGhQYXJzZXJzID0gbmV3IEFycmF5KG51bUNvZGVibG9ja3NYKTtcclxuICAgICAgICBpc0NvZGVibG9ja3NJbmNsdWRlZCA9IG5ldyBBcnJheShudW1Db2RlYmxvY2tzWCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBudW1Db2RlYmxvY2tzWDsgKyt4KSB7XHJcbiAgICAgICAgICAgIGNvZGVibG9ja0xlbmd0aFBhcnNlcnNbeF0gPSBuZXcgQXJyYXkobnVtQ29kZWJsb2Nrc1kpO1xyXG4gICAgICAgICAgICBpc0NvZGVibG9ja3NJbmNsdWRlZFt4XSA9IG5ldyBBcnJheShudW1Db2RlYmxvY2tzWSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IG51bUNvZGVibG9ja3NZOyArK3kpIHtcclxuICAgICAgICAgICAgICAgIGNvZGVibG9ja0xlbmd0aFBhcnNlcnNbeF1beV0gPVxyXG4gICAgICAgICAgICAgICAgICAgIGpwaXBGYWN0b3J5LmNyZWF0ZUNvZGVibG9ja0xlbmd0aFBhcnNlcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgYml0c3RyZWFtUmVhZGVyLCB0cmFuc2FjdGlvbkhlbHBlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpc0NvZGVibG9ja3NJbmNsdWRlZFt4XVt5XSA9IHRyYW5zYWN0aW9uSGVscGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLmNyZWF0ZVRyYW5zYWN0aW9uYWxPYmplY3QoeyBpc0luY2x1ZGVkOiBmYWxzZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gZ2V0TmV4dENvZGVibG9ja0xlbmd0aCh4LCB5LCBxdWFsaXR5TGF5ZXIpIHtcclxuICAgICAgICB2YXIgaXNDb2RlYmxvY2tBbHJlYWR5SW5jbHVkZWQgPSBpc0NvZGVibG9ja3NJbmNsdWRlZFt4XVt5XS5nZXRWYWx1ZShcclxuICAgICAgICAgICAgYml0c3RyZWFtUmVhZGVyLmFjdGl2ZVRyYW5zYWN0aW9uKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgaXNDb2RlYmxvY2tJbmNsdWRlZE5vdztcclxuICAgICAgICBpZiAoaXNDb2RlYmxvY2tBbHJlYWR5SW5jbHVkZWQuaXNJbmNsdWRlZCkge1xyXG4gICAgICAgICAgICBpc0NvZGVibG9ja0luY2x1ZGVkTm93ID0gYml0c3RyZWFtUmVhZGVyLnNoaWZ0Qml0KCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaXNDb2RlYmxvY2tJbmNsdWRlZE5vdyA9IGluY2x1c2lvblRyZWUuaXNTbWFsbGVyVGhhbk9yRXF1YWxzVG8oXHJcbiAgICAgICAgICAgICAgICB4LCB5LCBxdWFsaXR5TGF5ZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgaWYgKGlzQ29kZWJsb2NrSW5jbHVkZWROb3cgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSBlbHNlIGlmICghaXNDb2RlYmxvY2tJbmNsdWRlZE5vdykge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgY29kZWJsb2NrQm9keUxlbmd0aEJ5dGVzOiAwLFxyXG4gICAgICAgICAgICAgICAgY29kaW5nUGFzc2VzOiAwXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgemVyb0JpdFBsYW5lcyA9IG51bGw7XHJcbiAgICAgICAgaWYgKCFpc0NvZGVibG9ja0FscmVhZHlJbmNsdWRlZC5pc0luY2x1ZGVkKSB7XHJcbiAgICAgICAgICAgIHplcm9CaXRQbGFuZXMgPSB6ZXJvQml0UGxhbmVzVHJlZS5nZXRWYWx1ZSh4LCB5KTtcclxuICAgICAgICAgICAgaWYgKHplcm9CaXRQbGFuZXMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBjb2RpbmdQYXNzZXMgPSBjb2RpbmdQYXNzZXNOdW1iZXJQYXJzZXIucGFyc2UoYml0c3RyZWFtUmVhZGVyKTtcclxuICAgICAgICBpZiAoY29kaW5nUGFzc2VzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgbGVuZ3RoUGFyc2VyID0gY29kZWJsb2NrTGVuZ3RoUGFyc2Vyc1t4XVt5XTtcclxuICAgICAgICB2YXIgYm9keUxlbmd0aEJ5dGVzID0gbGVuZ3RoUGFyc2VyLnBhcnNlKGNvZGluZ1Bhc3Nlcyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGJvZHlMZW5ndGhCeXRlcyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaXNDb2RlYmxvY2tBbHJlYWR5SW5jbHVkZWQuaXNJbmNsdWRlZCA9IHRydWU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgY29kZWJsb2NrQm9keUxlbmd0aEJ5dGVzOiBib2R5TGVuZ3RoQnl0ZXMsXHJcbiAgICAgICAgICAgIGNvZGluZ1Bhc3NlczogY29kaW5nUGFzc2VzXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHplcm9CaXRQbGFuZXMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzdWx0Lnplcm9CaXRQbGFuZXMgPSB6ZXJvQml0UGxhbmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBqR2xvYmFscyA9IHJlcXVpcmUoJ2oyay1qcGlwLWdsb2JhbHMuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLkpwaXBUYWdUcmVlID0gZnVuY3Rpb24gSnBpcFRhZ1RyZWUoXHJcbiAgICBiaXRzdHJlYW1SZWFkZXIsIHdpZHRoLCBoZWlnaHQsIHRyYW5zYWN0aW9uSGVscGVyKSB7XHJcbiAgICBcclxuICAgIHZhciBpc0FscmVhZHlSZWFkQml0c1RyYW5zYWN0aW9uYWxPYmplY3QgPVxyXG4gICAgICAgIHRyYW5zYWN0aW9uSGVscGVyLmNyZWF0ZVRyYW5zYWN0aW9uYWxPYmplY3QoZmFsc2UsIC8qaXNWYWx1ZVR5cGU9Ki90cnVlKTtcclxuICAgIHZhciBsZXZlbHM7XHJcbiAgICBcclxuICAgIGNyZWF0ZUxldmVsc0FycmF5KCk7XHJcbiAgICAgICAgXHJcbiAgICB0aGlzLnNldE1pbmltYWxWYWx1ZUlmTm90UmVhZEJpdHMgPSBmdW5jdGlvbiBzZXRNaW5pbWFsVmFsdWVJZk5vdFJlYWRCaXRzKFxyXG4gICAgICAgIG1pbmltYWxWYWx1ZSkge1xyXG4gICAgXHJcbiAgICAgICAgaWYgKGlzQWxyZWFkeVJlYWRCaXRzKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgdHJhbnNhY3Rpb25hbE9iamVjdCA9IGxldmVsc1swXS5jb250ZW50WzBdO1xyXG4gICAgICAgIHZhciBub2RlID0gdHJhbnNhY3Rpb25hbE9iamVjdC5nZXRWYWx1ZShcclxuICAgICAgICAgICAgYml0c3RyZWFtUmVhZGVyLmFjdGl2ZVRyYW5zYWN0aW9uKTtcclxuICAgICAgICBcclxuICAgICAgICBub2RlLm1pbmltYWxQb3NzaWJsZVZhbHVlID0gbWluaW1hbFZhbHVlO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgdGhpcy5pc1NtYWxsZXJUaGFuT3JFcXVhbHNUbyA9IGZ1bmN0aW9uIGlzU21hbGxlclRoYW5PckVxdWFsc1RvKFxyXG4gICAgICAgIHgsIHksIHZhbHVlKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgc2V0QWxyZWFkeVJlYWRCaXRzKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGdldE5leHROb2RlID0gZ2V0Um9vdFRvTGVhZkl0ZXJhdG9yKHgsIHkpO1xyXG4gICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IGdldE5leHROb2RlKCk7XHJcbiAgICAgICAgdmFyIGxhc3ROb2RlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudE5vZGUubWluaW1hbFBvc3NpYmxlVmFsdWUgPiB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoIWN1cnJlbnROb2RlLmlzRmluYWxWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1heEJpdHNUb1NoaWZ0ID0gdmFsdWUgLSBjdXJyZW50Tm9kZS5taW5pbWFsUG9zc2libGVWYWx1ZSArIDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWRkVG9WYWx1ZSA9IGJpdHN0cmVhbVJlYWRlci5jb3VudFplcm9zQW5kU2hpZnRVbnRpbEZpcnN0T25lQml0KFxyXG4gICAgICAgICAgICAgICAgICAgIG1heEJpdHNUb1NoaWZ0KTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmIChhZGRUb1ZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLm1pbmltYWxQb3NzaWJsZVZhbHVlICs9IGFkZFRvVmFsdWU7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmIChhZGRUb1ZhbHVlIDwgbWF4Qml0c1RvU2hpZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5pc0ZpbmFsVmFsdWUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBsYXN0Tm9kZSA9IGN1cnJlbnROb2RlO1xyXG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGdldE5leHROb2RlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciByZXN1bHQgPSBsYXN0Tm9kZS5taW5pbWFsUG9zc2libGVWYWx1ZSA8PSB2YWx1ZTtcclxuICAgICAgICBpZiAocmVzdWx0ICYmICFsYXN0Tm9kZS5pc0ZpbmFsVmFsdWUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAnV3JvbmcgcGFyc2luZyBpbiBUYWdUcmVlLmlzU21hbGxlclRoYW5PckVxdWFsc1RvOiAnICtcclxuICAgICAgICAgICAgICAgICdub3Qgc3VyZSBpZiB2YWx1ZSBpcyBzbWFsbGVyIHRoYW4gYXNrZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSh4LCB5KSB7XHJcbiAgICAgICAgdmFyIGdldE5leHROb2RlID0gZ2V0Um9vdFRvTGVhZkl0ZXJhdG9yKHgsIHkpO1xyXG4gICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IGdldE5leHROb2RlKCk7XHJcbiAgICAgICAgdmFyIGxlYWY7XHJcbiAgICAgICAgXHJcbiAgICAgICAgc2V0QWxyZWFkeVJlYWRCaXRzKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICghY3VycmVudE5vZGUuaXNGaW5hbFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWRkVG9WYWx1ZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgYml0c3RyZWFtUmVhZGVyLmNvdW50WmVyb3NBbmRTaGlmdFVudGlsRmlyc3RPbmVCaXQoKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKGFkZFRvVmFsdWUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5taW5pbWFsUG9zc2libGVWYWx1ZSArPSBhZGRUb1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUuaXNGaW5hbFZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbGVhZiA9IGN1cnJlbnROb2RlO1xyXG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGdldE5leHROb2RlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBsZWFmLm1pbmltYWxQb3NzaWJsZVZhbHVlO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZnVuY3Rpb24gY3JlYXRlTGV2ZWxzQXJyYXkoKSB7XHJcbiAgICAgICAgbGV2ZWxzID0gW107XHJcbiAgICAgICAgdmFyIGxldmVsV2lkdGggPSB3aWR0aDtcclxuICAgICAgICB2YXIgbGV2ZWxIZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgd2hpbGUgKGxldmVsV2lkdGggPj0gMSB8fCBsZXZlbEhlaWdodCA+PSAxKSB7XHJcbiAgICAgICAgICAgIGxldmVsV2lkdGggPSBNYXRoLmNlaWwobGV2ZWxXaWR0aCk7XHJcbiAgICAgICAgICAgIGxldmVsSGVpZ2h0ID0gTWF0aC5jZWlsKGxldmVsSGVpZ2h0KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50Q291bnQgPSBsZXZlbFdpZHRoICogbGV2ZWxIZWlnaHQ7XHJcbiAgICAgICAgICAgIGxldmVscy51bnNoaWZ0KHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBsZXZlbFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBsZXZlbEhlaWdodCxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG5ldyBBcnJheShlbGVtZW50Q291bnQpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldmVsV2lkdGggLz0gMjtcclxuICAgICAgICAgICAgbGV2ZWxIZWlnaHQgLz0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgaW5pdE5vZGUoMCwgMCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGdldFJvb3RUb0xlYWZJdGVyYXRvcih4LCB5KSB7XHJcbiAgICAgICAgdmFyIGxldmVsID0gMDtcclxuICAgICAgICB2YXIgcHJldkl0ZXJhdGVkTm9kZSA9IG51bGw7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0TmV4dCgpIHtcclxuICAgICAgICAgICAgaWYgKGxldmVsID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAnSXRlcmF0ZWQgdG9vIGRlZXAgaW4gdGFnIHRyZWUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGxldmVsID09PSBsZXZlbHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBsZXZlbCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHNoaWZ0RmFjdG9yID0gbGV2ZWxzLmxlbmd0aCAtIGxldmVsIC0gMTtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRYID0gTWF0aC5mbG9vcih4ID4+IHNoaWZ0RmFjdG9yKTtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRZID0gTWF0aC5mbG9vcih5ID4+IHNoaWZ0RmFjdG9yKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBpbmRleEluTGV2ZWwgPSBsZXZlbHNbbGV2ZWxdLndpZHRoICogY3VycmVudFkgKyBjdXJyZW50WDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbmFsT2JqZWN0ID0gbGV2ZWxzW2xldmVsXS5jb250ZW50W2luZGV4SW5MZXZlbF07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25hbE9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbmFsT2JqZWN0ID0gaW5pdE5vZGUobGV2ZWwsIGluZGV4SW5MZXZlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cmFuc2FjdGlvbmFsT2JqZWN0LmdldFZhbHVlKFxyXG4gICAgICAgICAgICAgICAgYml0c3RyZWFtUmVhZGVyLmFjdGl2ZVRyYW5zYWN0aW9uKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChwcmV2SXRlcmF0ZWROb2RlICE9PSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICBwcmV2SXRlcmF0ZWROb2RlLm1pbmltYWxQb3NzaWJsZVZhbHVlID4gcmVzdWx0Lm1pbmltYWxQb3NzaWJsZVZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5taW5pbWFsUG9zc2libGVWYWx1ZSA9IHByZXZJdGVyYXRlZE5vZGUubWluaW1hbFBvc3NpYmxlVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHByZXZJdGVyYXRlZE5vZGUgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgICsrbGV2ZWw7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBnZXROZXh0O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBpbml0Tm9kZShsZXZlbCwgaW5kZXhJbkxldmVsKSB7XHJcbiAgICAgICAgdmFyIG9iamVjdFZhbHVlID0ge1xyXG4gICAgICAgICAgICBtaW5pbWFsUG9zc2libGVWYWx1ZTogMCxcclxuICAgICAgICAgICAgaXNGaW5hbFZhbHVlOiBmYWxzZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB2YXIgdHJhbnNhY3Rpb25hbE9iamVjdCA9IHRyYW5zYWN0aW9uSGVscGVyLmNyZWF0ZVRyYW5zYWN0aW9uYWxPYmplY3QoXHJcbiAgICAgICAgICAgIG9iamVjdFZhbHVlKTtcclxuICAgICAgICBcclxuICAgICAgICBsZXZlbHNbbGV2ZWxdLmNvbnRlbnRbaW5kZXhJbkxldmVsXSA9IHRyYW5zYWN0aW9uYWxPYmplY3Q7XHJcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uYWxPYmplY3Q7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGlzQWxyZWFkeVJlYWRCaXRzKCkge1xyXG4gICAgICAgIHZhciBpc0FscmVhZHlSZWFkQml0c1RyYW5zYWN0aW9uYWxWYWx1ZSA9XHJcbiAgICAgICAgICAgIGlzQWxyZWFkeVJlYWRCaXRzVHJhbnNhY3Rpb25hbE9iamVjdC5nZXRWYWx1ZShcclxuICAgICAgICAgICAgICAgIGJpdHN0cmVhbVJlYWRlci5hY3RpdmVUcmFuc2FjdGlvbik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGlzQWxyZWFkeVJlYWRCaXRzVHJhbnNhY3Rpb25hbFZhbHVlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBzZXRBbHJlYWR5UmVhZEJpdHMoKSB7XHJcbiAgICAgICAgaXNBbHJlYWR5UmVhZEJpdHNUcmFuc2FjdGlvbmFsT2JqZWN0LnNldFZhbHVlKFxyXG4gICAgICAgICAgICBiaXRzdHJlYW1SZWFkZXIuYWN0aXZlVHJhbnNhY3Rpb24sIHRydWUpO1xyXG4gICAgfVxyXG59OyIsIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBqR2xvYmFscyA9IHJlcXVpcmUoJ2oyay1qcGlwLWdsb2JhbHMuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzLm11dHVhbEV4Y2x1c2l2ZVRyYW5zYWN0aW9uSGVscGVyID0ge1xyXG4gICAgY3JlYXRlVHJhbnNhY3Rpb246IGZ1bmN0aW9uIGNyZWF0ZVRyYW5zYWN0aW9uKCkge1xyXG4gICAgICAgIC8vIFRoaXMgY29kZSBpcyBleGVjdXRlZCBhIExPVC4gRm9yIG9wdGltaXphdGlvbiwgc3RhdGUgaXMgcmVwcmVzZW50ZWRcclxuICAgICAgICAvLyBkaXJlY3RseSBhcyBudW1iZXJzIChJIGNvdWxkbid0IHRoaW5rIGFib3V0IG1vcmUgcmVhZGFibGUgd2F5IHdoaWNoXHJcbiAgICAgICAgLy8gaXMgcGVyZm9ybWFuY2UtZXF1aXZhbGVudCkuXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gc3RhdGUgPSAxID09PiBUcmFuc2FjdGlvbiBpcyBhY3RpdmVcclxuICAgICAgICAvLyBzdGF0ZSA9IDIgPT0+IFRyYW5zYWN0aW9uIGhhcyBjb21taXR0ZWQgc3VjY2Vzc2Z1bGx5XHJcbiAgICAgICAgLy8gc3RhdGUgPSAzID09PiBUcmFuc2FjdGlvbiBoYXMgYmVlbiBhYm9ydGVkXHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHN0YXRlID0gMTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgdHJhbnNhY3Rpb24gPSB7XHJcbiAgICAgICAgICAgIGdldCBpc0Fib3J0ZWQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUgPT09IDM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBnZXQgaXNBY3RpdmUoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUgPT09IDE7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb21taXQ6IGZ1bmN0aW9uIGNvbW1pdCgpIHtcclxuICAgICAgICAgICAgICAgIHRlcm1pbmF0ZSh0cnVlKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBcclxuICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KCkge1xyXG4gICAgICAgICAgICAgICAgdGVybWluYXRlKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgZnVuY3Rpb24gdGVybWluYXRlKGlzU3VjY2Vzc2Z1bF8pIHtcclxuICAgICAgICAgICAgaWYgKCF0cmFuc2FjdGlvbi5pc0FjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGpHbG9iYWxzLmpwaXBFeGNlcHRpb25zLkludGVybmFsRXJyb3JFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgJ0Nhbm5vdCB0ZXJtaW5hdGUgYW4gYWxyZWFkeSB0ZXJtaW5hdGVkIHRyYW5zYWN0aW9uJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RhdGUgPSBpc1N1Y2Nlc3NmdWxfID8gMiA6IDM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb247XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICBjcmVhdGVUcmFuc2FjdGlvbmFsT2JqZWN0OiBmdW5jdGlvbiBjb21taXRUcmFuc2FjdGlvbihcclxuICAgICAgICBpbml0aWFsVmFsdWUsIGlzVmFsdWVUeXBlKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcclxuICAgICAgICB2YXIgcHJldlZhbHVlID0gaW5pdGlhbFZhbHVlO1xyXG4gICAgICAgIHZhciBsYXN0QWNjZXNzZWRUcmFuc2FjdGlvbiA9IHtcclxuICAgICAgICAgICAgaXNBY3RpdmU6IGZhbHNlLFxyXG4gICAgICAgICAgICBpc0Fib3J0ZWQ6IHRydWVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB2YXIgY2xvbmUgPSBpc1ZhbHVlVHlwZSA/IGNsb25lVmFsdWVUeXBlIDogY2xvbmVCeUpTT047XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHRyYW5zYWN0aW9uYWxPYmplY3QgPSB7XHJcbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZShhY3RpdmVUcmFuc2FjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgZW5zdXJlQWxsb3dlZEFjY2VzcyhhY3RpdmVUcmFuc2FjdGlvbik7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RBY2Nlc3NlZFRyYW5zYWN0aW9uID09PSBhY3RpdmVUcmFuc2FjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RBY2Nlc3NlZFRyYW5zYWN0aW9uLmlzQWJvcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2xvbmUocHJldlZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldlZhbHVlID0gY2xvbmUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxhc3RBY2Nlc3NlZFRyYW5zYWN0aW9uID0gYWN0aXZlVHJhbnNhY3Rpb247XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUoYWN0aXZlVHJhbnNhY3Rpb24sIG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBlbnN1cmVBbGxvd2VkQWNjZXNzKGFjdGl2ZVRyYW5zYWN0aW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdEFjY2Vzc2VkVHJhbnNhY3Rpb24gPT09IGFjdGl2ZVRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmICghbGFzdEFjY2Vzc2VkVHJhbnNhY3Rpb24uaXNBYm9ydGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldlZhbHVlID0gY2xvbmUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBsYXN0QWNjZXNzZWRUcmFuc2FjdGlvbiA9IGFjdGl2ZVRyYW5zYWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgZnVuY3Rpb24gZW5zdXJlQWxsb3dlZEFjY2VzcyhhY3RpdmVUcmFuc2FjdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoIWFjdGl2ZVRyYW5zYWN0aW9uLmlzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IHVzZSB0ZXJtaW5hdGVkIHRyYW5zYWN0aW9uIHRvIGFjY2VzcyBvYmplY3RzJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChhY3RpdmVUcmFuc2FjdGlvbiAhPT0gbGFzdEFjY2Vzc2VkVHJhbnNhY3Rpb24gJiZcclxuICAgICAgICAgICAgICAgIGxhc3RBY2Nlc3NlZFRyYW5zYWN0aW9uLmlzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucy5JbnRlcm5hbEVycm9yRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgICdDYW5ub3Qgc2ltdWx0YW5vdXNseSBhY2Nlc3MgdHJhbnNhY3Rpb25hbCBvYmplY3QgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2Zyb20gdHdvIGFjdGl2ZSB0cmFuc2FjdGlvbnMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBmdW5jdGlvbiBjbG9uZVZhbHVlVHlwZSh2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZ1bmN0aW9uIGNsb25lQnlKU09OKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25hbE9iamVjdDtcclxuICAgIH1cclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgakdsb2JhbHMgPSByZXF1aXJlKCdqMmstanBpcC1nbG9iYWxzLmpzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5KcGlwQ29kZXN0cmVhbUNsaWVudCA9IHJlcXVpcmUoJ2pwaXAtY29kZXN0cmVhbS1jbGllbnQuanMnKTtcclxubW9kdWxlLmV4cG9ydHMuSnBpcENvZGVzdHJlYW1TaXplc0NhbGN1bGF0b3IgPSByZXF1aXJlKCdqcGlwLWNvZGVzdHJlYW0tc2l6ZXMtY2FsY3VsYXRvci5qcycpO1xyXG5tb2R1bGUuZXhwb3J0cy5qMmtFeGNlcHRpb25zID0gakdsb2JhbHMuajJrRXhjZXB0aW9ucztcclxubW9kdWxlLmV4cG9ydHMuanBpcEV4Y2VwdGlvbnMgPSBqR2xvYmFscy5qcGlwRXhjZXB0aW9ucztcclxubW9kdWxlLmV4cG9ydHMuSW50ZXJuYWxzID0ge1xyXG4gICAganBpcFJ1bnRpbWVGYWN0b3J5OiByZXF1aXJlKCdqcGlwLXJ1bnRpbWUtZmFjdG9yeS5qcycpLFxyXG4gICAgakdsb2JhbHM6IGpHbG9iYWxzXHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGpHbG9iYWxzID0gcmVxdWlyZSgnajJrLWpwaXAtZ2xvYmFscy5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuSnBpcENvZGVzdHJlYW1SZWNvbnN0cnVjdG9yID0gZnVuY3Rpb24gSnBpcENvZGVzdHJlYW1SZWNvbnN0cnVjdG9yKFxyXG4gICAgY29kZXN0cmVhbVN0cnVjdHVyZSxcclxuICAgIGRhdGFiaW5zU2F2ZXIsXHJcbiAgICBoZWFkZXJNb2RpZmllcixcclxuICAgIHF1YWxpdHlMYXllcnNDYWNoZSkge1xyXG4gICAgXHJcbiAgICB0aGlzLnJlY29uc3RydWN0Q29kZXN0cmVhbSA9IGZ1bmN0aW9uIHJlY29uc3RydWN0Q29kZXN0cmVhbShcclxuICAgICAgICBtaW5OdW1RdWFsaXR5TGF5ZXJzKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIHZhciBjdXJyZW50T2Zmc2V0ID0gY3JlYXRlTWFpbkhlYWRlcihyZXN1bHQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChjdXJyZW50T2Zmc2V0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgbnVtVGlsZXMgPVxyXG4gICAgICAgICAgICBjb2Rlc3RyZWFtU3RydWN0dXJlLmdldE51bVRpbGVzWCgpICogY29kZXN0cmVhbVN0cnVjdHVyZS5nZXROdW1UaWxlc1koKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgY29kZXN0cmVhbVBhcnQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKG1pbk51bVF1YWxpdHlMYXllcnMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBtaW5OdW1RdWFsaXR5TGF5ZXJzID0gJ21heCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAodmFyIHRpbGVJZCA9IDA7IHRpbGVJZCA8IG51bVRpbGVzOyArK3RpbGVJZCkge1xyXG4gICAgICAgICAgICB2YXIgdGlsZUJ5dGVzQ29waWVkID0gY3JlYXRlVGlsZShcclxuICAgICAgICAgICAgICAgIHJlc3VsdCxcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICB0aWxlSWQsXHJcbiAgICAgICAgICAgICAgICB0aWxlSWQsXHJcbiAgICAgICAgICAgICAgICBjb2Rlc3RyZWFtUGFydCxcclxuICAgICAgICAgICAgICAgIG1pbk51bVF1YWxpdHlMYXllcnMpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY3VycmVudE9mZnNldCArPSB0aWxlQnl0ZXNDb3BpZWQ7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAodGlsZUJ5dGVzQ29waWVkID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgbWFya2VyQnl0ZXNDb3BpZWQgPSBjb3B5Qnl0ZXMoXHJcbiAgICAgICAgICAgIHJlc3VsdCwgY3VycmVudE9mZnNldCwgakdsb2JhbHMuajJrTWFya2Vycy5FbmRPZkNvZGVzdHJlYW0pO1xyXG4gICAgICAgIGN1cnJlbnRPZmZzZXQgKz0gbWFya2VyQnl0ZXNDb3BpZWQ7XHJcbiAgICAgICAgcmVzdWx0Lmxlbmd0aCA9IGN1cnJlbnRPZmZzZXQ7XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmNyZWF0ZUNvZGVzdHJlYW1Gb3JSZWdpb24gPSBmdW5jdGlvbiBjcmVhdGVDb2Rlc3RyZWFtRm9yUmVnaW9uKFxyXG4gICAgICAgIHBhcmFtcywgbWluTnVtUXVhbGl0eUxheWVycywgaXNPbmx5SGVhZGVyc1dpdGhvdXRCaXRzdHJlYW0pIHtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgY29kZXN0cmVhbSA9IFtdO1xyXG4gICAgICAgIHZhciBjdXJyZW50T2Zmc2V0ID0gY3JlYXRlTWFpbkhlYWRlcihcclxuICAgICAgICAgICAgY29kZXN0cmVhbSwgcGFyYW1zLm51bVJlc29sdXRpb25MZXZlbHNUb0N1dCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGN1cnJlbnRPZmZzZXQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciB0aWxlSWRUb1dyaXRlID0gMDtcclxuICAgICAgICB2YXIgdGlsZUl0ZXJhdG9yID0gY29kZXN0cmVhbVN0cnVjdHVyZS5nZXRUaWxlc0l0ZXJhdG9yKHBhcmFtcyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGZpcnN0VGlsZUlkID0gdGlsZUl0ZXJhdG9yLnRpbGVJbmRleDtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgZmlyc3RUaWxlTGVmdCA9IGNvZGVzdHJlYW1TdHJ1Y3R1cmUuZ2V0VGlsZUxlZnQoXHJcbiAgICAgICAgICAgIGZpcnN0VGlsZUlkLCBwYXJhbXMubnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0KTtcclxuICAgICAgICB2YXIgZmlyc3RUaWxlVG9wID0gY29kZXN0cmVhbVN0cnVjdHVyZS5nZXRUaWxlVG9wKFxyXG4gICAgICAgICAgICBmaXJzdFRpbGVJZCwgcGFyYW1zLm51bVJlc29sdXRpb25MZXZlbHNUb0N1dCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIHZhciBvZmZzZXRYID0gcGFyYW1zLm1pblggLSBmaXJzdFRpbGVMZWZ0O1xyXG4gICAgICAgIHZhciBvZmZzZXRZID0gcGFyYW1zLm1pblkgLSBmaXJzdFRpbGVUb3A7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICB2YXIgdGlsZUlkT3JpZ2luYWwgPSB0aWxlSXRlcmF0b3IudGlsZUluZGV4O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHRpbGVCeXRlc0NvcGllZCA9IGNyZWF0ZVRpbGUoXHJcbiAgICAgICAgICAgICAgICBjb2Rlc3RyZWFtLFxyXG4gICAgICAgICAgICAgICAgY3VycmVudE9mZnNldCxcclxuICAgICAgICAgICAgICAgIHRpbGVJZFRvV3JpdGUrKyxcclxuICAgICAgICAgICAgICAgIHRpbGVJZE9yaWdpbmFsLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgbWluTnVtUXVhbGl0eUxheWVycyxcclxuICAgICAgICAgICAgICAgIGlzT25seUhlYWRlcnNXaXRob3V0Qml0c3RyZWFtKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjdXJyZW50T2Zmc2V0ICs9IHRpbGVCeXRlc0NvcGllZDtcclxuICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHRpbGVCeXRlc0NvcGllZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlICh0aWxlSXRlcmF0b3IudHJ5QWR2YW5jZSgpKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgbWFya2VyQnl0ZXNDb3BpZWQgPSBjb3B5Qnl0ZXMoXHJcbiAgICAgICAgICAgIGNvZGVzdHJlYW0sIGN1cnJlbnRPZmZzZXQsIGpHbG9iYWxzLmoya01hcmtlcnMuRW5kT2ZDb2Rlc3RyZWFtKTtcclxuICAgICAgICBjdXJyZW50T2Zmc2V0ICs9IG1hcmtlckJ5dGVzQ29waWVkO1xyXG5cclxuICAgICAgICBoZWFkZXJNb2RpZmllci5tb2RpZnlJbWFnZVNpemUoY29kZXN0cmVhbSwgcGFyYW1zKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoY29kZXN0cmVhbSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29kZXN0cmVhbS5sZW5ndGggPSBjdXJyZW50T2Zmc2V0O1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb2Rlc3RyZWFtOiBjb2Rlc3RyZWFtLFxyXG4gICAgICAgICAgICBvZmZzZXRYOiBvZmZzZXRYLFxyXG4gICAgICAgICAgICBvZmZzZXRZOiBvZmZzZXRZXHJcbiAgICAgICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmNyZWF0ZUNvZGVzdHJlYW1Gb3JUaWxlID0gZnVuY3Rpb24gY3JlYXRlQ29kZXN0cmVhbUZvclRpbGUoXHJcbiAgICAgICAgdGlsZUlkLFxyXG4gICAgICAgIG51bVJlc29sdXRpb25MZXZlbHNUb0N1dCxcclxuICAgICAgICBtaW5OdW1RdWFsaXR5TGF5ZXJzLFxyXG4gICAgICAgIG1heE51bVF1YWxpdHlMYXllcnMpIHtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgdmFyIGN1cnJlbnRPZmZzZXQgPSBjcmVhdGVNYWluSGVhZGVyKHJlc3VsdCwgbnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0KTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoY3VycmVudE9mZnNldCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgZnVuY3Rpb24gYW5kIHRlc3QgY3JlYXRlQ29kZXN0cmVhbUZvclJlZ2lvbiBpbnN0ZWFkXHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGNvZGVzdHJlYW1QYXJ0UGFyYW1zID0ge1xyXG4gICAgICAgICAgICBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQ6IG51bVJlc29sdXRpb25MZXZlbHNUb0N1dCxcclxuICAgICAgICAgICAgbWF4TnVtUXVhbGl0eUxheWVyczogbWF4TnVtUXVhbGl0eUxheWVyc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciB0aWxlQnl0ZXNDb3BpZWQgPSBjcmVhdGVUaWxlKFxyXG4gICAgICAgICAgICByZXN1bHQsXHJcbiAgICAgICAgICAgIGN1cnJlbnRPZmZzZXQsXHJcbiAgICAgICAgICAgIC8qdGlsZUlkVG9Xcml0ZT0qLzAsXHJcbiAgICAgICAgICAgIC8qdGlsZUlkT3JpZ2luYWw9Ki90aWxlSWQsXHJcbiAgICAgICAgICAgIGNvZGVzdHJlYW1QYXJ0UGFyYW1zLFxyXG4gICAgICAgICAgICBtaW5OdW1RdWFsaXR5TGF5ZXJzKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgY3VycmVudE9mZnNldCArPSB0aWxlQnl0ZXNDb3BpZWQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHRpbGVCeXRlc0NvcGllZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBtYXJrZXJCeXRlc0NvcGllZCA9IGNvcHlCeXRlcyhcclxuICAgICAgICAgICAgcmVzdWx0LCBjdXJyZW50T2Zmc2V0LCBqR2xvYmFscy5qMmtNYXJrZXJzLkVuZE9mQ29kZXN0cmVhbSk7XHJcbiAgICAgICAgY3VycmVudE9mZnNldCArPSBtYXJrZXJCeXRlc0NvcGllZDtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgbnVtVGlsZXNYID0gY29kZXN0cmVhbVN0cnVjdHVyZS5nZXROdW1UaWxlc1goKTtcclxuICAgICAgICB2YXIgdGlsZVggPSB0aWxlSWQgJSBudW1UaWxlc1g7XHJcbiAgICAgICAgdmFyIHRpbGVZID0gTWF0aC5mbG9vcih0aWxlSWQgLyBudW1UaWxlc1gpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGhlYWRlck1vZGlmaWVyLm1vZGlmeUltYWdlU2l6ZShyZXN1bHQsIHtcclxuICAgICAgICAgICAgbnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0OiBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQsXHJcbiAgICAgICAgICAgIG1pblRpbGVYOiB0aWxlWCxcclxuICAgICAgICAgICAgbWF4VGlsZVhFeGNsdXNpdmU6IHRpbGVYICsgMSxcclxuICAgICAgICAgICAgbWluVGlsZVk6IHRpbGVZLFxyXG4gICAgICAgICAgICBtYXhUaWxlWUV4Y2x1c2l2ZTogdGlsZVkgKyAxXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJlc3VsdC5sZW5ndGggPSBjdXJyZW50T2Zmc2V0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVNYWluSGVhZGVyKHJlc3VsdCwgbnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0KSB7XHJcbiAgICAgICAgaWYgKGRhdGFiaW5zU2F2ZXIuZ2V0SXNKcGlwVGlsZVBhcnRTdHJlYW0oKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuVW5zdXBwb3J0ZWRGZWF0dXJlRXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgJ3JlY29uc3RydWN0aW9uIG9mIGNvZGVzdHJlYW0gZnJvbSBKUFQgKEpwaXAgVGlsZS1wYXJ0KSBzdHJlYW0nLCAnQS4zLjQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIG1haW5IZWFkZXIgPSBkYXRhYmluc1NhdmVyLmdldE1haW5IZWFkZXJEYXRhYmluKCk7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRPZmZzZXQgPSBtYWluSGVhZGVyLmNvcHlCeXRlcyhyZXN1bHQsIC8qc3RhcnRPZmZzZXQ9Ki8wLCB7XHJcbiAgICAgICAgICAgIGZvcmNlQ29weUFsbFJhbmdlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChjdXJyZW50T2Zmc2V0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgYnl0ZXNBZGRlZCA9IGhlYWRlck1vZGlmaWVyLm1vZGlmeU1haW5PclRpbGVIZWFkZXIoXHJcbiAgICAgICAgICAgIHJlc3VsdCwgbWFpbkhlYWRlciwgLypvZmZzZXQ9Ki8wLCBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGN1cnJlbnRPZmZzZXQgKz0gYnl0ZXNBZGRlZDtcclxuICAgICAgICBcclxuICAgICAgICBieXRlc0FkZGVkID0gYWRkTWFtYXphdkNvbW1lbnQocmVzdWx0LCBjdXJyZW50T2Zmc2V0KTtcclxuICAgICAgICBjdXJyZW50T2Zmc2V0ICs9IGJ5dGVzQWRkZWQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRPZmZzZXQ7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRpbGUoXHJcbiAgICAgICAgcmVzdWx0LFxyXG4gICAgICAgIGN1cnJlbnRPZmZzZXQsXHJcbiAgICAgICAgdGlsZUlkVG9Xcml0ZSxcclxuICAgICAgICB0aWxlSWRPcmlnaW5hbCxcclxuICAgICAgICBjb2Rlc3RyZWFtUGFydFBhcmFtcyxcclxuICAgICAgICBtaW5OdW1RdWFsaXR5TGF5ZXJzLFxyXG4gICAgICAgIGlzT25seUhlYWRlcnNXaXRob3V0Qml0c3RyZWFtKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHRpbGVTdHJ1Y3R1cmUgPSBjb2Rlc3RyZWFtU3RydWN0dXJlLmdldFRpbGVTdHJ1Y3R1cmUoXHJcbiAgICAgICAgICAgIHRpbGVJZE9yaWdpbmFsKTtcclxuXHJcbiAgICAgICAgdmFyIHN0YXJ0VGlsZU9mZnNldCA9IGN1cnJlbnRPZmZzZXQ7XHJcbiAgICAgICAgdmFyIHRpbGVIZWFkZXJEYXRhYmluID0gZGF0YWJpbnNTYXZlci5nZXRUaWxlSGVhZGVyRGF0YWJpbihcclxuICAgICAgICAgICAgdGlsZUlkT3JpZ2luYWwpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQ7XHJcbiAgICAgICAgaWYgKGNvZGVzdHJlYW1QYXJ0UGFyYW1zICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0ID0gY29kZXN0cmVhbVBhcnRQYXJhbXMubnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgdGlsZUhlYWRlck9mZnNldHMgPSBjcmVhdGVUaWxlSGVhZGVyQW5kR2V0T2Zmc2V0cyhcclxuICAgICAgICAgICAgcmVzdWx0LFxyXG4gICAgICAgICAgICBjdXJyZW50T2Zmc2V0LFxyXG4gICAgICAgICAgICB0aWxlSGVhZGVyRGF0YWJpbixcclxuICAgICAgICAgICAgdGlsZUlkVG9Xcml0ZSxcclxuICAgICAgICAgICAgbnVtUmVzb2x1dGlvbkxldmVsc1RvQ3V0KTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAodGlsZUhlYWRlck9mZnNldHMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICBjdXJyZW50T2Zmc2V0ID0gdGlsZUhlYWRlck9mZnNldHMuZW5kVGlsZUhlYWRlck9mZnNldDtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoIWlzT25seUhlYWRlcnNXaXRob3V0Qml0c3RyZWFtKSB7XHJcbiAgICAgICAgICAgIHZhciB0aWxlQnl0ZXNDb3BpZWQgPSBjcmVhdGVUaWxlQml0c3RyZWFtKFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LFxyXG4gICAgICAgICAgICAgICAgY3VycmVudE9mZnNldCxcclxuICAgICAgICAgICAgICAgIHRpbGVTdHJ1Y3R1cmUsXHJcbiAgICAgICAgICAgICAgICB0aWxlSWRPcmlnaW5hbCxcclxuICAgICAgICAgICAgICAgIGNvZGVzdHJlYW1QYXJ0UGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgbWluTnVtUXVhbGl0eUxheWVycyk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgY3VycmVudE9mZnNldCArPSB0aWxlQnl0ZXNDb3BpZWQ7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAodGlsZUJ5dGVzQ29waWVkID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGVuZFRpbGVPZmZzZXQgPSBjdXJyZW50T2Zmc2V0O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBoZWFkZXJBbmREYXRhTGVuZ3RoID1cclxuICAgICAgICAgICAgZW5kVGlsZU9mZnNldCAtIHRpbGVIZWFkZXJPZmZzZXRzLnN0YXJ0T2ZUaWxlSGVhZGVyT2Zmc2V0O1xyXG5cclxuICAgICAgICBoZWFkZXJNb2RpZmllci5tb2RpZnlJbnQzMihcclxuICAgICAgICAgICAgcmVzdWx0LFxyXG4gICAgICAgICAgICB0aWxlSGVhZGVyT2Zmc2V0cy5oZWFkZXJBbmREYXRhTGVuZ3RoUGxhY2Vob2xkZXJPZmZzZXQsXHJcbiAgICAgICAgICAgIGhlYWRlckFuZERhdGFMZW5ndGgpO1xyXG5cclxuICAgICAgICB2YXIgYnl0ZXNDb3BpZWQgPSBlbmRUaWxlT2Zmc2V0IC0gc3RhcnRUaWxlT2Zmc2V0O1xyXG4gICAgICAgIHJldHVybiBieXRlc0NvcGllZDtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gY3JlYXRlVGlsZUhlYWRlckFuZEdldE9mZnNldHMoXHJcbiAgICAgICAgcmVzdWx0LFxyXG4gICAgICAgIGN1cnJlbnRPZmZzZXQsXHJcbiAgICAgICAgdGlsZUhlYWRlckRhdGFiaW4sXHJcbiAgICAgICAgdGlsZUlkVG9Xcml0ZSxcclxuICAgICAgICBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQpIHtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgc3RhcnRPZlRpbGVIZWFkZXJPZmZzZXQgPSBjdXJyZW50T2Zmc2V0O1xyXG4gICAgXHJcbiAgICAgICAgdmFyIGJ5dGVzQ29waWVkID0gY29weUJ5dGVzKFxyXG4gICAgICAgICAgICByZXN1bHQsIGN1cnJlbnRPZmZzZXQsIGpHbG9iYWxzLmoya01hcmtlcnMuU3RhcnRPZlRpbGUpO1xyXG4gICAgICAgIGN1cnJlbnRPZmZzZXQgKz0gYnl0ZXNDb3BpZWQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQS40LjJcclxuICAgICAgICBcclxuICAgICAgICB2YXIgc3RhcnRPZlRpbGVTZWdtZW50TGVuZ3RoID0gWzAsIDEwXTsgLy8gTHNvdFxyXG4gICAgICAgIGJ5dGVzQ29waWVkID0gY29weUJ5dGVzKHJlc3VsdCwgY3VycmVudE9mZnNldCwgc3RhcnRPZlRpbGVTZWdtZW50TGVuZ3RoKTtcclxuICAgICAgICBjdXJyZW50T2Zmc2V0ICs9IGJ5dGVzQ29waWVkO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciB0aWxlSW5kZXggPSBbdGlsZUlkVG9Xcml0ZSA+Pj4gOCwgdGlsZUlkVG9Xcml0ZSAmIDB4RkZdOyAvLyBJc290XHJcbiAgICAgICAgYnl0ZXNDb3BpZWQgPSBjb3B5Qnl0ZXMocmVzdWx0LCBjdXJyZW50T2Zmc2V0LCB0aWxlSW5kZXgpO1xyXG4gICAgICAgIGN1cnJlbnRPZmZzZXQgKz0gYnl0ZXNDb3BpZWQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGhlYWRlckFuZERhdGFMZW5ndGhQbGFjZWhvbGRlck9mZnNldCA9IGN1cnJlbnRPZmZzZXQ7XHJcbiAgICAgICAgdmFyIGhlYWRlckFuZERhdGFMZW5ndGhQbGFjZWhvbGRlciA9IFswLCAwLCAwLCAwXTsgLy8gUHNvdFxyXG4gICAgICAgIGJ5dGVzQ29waWVkID0gY29weUJ5dGVzKHJlc3VsdCwgY3VycmVudE9mZnNldCwgaGVhZGVyQW5kRGF0YUxlbmd0aFBsYWNlaG9sZGVyKTtcclxuICAgICAgICBjdXJyZW50T2Zmc2V0ICs9IGJ5dGVzQ29waWVkO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciB0aWxlUGFydEluZGV4ID0gWzBdOyAvLyBUUHNvdFxyXG4gICAgICAgIGJ5dGVzQ29waWVkID0gY29weUJ5dGVzKHJlc3VsdCwgY3VycmVudE9mZnNldCwgdGlsZVBhcnRJbmRleCk7XHJcbiAgICAgICAgY3VycmVudE9mZnNldCArPSBieXRlc0NvcGllZDtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgbnVtYmVyT2ZUaWxlcGFydHMgPSBbMV07IC8vIFROc290XHJcbiAgICAgICAgYnl0ZXNDb3BpZWQgPSBjb3B5Qnl0ZXMocmVzdWx0LCBjdXJyZW50T2Zmc2V0LCBudW1iZXJPZlRpbGVwYXJ0cyk7XHJcbiAgICAgICAgY3VycmVudE9mZnNldCArPSBieXRlc0NvcGllZDtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgYWZ0ZXJTdGFydE9mVGlsZVNlZ21lbnRPZmZzZXQgPSBjdXJyZW50T2Zmc2V0O1xyXG4gICAgICAgIGJ5dGVzQ29waWVkID0gdGlsZUhlYWRlckRhdGFiaW4uY29weUJ5dGVzKHJlc3VsdCwgY3VycmVudE9mZnNldCwge1xyXG4gICAgICAgICAgICBmb3JjZUNvcHlBbGxSYW5nZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBjdXJyZW50T2Zmc2V0ICs9IGJ5dGVzQ29waWVkO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChieXRlc0NvcGllZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBOT1RFOiBDYW4gY3JlYXRlIGVtcHR5IHRpbGVcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBpc0VuZGVkV2l0aFN0YXJ0T2ZEYXRhTWFya2VyID1cclxuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbnRPZmZzZXQgLSAyXSA9PT0gakdsb2JhbHMuajJrTWFya2Vycy5TdGFydE9mRGF0YVswXSAmJlxyXG4gICAgICAgICAgICByZXN1bHRbY3VycmVudE9mZnNldCAtIDFdID09PSBqR2xvYmFscy5qMmtNYXJrZXJzLlN0YXJ0T2ZEYXRhWzFdO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICBpZiAoIWlzRW5kZWRXaXRoU3RhcnRPZkRhdGFNYXJrZXIpIHtcclxuICAgICAgICAgICAgYnl0ZXNDb3BpZWQgPSBjb3B5Qnl0ZXMoXHJcbiAgICAgICAgICAgICAgICByZXN1bHQsIGN1cnJlbnRPZmZzZXQsIGpHbG9iYWxzLmoya01hcmtlcnMuU3RhcnRPZkRhdGEpO1xyXG4gICAgICAgICAgICBjdXJyZW50T2Zmc2V0ICs9IGJ5dGVzQ29waWVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgYnl0ZXNBZGRlZCA9IGhlYWRlck1vZGlmaWVyLm1vZGlmeU1haW5PclRpbGVIZWFkZXIoXHJcbiAgICAgICAgICAgIHJlc3VsdCxcclxuICAgICAgICAgICAgdGlsZUhlYWRlckRhdGFiaW4sXHJcbiAgICAgICAgICAgIGFmdGVyU3RhcnRPZlRpbGVTZWdtZW50T2Zmc2V0LFxyXG4gICAgICAgICAgICBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGN1cnJlbnRPZmZzZXQgKz0gYnl0ZXNBZGRlZDtcclxuXHJcbiAgICAgICAgdmFyIG9mZnNldHMgPSB7XHJcbiAgICAgICAgICAgIHN0YXJ0T2ZUaWxlSGVhZGVyT2Zmc2V0OiBzdGFydE9mVGlsZUhlYWRlck9mZnNldCxcclxuICAgICAgICAgICAgaGVhZGVyQW5kRGF0YUxlbmd0aFBsYWNlaG9sZGVyT2Zmc2V0OiBoZWFkZXJBbmREYXRhTGVuZ3RoUGxhY2Vob2xkZXJPZmZzZXQsXHJcbiAgICAgICAgICAgIGVuZFRpbGVIZWFkZXJPZmZzZXQ6IGN1cnJlbnRPZmZzZXRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gb2Zmc2V0cztcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gY3JlYXRlVGlsZUJpdHN0cmVhbShcclxuICAgICAgICByZXN1bHQsXHJcbiAgICAgICAgY3VycmVudE9mZnNldCxcclxuICAgICAgICB0aWxlU3RydWN0dXJlLFxyXG4gICAgICAgIHRpbGVJZE9yaWdpbmFsLFxyXG4gICAgICAgIGNvZGVzdHJlYW1QYXJ0UGFyYW1zLFxyXG4gICAgICAgIG1pbk51bVF1YWxpdHlMYXllcnMpIHtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgbnVtUXVhbGl0eUxheWVyc0luVGlsZSA9IHRpbGVTdHJ1Y3R1cmUuZ2V0TnVtUXVhbGl0eUxheWVycygpO1xyXG4gICAgICAgIHZhciBtYXhOdW1RdWFsaXR5TGF5ZXJzO1xyXG4gICAgICAgIHZhciBpdGVyYXRvciA9IHRpbGVTdHJ1Y3R1cmUuZ2V0UHJlY2luY3RJdGVyYXRvcihcclxuICAgICAgICAgICAgdGlsZUlkT3JpZ2luYWwsXHJcbiAgICAgICAgICAgIGNvZGVzdHJlYW1QYXJ0UGFyYW1zLFxyXG4gICAgICAgICAgICAvKmlzSXRlcmF0ZVByZWNpbmN0c05vdEluQ29kZXN0cmVhbVBhcnQ9Ki90cnVlKTtcclxuXHJcbiAgICAgICAgdmFyIGFsbEJ5dGVzQ29waWVkID0gMDtcclxuICAgICAgICB2YXIgaGFzTW9yZVBhY2tldHM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGNvZGVzdHJlYW1QYXJ0UGFyYW1zICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbWF4TnVtUXVhbGl0eUxheWVycyA9IGNvZGVzdHJlYW1QYXJ0UGFyYW1zLm1heE51bVF1YWxpdHlMYXllcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChtaW5OdW1RdWFsaXR5TGF5ZXJzID09PSAnbWF4Jykge1xyXG4gICAgICAgICAgICBtaW5OdW1RdWFsaXR5TGF5ZXJzID0gbnVtUXVhbGl0eUxheWVyc0luVGlsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICB2YXIgZW1wdHlQYWNrZXRzVG9QdXNoID0gbnVtUXVhbGl0eUxheWVyc0luVGlsZTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChpdGVyYXRvci5pc0luQ29kZXN0cmVhbVBhcnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbkNsYXNzSWQgPVxyXG4gICAgICAgICAgICAgICAgICAgIHRpbGVTdHJ1Y3R1cmUucHJlY2luY3RQb3NpdGlvblRvSW5DbGFzc0luZGV4KGl0ZXJhdG9yKTtcclxuICAgICAgICAgICAgICAgIHZhciBwcmVjaW5jdERhdGFiaW4gPSBkYXRhYmluc1NhdmVyLmdldFByZWNpbmN0RGF0YWJpbihpbkNsYXNzSWQpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgcXVhbGl0eUxheWVyT2Zmc2V0ID0gcXVhbGl0eUxheWVyc0NhY2hlLmdldFF1YWxpdHlMYXllck9mZnNldChcclxuICAgICAgICAgICAgICAgICAgICBwcmVjaW5jdERhdGFiaW4sXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4TnVtUXVhbGl0eUxheWVycyxcclxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvcik7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHZhciBieXRlc1RvQ29weSA9IHF1YWxpdHlMYXllck9mZnNldC5lbmRPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBlbXB0eVBhY2tldHNUb1B1c2ggPVxyXG4gICAgICAgICAgICAgICAgICAgIG51bVF1YWxpdHlMYXllcnNJblRpbGUgLSBxdWFsaXR5TGF5ZXJPZmZzZXQubnVtUXVhbGl0eUxheWVycztcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKHF1YWxpdHlMYXllck9mZnNldC5udW1RdWFsaXR5TGF5ZXJzIDwgbWluTnVtUXVhbGl0eUxheWVycykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZXNDb3BpZWQgPSBwcmVjaW5jdERhdGFiaW4uY29weUJ5dGVzKHJlc3VsdCwgY3VycmVudE9mZnNldCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlQ29weUFsbFJhbmdlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG1heExlbmd0aFRvQ29weTogYnl0ZXNUb0NvcHlcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVzQ29waWVkID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXNDb3BpZWQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGVtcHR5UGFja2V0c1RvUHVzaCA9IG51bVF1YWxpdHlMYXllcnNJblRpbGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGFsbEJ5dGVzQ29waWVkICs9IGJ5dGVzQ29waWVkO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudE9mZnNldCArPSBieXRlc0NvcGllZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbXB0eVBhY2tldHNUb1B1c2g7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2N1cnJlbnRPZmZzZXQrK10gPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFsbEJ5dGVzQ29waWVkICs9IGVtcHR5UGFja2V0c1RvUHVzaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGl0ZXJhdG9yLnRyeUFkdmFuY2UoKSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGFsbEJ5dGVzQ29waWVkO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBhZGRNYW1hemF2Q29tbWVudChyZXN1bHQsIGN1cnJlbnRPZmZzZXQpIHtcclxuICAgICAgICB2YXIgc3RhcnRPZmZzZXQgPSBjdXJyZW50T2Zmc2V0O1xyXG4gICAgXHJcbiAgICAgICAgcmVzdWx0W2N1cnJlbnRPZmZzZXQrK10gPSAweEZGO1xyXG4gICAgICAgIHJlc3VsdFtjdXJyZW50T2Zmc2V0KytdID0gMHg2NDtcclxuICAgICAgICByZXN1bHRbY3VycmVudE9mZnNldCsrXSA9IDB4MDA7XHJcbiAgICAgICAgcmVzdWx0W2N1cnJlbnRPZmZzZXQrK10gPSAweDA5O1xyXG4gICAgICAgIHJlc3VsdFtjdXJyZW50T2Zmc2V0KytdID0gNzc7XHJcbiAgICAgICAgcmVzdWx0W2N1cnJlbnRPZmZzZXQrK10gPSA5NztcclxuICAgICAgICByZXN1bHRbY3VycmVudE9mZnNldCsrXSA9IDEwOTtcclxuICAgICAgICByZXN1bHRbY3VycmVudE9mZnNldCsrXSA9IDk3O1xyXG4gICAgICAgIHJlc3VsdFtjdXJyZW50T2Zmc2V0KytdID0gMTIyO1xyXG4gICAgICAgIHJlc3VsdFtjdXJyZW50T2Zmc2V0KytdID0gOTc7XHJcbiAgICAgICAgcmVzdWx0W2N1cnJlbnRPZmZzZXQrK10gPSAxMTg7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGJ5dGVzQWRkZWQgPSBjdXJyZW50T2Zmc2V0IC0gc3RhcnRPZmZzZXQ7XHJcbiAgICAgICAgcmV0dXJuIGJ5dGVzQWRkZWQ7XHJcbiAgICB9XHJcbiAgICAgICAgXHJcbiAgICBmdW5jdGlvbiBjb3B5Qnl0ZXMocmVzdWx0LCByZXN1bHRTdGFydE9mZnNldCwgYnl0ZXNUb0NvcHkpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzVG9Db3B5Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFtpICsgcmVzdWx0U3RhcnRPZmZzZXRdID0gYnl0ZXNUb0NvcHlbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBieXRlc1RvQ29weS5sZW5ndGg7XHJcbiAgICB9XHJcbn07IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGpHbG9iYWxzID0gcmVxdWlyZSgnajJrLWpwaXAtZ2xvYmFscy5qcycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMuSnBpcEhlYWRlck1vZGlmaWVyID0gZnVuY3Rpb24gSnBpcEhlYWRlck1vZGlmaWVyKFxyXG4gICAgY29kZXN0cmVhbVN0cnVjdHVyZSwgb2Zmc2V0c0NhbGN1bGF0b3IsIHByb2dyZXNzaW9uT3JkZXIpIHtcclxuXHJcbiAgICB2YXIgZW5jb2RlZFByb2dyZXNzaW9uT3JkZXIgPSBlbmNvZGVQcm9ncmVzc2lvbk9yZGVyKHByb2dyZXNzaW9uT3JkZXIpO1xyXG4gICAgICAgIFxyXG4gICAgdGhpcy5tb2RpZnlNYWluT3JUaWxlSGVhZGVyID0gZnVuY3Rpb24gbW9kaWZ5TWFpbk9yVGlsZUhlYWRlcihcclxuICAgICAgICByZXN1bHQsIG9yaWdpbmFsRGF0YWJpbiwgZGF0YWJpbk9mZnNldEluUmVzdWx0LCBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQpIHtcclxuICAgICAgICBcclxuICAgICAgICBtb2RpZnlQcm9ncmVzc2lvbk9yZGVyKHJlc3VsdCwgb3JpZ2luYWxEYXRhYmluLCBkYXRhYmluT2Zmc2V0SW5SZXN1bHQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIGJlc3RSZXNvbHV0aW9uTGV2ZWxzUmFuZ2VzID1cclxuICAgICAgICAgICAgb2Zmc2V0c0NhbGN1bGF0b3IuZ2V0UmFuZ2VzT2ZCZXN0UmVzb2x1dGlvbkxldmVsc0RhdGEoXHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbERhdGFiaW4sIG51bVJlc29sdXRpb25MZXZlbHNUb0N1dCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGJlc3RSZXNvbHV0aW9uTGV2ZWxzUmFuZ2VzLm51bURlY29tcG9zaXRpb25MZXZlbHNPZmZzZXQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9XHJcbiAgICAgICAgICAgICAgICBkYXRhYmluT2Zmc2V0SW5SZXN1bHQgK1xyXG4gICAgICAgICAgICAgICAgYmVzdFJlc29sdXRpb25MZXZlbHNSYW5nZXMubnVtRGVjb21wb3NpdGlvbkxldmVsc09mZnNldDtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXN1bHRbb2Zmc2V0XSAtPSBudW1SZXNvbHV0aW9uTGV2ZWxzVG9DdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBieXRlc1JlbW92ZWQgPSByZW1vdmVSYW5nZXMoXHJcbiAgICAgICAgICAgIHJlc3VsdCwgYmVzdFJlc29sdXRpb25MZXZlbHNSYW5nZXMucmFuZ2VzLCBkYXRhYmluT2Zmc2V0SW5SZXN1bHQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBieXRlc0FkZGVkID0gLWJ5dGVzUmVtb3ZlZDtcclxuICAgICAgICByZXR1cm4gYnl0ZXNBZGRlZDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHRoaXMubW9kaWZ5SW1hZ2VTaXplID0gZnVuY3Rpb24gbW9kaWZ5SW1hZ2VTaXplKHJlc3VsdCwgY29kZXN0cmVhbVBhcnRQYXJhbXMpIHtcclxuICAgICAgICB2YXIgbmV3VGlsZVdpZHRoID0gY29kZXN0cmVhbVN0cnVjdHVyZS5nZXRUaWxlV2lkdGgoXHJcbiAgICAgICAgICAgIGNvZGVzdHJlYW1QYXJ0UGFyYW1zLm51bVJlc29sdXRpb25MZXZlbHNUb0N1dCk7XHJcbiAgICAgICAgdmFyIG5ld1RpbGVIZWlnaHQgPSBjb2Rlc3RyZWFtU3RydWN0dXJlLmdldFRpbGVIZWlnaHQoXHJcbiAgICAgICAgICAgIGNvZGVzdHJlYW1QYXJ0UGFyYW1zLm51bVJlc29sdXRpb25MZXZlbHNUb0N1dCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIG5ld1JlZmVyZW5jZUdyaWRTaXplID0gY29kZXN0cmVhbVN0cnVjdHVyZS5nZXRTaXplT2ZQYXJ0KFxyXG4gICAgICAgICAgICBjb2Rlc3RyZWFtUGFydFBhcmFtcyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHNpek1hcmtlck9mZnNldCA9IG9mZnNldHNDYWxjdWxhdG9yLmdldEltYWdlQW5kVGlsZVNpemVPZmZzZXQoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgdmFyIHJlZmVyZW5jZUdyaWRTaXplT2Zmc2V0ID1cclxuICAgICAgICAgICAgc2l6TWFya2VyT2Zmc2V0ICsgakdsb2JhbHMuajJrT2Zmc2V0cy5SRUZFUkVOQ0VfR1JJRF9TSVpFX09GRlNFVF9BRlRFUl9TSVpfTUFSS0VSO1xyXG5cclxuICAgICAgICB2YXIgaW1hZ2VPZmZzZXRCeXRlc09mZnNldCA9IHJlZmVyZW5jZUdyaWRTaXplT2Zmc2V0ICsgODtcclxuICAgICAgICB2YXIgdGlsZVNpemVCeXRlc09mZnNldCA9IHJlZmVyZW5jZUdyaWRTaXplT2Zmc2V0ICsgMTY7XHJcbiAgICAgICAgdmFyIGZpcnN0VGlsZU9mZnNldEJ5dGVzT2Zmc2V0ID0gcmVmZXJlbmNlR3JpZFNpemVPZmZzZXQgKyAyNDtcclxuICAgICAgICBcclxuICAgICAgICBtb2RpZnlJbnQzMihyZXN1bHQsIHJlZmVyZW5jZUdyaWRTaXplT2Zmc2V0LCBuZXdSZWZlcmVuY2VHcmlkU2l6ZS53aWR0aCk7XHJcbiAgICAgICAgbW9kaWZ5SW50MzIocmVzdWx0LCByZWZlcmVuY2VHcmlkU2l6ZU9mZnNldCArIDQsIG5ld1JlZmVyZW5jZUdyaWRTaXplLmhlaWdodCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbW9kaWZ5SW50MzIocmVzdWx0LCB0aWxlU2l6ZUJ5dGVzT2Zmc2V0LCBuZXdUaWxlV2lkdGgpO1xyXG4gICAgICAgIG1vZGlmeUludDMyKHJlc3VsdCwgdGlsZVNpemVCeXRlc09mZnNldCArIDQsIG5ld1RpbGVIZWlnaHQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIG1vZGlmeUludDMyKHJlc3VsdCwgaW1hZ2VPZmZzZXRCeXRlc09mZnNldCwgMCk7XHJcbiAgICAgICAgbW9kaWZ5SW50MzIocmVzdWx0LCBpbWFnZU9mZnNldEJ5dGVzT2Zmc2V0ICsgNCwgMCk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICBtb2RpZnlJbnQzMihyZXN1bHQsIGZpcnN0VGlsZU9mZnNldEJ5dGVzT2Zmc2V0LCAwKTtcclxuICAgICAgICBtb2RpZnlJbnQzMihyZXN1bHQsIGZpcnN0VGlsZU9mZnNldEJ5dGVzT2Zmc2V0ICsgNCwgMCk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLm1vZGlmeUludDMyID0gbW9kaWZ5SW50MzI7XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIG1vZGlmeVByb2dyZXNzaW9uT3JkZXIocmVzdWx0LCBvcmlnaW5hbERhdGFiaW4sIGRhdGFiaW5PZmZzZXRJblJlc3VsdCkge1xyXG4gICAgICAgIHZhciBjb2RpbmdTdHlsZU9mZnNldCA9IG9mZnNldHNDYWxjdWxhdG9yLmdldENvZGluZ1N0eWxlT2Zmc2V0KG9yaWdpbmFsRGF0YWJpbik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGNvZGluZ1N0eWxlT2Zmc2V0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc2lvbk9yZGVyT2Zmc2V0ID1cclxuICAgICAgICAgICAgICAgIGRhdGFiaW5PZmZzZXRJblJlc3VsdCArIGNvZGluZ1N0eWxlT2Zmc2V0ICsgNTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJlc3VsdFtwcm9ncmVzc2lvbk9yZGVyT2Zmc2V0XSA9IGVuY29kZWRQcm9ncmVzc2lvbk9yZGVyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlUmFuZ2VzKHJlc3VsdCwgcmFuZ2VzVG9SZW1vdmUsIGFkZE9mZnNldCkge1xyXG4gICAgICAgIGlmIChyYW5nZXNUb1JlbW92ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7IC8vIHplcm8gYnl0ZXMgcmVtb3ZlZFxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlc1RvUmVtb3ZlLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPVxyXG4gICAgICAgICAgICAgICAgYWRkT2Zmc2V0ICtcclxuICAgICAgICAgICAgICAgIHJhbmdlc1RvUmVtb3ZlW2ldLm1hcmtlclNlZ21lbnRMZW5ndGhPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsTWFya2VyU2VnbWVudExlbmd0aCA9XHJcbiAgICAgICAgICAgICAgICAocmVzdWx0W29mZnNldF0gPDwgOCkgKyByZXN1bHRbb2Zmc2V0ICsgMV07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgbmV3TWFya2VyU2VnbWVudExlbmd0aCA9XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbE1hcmtlclNlZ21lbnRMZW5ndGggLSByYW5nZXNUb1JlbW92ZVtpXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICByZXN1bHRbb2Zmc2V0XSA9IG5ld01hcmtlclNlZ21lbnRMZW5ndGggPj4+IDg7XHJcbiAgICAgICAgICAgIHJlc3VsdFtvZmZzZXQgKyAxXSA9IG5ld01hcmtlclNlZ21lbnRMZW5ndGggJiAweEZGO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB2YXIgb2Zmc2V0VGFyZ2V0ID0gYWRkT2Zmc2V0ICsgcmFuZ2VzVG9SZW1vdmVbMF0uc3RhcnQ7XHJcbiAgICAgICAgdmFyIG9mZnNldFNvdXJjZSA9IG9mZnNldFRhcmdldDtcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJhbmdlc1RvUmVtb3ZlLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgIG9mZnNldFNvdXJjZSArPSByYW5nZXNUb1JlbW92ZVtqXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgbmV4dFJhbmdlT2Zmc2V0ID1cclxuICAgICAgICAgICAgICAgIGogKyAxIDwgcmFuZ2VzVG9SZW1vdmUubGVuZ3RoID9cclxuICAgICAgICAgICAgICAgICAgICBhZGRPZmZzZXQgKyByYW5nZXNUb1JlbW92ZVtqICsgMV0uc3RhcnQgOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgb2Zmc2V0U291cmNlIDwgbmV4dFJhbmdlT2Zmc2V0OyArK29mZnNldFNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W29mZnNldFRhcmdldF0gPSByZXN1bHRbb2Zmc2V0U291cmNlXTtcclxuICAgICAgICAgICAgICAgICsrb2Zmc2V0VGFyZ2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBieXRlc1JlbW92ZWQgPSBvZmZzZXRTb3VyY2UgLSBvZmZzZXRUYXJnZXQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGJ5dGVzUmVtb3ZlZDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtb2RpZnlJbnQzMihieXRlcywgb2Zmc2V0LCBuZXdWYWx1ZSkge1xyXG4gICAgICAgIGJ5dGVzW29mZnNldCsrXSA9IG5ld1ZhbHVlID4+PiAyNDtcclxuICAgICAgICBieXRlc1tvZmZzZXQrK10gPSAobmV3VmFsdWUgPj4+IDE2KSAmIDB4RkY7XHJcbiAgICAgICAgYnl0ZXNbb2Zmc2V0KytdID0gKG5ld1ZhbHVlID4+PiA4KSAmIDB4RkY7XHJcbiAgICAgICAgYnl0ZXNbb2Zmc2V0KytdID0gbmV3VmFsdWUgJiAweEZGO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVuY29kZVByb2dyZXNzaW9uT3JkZXIocHJvZ3Jlc3Npb25PcmRlcikge1xyXG4gICAgICAgIC8vIEEuNi4xXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVGFibGUgQS4xNlxyXG4gICAgICAgIFxyXG4gICAgICAgIHN3aXRjaCAocHJvZ3Jlc3Npb25PcmRlcikge1xyXG4gICAgICAgICAgICBjYXNlICdMUkNQJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhc2UgJ1JMQ1AnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgY2FzZSAnUlBDTCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNhc2UgJ1BDUkwnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDM7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgY2FzZSAnQ1BSTCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gNDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuajJrRXhjZXB0aW9ucy5JbGxlZ2FsRGF0YUV4Y2VwdGlvbignUHJvZ3Jlc3Npb24gb3JkZXIgb2YgJyArIHByb2dyZXNzaW9uT3JkZXIsICdBLjYuMSwgdGFibGUgQS4xNicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTsiLCIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgakdsb2JhbHMgPSByZXF1aXJlKCdqMmstanBpcC1nbG9iYWxzLmpzJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5KcGlwUGFja2V0c0RhdGFDb2xsZWN0b3IgPSBmdW5jdGlvbiBKcGlwUGFja2V0c0RhdGFDb2xsZWN0b3IoXHJcbiAgICBjb2Rlc3RyZWFtU3RydWN0dXJlLFxyXG4gICAgZGF0YWJpbnNTYXZlcixcclxuICAgIHF1YWxpdHlMYXllcnNDYWNoZSxcclxuICAgIGpwaXBGYWN0b3J5KSB7XHJcbiAgICBcclxuICAgIHRoaXMuZ2V0QWxsQ29kZWJsb2Nrc0RhdGEgPSBmdW5jdGlvbiBnZXRDb2RlYmxvY2tzRGF0YShcclxuICAgICAgICBjb2Rlc3RyZWFtUGFydFBhcmFtcywgbWluTnVtUXVhbGl0eUxheWVycykge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBhbHJlYWR5UmV0dXJuZWRDb2RlYmxvY2tzID0ganBpcEZhY3RvcnkuY3JlYXRlT2JqZWN0UG9vbEJ5RGF0YWJpbigpO1xyXG4gICAgICAgIHZhciBjb2RlYmxvY2tzRGF0YSA9IGdldE5ld0NvZGVibG9ja3NEYXRhQW5kVXBkYXRlUmV0dXJuZWRDb2RlYmxvY2tzKFxyXG4gICAgICAgICAgICBjb2Rlc3RyZWFtUGFydFBhcmFtcywgbWluTnVtUXVhbGl0eUxheWVycywgYWxyZWFkeVJldHVybmVkQ29kZWJsb2Nrcyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29kZWJsb2Nrc0RhdGE6IGNvZGVibG9ja3NEYXRhLFxyXG4gICAgICAgICAgICBhbHJlYWR5UmV0dXJuZWRDb2RlYmxvY2tzOiBhbHJlYWR5UmV0dXJuZWRDb2RlYmxvY2tzXHJcbiAgICAgICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB0aGlzLmdldE5ld0NvZGVibG9ja3NEYXRhQW5kVXBkYXRlUmV0dXJuZWRDb2RlYmxvY2tzID1cclxuICAgICAgICBnZXROZXdDb2RlYmxvY2tzRGF0YUFuZFVwZGF0ZVJldHVybmVkQ29kZWJsb2NrcztcclxuICAgICAgICBcclxuICAgIGZ1bmN0aW9uIGdldE5ld0NvZGVibG9ja3NEYXRhQW5kVXBkYXRlUmV0dXJuZWRDb2RlYmxvY2tzKFxyXG4gICAgICAgIGNvZGVzdHJlYW1QYXJ0UGFyYW1zLCBtaW5OdW1RdWFsaXR5TGF5ZXJzLCBhbHJlYWR5UmV0dXJuZWRDb2RlYmxvY2tzKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIHRpbGVJdGVyYXRvciA9IGNvZGVzdHJlYW1TdHJ1Y3R1cmUuZ2V0VGlsZXNJdGVyYXRvcihcclxuICAgICAgICAgICAgY29kZXN0cmVhbVBhcnRQYXJhbXMpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciB0aWxlSW5kZXhJbkNvZGVzdHJlYW1QYXJ0ID0gMDtcclxuICAgICAgICB2YXIgZHVtbXlPZmZzZXQgPSAwO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgIHBhY2tldERhdGFPZmZzZXRzOiBbXSxcclxuICAgICAgICAgICAgZGF0YToganBpcEZhY3RvcnkuY3JlYXRlQ29tcG9zaXRlQXJyYXkoZHVtbXlPZmZzZXQpLFxyXG4gICAgICAgICAgICBhbGxSZWxldmFudEJ5dGVzTG9hZGVkOiAwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICB2YXIgdGlsZVN0cnVjdHVyZSA9IGNvZGVzdHJlYW1TdHJ1Y3R1cmUuZ2V0VGlsZVN0cnVjdHVyZShcclxuICAgICAgICAgICAgICAgIHRpbGVJdGVyYXRvci50aWxlSW5kZXgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIHByZWNpbmN0SXRlcmF0b3IgPSB0aWxlU3RydWN0dXJlLmdldFByZWNpbmN0SXRlcmF0b3IoXHJcbiAgICAgICAgICAgICAgICB0aWxlSXRlcmF0b3IudGlsZUluZGV4LCBjb2Rlc3RyZWFtUGFydFBhcmFtcyk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgbWF4TnVtUXVhbGl0eUxheWVycyA9IHRpbGVTdHJ1Y3R1cmUuZ2V0TnVtUXVhbGl0eUxheWVycygpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGNvZGVzdHJlYW1QYXJ0UGFyYW1zLm1heE51bVF1YWxpdHlMYXllcnMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgbWF4TnVtUXVhbGl0eUxheWVycyA9IE1hdGgubWluKFxyXG4gICAgICAgICAgICAgICAgICAgIG1heE51bVF1YWxpdHlMYXllcnMsIGNvZGVzdHJlYW1QYXJ0UGFyYW1zLm1heE51bVF1YWxpdHlMYXllcnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAobWluTnVtUXVhbGl0eUxheWVycyA9PT0gJ21heCcpIHtcclxuICAgICAgICAgICAgICAgIG1pbk51bVF1YWxpdHlMYXllcnMgPSBtYXhOdW1RdWFsaXR5TGF5ZXJzO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1pbk51bVF1YWxpdHlMYXllcnMgPiBtYXhOdW1RdWFsaXR5TGF5ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAnbWluTnVtUXVhbGl0eUxheWVycyBpcyBsYXJnZXIgdGhhbiBtYXhOdW1RdWFsaXR5TGF5ZXJzJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIGlmICghcHJlY2luY3RJdGVyYXRvci5pc0luQ29kZXN0cmVhbVBhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgakdsb2JhbHMuanBpcEV4Y2VwdGlvbnMuSW50ZXJuYWxFcnJvckV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1VuZXhwZWN0ZWQgcHJlY2luY3Qgbm90IGluIGNvZGVzdHJlYW0gcGFydCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgaW5DbGFzc0luZGV4ID0gdGlsZVN0cnVjdHVyZS5wcmVjaW5jdFBvc2l0aW9uVG9JbkNsYXNzSW5kZXgoXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlY2luY3RJdGVyYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgcHJlY2luY3REYXRhYmluID0gZGF0YWJpbnNTYXZlci5nZXRQcmVjaW5jdERhdGFiaW4oXHJcbiAgICAgICAgICAgICAgICAgICAgaW5DbGFzc0luZGV4KTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdmFyIHJldHVybmVkSW5QcmVjaW5jdCA9XHJcbiAgICAgICAgICAgICAgICAgICAgYWxyZWFkeVJldHVybmVkQ29kZWJsb2Nrcy5nZXRPYmplY3QocHJlY2luY3REYXRhYmluKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5lZEluUHJlY2luY3QubGF5ZXJQZXJDb2RlYmxvY2sgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybmVkSW5QcmVjaW5jdC5sYXllclBlckNvZGVibG9jayA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHZhciBsYXllclJlYWNoZWQgPSBwdXNoUGFja2V0cyhcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGlsZUluZGV4SW5Db2Rlc3RyZWFtUGFydCxcclxuICAgICAgICAgICAgICAgICAgICBwcmVjaW5jdEl0ZXJhdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIHByZWNpbmN0RGF0YWJpbixcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5lZEluUHJlY2luY3QsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4TnVtUXVhbGl0eUxheWVycyk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmIChsYXllclJlYWNoZWQgPCBtaW5OdW1RdWFsaXR5TGF5ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogYWxyZWFkeVJldHVybmVkQ29kZWJsb2NrcyBpcyB3cm9uZyBpbiB0aGlzIHN0YWdlLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgaXQgd2FzIHVwZGF0ZWQgd2l0aCBhIGRhdGEgd2hpY2ggd2lsbCBub3QgYmVcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5lZC4gSSBkb24ndCBjYXJlIGFib3V0IGl0IG5vdyBiZWNhdXNlIHJldHVybmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG51bGwgaGVyZSBtZWFucyBzb21ldGhpbmcgYmFkIGhhcHBlbmVkIChhbiBleGNlcHRpb24gaXNcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aHJvd24gaW4gUmVxdWVzdENvbnRleHQgd2hlbiB0aGlzIGhhcHBlbnMpLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHNvbWUgZGF5IHRoZSBjb25zaXN0ZW5jeSBvZiBhbHJlYWR5UmV0dXJuZWRDb2RlYmxvY2tzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgaW1wb3J0YW50IHRoZW4gYSBuZXcgb2JqZWN0IHNob3VsZCBiZSByZXR1cm5lZCBvbiBlYWNoXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCB0byB0aGlzIGZ1bmN0aW9uLCBvciBhIHRyYW5zYWN0aW9uYWwgc3R5bGUgc2hvdWxkIGJlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlZCBoZXJlIHRvIGFib3J0IGFsbCBub24tcmV0dXJuZWQgZGF0YS5cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSB3aGlsZSAocHJlY2luY3RJdGVyYXRvci50cnlBZHZhbmNlKCkpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgKyt0aWxlSW5kZXhJbkNvZGVzdHJlYW1QYXJ0O1xyXG4gICAgICAgIH0gd2hpbGUgKHRpbGVJdGVyYXRvci50cnlBZHZhbmNlKCkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBkYXRhQXNVaW50OCA9IG5ldyBVaW50OEFycmF5KHJlc3VsdC5kYXRhLmdldExlbmd0aCgpKTtcclxuICAgICAgICByZXN1bHQuZGF0YS5jb3B5VG9UeXBlZEFycmF5KGRhdGFBc1VpbnQ4LCAwLCAwLCByZXN1bHQuZGF0YS5nZXRMZW5ndGgoKSk7XHJcbiAgICAgICAgcmVzdWx0LmRhdGEgPSBkYXRhQXNVaW50ODtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHB1c2hQYWNrZXRzKFxyXG4gICAgICAgIHJlc3VsdCxcclxuICAgICAgICB0aWxlSW5kZXhJbkNvZGVzdHJlYW1QYXJ0LFxyXG4gICAgICAgIHByZWNpbmN0SXRlcmF0b3IsXHJcbiAgICAgICAgcHJlY2luY3REYXRhYmluLFxyXG4gICAgICAgIHJldHVybmVkQ29kZWJsb2Nrc0luUHJlY2luY3QsXHJcbiAgICAgICAgbWF4TnVtUXVhbGl0eUxheWVycykge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBsYXllcjtcclxuICAgICAgICB2YXIgb2Zmc2V0SW5QcmVjaW5jdERhdGFiaW47XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yIChsYXllciA9IDA7IGxheWVyIDwgbWF4TnVtUXVhbGl0eUxheWVyczsgKytsYXllcikge1xyXG4gICAgICAgICAgICB2YXIgY29kZWJsb2NrT2Zmc2V0c0luRGF0YWJpbiA9XHJcbiAgICAgICAgICAgICAgICBxdWFsaXR5TGF5ZXJzQ2FjaGUuZ2V0UGFja2V0T2Zmc2V0c0J5Q29kZWJsb2NrSW5kZXgoXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlY2luY3REYXRhYmluLCBsYXllciwgcHJlY2luY3RJdGVyYXRvcik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoY29kZWJsb2NrT2Zmc2V0c0luRGF0YWJpbiA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIG9mZnNldEluUHJlY2luY3REYXRhYmluID1cclxuICAgICAgICAgICAgICAgIGNvZGVibG9ja09mZnNldHNJbkRhdGFiaW4uaGVhZGVyU3RhcnRPZmZzZXQgK1xyXG4gICAgICAgICAgICAgICAgY29kZWJsb2NrT2Zmc2V0c0luRGF0YWJpbi5oZWFkZXJMZW5ndGg7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgbnVtQ29kZWJsb2NrcyA9XHJcbiAgICAgICAgICAgICAgICBjb2RlYmxvY2tPZmZzZXRzSW5EYXRhYmluLmNvZGVibG9ja0JvZHlMZW5ndGhCeUluZGV4Lmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIGNvZGVibG9ja09mZnNldHNJblJlc3VsdCA9IG5ldyBBcnJheShudW1Db2RlYmxvY2tzKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBpc0luY29tcGxldGVQYWNrZXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ29kZWJsb2NrczsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmV0dXJuZWQgPSByZXR1cm5lZENvZGVibG9ja3NJblByZWNpbmN0LmxheWVyUGVyQ29kZWJsb2NrW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJldHVybmVkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5lZCA9IHsgbGF5ZXI6IC0xIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWRDb2RlYmxvY2tzSW5QcmVjaW5jdC5sYXllclBlckNvZGVibG9ja1tpXSA9IHJldHVybmVkO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXR1cm5lZC5sYXllciA+PSBsYXllcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgY29kZWJsb2NrID1cclxuICAgICAgICAgICAgICAgICAgICBjb2RlYmxvY2tPZmZzZXRzSW5EYXRhYmluLmNvZGVibG9ja0JvZHlMZW5ndGhCeUluZGV4W2ldO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0SW5SZXN1bHRBcnJheSA9IHJlc3VsdC5kYXRhLmdldExlbmd0aCgpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZXNDb3BpZWQgPSBwcmVjaW5jdERhdGFiaW4uY29weVRvQ29tcG9zaXRlQXJyYXkoXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhYmluU3RhcnRPZmZzZXQ6IG9mZnNldEluUHJlY2luY3REYXRhYmluLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhMZW5ndGhUb0NvcHk6IGNvZGVibG9jay5jb2RlYmxvY2tCb2R5TGVuZ3RoQnl0ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlQ29weUFsbFJhbmdlOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmIChieXRlc0NvcGllZCAhPT0gY29kZWJsb2NrLmNvZGVibG9ja0JvZHlMZW5ndGhCeXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVibG9ja09mZnNldHNJblJlc3VsdC5sZW5ndGggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzSW5jb21wbGV0ZVBhY2tldCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHJldHVybmVkLmxheWVyID0gbGF5ZXI7XHJcbiAgICAgICAgICAgICAgICBjb2RlYmxvY2tPZmZzZXRzSW5SZXN1bHRbaV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG9mZnNldEluUmVzdWx0QXJyYXksXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBvZmZzZXRJblJlc3VsdEFycmF5ICsgY29kZWJsb2NrLmNvZGVibG9ja0JvZHlMZW5ndGhCeXRlcyxcclxuICAgICAgICAgICAgICAgICAgICBjb2RpbmdwYXNzZXM6IGNvZGVibG9jay5jb2RpbmdQYXNzZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgemVyb0JpdFBsYW5lczogY29kZWJsb2NrLnplcm9CaXRQbGFuZXNcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBvZmZzZXRJblByZWNpbmN0RGF0YWJpbiArPSBjb2RlYmxvY2suY29kZWJsb2NrQm9keUxlbmd0aEJ5dGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgcGFja2V0ID0ge1xyXG4gICAgICAgICAgICAgICAgdGlsZUluZGV4OiB0aWxlSW5kZXhJbkNvZGVzdHJlYW1QYXJ0LFxyXG4gICAgICAgICAgICAgICAgcjogcHJlY2luY3RJdGVyYXRvci5yZXNvbHV0aW9uTGV2ZWwsXHJcbiAgICAgICAgICAgICAgICBwOiBwcmVjaW5jdEl0ZXJhdG9yLnByZWNpbmN0SW5kZXhJbkNvbXBvbmVudFJlc29sdXRpb24sXHJcbiAgICAgICAgICAgICAgICBjOiBwcmVjaW5jdEl0ZXJhdG9yLmNvbXBvbmVudCxcclxuICAgICAgICAgICAgICAgIGw6IGxheWVyLFxyXG4gICAgICAgICAgICAgICAgY29kZWJsb2NrT2Zmc2V0czogY29kZWJsb2NrT2Zmc2V0c0luUmVzdWx0XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgcmVzdWx0LnBhY2tldERhdGFPZmZzZXRzLnB1c2gocGFja2V0KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChpc0luY29tcGxldGVQYWNrZXQpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJlc3VsdC5hbGxSZWxldmFudEJ5dGVzTG9hZGVkICs9IG9mZnNldEluUHJlY2luY3REYXRhYmluO1xyXG4gICAgICAgIHJldHVybiBsYXllcjtcclxuICAgIH0gICAgXHJcbn07Il19
